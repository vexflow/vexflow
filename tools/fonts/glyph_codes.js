#!/usr/bin/env node

// Node JS script to generate a TS file containing an enum of SMuFL glyphs.
// Usage: node glyph_codes.js
//
// The original data is here: https://raw.githubusercontent.com/w3c/smufl/gh-pages/metadata/glyphnames.json

const fs = require('fs');
const path = require('path');

// Read in glyphnames.json into a JS object.
const glyphNames = JSON.parse(fs.readFileSync(path.join(__dirname, 'config', 'glyphnames.json'), 'utf8'));

let outputEnum = `// This file was generated by \`glyph_codes.js\'
// The enum includes all SMuFL glyphs, and a few others that VexFlow uses.
// See the list of SMuFL glyphs:
//   https://w3c.github.io/smufl/latest/tables/
//   https://raw.githubusercontent.com/w3c/smufl/gh-pages/metadata/glyphnames.json
// We renamed the two SMuFL names that start with a digit:
//   4stringTabClef => fourStringTabClef
//   6stringTabClef => sixStringTabClef
//
export enum Glyphs {`;

function addSpecialGlyphs() {
  outputEnum += `\n  ////// SPECIAL GLYPHS ///////////////////////////////////////\n`;
  outputEnum += `  // Null character\n  null = '\\0',\n`;
}

function addEntry(smuflCodeName, codepoint, description = '', suffix = '') {
  if (!codepoint) {
    console.warn(`addEntry(${smuflCodeName}, ...) called with an undefined codepoint.`);
    return;
  }

  // Add a comment.
  let comment = '// ' + codepoint + '  ' + description + '\n';

  // Translate the codepoint to a hex number (instead of strings of the format U+E06E).
  const hex = codepoint.slice(2).toLowerCase();

  let glyphString = '';
  // If the codepoint is greater than 0xFFFF, we need to add braces.
  if (hex.length > 4) {
    glyphString = `'\\u{${hex}}'`;
  } else {
    // Otherwise, use the regular unicode escape.
    glyphString = `'\\u${hex}'`;
  }

  outputEnum += `  ${comment}  ${smuflCodeName}${suffix} = ${glyphString},\n`;
}

function sanitizeDescription(description) {
  // Avoid an eslint warning by replacing codepoint 160 (non-breaking space) with a regular space.
  return description.replace(/\xA0/g, ' ');
}

function addSMuFLGlyphs() {
  outputEnum += `\n  ////// SMuFL GLYPHS /////////////////////////////////////////\n`;
  for (let smuflCodeName in glyphNames) {
    const glyphInfo = glyphNames[smuflCodeName];

    // Override SMuFL names that start with a digit, since they don't work as variable names.
    if (smuflCodeName === '4stringTabClef') {
      smuflCodeName = 'fourStringTabClef';
    } else if (smuflCodeName === '6stringTabClef') {
      smuflCodeName = 'sixStringTabClef';
    }

    addEntry(smuflCodeName, glyphInfo.codepoint, sanitizeDescription(glyphInfo.description));

    // We do not include alternate codepoints for now.
    // if (glyphInfo.alternateCodepoint) {
    //   addEntry(smuflCodeName, glyphInfo.alternateCodepoint, sanitizeDescription(glyphInfo.description), 'Alternate');
    // }
  }
}

function saveFile() {
  // Save the output to vexflow/src/smufl.ts.
  fs.writeFileSync(path.join(__dirname, '../../src/glyphs.ts'), outputEnum, 'utf8');
  console.log('Saved as vexflow/src/glyphs.ts');
}

addSpecialGlyphs();
addSMuFLGlyphs();
outputEnum += '}\n';
saveFile();
