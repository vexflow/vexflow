/*!
 * VexFlow 5.0.0-alpha.3   2023-10-03T22:12:18.099Z   be773cdcf2d021c3011642a3ce09829188a4b63f
 * Copyright (c) 2023-present VexFlow contributors (see https://github.com/vexflow/vexflow/blob/main/AUTHORS.md).
 *
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Vex"] = factory();
	else
		root["Vex"] = factory();
})((typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : this), () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/version.ts":
/*!************************!*\
  !*** ./src/version.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DATE: () => (/* binding */ DATE),
/* harmony export */   ID: () => (/* binding */ ID),
/* harmony export */   VERSION: () => (/* binding */ VERSION)
/* harmony export */ });
const VERSION = '5.0.0-alpha.3';
const ID = 'be773cdcf2d021c3011642a3ce09829188a4b63f';
const DATE = '2023-10-03T22:12:18.099Z';


/***/ }),

/***/ "./src/accidental.ts":
/*!***************************!*\
  !*** ./src/accidental.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Accidental: () => (/* binding */ Accidental)
/* harmony export */ });
/* harmony import */ var _fraction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fraction */ "./src/fraction.ts");
/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./metrics */ "./src/metrics.ts");
/* harmony import */ var _modifier__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifier */ "./src/modifier.ts");
/* harmony import */ var _music__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./music */ "./src/music.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
// @author Mohit Cheppudira
// @author Greg Ristow (modifications)
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _a, _Accidental_checkCollision;







// eslint-disable-next-line
function L(...args) {
    if (Accidental.DEBUG)
        (0,_util__WEBPACK_IMPORTED_MODULE_6__.log)('Vex.Flow.Accidental', args);
}
/**
 * An `Accidental` inherits from `Modifier`, and is formatted within a
 * `ModifierContext`. Accidentals are modifiers that can be attached to
 * notes. Support is included for both western and microtonal accidentals.
 *
 * See `tests/accidental_tests.ts` for usage examples.
 */
class Accidental extends _modifier__WEBPACK_IMPORTED_MODULE_2__.Modifier {
    /** Accidentals category string. */
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_5__.Category.Accidental;
    }
    /** Arrange accidentals inside a ModifierContext. */
    static format(accidentals, state) {
        // If there are no accidentals, no need to format their positions.
        if (!accidentals || accidentals.length === 0)
            return;
        const noteheadAccidentalPadding = _metrics__WEBPACK_IMPORTED_MODULE_1__.Metrics.get('Accidental.noteheadAccidentalPadding');
        const leftShift = state.leftShift + noteheadAccidentalPadding;
        const accidentalSpacing = _metrics__WEBPACK_IMPORTED_MODULE_1__.Metrics.get('Accidental.accidentalSpacing');
        const additionalPadding = _metrics__WEBPACK_IMPORTED_MODULE_1__.Metrics.get('Accidental.leftPadding'); // padding to the left of all accidentals
        const accidentalLinePositionsAndSpaceNeeds = [];
        let prevNote = undefined;
        let extraXSpaceNeededForLeftDisplacedNotehead = 0;
        // First determine the accidentals' Y positions from the note.keys
        for (let i = 0; i < accidentals.length; ++i) {
            const accidental = accidentals[i];
            const note = accidental.getNote();
            const stave = note.getStave();
            const index = accidental.checkIndex();
            const props = note.getKeyProps()[index];
            if (note !== prevNote) {
                // Iterate through all notes to get the displaced pixels
                for (let n = 0; n < note.keys.length; ++n) {
                    // If the current extra left-space needed isn't as big as this note's,
                    // then we need to use this note's.
                    extraXSpaceNeededForLeftDisplacedNotehead = Math.max(note.getLeftDisplacedHeadPx() - note.getXShift(), extraXSpaceNeededForLeftDisplacedNotehead);
                }
                prevNote = note;
            }
            if (stave) {
                const lineSpace = stave.getSpacingBetweenLines();
                const y = stave.getYForLine(props.line);
                const accLine = Math.round((y / lineSpace) * 2) / 2;
                accidentalLinePositionsAndSpaceNeeds.push({
                    y,
                    line: accLine,
                    extraXSpaceNeeded: extraXSpaceNeededForLeftDisplacedNotehead,
                    accidental: accidental,
                    spacingBetweenStaveLines: lineSpace,
                });
            }
            else {
                accidentalLinePositionsAndSpaceNeeds.push({
                    line: props.line,
                    extraXSpaceNeeded: extraXSpaceNeededForLeftDisplacedNotehead,
                    accidental: accidental,
                });
            }
        }
        // Sort accidentals by line number.
        accidentalLinePositionsAndSpaceNeeds.sort((a, b) => b.line - a.line);
        const staveLineAccidentalLayoutMetrics = [];
        // amount by which all accidentals must be shifted right or left for
        // stem flipping, notehead shifting concerns.
        let maxExtraXSpaceNeeded = 0;
        // Create an array of unique line numbers (staveLineAccidentalLayoutMetrics)
        // from accidentalLinePositionsAndSpaceNeeds
        for (let i = 0; i < accidentalLinePositionsAndSpaceNeeds.length; i++) {
            const accidentalLinePositionAndSpaceNeeds = accidentalLinePositionsAndSpaceNeeds[i];
            const accidentalType = accidentalLinePositionAndSpaceNeeds.accidental.type;
            const priorLineMetric = staveLineAccidentalLayoutMetrics[staveLineAccidentalLayoutMetrics.length - 1];
            let currentLineMetric;
            // if this is the first line, or a new line, add a staveLineAccidentalLayoutMetric
            if (!priorLineMetric || (priorLineMetric === null || priorLineMetric === void 0 ? void 0 : priorLineMetric.line) !== accidentalLinePositionAndSpaceNeeds.line) {
                currentLineMetric = {
                    line: accidentalLinePositionAndSpaceNeeds.line,
                    flatLine: true,
                    dblSharpLine: true,
                    numAcc: 0,
                    width: 0,
                    column: 0,
                };
                staveLineAccidentalLayoutMetrics.push(currentLineMetric);
            }
            else {
                currentLineMetric = priorLineMetric;
            }
            // if this accidental is not a flat, the accidental needs 3.0 lines lower
            // clearance instead of 2.5 lines for b or bb.
            if (accidentalType !== 'b' && accidentalType !== 'bb') {
                currentLineMetric.flatLine = false;
            }
            // if this accidental is not a double sharp, the accidental needs 3.0 lines above
            if (accidentalType !== '##') {
                currentLineMetric.dblSharpLine = false;
            }
            // Track how many accidentals are on this line:
            currentLineMetric.numAcc++;
            // Track the total xOffset needed for this line which will be needed
            // for formatting lines w/ multiple accidentals:
            // width = accidental width + universal spacing between accidentals
            currentLineMetric.width += accidentalLinePositionAndSpaceNeeds.accidental.getWidth() + accidentalSpacing;
            // if this extraXSpaceNeeded is the largest so far, use it as the starting point for
            // all accidental columns.
            maxExtraXSpaceNeeded = Math.max(accidentalLinePositionAndSpaceNeeds.extraXSpaceNeeded, maxExtraXSpaceNeeded);
        }
        // ### Place Accidentals in Columns
        //
        // Default to a classic triangular layout (middle accidental farthest left),
        // but follow exceptions as outlined in G. Read's _Music Notation_ and
        // Elaine Gould's _Behind Bars_.
        //
        // Additionally, this implements different vertical collision rules for
        // flats (only need 2.5 lines clearance below) and double sharps (only
        // need 2.5 lines of clearance above or below).
        //
        // Classic layouts and exception patterns are found in the 'tables.js'
        // in 'Tables.accidentalColumnsTable'
        //
        // Beyond 6 vertical accidentals, default to the parallel ascending lines approach,
        // using as few columns as possible for the verticle structure.
        //
        // TODO (?): Allow column to be specified for an accidental at run-time?
        let totalColumns = 0;
        // establish the boundaries for a group of notes with clashing accidentals:
        for (let i = 0; i < staveLineAccidentalLayoutMetrics.length; i++) {
            let noFurtherConflicts = false;
            const groupStart = i;
            let groupEnd = i;
            while (groupEnd + 1 < staveLineAccidentalLayoutMetrics.length && !noFurtherConflicts) {
                // if this note conflicts with the next:
                if (__classPrivateFieldGet(this, _a, "m", _Accidental_checkCollision).call(this, staveLineAccidentalLayoutMetrics[groupEnd], staveLineAccidentalLayoutMetrics[groupEnd + 1])) {
                    // include the next note in the group:
                    groupEnd++;
                }
                else {
                    noFurtherConflicts = true;
                }
            }
            // Gets an a line from the `lineList`, relative to the current group
            const getGroupLine = (index) => staveLineAccidentalLayoutMetrics[groupStart + index];
            const getGroupLines = (indexes) => indexes.map(getGroupLine);
            const lineDifference = (indexA, indexB) => {
                const [a, b] = getGroupLines([indexA, indexB]).map((item) => item.line);
                return a - b;
            };
            const notColliding = (...indexPairs) => indexPairs.map(getGroupLines).every(([line1, line2]) => !__classPrivateFieldGet(this, _a, "m", _Accidental_checkCollision).call(this, line1, line2));
            // Set columns for the lines in this group:
            const groupLength = groupEnd - groupStart + 1;
            // Set the accidental column for each line of the group
            let endCase = __classPrivateFieldGet(this, _a, "m", _Accidental_checkCollision).call(this, staveLineAccidentalLayoutMetrics[groupStart], staveLineAccidentalLayoutMetrics[groupEnd])
                ? 'a'
                : 'b';
            switch (groupLength) {
                case 3:
                    if (endCase === 'a' && lineDifference(1, 2) === 0.5 && lineDifference(0, 1) !== 0.5) {
                        endCase = 'secondOnBottom';
                    }
                    break;
                case 4:
                    if (notColliding([0, 2], [1, 3])) {
                        endCase = 'spacedOutTetrachord';
                    }
                    break;
                case 5:
                    if (endCase === 'b' && notColliding([1, 3])) {
                        endCase = 'spacedOutPentachord';
                        if (notColliding([0, 2], [2, 4])) {
                            endCase = 'verySpacedOutPentachord';
                        }
                    }
                    break;
                case 6:
                    if (notColliding([0, 3], [1, 4], [2, 5])) {
                        endCase = 'spacedOutHexachord';
                    }
                    if (notColliding([0, 2], [2, 4], [1, 3], [3, 5])) {
                        endCase = 'verySpacedOutHexachord';
                    }
                    break;
                default:
                    break;
            }
            let groupMember;
            let column;
            // If the group contains seven members or more, use ascending parallel lines
            // of accidentals, using as few columns as possible while avoiding collisions.
            if (groupLength >= 7) {
                // First, determine how many columns to use:
                let patternLength = 2;
                let collisionDetected = true;
                while (collisionDetected === true) {
                    collisionDetected = false;
                    for (let line = 0; line + patternLength < staveLineAccidentalLayoutMetrics.length; line++) {
                        if (__classPrivateFieldGet(this, _a, "m", _Accidental_checkCollision).call(this, staveLineAccidentalLayoutMetrics[line], staveLineAccidentalLayoutMetrics[line + patternLength])) {
                            collisionDetected = true;
                            patternLength++;
                            break;
                        }
                    }
                }
                // Then, assign a column to each line of accidentals
                for (groupMember = i; groupMember <= groupEnd; groupMember++) {
                    column = ((groupMember - i) % patternLength) + 1;
                    staveLineAccidentalLayoutMetrics[groupMember].column = column;
                    totalColumns = totalColumns > column ? totalColumns : column;
                }
            }
            else {
                // If the group contains fewer than seven members, use the layouts from
                // the Tables.accidentalColumnsTable (See: tables.ts).
                for (groupMember = i; groupMember <= groupEnd; groupMember++) {
                    column = _tables__WEBPACK_IMPORTED_MODULE_4__.Tables.accidentalColumnsTable[groupLength][endCase][groupMember - i];
                    staveLineAccidentalLayoutMetrics[groupMember].column = column;
                    totalColumns = totalColumns > column ? totalColumns : column;
                }
            }
            // Increment i to the last note that was set, so that if a lower set of notes
            // does not conflict at all with this group, it can have its own classic shape.
            i = groupEnd;
        }
        // ### Convert Columns to xOffsets
        //
        // This keeps columns aligned, even if they have different accidentals within them
        // which sometimes results in a larger xOffset than is an accidental might need
        // to preserve the symmetry of the accidental shape.
        //
        // Neither A.C. Vinci nor G. Read address this, and it typically only happens in
        // music with complex chord clusters.
        //
        // TODO (?): Optionally allow closer compression of accidentals, instead of forcing
        // parallel columns.
        // track each column's max width, which will be used as initial shift of later columns:
        const columnWidths = [];
        const columnXOffsets = [];
        for (let i = 0; i <= totalColumns; i++) {
            columnWidths[i] = 0;
            columnXOffsets[i] = 0;
        }
        columnWidths[0] = leftShift + maxExtraXSpaceNeeded;
        columnXOffsets[0] = leftShift;
        // Fill columnWidths with widest needed x-space;
        // this is what keeps the columns parallel.
        staveLineAccidentalLayoutMetrics.forEach((line) => {
            if (line.width > columnWidths[line.column])
                columnWidths[line.column] = line.width;
        });
        for (let i = 1; i < columnWidths.length; i++) {
            // this column's offset = this column's width + previous column's offset
            columnXOffsets[i] = columnWidths[i] + columnXOffsets[i - 1];
        }
        const totalShift = columnXOffsets[columnXOffsets.length - 1];
        // Set the xShift for each accidental according to column offsets:
        let accCount = 0;
        staveLineAccidentalLayoutMetrics.forEach((line) => {
            let lineWidth = 0;
            const lastAccOnLine = accCount + line.numAcc;
            // handle all of the accidentals on a given line:
            for (accCount; accCount < lastAccOnLine; accCount++) {
                const xShift = columnXOffsets[line.column - 1] + lineWidth + maxExtraXSpaceNeeded;
                accidentalLinePositionsAndSpaceNeeds[accCount].accidental.setXShift(xShift);
                // keep track of the width of accidentals we've added so far, so that when
                // we loop, we add space for them.
                lineWidth += accidentalLinePositionsAndSpaceNeeds[accCount].accidental.getWidth() + accidentalSpacing;
                L('Line, accCount, shift: ', line.line, accCount, xShift);
            }
        });
        // update the overall layout with the full width of the accidental shapes:
        state.leftShift = totalShift + additionalPadding;
    }
    /**
     * Use this method to automatically apply accidentals to a set of `voices`.
     * The accidentals will be remembered between all the voices provided.
     * Optionally, you can also provide an initial `keySignature`.
     */
    static applyAccidentals(voices, keySignature) {
        const tickPositions = [];
        const tickNoteMap = {};
        // Sort the tickables in each voice by their tick position in the voice.
        voices.forEach((voice) => {
            const tickPosition = new _fraction__WEBPACK_IMPORTED_MODULE_0__.Fraction(0, 1);
            const tickable = voice.getTickables();
            tickable.forEach((t) => {
                if (t.shouldIgnoreTicks())
                    return;
                const notesAtPosition = tickNoteMap[tickPosition.value()];
                if (!notesAtPosition) {
                    tickPositions.push(tickPosition.value());
                    tickNoteMap[tickPosition.value()] = [t];
                }
                else {
                    notesAtPosition.push(t);
                }
                tickPosition.add(t.getTicks());
            });
        });
        const music = new _music__WEBPACK_IMPORTED_MODULE_3__.Music();
        // Default key signature is C major.
        if (!keySignature)
            keySignature = 'C';
        // Get the scale map, which represents the current state of each pitch.
        const scaleMapKey = music.createScaleMap(keySignature);
        const scaleMap = {};
        tickPositions.forEach((tickPos) => {
            const tickables = tickNoteMap[tickPos];
            // Array to store all pitches that modified accidental states
            // at this tick position
            const modifiedPitches = [];
            const processNote = (t) => {
                // Only StaveNote implements .addModifier(), which is used below.
                if (!(0,_typeguard__WEBPACK_IMPORTED_MODULE_5__.isStaveNote)(t) || t.isRest() || t.shouldIgnoreTicks()) {
                    return;
                }
                // Go through each key and determine if an accidental should be applied.
                const staveNote = t;
                staveNote.keys.forEach((keyString, keyIndex) => {
                    const key = music.getNoteParts(keyString.split('/')[0]);
                    const octave = keyString.split('/')[1];
                    // Force a natural for every key without an accidental
                    const accidentalString = key.accidental || 'n';
                    const pitch = key.root + accidentalString;
                    // Determine if the current pitch has the same accidental
                    // as the scale state
                    if (!scaleMap[key.root + octave])
                        scaleMap[key.root + octave] = scaleMapKey[key.root];
                    const sameAccidental = scaleMap[key.root + octave] === pitch;
                    // Determine if an identical pitch in the chord already
                    // modified the accidental state
                    const previouslyModified = modifiedPitches.indexOf(keyString) > -1;
                    // Remove accidentals
                    staveNote.getModifiers().forEach((modifier, index) => {
                        if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_5__.isAccidental)(modifier) && modifier.type == accidentalString && modifier.getIndex() == keyIndex) {
                            staveNote.getModifiers().splice(index, 1);
                        }
                    });
                    // Add the accidental to the StaveNote
                    if (!sameAccidental || (sameAccidental && previouslyModified)) {
                        // Modify the scale map so that the root pitch has an
                        // updated state
                        scaleMap[key.root + octave] = pitch;
                        // Create the accidental
                        const accidental = new Accidental(accidentalString);
                        // Attach the accidental to the StaveNote
                        staveNote.addModifier(accidental, keyIndex);
                        // Add the pitch to list of pitches that modified accidentals
                        modifiedPitches.push(keyString);
                    }
                });
                // process grace notes
                staveNote.getModifiers().forEach((modifier) => {
                    if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_5__.isGraceNoteGroup)(modifier)) {
                        modifier.getGraceNotes().forEach(processNote);
                    }
                });
            };
            tickables.forEach(processNote);
        });
    }
    /**
     * Create accidental.
     * @param type value from `Vex.Flow.accidentalCodes.accidentals` table in `tables.ts`.
     * For example: `#`, `##`, `b`, `n`, etc.
     */
    constructor(type) {
        super();
        L('New accidental: ', type);
        this.type = type;
        this.position = _modifier__WEBPACK_IMPORTED_MODULE_2__.Modifier.Position.LEFT;
        // Cautionary accidentals have parentheses around them
        this.cautionary = false;
        this.reset();
    }
    reset() {
        this.text = '';
        if (!this.cautionary) {
            this.text += _tables__WEBPACK_IMPORTED_MODULE_4__.Tables.accidentalCodes(this.type);
            this.fontInfo.size = _metrics__WEBPACK_IMPORTED_MODULE_1__.Metrics.get('Accidental.fontSize');
        }
        else {
            this.text += _tables__WEBPACK_IMPORTED_MODULE_4__.Tables.accidentalCodes('{');
            this.text += _tables__WEBPACK_IMPORTED_MODULE_4__.Tables.accidentalCodes(this.type);
            this.text += _tables__WEBPACK_IMPORTED_MODULE_4__.Tables.accidentalCodes('}');
            this.fontInfo.size = _metrics__WEBPACK_IMPORTED_MODULE_1__.Metrics.get('Accidental.cautionary.fontSize');
        }
        // Accidentals attached to grace notes are rendered smaller.
        if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_5__.isGraceNote)(this.note)) {
            this.fontInfo.size = _metrics__WEBPACK_IMPORTED_MODULE_1__.Metrics.get('Accidental.grace.fontSize');
        }
    }
    /** Attach this accidental to `note`, which must be a `StaveNote`. */
    setNote(note) {
        (0,_util__WEBPACK_IMPORTED_MODULE_6__.defined)(note, 'ArgumentError', `Bad note value: ${note}`);
        this.note = note;
        this.reset();
        return this;
    }
    /** If called, draws parenthesis around accidental. */
    setAsCautionary() {
        this.cautionary = true;
        this.reset();
        return this;
    }
    /** Render accidental onto canvas. */
    draw() {
        const { type, position, index } = this;
        const ctx = this.checkContext();
        const note = this.checkAttachedNote();
        this.setRendered();
        // Figure out the start `x` and `y` coordinates for note and index.
        const start = note.getModifierStartXY(position, index);
        const accX = start.x;
        const accY = start.y;
        L('Rendering: ', type, accX, accY);
        this.renderText(ctx, accX - this.width, accY);
    }
}
_a = Accidental, _Accidental_checkCollision = function _Accidental_checkCollision(line1, line2) {
    let clearance = line2.line - line1.line;
    let clearanceRequired = 3;
    // But less clearance is required for certain accidentals: b, bb and ##.
    if (clearance > 0) {
        // then line 2 is on top
        clearanceRequired = line2.flatLine || line2.dblSharpLine ? 2.5 : 3.0;
        if (line1.dblSharpLine)
            clearance -= 0.5;
    }
    else {
        // line 1 is on top
        clearanceRequired = line1.flatLine || line1.dblSharpLine ? 2.5 : 3.0;
        if (line2.dblSharpLine)
            clearance -= 0.5;
    }
    const collision = Math.abs(clearance) < clearanceRequired;
    L('Line1, Line2, Collision: ', line1.line, line2.line, collision);
    return collision;
};
/** To enable logging for this class. Set `Vex.Flow.Accidental.DEBUG` to `true`. */
Accidental.DEBUG = false;


/***/ }),

/***/ "./src/annotation.ts":
/*!***************************!*\
  !*** ./src/annotation.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Annotation: () => (/* binding */ Annotation),
/* harmony export */   AnnotationHorizontalJustify: () => (/* binding */ AnnotationHorizontalJustify),
/* harmony export */   AnnotationVerticalJustify: () => (/* binding */ AnnotationVerticalJustify)
/* harmony export */ });
/* harmony import */ var _font__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./font */ "./src/font.ts");
/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./metrics */ "./src/metrics.ts");
/* harmony import */ var _modifier__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifier */ "./src/modifier.ts");
/* harmony import */ var _stem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stem */ "./src/stem.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License







// eslint-disable-next-line
function L(...args) {
    if (Annotation.DEBUG)
        (0,_util__WEBPACK_IMPORTED_MODULE_6__.log)('Vex.Flow.Annotation', args);
}
var AnnotationHorizontalJustify;
(function (AnnotationHorizontalJustify) {
    AnnotationHorizontalJustify[AnnotationHorizontalJustify["LEFT"] = 1] = "LEFT";
    AnnotationHorizontalJustify[AnnotationHorizontalJustify["CENTER"] = 2] = "CENTER";
    AnnotationHorizontalJustify[AnnotationHorizontalJustify["RIGHT"] = 3] = "RIGHT";
    AnnotationHorizontalJustify[AnnotationHorizontalJustify["CENTER_STEM"] = 4] = "CENTER_STEM";
})(AnnotationHorizontalJustify || (AnnotationHorizontalJustify = {}));
var AnnotationVerticalJustify;
(function (AnnotationVerticalJustify) {
    AnnotationVerticalJustify[AnnotationVerticalJustify["TOP"] = 1] = "TOP";
    AnnotationVerticalJustify[AnnotationVerticalJustify["CENTER"] = 2] = "CENTER";
    AnnotationVerticalJustify[AnnotationVerticalJustify["BOTTOM"] = 3] = "BOTTOM";
    AnnotationVerticalJustify[AnnotationVerticalJustify["CENTER_STEM"] = 4] = "CENTER_STEM";
})(AnnotationVerticalJustify || (AnnotationVerticalJustify = {}));
/**
 * Annotations are modifiers that can be attached to
 * notes.
 *
 * See `tests/annotation_tests.ts` for usage examples.
 */
class Annotation extends _modifier__WEBPACK_IMPORTED_MODULE_2__.Modifier {
    /** Annotations category string. */
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_5__.Category.Annotation;
    }
    // Use the same padding for annotations as note head so the
    // words don't run into each other.
    static get minAnnotationPadding() {
        return _metrics__WEBPACK_IMPORTED_MODULE_1__.Metrics.get('NoteHead.minPadding');
    }
    /** Arrange annotations within a `ModifierContext` */
    static format(annotations, state) {
        if (!annotations || annotations.length === 0)
            return false;
        let leftWidth = 0;
        let rightWidth = 0;
        let maxLeftGlyphWidth = 0;
        let maxRightGlyphWidth = 0;
        for (let i = 0; i < annotations.length; ++i) {
            const annotation = annotations[i];
            // Text height is expressed in fractional stave spaces.
            const textLines = (2 + _font__WEBPACK_IMPORTED_MODULE_0__.Font.convertSizeToPixelValue(annotation.fontInfo.size)) / _tables__WEBPACK_IMPORTED_MODULE_4__.Tables.STAVE_LINE_DISTANCE;
            let verticalSpaceNeeded = textLines;
            const note = annotation.checkAttachedNote();
            const glyphWidth = note.getGlyphWidth();
            // Get the text width from the font metrics.
            const textWidth = annotation.getWidth();
            if (annotation.horizontalJustification === AnnotationHorizontalJustify.LEFT) {
                maxLeftGlyphWidth = Math.max(glyphWidth, maxLeftGlyphWidth);
                leftWidth = Math.max(leftWidth, textWidth) + Annotation.minAnnotationPadding;
            }
            else if (annotation.horizontalJustification === AnnotationHorizontalJustify.RIGHT) {
                maxRightGlyphWidth = Math.max(glyphWidth, maxRightGlyphWidth);
                rightWidth = Math.max(rightWidth, textWidth);
            }
            else {
                leftWidth = Math.max(leftWidth, textWidth / 2) + Annotation.minAnnotationPadding;
                rightWidth = Math.max(rightWidth, textWidth / 2);
                maxLeftGlyphWidth = Math.max(glyphWidth / 2, maxLeftGlyphWidth);
                maxRightGlyphWidth = Math.max(glyphWidth / 2, maxRightGlyphWidth);
            }
            const stave = note.getStave();
            const stemDirection = note.hasStem() ? note.getStemDirection() : _stem__WEBPACK_IMPORTED_MODULE_3__.Stem.UP;
            let stemHeight = 0;
            let lines = 5;
            if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_5__.isTabNote)(note)) {
                if (note.renderOptions.drawStem) {
                    const stem = note.getStem();
                    if (stem) {
                        stemHeight = Math.abs(stem.getHeight()) / _tables__WEBPACK_IMPORTED_MODULE_4__.Tables.STAVE_LINE_DISTANCE;
                    }
                }
                else {
                    stemHeight = 0;
                }
            }
            else if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_5__.isStemmableNote)(note)) {
                const stem = note.getStem();
                if (stem && note.getNoteType() === 'n') {
                    stemHeight = Math.abs(stem.getHeight()) / _tables__WEBPACK_IMPORTED_MODULE_4__.Tables.STAVE_LINE_DISTANCE;
                }
            }
            if (stave) {
                lines = stave.getNumLines();
            }
            if (annotation.verticalJustification === this.VerticalJustify.TOP) {
                let noteLine = note.getLineNumber(true);
                if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_5__.isTabNote)(note)) {
                    noteLine = lines - (note.leastString() - 0.5);
                }
                if (stemDirection === _stem__WEBPACK_IMPORTED_MODULE_3__.Stem.UP) {
                    noteLine += stemHeight;
                }
                const curTop = noteLine + state.topTextLine + 0.5;
                if (curTop < lines) {
                    annotation.setTextLine(lines - noteLine);
                    verticalSpaceNeeded += lines - noteLine;
                    state.topTextLine = verticalSpaceNeeded;
                }
                else {
                    annotation.setTextLine(state.topTextLine);
                    state.topTextLine += verticalSpaceNeeded;
                }
            }
            else if (annotation.verticalJustification === this.VerticalJustify.BOTTOM) {
                let noteLine = lines - note.getLineNumber();
                if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_5__.isTabNote)(note)) {
                    noteLine = note.greatestString() - 1;
                }
                if (stemDirection === _stem__WEBPACK_IMPORTED_MODULE_3__.Stem.DOWN) {
                    noteLine += stemHeight;
                }
                const curBottom = noteLine + state.textLine + 1;
                if (curBottom < lines) {
                    annotation.setTextLine(lines - curBottom);
                    verticalSpaceNeeded += lines - curBottom;
                    state.textLine = verticalSpaceNeeded;
                }
                else {
                    annotation.setTextLine(state.textLine);
                    state.textLine += verticalSpaceNeeded;
                }
            }
            else {
                annotation.setTextLine(state.textLine);
            }
        }
        const rightOverlap = Math.min(Math.max(rightWidth - maxRightGlyphWidth, 0), Math.max(rightWidth - state.rightShift, 0));
        const leftOverlap = Math.min(Math.max(leftWidth - maxLeftGlyphWidth, 0), Math.max(leftWidth - state.leftShift, 0));
        state.leftShift += leftOverlap;
        state.rightShift += rightOverlap;
        return true;
    }
    /**
     * Annotations inherit from `Modifier` and is positioned correctly when
     * in a `ModifierContext`.
     * Create a new `Annotation` with the string `text`.
     */
    constructor(text) {
        super();
        this.text = text;
        this.horizontalJustification = AnnotationHorizontalJustify.CENTER;
        // warning: the default in the constructor is TOP, but in the factory the default is BOTTOM.
        // this is to support legacy application that may expect this.
        this.verticalJustification = AnnotationVerticalJustify.TOP;
    }
    /**
     * Set vertical position of text (above or below stave).
     * @param just value in `AnnotationVerticalJustify`.
     */
    setVerticalJustification(just) {
        this.verticalJustification = typeof just === 'string' ? Annotation.VerticalJustifyString[just] : just;
        return this;
    }
    /**
     * Get horizontal justification.
     */
    getJustification() {
        return this.horizontalJustification;
    }
    /**
     * Set horizontal justification.
     * @param justification value in `Annotation.Justify`.
     */
    setJustification(just) {
        this.horizontalJustification = typeof just === 'string' ? Annotation.HorizontalJustifyString[just] : just;
        return this;
    }
    /** Render text beside the note. */
    draw() {
        const ctx = this.checkContext();
        const note = this.checkAttachedNote();
        const stemDirection = note.hasStem() ? note.getStemDirection() : _stem__WEBPACK_IMPORTED_MODULE_3__.Stem.UP;
        const start = note.getModifierStartXY(_modifier__WEBPACK_IMPORTED_MODULE_2__.ModifierPosition.ABOVE, this.index);
        this.setRendered();
        // Apply style might not save context, if this.style is undefined, so we
        // still need to save context state just before this, since we will be
        // changing ctx parameters below.
        this.applyStyle();
        ctx.openGroup('annotation', this.getAttribute('id'));
        const textWidth = this.getWidth();
        const textHeight = _font__WEBPACK_IMPORTED_MODULE_0__.Font.convertSizeToPixelValue(this.fontInfo.size);
        let x;
        let y;
        if (this.horizontalJustification === AnnotationHorizontalJustify.LEFT) {
            x = start.x;
        }
        else if (this.horizontalJustification === AnnotationHorizontalJustify.RIGHT) {
            x = start.x - textWidth;
        }
        else if (this.horizontalJustification === AnnotationHorizontalJustify.CENTER) {
            x = start.x - textWidth / 2;
        } /* CENTER_STEM */
        else {
            x = note.getStemX() - textWidth / 2;
        }
        let stemExt = {};
        let spacing = 0;
        const hasStem = note.hasStem();
        const stave = note.checkStave();
        // The position of the text varies based on whether or not the note
        // has a stem.
        if (hasStem) {
            stemExt = note.checkStem().getExtents();
            spacing = stave.getSpacingBetweenLines();
        }
        if (this.verticalJustification === AnnotationVerticalJustify.BOTTOM) {
            // Use the largest (lowest) Y value
            const ys = note.getYs();
            y = ys.reduce((a, b) => (a > b ? a : b));
            y += (this.textLine + 1) * _tables__WEBPACK_IMPORTED_MODULE_4__.Tables.STAVE_LINE_DISTANCE + textHeight;
            if (hasStem && stemDirection === _stem__WEBPACK_IMPORTED_MODULE_3__.Stem.DOWN) {
                y = Math.max(y, stemExt.topY + textHeight + spacing * this.textLine);
            }
        }
        else if (this.verticalJustification === AnnotationVerticalJustify.CENTER) {
            const yt = note.getYForTopText(this.textLine) - 1;
            const yb = stave.getYForBottomText(this.textLine);
            y = yt + (yb - yt) / 2 + textHeight / 2;
        }
        else if (this.verticalJustification === AnnotationVerticalJustify.TOP) {
            const topY = Math.min(...note.getYs());
            y = topY - (this.textLine + 1) * _tables__WEBPACK_IMPORTED_MODULE_4__.Tables.STAVE_LINE_DISTANCE;
            if (hasStem && stemDirection === _stem__WEBPACK_IMPORTED_MODULE_3__.Stem.UP) {
                // If the stem is above the stave already, go with default line width vs. actual
                // since the lines between don't really matter.
                spacing = stemExt.topY < stave.getTopLineTopY() ? _tables__WEBPACK_IMPORTED_MODULE_4__.Tables.STAVE_LINE_DISTANCE : spacing;
                y = Math.min(y, stemExt.topY - spacing * (this.textLine + 1));
            }
        } /* CENTER_STEM */
        else {
            const extents = note.getStemExtents();
            y = extents.topY + (extents.baseY - extents.topY) / 2 + textHeight / 2;
        }
        L('Rendering annotation: ', this.text, x, y);
        this.renderText(ctx, x, y);
        ctx.closeGroup();
        this.restoreStyle();
    }
}
/** To enable logging for this class. Set `Vex.Flow.Annotation.DEBUG` to `true`. */
Annotation.DEBUG = false;
/** Text annotations can be positioned and justified relative to the note. */
Annotation.HorizontalJustify = AnnotationHorizontalJustify;
Annotation.HorizontalJustifyString = {
    left: AnnotationHorizontalJustify.LEFT,
    right: AnnotationHorizontalJustify.RIGHT,
    center: AnnotationHorizontalJustify.CENTER,
    centerStem: AnnotationHorizontalJustify.CENTER_STEM,
};
Annotation.VerticalJustify = AnnotationVerticalJustify;
Annotation.VerticalJustifyString = {
    above: AnnotationVerticalJustify.TOP,
    top: AnnotationVerticalJustify.TOP,
    below: AnnotationVerticalJustify.BOTTOM,
    bottom: AnnotationVerticalJustify.BOTTOM,
    center: AnnotationVerticalJustify.CENTER,
    centerStem: AnnotationVerticalJustify.CENTER_STEM,
};


/***/ }),

/***/ "./src/articulation.ts":
/*!*****************************!*\
  !*** ./src/articulation.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Articulation: () => (/* binding */ Articulation),
/* harmony export */   getBottomY: () => (/* binding */ getBottomY),
/* harmony export */   getInitialOffset: () => (/* binding */ getInitialOffset),
/* harmony export */   getTopY: () => (/* binding */ getTopY)
/* harmony export */ });
/* harmony import */ var _glyphs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glyphs */ "./src/glyphs.ts");
/* harmony import */ var _modifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifier */ "./src/modifier.ts");
/* harmony import */ var _stem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stem */ "./src/stem.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// @author Larry Kuhns.
// MIT License






// eslint-disable-next-line
function L(...args) {
    if (Articulation.DEBUG)
        (0,_util__WEBPACK_IMPORTED_MODULE_5__.log)('Vex.Flow.Articulation', args);
}
const { ABOVE, BELOW } = _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position;
function roundToNearestHalf(mathFn, value) {
    return mathFn(value / 0.5) * 0.5;
}
// This includes both staff and ledger lines
function isWithinLines(line, position) {
    return position === ABOVE ? line <= 5 : line >= 1;
}
function getRoundingFunction(line, position) {
    if (isWithinLines(line, position)) {
        if (position === ABOVE) {
            return Math.ceil;
        }
        else {
            return Math.floor;
        }
    }
    else {
        return Math.round;
    }
}
function snapLineToStaff(canSitBetweenLines, line, position, offsetDirection) {
    // Initially, snap to nearest staff line or space
    const snappedLine = roundToNearestHalf(getRoundingFunction(line, position), line);
    const canSnapToStaffSpace = canSitBetweenLines && isWithinLines(snappedLine, position);
    const onStaffLine = snappedLine % 1 === 0;
    if (canSnapToStaffSpace && onStaffLine) {
        const HALF_STAFF_SPACE = 0.5;
        return snappedLine + HALF_STAFF_SPACE * -offsetDirection;
    }
    else {
        return snappedLine;
    }
}
// Helper function for checking if a Note object is either a StaveNote or a GraceNote.
const isStaveOrGraceNote = (note) => (0,_typeguard__WEBPACK_IMPORTED_MODULE_4__.isStaveNote)(note) || (0,_typeguard__WEBPACK_IMPORTED_MODULE_4__.isGraceNote)(note);
function getTopY(note, textLine) {
    const stemDirection = note.getStemDirection();
    const { topY: stemTipY, baseY: stemBaseY } = note.getStemExtents();
    if (isStaveOrGraceNote(note)) {
        if (note.hasStem()) {
            if (stemDirection === _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.UP) {
                return stemTipY;
            }
            else {
                return stemBaseY;
            }
        }
        else {
            return Math.min(...note.getYs());
        }
    }
    else if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_4__.isTabNote)(note)) {
        if (note.hasStem()) {
            if (stemDirection === _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.UP) {
                return stemTipY;
            }
            else {
                return note.checkStave().getYForTopText(textLine);
            }
        }
        else {
            return note.checkStave().getYForTopText(textLine);
        }
    }
    else {
        throw new _util__WEBPACK_IMPORTED_MODULE_5__.RuntimeError('UnknownCategory', 'Only can get the top and bottom ys of stavenotes and tabnotes');
    }
}
function getBottomY(note, textLine) {
    const stemDirection = note.getStemDirection();
    const { topY: stemTipY, baseY: stemBaseY } = note.getStemExtents();
    if (isStaveOrGraceNote(note)) {
        if (note.hasStem()) {
            if (stemDirection === _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.UP) {
                return stemBaseY;
            }
            else {
                return stemTipY;
            }
        }
        else {
            return Math.max(...note.getYs());
        }
    }
    else if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_4__.isTabNote)(note)) {
        if (note.hasStem()) {
            if (stemDirection === _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.UP) {
                return note.checkStave().getYForBottomText(textLine);
            }
            else {
                return stemTipY;
            }
        }
        else {
            return note.checkStave().getYForBottomText(textLine);
        }
    }
    else {
        throw new _util__WEBPACK_IMPORTED_MODULE_5__.RuntimeError('UnknownCategory', 'Only can get the top and bottom ys of stavenotes and tabnotes');
    }
}
/**
 * Get the initial offset of the articulation from the y value of the starting position.
 * This is required because the top/bottom text positions already have spacing applied to
 * provide a "visually pleasant" default position. However the y values provided from
 * the stavenote's top/bottom do *not* have any pre-applied spacing. This function
 * normalizes this asymmetry.
 * @param note
 * @param position
 * @returns
 */
function getInitialOffset(note, position) {
    const isOnStemTip = (position === ABOVE && note.getStemDirection() === _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.UP) ||
        (position === BELOW && note.getStemDirection() === _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.DOWN);
    if (isStaveOrGraceNote(note)) {
        if (note.hasStem() && isOnStemTip) {
            return 0.5;
        }
        else {
            // this amount is larger than the stem-tip offset because we start from
            // the center of the notehead
            return 1;
        }
    }
    else {
        if (note.hasStem() && isOnStemTip) {
            return 1;
        }
        else {
            return 0;
        }
    }
}
/**
 * Articulations and Accents are modifiers that can be
 * attached to notes. The complete list of articulations is available in
 * `tables.ts` under `Vex.Flow.articulationCodes`.
 *
 * See `tests/articulation_tests.ts` for usage examples.
 */
class Articulation extends _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier {
    /** Articulations category string. */
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_4__.Category.Articulation;
    }
    /**
     * FIXME:
     * Most of the complex formatting logic (ie: snapping to space) is
     * actually done in .render(). But that logic belongs in this method.
     *
     * Unfortunately, this isn't possible because, by this point, stem lengths
     * have not yet been finalized. Finalized stem lengths are required to determine the
     * initial position of any stem-side articulation.
     *
     * This indicates that all objects should have their stave set before being
     * formatted. It can't be an optional if you want accurate vertical positioning.
     * Consistently positioned articulations that play nice with other modifiers
     * won't be possible until we stop relying on render-time formatting.
     *
     * Ideally, when this function has completed, the vertical articulation positions
     * should be ready to render without further adjustment. But the current state
     * is far from this ideal.
     */
    static format(articulations, state) {
        if (!articulations || articulations.length === 0)
            return false;
        const margin = 0.5;
        let maxGlyphWidth = 0;
        const getIncrement = (articulation, line, position) => roundToNearestHalf(getRoundingFunction(line, position), articulation.height / 10 + margin);
        articulations.forEach((articulation) => {
            const note = articulation.checkAttachedNote();
            maxGlyphWidth = Math.max(note.getGlyphWidth(), maxGlyphWidth);
            let lines = 5;
            const stemDirection = note.hasStem() ? note.getStemDirection() : _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.UP;
            let stemHeight = 0;
            // Decide if we need to consider beam direction in placement.
            if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_4__.isStemmableNote)(note)) {
                const stem = note.getStem();
                if (stem) {
                    stemHeight = Math.abs(stem.getHeight()) / _tables__WEBPACK_IMPORTED_MODULE_3__.Tables.STAVE_LINE_DISTANCE;
                }
            }
            const stave = note.getStave();
            if (stave) {
                lines = stave.getNumLines();
            }
            if (articulation.getPosition() === ABOVE) {
                let noteLine = note.getLineNumber(true);
                if (stemDirection === _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.UP) {
                    noteLine += stemHeight;
                }
                let increment = getIncrement(articulation, state.topTextLine, ABOVE);
                const curTop = noteLine + state.topTextLine + 0.5;
                // If articulation must be above stave, add lines between note and stave top
                if (!articulation.articulation.betweenLines && curTop < lines) {
                    increment += lines - curTop;
                }
                articulation.setTextLine(state.topTextLine);
                state.topTextLine += increment;
            }
            else if (articulation.getPosition() === BELOW) {
                let noteLine = Math.max(lines - note.getLineNumber(), 0);
                if (stemDirection === _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.DOWN) {
                    noteLine += stemHeight;
                }
                let increment = getIncrement(articulation, state.textLine, BELOW);
                const curBottom = noteLine + state.textLine + 0.5;
                // if articulation must be below stave, add lines from note to stave bottom
                if (!articulation.articulation.betweenLines && curBottom < lines) {
                    increment += lines - curBottom;
                }
                articulation.setTextLine(state.textLine);
                state.textLine += increment;
            }
        });
        const width = articulations
            .map((articulation) => articulation.getWidth())
            .reduce((maxWidth, articWidth) => Math.max(articWidth, maxWidth));
        const overlap = Math.min(Math.max(width - maxGlyphWidth, 0), Math.max(width - (state.leftShift + state.rightShift), 0));
        state.leftShift += overlap / 2;
        state.rightShift += overlap / 2;
        return true;
    }
    static easyScoreHook({ articulations }, note, builder) {
        if (!articulations)
            return;
        const articNameToCode = {
            staccato: 'a.',
            tenuto: 'a-',
            accent: 'a>',
        };
        articulations
            .split(',')
            .map((articString) => articString.trim().split('.'))
            .map(([name, position]) => {
            const artic = { type: articNameToCode[name] };
            if (position)
                artic.position = _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.PositionString[position];
            return builder.getFactory().Articulation(artic);
        })
            .map((artic) => note.addModifier(artic, 0));
    }
    /**
     * Create a new articulation.
     * @param type entry in `Vex.Flow.articulationCodes` in `tables.ts` or Glyph code.
     *
     * Notes default positions (see https://w3c.github.io/smufl/latest/tables/articulation.html):
     * - Even codes will be positioned ABOVE
     * - Odd codes will be positioned BELOW
     */
    constructor(type) {
        var _a;
        super();
        this.heightShift = 0;
        this.type = type;
        this.position = ABOVE;
        if (!_tables__WEBPACK_IMPORTED_MODULE_3__.Tables.articulationCodes(this.type)) {
            if (((_a = this.type.codePointAt(0)) !== null && _a !== void 0 ? _a : 0) % 2 === 0)
                this.position = ABOVE;
            else
                this.position = BELOW;
        }
        this.articulation = { betweenLines: false };
        this.reset();
    }
    reset() {
        this.articulation = _tables__WEBPACK_IMPORTED_MODULE_3__.Tables.articulationCodes(this.type);
        // Use type as glyph code, if not defined as articulation code
        if (!this.articulation) {
            this.articulation = { code: this.type, betweenLines: false };
        }
        const code = (this.position === ABOVE ? this.articulation.aboveCode : this.articulation.belowCode) ||
            this.articulation.code ||
            _glyphs__WEBPACK_IMPORTED_MODULE_0__.Glyphs.null;
        this.text = code;
    }
    /** Set if articulation should be rendered between lines. */
    setBetweenLines(betweenLines = true) {
        this.articulation.betweenLines = betweenLines;
        return this;
    }
    /** Render articulation in position next to note. */
    draw() {
        const ctx = this.checkContext();
        const note = this.checkAttachedNote();
        this.setRendered();
        const index = this.checkIndex();
        const { position, textLine } = this;
        const canSitBetweenLines = this.articulation.betweenLines;
        const stave = note.checkStave();
        const staffSpace = stave.getSpacingBetweenLines();
        const isTab = (0,_typeguard__WEBPACK_IMPORTED_MODULE_4__.isTabNote)(note);
        // Articulations are centered over/under the note head.
        const { x } = note.getModifierStartXY(position, index);
        const shouldSitOutsideStaff = !canSitBetweenLines || isTab;
        const initialOffset = getInitialOffset(note, position);
        let y = {
            [ABOVE]: () => {
                this.setOrigin(0.5, 1);
                const y = getTopY(note, textLine) - (textLine + initialOffset) * staffSpace;
                return shouldSitOutsideStaff ? Math.min(stave.getYForTopText(Articulation.INITIAL_OFFSET), y) : y;
            },
            [BELOW]: () => {
                this.setOrigin(0.5, 0);
                const y = getBottomY(note, textLine) + (textLine + initialOffset) * staffSpace;
                return shouldSitOutsideStaff ? Math.max(stave.getYForBottomText(Articulation.INITIAL_OFFSET), y) : y;
            },
        }[position]();
        if (!isTab) {
            const offsetDirection = position === ABOVE ? -1 : +1;
            const noteLine = note.getKeyProps()[index].line;
            const distanceFromNote = (note.getYs()[index] - y) / staffSpace;
            const articLine = distanceFromNote + Number(noteLine);
            const snappedLine = snapLineToStaff(canSitBetweenLines, articLine, position, offsetDirection);
            if (isWithinLines(snappedLine, position))
                this.setOrigin(0.5, 0.5);
            y += Math.abs(snappedLine - articLine) * staffSpace * offsetDirection;
        }
        L(`Rendering articulation at (x: ${x}, y: ${y})`);
        this.renderText(ctx, x, y);
    }
}
/** To enable logging for this class. Set `Vex.Flow.Articulation.DEBUG` to `true`. */
Articulation.DEBUG = false;
Articulation.INITIAL_OFFSET = -0.5;


/***/ }),

/***/ "./src/barnote.ts":
/*!************************!*\
  !*** ./src/barnote.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BarNote: () => (/* binding */ BarNote)
/* harmony export */ });
/* harmony import */ var _note__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./note */ "./src/note.ts");
/* harmony import */ var _stavebarline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stavebarline */ "./src/stavebarline.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License




// eslint-disable-next-line
function L(...args) {
    if (BarNote.DEBUG)
        (0,_util__WEBPACK_IMPORTED_MODULE_3__.log)('Vex.Flow.BarNote', args);
}
/**
 * A `BarNote` is used to render bar lines (from `barline.ts`). `BarNote`s can
 * be added to a voice and rendered in the middle of a stave. Since it has no
 * duration, it consumes no `tick`s, and is dealt with appropriately by the formatter.
 *
 * See `tests/barnote_tests.ts` for usage examples.
 */
class BarNote extends _note__WEBPACK_IMPORTED_MODULE_0__.Note {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_2__.Category.BarNote;
    }
    constructor(type = _stavebarline__WEBPACK_IMPORTED_MODULE_1__.BarlineType.SINGLE) {
        super({ duration: 'b' });
        this.metrics = {
            widths: {},
        };
        const TYPE = _stavebarline__WEBPACK_IMPORTED_MODULE_1__.BarlineType;
        this.metrics.widths = {
            [TYPE.SINGLE]: 8,
            [TYPE.DOUBLE]: 12,
            [TYPE.END]: 15,
            [TYPE.REPEAT_BEGIN]: 14,
            [TYPE.REPEAT_END]: 14,
            [TYPE.REPEAT_BOTH]: 18,
            [TYPE.NONE]: 0,
        };
        // Tell the formatter that bar notes have no duration.
        this.ignoreTicks = true;
        this.setType(type);
    }
    /** Get the type of bar note.*/
    getType() {
        return this.type;
    }
    /** Set the type of bar note. */
    setType(type) {
        this.type = typeof type === 'string' ? _stavebarline__WEBPACK_IMPORTED_MODULE_1__.Barline.typeString[type] : type;
        // Set width to width of relevant `Barline`.
        this.setWidth(this.metrics.widths[this.type]);
        return this;
    }
    /* Overridden to ignore */
    // eslint-disable-next-line
    addToModifierContext(mc) {
        // DO NOTHING.
        return this;
    }
    /** Overridden to ignore. */
    preFormat() {
        this.preFormatted = true;
        return this;
    }
    /** Render note to stave. */
    draw() {
        const ctx = this.checkContext();
        L('Rendering bar line at: ', this.getAbsoluteX());
        this.applyStyle(ctx);
        const barline = new _stavebarline__WEBPACK_IMPORTED_MODULE_1__.Barline(this.type);
        barline.setX(this.getAbsoluteX());
        barline.draw(this.checkStave());
        this.restoreStyle(ctx);
        this.setRendered();
    }
}
/** To enable logging for this class. Set `Vex.Flow.BarNote.DEBUG` to `true`. */
BarNote.DEBUG = false;


/***/ }),

/***/ "./src/beam.ts":
/*!*********************!*\
  !*** ./src/beam.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BEAM_BOTH: () => (/* binding */ BEAM_BOTH),
/* harmony export */   BEAM_LEFT: () => (/* binding */ BEAM_LEFT),
/* harmony export */   BEAM_RIGHT: () => (/* binding */ BEAM_RIGHT),
/* harmony export */   Beam: () => (/* binding */ Beam)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _fraction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fraction */ "./src/fraction.ts");
/* harmony import */ var _stem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stem */ "./src/stem.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _tuplet__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tuplet */ "./src/tuplet.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Beam_stemDirection, _Beam_ticks, _Beam_yShift, _Beam_breakOnIndexes, _Beam_beamCount, _Beam_unbeamable, _Beam_forcedPartialDirections;







function calculateStemDirection(notes) {
    let lineSum = 0;
    notes.forEach((note) => {
        if (note.keyProps) {
            note.keyProps.forEach((keyProp) => {
                lineSum += keyProp.line - 3;
            });
        }
    });
    if (lineSum >= 0) {
        return _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.DOWN;
    }
    return _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.UP;
}
function getStemSlope(firstNote, lastNote) {
    const firstStemTipY = firstNote.getStemExtents().topY;
    const firstStemX = firstNote.getStemX();
    const lastStemTipY = lastNote.getStemExtents().topY;
    const lastStemX = lastNote.getStemX();
    return (lastStemTipY - firstStemTipY) / (lastStemX - firstStemX);
}
const BEAM_LEFT = 'L';
const BEAM_RIGHT = 'R';
const BEAM_BOTH = 'B';
/** `Beams` span over a set of `StemmableNotes`. */
class Beam extends _element__WEBPACK_IMPORTED_MODULE_0__.Element {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_5__.Category.Beam;
    }
    /** Get the direction of the beam */
    getStemDirection() {
        return __classPrivateFieldGet(this, _Beam_stemDirection, "f");
    }
    /**
     * Get the default beam groups for a provided time signature.
     * Attempt to guess if the time signature is not found in table.
     * Currently this is fairly naive.
     */
    static getDefaultBeamGroups(timeSig) {
        if (!timeSig || timeSig === 'c') {
            timeSig = '4/4';
        }
        const defaults = {
            '1/2': ['1/2'],
            '2/2': ['1/2'],
            '3/2': ['1/2'],
            '4/2': ['1/2'],
            '1/4': ['1/4'],
            '2/4': ['1/4'],
            '3/4': ['1/4'],
            '4/4': ['1/4'],
            '1/8': ['1/8'],
            '2/8': ['2/8'],
            '3/8': ['3/8'],
            '4/8': ['2/8'],
            '1/16': ['1/16'],
            '2/16': ['2/16'],
            '3/16': ['3/16'],
            '4/16': ['2/16'],
        };
        const groups = defaults[timeSig];
        if (groups === undefined) {
            // If no beam groups found, naively determine
            // the beam groupings from the time signature
            const beatTotal = parseInt(timeSig.split('/')[0], 10);
            const beatValue = parseInt(timeSig.split('/')[1], 10);
            const tripleMeter = beatTotal % 3 === 0;
            if (tripleMeter) {
                return [new _fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction(3, beatValue)];
            }
            else if (beatValue > 4) {
                return [new _fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction(2, beatValue)];
            }
            else if (beatValue <= 4) {
                return [new _fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction(1, beatValue)];
            }
        }
        else {
            return groups.map((group) => new _fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction().parse(group));
        }
        return [new _fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction(1, 4)];
    }
    /**
     * A helper function to automatically build basic beams for a voice. For more
     * complex auto-beaming use `Beam.generateBeams()`.
     * @param voice the voice to generate the beams for
     * @param stemDirection a stem direction to apply to the entire voice
     * @param groups an array of `Fraction` representing beat groupings for the beam
     */
    static applyAndGetBeams(voice, stemDirection, groups) {
        return Beam.generateBeams(voice.getTickables(), { groups, stemDirection });
    }
    /**
     * A helper function to autimatically build beams for a voice with
     * configuration options.
     *
     * Example configuration object:
     *
     * ```
     * config = {
     *   groups: [new Vex.Flow.Fraction(2, 8)],
     *   stemDirection: -1,
     *   beamRests: true,
     *   beamMiddleOnly: true,
     *   showStemlets: false
     * };
     * ```
     * @param notes an array of notes to create the beams for
     * @param config the configuration object
     * @param config.stemDirection set to apply the same direction to all notes
     * @param config.beamRests set to `true` to include rests in the beams
     * @param config.beamMiddleOnly set to `true` to only beam rests in the middle of the beat
     * @param config.showStemlets set to `true` to draw stemlets for rests
     * @param config.maintainStemDirections set to `true` to not apply new stem directions
     * @param config.groups array of `Fractions` that represent the beat structure to beam the notes
     *
     */
    static generateBeams(notes, config = {}) {
        if (!config.groups || !config.groups.length) {
            config.groups = [new _fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction(2, 8)];
        }
        // Convert beam groups to tick amounts
        const tickGroups = config.groups.map((group) => {
            if (!group.multiply) {
                throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('InvalidBeamGroups', 'The beam groups must be an array of Vex.Flow.Fractions');
            }
            return group.clone().multiply(_tables__WEBPACK_IMPORTED_MODULE_3__.Tables.RESOLUTION, 1);
        });
        const unprocessedNotes = notes;
        let currentTickGroup = 0;
        let noteGroups = [];
        let currentGroup = [];
        function getTotalTicks(notes) {
            return notes.reduce((memo, note) => note.getTicks().clone().add(memo), new _fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction(0, 1));
        }
        function nextTickGroup() {
            if (tickGroups.length - 1 > currentTickGroup) {
                currentTickGroup += 1;
            }
            else {
                currentTickGroup = 0;
            }
        }
        function createGroups() {
            let nextGroup = [];
            // number of ticks in current group
            let currentGroupTotalTicks = new _fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction(0, 1);
            unprocessedNotes.forEach((unprocessedNote) => {
                nextGroup = [];
                if (unprocessedNote.shouldIgnoreTicks()) {
                    noteGroups.push(currentGroup);
                    currentGroup = nextGroup;
                    return; // Ignore untickables (like bar notes)
                }
                currentGroup.push(unprocessedNote);
                const ticksPerGroup = tickGroups[currentTickGroup].clone();
                const totalTicks = getTotalTicks(currentGroup).add(currentGroupTotalTicks);
                // Double the amount of ticks in a group, if it's an unbeamable tuplet
                const unbeamable = _tables__WEBPACK_IMPORTED_MODULE_3__.Tables.durationToNumber(unprocessedNote.getDuration()) < 8;
                if (unbeamable && unprocessedNote.getTuplet()) {
                    ticksPerGroup.numerator *= 2;
                }
                // If the note that was just added overflows the group tick total
                if (totalTicks.greaterThan(ticksPerGroup)) {
                    // If the overflow note can be beamed, start the next group
                    // with it. Unbeamable notes leave the group overflowed.
                    if (!unbeamable) {
                        const note = currentGroup.pop();
                        if (note)
                            nextGroup.push(note);
                    }
                    noteGroups.push(currentGroup);
                    // We have overflown, so we're going to next tick group. As we might have
                    // overflown by more than 1 group, we need to go forward as many times as
                    // needed, decreasing currentGroupTotalTicks by as many ticks as there are
                    // in current groups as we go forward.
                    do {
                        currentGroupTotalTicks = totalTicks.subtract(tickGroups[currentTickGroup]);
                        nextTickGroup();
                    } while (currentGroupTotalTicks.greaterThanEquals(tickGroups[currentTickGroup]));
                    currentGroup = nextGroup;
                }
                else if (totalTicks.equals(ticksPerGroup)) {
                    noteGroups.push(currentGroup);
                    currentGroupTotalTicks = new _fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction(0, 1);
                    currentGroup = nextGroup;
                    nextTickGroup();
                }
            });
            // Adds any remainder notes beam
            if (currentGroup.length > 0) {
                noteGroups.push(currentGroup);
            }
        }
        function getBeamGroups() {
            return noteGroups.filter((group) => {
                if (group.length > 1) {
                    let beamable = true;
                    group.forEach((note) => {
                        if (note.getIntrinsicTicks() >= _tables__WEBPACK_IMPORTED_MODULE_3__.Tables.durationToTicks('4')) {
                            beamable = false;
                        }
                    });
                    return beamable;
                }
                return false;
            });
        }
        // Splits up groups by Rest
        function sanitizeGroups() {
            const sanitizedGroups = [];
            noteGroups.forEach((group) => {
                let tempGroup = [];
                group.forEach((note, index, group) => {
                    const isFirstOrLast = index === 0 || index === group.length - 1;
                    const prevNote = group[index - 1];
                    const breaksOnEachRest = !config.beamRests && note.isRest();
                    const breaksOnFirstOrLastRest = config.beamRests && config.beamMiddleOnly && note.isRest() && isFirstOrLast;
                    let breakOnStemChange = false;
                    if (config.maintainStemDirections && prevNote && !note.isRest() && !prevNote.isRest()) {
                        const prevDirection = prevNote.getStemDirection();
                        const currentDirection = note.getStemDirection();
                        breakOnStemChange = currentDirection !== prevDirection;
                    }
                    const isUnbeamableDuration = parseInt(note.getDuration(), 10) < 8;
                    // Determine if the group should be broken at this note
                    const shouldBreak = breaksOnEachRest || breaksOnFirstOrLastRest || breakOnStemChange || isUnbeamableDuration;
                    if (shouldBreak) {
                        // Add current group
                        if (tempGroup.length > 0) {
                            sanitizedGroups.push(tempGroup);
                        }
                        // Start a new group. Include the current note if the group
                        // was broken up by stem direction, as that note needs to start
                        // the next group of notes
                        tempGroup = breakOnStemChange ? [note] : [];
                    }
                    else {
                        // Add note to group
                        tempGroup.push(note);
                    }
                });
                // If there is a remaining group, add it as well
                if (tempGroup.length > 0) {
                    sanitizedGroups.push(tempGroup);
                }
            });
            noteGroups = sanitizedGroups;
        }
        function formatStems() {
            noteGroups.forEach((group) => {
                let stemDirection;
                if (config.maintainStemDirections) {
                    const note = findFirstNote(group);
                    stemDirection = note ? note.getStemDirection() : _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.UP;
                }
                else {
                    if (config.stemDirection) {
                        stemDirection = config.stemDirection;
                    }
                    else {
                        stemDirection = calculateStemDirection(group);
                    }
                }
                applyStemDirection(group, stemDirection);
            });
        }
        function findFirstNote(group) {
            for (let i = 0; i < group.length; i++) {
                const note = group[i];
                if (!note.isRest()) {
                    return note;
                }
            }
            return false;
        }
        function applyStemDirection(group, direction) {
            group.forEach((note) => {
                note.setStemDirection(direction);
            });
        }
        // Get all of the tuplets in all of the note groups
        function getTuplets() {
            const uniqueTuplets = [];
            // Go through all of the note groups and inspect for tuplets
            noteGroups.forEach((group) => {
                let tuplet;
                group.forEach((note) => {
                    const noteTuplet = note.getTuplet();
                    if (noteTuplet && tuplet !== noteTuplet) {
                        tuplet = noteTuplet;
                        uniqueTuplets.push(tuplet);
                    }
                });
            });
            return uniqueTuplets;
        }
        // Using closures to store the variables throughout the various functions
        // IMO Keeps it this process lot cleaner - but not super consistent with
        // the rest of the API's style - Silverwolf90 (Cyril)
        createGroups();
        sanitizeGroups();
        formatStems();
        // Get the notes to be beamed
        const beamedNoteGroups = getBeamGroups();
        // Get the tuplets in order to format them accurately
        const allTuplets = getTuplets();
        // Create a Vex.Flow.Beam from each group of notes to be beamed
        const beams = [];
        beamedNoteGroups.forEach((group) => {
            const beam = new Beam(group);
            if (config.showStemlets) {
                beam.renderOptions.showStemlets = true;
            }
            if (config.secondaryBreaks) {
                beam.renderOptions.secondaryBreakTicks = _tables__WEBPACK_IMPORTED_MODULE_3__.Tables.durationToTicks(config.secondaryBreaks);
            }
            if (config.flatBeams === true) {
                beam.renderOptions.flatBeams = true;
                beam.renderOptions.flatBeamOffset = config.flatBeamOffset;
            }
            beams.push(beam);
        });
        // Reformat tuplets
        allTuplets.forEach((tuplet) => {
            // Set the tuplet location based on the stem direction
            const direction = tuplet.notes[0].stemDirection === _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.DOWN ? _tuplet__WEBPACK_IMPORTED_MODULE_4__.TupletLocation.BOTTOM : _tuplet__WEBPACK_IMPORTED_MODULE_4__.TupletLocation.TOP;
            tuplet.setTupletLocation(direction);
            // If any of the notes in the tuplet are not beamed, draw a bracket.
            let bracketed = false;
            for (let i = 0; i < tuplet.notes.length; i++) {
                const note = tuplet.notes[i];
                if (!note.hasBeam()) {
                    bracketed = true;
                    break;
                }
            }
            tuplet.setBracketed(bracketed);
        });
        return beams;
    }
    constructor(notes, autoStem = false) {
        super();
        this.slope = 0;
        _Beam_stemDirection.set(this, void 0);
        _Beam_ticks.set(this, void 0);
        _Beam_yShift.set(this, 0);
        _Beam_breakOnIndexes.set(this, void 0);
        _Beam_beamCount.set(this, void 0);
        _Beam_unbeamable.set(this, void 0);
        /**
         * Overrides to default beam directions for secondary-level beams that do not
         * connect to any other note. See further explanation at
         * `setPartialBeamSideAt`
         */
        _Beam_forcedPartialDirections.set(this, {});
        if (!notes || notes.length === 0) {
            throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('BadArguments', 'No notes provided for beam.');
        }
        if (notes.length === 1) {
            throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('BadArguments', 'Too few notes for beam.');
        }
        // Validate beam line, direction and ticks.
        __classPrivateFieldSet(this, _Beam_ticks, notes[0].getIntrinsicTicks(), "f");
        if (__classPrivateFieldGet(this, _Beam_ticks, "f") >= _tables__WEBPACK_IMPORTED_MODULE_3__.Tables.durationToTicks('4')) {
            throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('BadArguments', 'Beams can only be applied to notes shorter than a quarter note.');
        }
        let i; // shared iterator
        let note;
        __classPrivateFieldSet(this, _Beam_stemDirection, notes[0].getStemDirection(), "f");
        let stemDirection = __classPrivateFieldGet(this, _Beam_stemDirection, "f");
        // Figure out optimal stem direction based on given notes
        if (autoStem && (0,_typeguard__WEBPACK_IMPORTED_MODULE_5__.isStaveNote)(notes[0])) {
            stemDirection = calculateStemDirection(notes);
        }
        else if (autoStem && (0,_typeguard__WEBPACK_IMPORTED_MODULE_5__.isTabNote)(notes[0])) {
            // Auto Stem TabNotes
            const stemWeight = notes.reduce((memo, note) => memo + note.getStemDirection(), 0);
            stemDirection = stemWeight > -1 ? _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.UP : _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.DOWN;
        }
        // Apply stem directions and attach beam to notes
        for (i = 0; i < notes.length; ++i) {
            note = notes[i];
            if (autoStem) {
                note.setStemDirection(stemDirection);
                __classPrivateFieldSet(this, _Beam_stemDirection, stemDirection, "f");
            }
            note.setBeam(this);
        }
        this.postFormatted = false;
        this.notes = notes;
        __classPrivateFieldSet(this, _Beam_beamCount, this.getBeamCount(), "f");
        __classPrivateFieldSet(this, _Beam_breakOnIndexes, [], "f");
        this.renderOptions = {
            beamWidth: 5,
            maxSlope: 0.25,
            minSlope: -0.25,
            slopeIterations: 20,
            slopeCost: 100,
            showStemlets: false,
            stemletExtension: 7,
            partialBeamLength: 10,
            flatBeams: false,
            minFlatBeamOffset: 15,
        };
    }
    /** Get the notes in this beam. */
    getNotes() {
        return this.notes;
    }
    /** Get the max number of beams in the set of notes. */
    getBeamCount() {
        const beamCounts = this.notes.map((note) => note.getGlyphProps().beamCount);
        const maxBeamCount = beamCounts.reduce((max, beamCount) => (beamCount > max ? beamCount : max));
        return maxBeamCount;
    }
    /** Set which note `indexes` to break the secondary beam at. */
    breakSecondaryAt(indexes) {
        __classPrivateFieldSet(this, _Beam_breakOnIndexes, indexes, "f");
        return this;
    }
    /**
     * Forces the direction of a partial beam (a secondary-level beam that exists
     * on one note only of the beam group). This is useful in rhythms such as 6/8
     * eighth-sixteenth-eighth-sixteenth, where the direction of the beam on the
     * first sixteenth note can help imply whether the rhythm is to be felt as
     * three groups of eighth notes (typical) or as two groups of three-sixteenths
     * (less common):
     * ```
     *        
     *         vs      
     *                     
     * ```
     */
    setPartialBeamSideAt(noteIndex, side) {
        __classPrivateFieldGet(this, _Beam_forcedPartialDirections, "f")[noteIndex] = side;
        return this;
    }
    /**
     * Restore the default direction of a partial beam (a secondary-level beam
     * that does not connect to any other notes).
     */
    unsetPartialBeamSideAt(noteIndex) {
        delete __classPrivateFieldGet(this, _Beam_forcedPartialDirections, "f")[noteIndex];
        return this;
    }
    /**
     * @param firstX specified in pixels.
     * @param firstY specified in pixels.
     *
     * @return the y coordinate for linear function.
     */
    getSlopeY(x, firstX, firstY, slope) {
        return firstY + (x - firstX) * slope;
    }
    /** Calculate the best possible slope for the provided notes. */
    calculateSlope() {
        const { notes, renderOptions: { maxSlope, minSlope, slopeIterations, slopeCost }, } = this;
        const stemDirection = __classPrivateFieldGet(this, _Beam_stemDirection, "f");
        const firstNote = notes[0];
        const initialSlope = getStemSlope(firstNote, notes[notes.length - 1]);
        const increment = (maxSlope - minSlope) / slopeIterations;
        let minCost = Number.MAX_VALUE;
        let bestSlope = 0;
        let yShift = 0;
        // iterate through slope values to find best weighted fit
        for (let slope = minSlope; slope <= maxSlope; slope += increment) {
            let totalStemExtension = 0;
            let yShiftTemp = 0;
            // iterate through notes, calculating y shift and stem extension
            for (let i = 1; i < notes.length; ++i) {
                const note = notes[i];
                if (note.hasStem() || note.isRest()) {
                    const adjustedStemTipY = this.getSlopeY(note.getStemX(), firstNote.getStemX(), firstNote.getStemExtents().topY, slope) + yShiftTemp;
                    const stemTipY = note.getStemExtents().topY;
                    // beam needs to be shifted up to accommodate note
                    if (stemTipY * stemDirection < adjustedStemTipY * stemDirection) {
                        const diff = Math.abs(stemTipY - adjustedStemTipY);
                        yShiftTemp += diff * -stemDirection;
                        totalStemExtension += diff * i;
                    }
                    else {
                        // beam overshoots note, account for the difference
                        totalStemExtension += (stemTipY - adjustedStemTipY) * stemDirection;
                    }
                }
            }
            // most engraving books suggest aiming for a slope about half the angle of the
            // difference between the first and last notes' stem length;
            const idealSlope = initialSlope / 2;
            const distanceFromIdeal = Math.abs(idealSlope - slope);
            // This tries to align most beams to something closer to the idealSlope, but
            // doesn't go crazy. To disable, set this.renderOptions.slopeCost = 0
            const cost = slopeCost * distanceFromIdeal + Math.abs(totalStemExtension);
            // update state when a more ideal slope is found
            if (cost < minCost) {
                minCost = cost;
                bestSlope = slope;
                yShift = yShiftTemp;
            }
        }
        this.slope = bestSlope;
        __classPrivateFieldSet(this, _Beam_yShift, yShift, "f");
    }
    /** Calculate a slope and y-shift for flat beams. */
    calculateFlatSlope() {
        const { notes, renderOptions: { beamWidth, minFlatBeamOffset, flatBeamOffset }, } = this;
        const stemDirection = __classPrivateFieldGet(this, _Beam_stemDirection, "f");
        // If a flat beam offset has not yet been supplied or calculated,
        // generate one based on the notes in this particular note group
        let total = 0;
        let extremeY = 0; // Store the highest or lowest note here
        let extremeBeamCount = 0; // The beam count of the extreme note
        let currentExtreme = 0;
        for (let i = 0; i < notes.length; i++) {
            // Total up all of the offsets so we can average them out later
            const note = notes[i];
            const stemTipY = note.getStemExtents().topY;
            total += stemTipY;
            // Store the highest (stems-up) or lowest (stems-down) note so the
            //  offset can be adjusted in case the average isn't enough
            if (stemDirection === _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.DOWN && currentExtreme < stemTipY) {
                currentExtreme = stemTipY;
                extremeY = Math.max(...note.getYs());
                extremeBeamCount = note.getBeamCount();
            }
            else if (stemDirection === _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.UP && (currentExtreme === 0 || currentExtreme > stemTipY)) {
                currentExtreme = stemTipY;
                extremeY = Math.min(...note.getYs());
                extremeBeamCount = note.getBeamCount();
            }
        }
        // Average the offsets to try and come up with a reasonable one that
        // works for all of the notes in the beam group.
        let offset = total / notes.length;
        // In case the average isn't long enough, add or subtract some more
        // based on the highest or lowest note (again, based on the stem
        // direction). This also takes into account the added height due to
        // the width of the beams.
        const extremeTest = minFlatBeamOffset + extremeBeamCount * beamWidth * 1.5;
        const newOffset = extremeY + extremeTest * -stemDirection;
        if (stemDirection === _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.DOWN && offset < newOffset) {
            offset = extremeY + extremeTest;
        }
        else if (stemDirection === _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.UP && offset > newOffset) {
            offset = extremeY - extremeTest;
        }
        if (!flatBeamOffset) {
            // Set the offset for the group based on the calculations above.
            this.renderOptions.flatBeamOffset = offset;
        }
        else if (stemDirection === _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.DOWN && offset > flatBeamOffset) {
            this.renderOptions.flatBeamOffset = offset;
        }
        else if (stemDirection === _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.UP && offset < flatBeamOffset) {
            this.renderOptions.flatBeamOffset = offset;
        }
        // For flat beams, the slope and yShift are 0.
        this.slope = 0;
        __classPrivateFieldSet(this, _Beam_yShift, 0, "f");
    }
    /** Return the Beam y offset. */
    getBeamYToDraw() {
        const firstNote = this.notes[0];
        const firstStemTipY = firstNote.getStemExtents().topY;
        let beamY = firstStemTipY;
        // For flat beams, set the first and last Y to the offset, rather than
        //  using the note's stem extents.
        if (this.renderOptions.flatBeams && this.renderOptions.flatBeamOffset) {
            beamY = this.renderOptions.flatBeamOffset;
        }
        return beamY;
    }
    /**
     * Create new stems for the notes in the beam, so that each stem
     * extends into the beams.
     */
    applyStemExtensions() {
        const { notes, slope, renderOptions: { showStemlets, stemletExtension, beamWidth }, } = this;
        const yShift = __classPrivateFieldGet(this, _Beam_yShift, "f");
        const beamCount = __classPrivateFieldGet(this, _Beam_beamCount, "f");
        const firstNote = notes[0];
        const firstStemTipY = this.getBeamYToDraw();
        const firstStemX = firstNote.getStemX();
        for (let i = 0; i < notes.length; ++i) {
            const note = notes[i];
            const stem = note.getStem();
            if (stem) {
                const stemX = note.getStemX();
                const { topY: stemTipY } = note.getStemExtents();
                const beamedStemTipY = this.getSlopeY(stemX, firstStemX, firstStemTipY, slope) + yShift;
                const preBeamExtension = stem.getExtension();
                const beamExtension = note.getStemDirection() === _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.UP ? stemTipY - beamedStemTipY : beamedStemTipY - stemTipY;
                // Determine necessary extension for cross-stave notes in the beam group
                let crossStemExtension = 0;
                if (note.getStemDirection() !== __classPrivateFieldGet(this, _Beam_stemDirection, "f")) {
                    const beamCount = note.getGlyphProps().beamCount;
                    crossStemExtension = (1 + (beamCount - 1) * 1.5) * this.renderOptions.beamWidth;
                    /* This will be required if the partial beams are moved to the note side.
                    if (i > 0 && note.getGlyph().beamCount > 1) {
                      const prevBeamCount = this.notes[i - 1].getGlyph().beamCount;
                      const beamDiff = Math.abs(prevBeamCount - beamCount);
                      if (beamDiff > 0) crossStemExtension -= beamDiff * (this.renderOptions.beamWidth * 1.5);
                    }
                    */
                }
                stem.setExtension(preBeamExtension + beamExtension + crossStemExtension);
                stem.adjustHeightForBeam();
                if (note.isRest() && showStemlets) {
                    const totalBeamWidth = (beamCount - 1) * beamWidth * 1.5 + beamWidth;
                    stem.setVisibility(true).setStemlet(true, totalBeamWidth + stemletExtension);
                }
            }
        }
    }
    /** Return upper level beam direction. */
    lookupBeamDirection(duration, prevTick, tick, nextTick, noteIndex) {
        if (duration === '4') {
            return BEAM_LEFT;
        }
        const forcedBeamDirection = __classPrivateFieldGet(this, _Beam_forcedPartialDirections, "f")[noteIndex];
        if (forcedBeamDirection)
            return forcedBeamDirection;
        const lookupDuration = `${_tables__WEBPACK_IMPORTED_MODULE_3__.Tables.durationToNumber(duration) / 2}`;
        const prevNoteGetsBeam = prevTick < _tables__WEBPACK_IMPORTED_MODULE_3__.Tables.durationToTicks(lookupDuration);
        const nextNoteGetsBeam = nextTick < _tables__WEBPACK_IMPORTED_MODULE_3__.Tables.durationToTicks(lookupDuration);
        const noteGetsBeam = tick < _tables__WEBPACK_IMPORTED_MODULE_3__.Tables.durationToTicks(lookupDuration);
        if (prevNoteGetsBeam && nextNoteGetsBeam && noteGetsBeam) {
            return BEAM_BOTH;
        }
        else if (prevNoteGetsBeam && !nextNoteGetsBeam && noteGetsBeam) {
            return BEAM_LEFT;
        }
        else if (!prevNoteGetsBeam && nextNoteGetsBeam && noteGetsBeam) {
            return BEAM_RIGHT;
        }
        return this.lookupBeamDirection(lookupDuration, prevTick, tick, nextTick, noteIndex);
    }
    /** Get the x coordinates for the beam lines of specific `duration`. */
    getBeamLines(duration) {
        const tickOfDuration = _tables__WEBPACK_IMPORTED_MODULE_3__.Tables.durationToTicks(duration);
        let beamStarted = false;
        const beamLines = [];
        let currentBeam = undefined;
        const partialBeamLength = this.renderOptions.partialBeamLength;
        let previousShouldBreak = false;
        let tickTally = 0;
        for (let i = 0; i < this.notes.length; ++i) {
            const note = this.notes[i];
            // See if we need to break secondary beams on this note.
            const ticks = note.getTicks().value();
            tickTally += ticks;
            let shouldBreak = false;
            // 8th note beams are always drawn.
            if (parseInt(duration, 10) >= 8) {
                // First, check to see if any indexes were set up through breakSecondaryAt()
                shouldBreak = __classPrivateFieldGet(this, _Beam_breakOnIndexes, "f").indexOf(i) !== -1;
                // If the secondary breaks were auto-configured in the render options,
                //  handle that as well.
                if (this.renderOptions.secondaryBreakTicks && tickTally >= this.renderOptions.secondaryBreakTicks) {
                    tickTally = 0;
                    shouldBreak = true;
                }
            }
            const noteGetsBeam = note.getIntrinsicTicks() < tickOfDuration;
            const stemX = note.getStemX() - _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.WIDTH / 2;
            // Check to see if the next note in the group will get a beam at this
            //  level. This will help to inform the partial beam logic below.
            const prevNote = this.notes[i - 1];
            const nextNote = this.notes[i + 1];
            const nextNoteGetsBeam = nextNote && nextNote.getIntrinsicTicks() < tickOfDuration;
            const prevNoteGetsBeam = prevNote && prevNote.getIntrinsicTicks() < tickOfDuration;
            const beamAlone = prevNote && nextNote && noteGetsBeam && !prevNoteGetsBeam && !nextNoteGetsBeam;
            // const beamAlone = noteGetsBeam && !prevNoteGetsBeam && !nextNoteGetsBeam;
            if (noteGetsBeam) {
                // This note gets a beam at the current level
                if (beamStarted) {
                    // We're currently in the middle of a beam. Just continue it on to
                    //  the stem X of the current note.
                    currentBeam = beamLines[beamLines.length - 1];
                    currentBeam.end = stemX;
                    // If a secondary beam break is set up, end the beam right now.
                    if (shouldBreak) {
                        beamStarted = false;
                        if (nextNote && !nextNoteGetsBeam && currentBeam.end === undefined) {
                            // This note gets a beam,.but the next one does not. This means
                            //  we need a partial pointing right.
                            currentBeam.end = currentBeam.start - partialBeamLength;
                        }
                    }
                }
                else {
                    // No beam started yet. Start a new one.
                    currentBeam = { start: stemX, end: undefined };
                    beamStarted = true;
                    if (beamAlone) {
                        // previous and next beam exists and does not get a beam but current gets it.
                        const prevTick = prevNote.getIntrinsicTicks();
                        const nextTick = nextNote.getIntrinsicTicks();
                        const tick = note.getIntrinsicTicks();
                        const beamDirection = this.lookupBeamDirection(duration, prevTick, tick, nextTick, i);
                        if ([BEAM_LEFT, BEAM_BOTH].includes(beamDirection)) {
                            currentBeam.end = currentBeam.start - partialBeamLength;
                        }
                        else {
                            currentBeam.end = currentBeam.start + partialBeamLength;
                        }
                    }
                    else if (!nextNoteGetsBeam) {
                        // The next note doesn't get a beam. Draw a partial.
                        if ((previousShouldBreak || i === 0) && nextNote) {
                            // This is the first note (but not the last one), or it is
                            //  following a secondary break. Draw a partial to the right.
                            currentBeam.end = currentBeam.start + partialBeamLength;
                        }
                        else {
                            // By default, draw a partial to the left.
                            currentBeam.end = currentBeam.start - partialBeamLength;
                        }
                    }
                    else if (shouldBreak) {
                        // This note should have a secondary break after it. Even though
                        //  we just started a beam, it needs to end immediately.
                        currentBeam.end = currentBeam.start - partialBeamLength;
                        beamStarted = false;
                    }
                    beamLines.push(currentBeam);
                }
            }
            else {
                // The current note does not get a beam.
                beamStarted = false;
            }
            // Store the secondary break flag to inform the partial beam logic in
            //  the next iteration of the loop.
            previousShouldBreak = shouldBreak;
        }
        // Add a partial beam pointing left if this is the last note in the group
        const lastBeam = beamLines[beamLines.length - 1];
        if (lastBeam && lastBeam.end === undefined) {
            lastBeam.end = lastBeam.start - partialBeamLength;
        }
        return beamLines;
    }
    /** Render the stems for each note. */
    drawStems(ctx) {
        this.notes.forEach((note) => {
            const stem = note.getStem();
            if (stem) {
                const stemX = note.getStemX();
                stem.setNoteHeadXBounds(stemX, stemX);
                stem.setContext(ctx).draw();
            }
        }, this);
    }
    // Render the beam lines
    drawBeamLines(ctx) {
        const validBeamDurations = ['4', '8', '16', '32', '64'];
        const firstNote = this.notes[0];
        let beamY = this.getBeamYToDraw();
        const firstStemX = firstNote.getStemX();
        const beamThickness = this.renderOptions.beamWidth * __classPrivateFieldGet(this, _Beam_stemDirection, "f");
        // Draw the beams.
        for (let i = 0; i < validBeamDurations.length; ++i) {
            const duration = validBeamDurations[i];
            const beamLines = this.getBeamLines(duration);
            for (let j = 0; j < beamLines.length; ++j) {
                const beamLine = beamLines[j];
                const startBeamX = beamLine.start;
                const startBeamY = this.getSlopeY(startBeamX, firstStemX, beamY, this.slope);
                const lastBeamX = beamLine.end;
                if (lastBeamX) {
                    const lastBeamY = this.getSlopeY(lastBeamX, firstStemX, beamY, this.slope);
                    ctx.beginPath();
                    ctx.moveTo(startBeamX, startBeamY);
                    ctx.lineTo(startBeamX, startBeamY + beamThickness);
                    ctx.lineTo(lastBeamX + 1, lastBeamY + beamThickness);
                    ctx.lineTo(lastBeamX + 1, lastBeamY);
                    ctx.closePath();
                    ctx.fill();
                }
                else {
                    throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('NoLastBeamX', 'lastBeamX undefined.');
                }
            }
            beamY += beamThickness * 1.5;
        }
    }
    /** Pre-format the beam. */
    preFormat() {
        return this;
    }
    /**
     * Post-format the beam. This can only be called after
     * the notes in the beam have both `x` and `y` values. ie: they've
     * been formatted and have staves.
     */
    postFormat() {
        if (this.postFormatted)
            return;
        // Calculate a smart slope if we're not forcing the beams to be flat.
        if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_5__.isTabNote)(this.notes[0]) || this.renderOptions.flatBeams) {
            this.calculateFlatSlope();
        }
        else {
            this.calculateSlope();
        }
        this.applyStemExtensions();
        this.postFormatted = true;
    }
    /** Render the beam to the canvas context */
    draw() {
        const ctx = this.checkContext();
        this.setRendered();
        if (__classPrivateFieldGet(this, _Beam_unbeamable, "f"))
            return;
        if (!this.postFormatted) {
            this.postFormat();
        }
        this.drawStems(ctx);
        this.applyStyle();
        ctx.openGroup('beam', this.getAttribute('id'));
        this.drawBeamLines(ctx);
        ctx.closeGroup();
        this.restoreStyle();
    }
}
_Beam_stemDirection = new WeakMap(), _Beam_ticks = new WeakMap(), _Beam_yShift = new WeakMap(), _Beam_breakOnIndexes = new WeakMap(), _Beam_beamCount = new WeakMap(), _Beam_unbeamable = new WeakMap(), _Beam_forcedPartialDirections = new WeakMap();


/***/ }),

/***/ "./src/bend.ts":
/*!*********************!*\
  !*** ./src/bend.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Bend: () => (/* binding */ Bend)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _modifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifier */ "./src/modifier.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License




/** Bend implements tablature bends. */
class Bend extends _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_2__.Category.Bend;
    }
    static get UP() {
        return 0;
    }
    static get DOWN() {
        return 1;
    }
    // Arrange bends in `ModifierContext`
    static format(bends, state) {
        if (!bends || bends.length === 0)
            return false;
        let lastWidth = 0;
        // Format Bends
        for (let i = 0; i < bends.length; ++i) {
            const bend = bends[i];
            const note = bend.checkAttachedNote();
            if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_2__.isTabNote)(note)) {
                const stringPos = note.leastString() - 1;
                if (state.topTextLine < stringPos) {
                    state.topTextLine = stringPos;
                }
            }
            bend.setXShift(lastWidth);
            lastWidth = bend.getWidth();
            bend.setTextLine(state.topTextLine);
        }
        state.rightShift += lastWidth;
        state.topTextLine += 1;
        return true;
    }
    /**
     * Example of a phrase:
     * ```
     *    [{
     *     type: UP,
     *     text: "whole"
     *     width: 8;
     *   },
     *   {
     *     type: DOWN,
     *     text: "whole"
     *     width: 8;
     *   },
     *   {
     *     type: UP,
     *     text: "half"
     *     width: 8;
     *   },
     *   {
     *     type: UP,
     *     text: "whole"
     *     width: 8;
     *   },
     *   {
     *     type: DOWN,
     *     text: "1 1/2"
     *     width: 8;
     *   }]
     * ```
     */
    constructor(phrase) {
        super();
        this.xShift = 0;
        this.tap = '';
        this.renderOptions = {
            lineWidth: 1.5,
            lineStyle: '#777777',
            bendWidth: 8,
            releaseWidth: 8,
        };
        this.phrase = phrase;
        this.updateWidth();
    }
    /** Set horizontal shift in pixels. */
    setXShift(value) {
        this.xShift = value;
        this.updateWidth();
        return this;
    }
    setTap(value) {
        this.tap = value;
        return this;
    }
    getTextHeight() {
        const element = new _element__WEBPACK_IMPORTED_MODULE_0__.Element(_typeguard__WEBPACK_IMPORTED_MODULE_2__.Category.Bend);
        element.setText(this.phrase[0].text);
        return element.getHeight();
    }
    /** Recalculate width. */
    updateWidth() {
        const measureText = (text) => {
            const element = new _element__WEBPACK_IMPORTED_MODULE_0__.Element(_typeguard__WEBPACK_IMPORTED_MODULE_2__.Category.Bend);
            element.setText(text);
            return element.getWidth();
        };
        let totalWidth = 0;
        for (let i = 0; i < this.phrase.length; ++i) {
            const bend = this.phrase[i];
            if (bend.width !== undefined) {
                totalWidth += bend.width;
            }
            else {
                const additionalWidth = bend.type === Bend.UP ? this.renderOptions.bendWidth : this.renderOptions.releaseWidth;
                bend.width = Math.max(additionalWidth, measureText(bend.text)) + 3;
                bend.drawWidth = bend.width / 2;
                totalWidth += bend.width;
            }
        }
        this.setWidth(totalWidth + this.xShift);
        return this;
    }
    /** Draw the bend on the rendering context. */
    draw() {
        var _a;
        const ctx = this.checkContext();
        const note = this.checkAttachedNote();
        this.setRendered();
        const start = note.getModifierStartXY(_modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.RIGHT, this.index);
        start.x += 3;
        start.y += 0.5;
        const xShift = this.xShift;
        const stave = note.checkStave();
        const spacing = stave.getSpacingBetweenLines();
        const lowestY = note.getYs().reduce((a, b) => (a < b ? a : b));
        // this.textLine is relative to top string in the group.
        const bendHeight = start.y - ((this.textLine + 1) * spacing + start.y - lowestY) + 3;
        const annotationY = start.y - ((this.textLine + 1) * spacing + start.y - lowestY) - 1;
        const renderBend = (x, y, width, height) => {
            const cpX = x + width;
            const cpY = y;
            ctx.save();
            ctx.beginPath();
            ctx.setLineWidth(this.renderOptions.lineWidth);
            ctx.setStrokeStyle(this.renderOptions.lineStyle);
            ctx.setFillStyle(this.renderOptions.lineStyle);
            ctx.moveTo(x, y);
            ctx.quadraticCurveTo(cpX, cpY, x + width, height);
            ctx.stroke();
            ctx.restore();
        };
        const renderRelease = (x, y, width, height) => {
            ctx.save();
            ctx.beginPath();
            ctx.setLineWidth(this.renderOptions.lineWidth);
            ctx.setStrokeStyle(this.renderOptions.lineStyle);
            ctx.setFillStyle(this.renderOptions.lineStyle);
            ctx.moveTo(x, height);
            ctx.quadraticCurveTo(x + width, height, x + width, y);
            ctx.stroke();
            ctx.restore();
        };
        const renderArrowHead = (x, y, direction) => {
            const width = 4;
            const yBase = y + width * direction;
            ctx.beginPath();
            ctx.moveTo(x, y); // tip of the arrow
            ctx.lineTo(x - width, yBase);
            ctx.lineTo(x + width, yBase);
            ctx.closePath();
            ctx.fill();
        };
        const renderText = (x, text) => {
            ctx.save();
            ctx.setFont(this.fontInfo);
            const renderX = x - ctx.measureText(text).width / 2;
            ctx.fillText(text, renderX, annotationY);
            ctx.restore();
        };
        let lastBend = undefined;
        let lastBendDrawWidth = 0;
        let lastDrawnWidth = 0;
        if ((_a = this.tap) === null || _a === void 0 ? void 0 : _a.length) {
            const tapStart = note.getModifierStartXY(_modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.CENTER, this.index);
            renderText(tapStart.x, this.tap);
        }
        for (let i = 0; i < this.phrase.length; ++i) {
            const bend = this.phrase[i];
            if (!bend.drawWidth)
                bend.drawWidth = 0;
            if (i === 0)
                bend.drawWidth += xShift;
            lastDrawnWidth = bend.drawWidth + lastBendDrawWidth - (i === 1 ? xShift : 0);
            if (bend.type === Bend.UP) {
                if (lastBend && lastBend.type === Bend.UP) {
                    renderArrowHead(start.x, bendHeight, +1);
                }
                renderBend(start.x, start.y, lastDrawnWidth, bendHeight);
            }
            if (bend.type === Bend.DOWN) {
                if (lastBend && lastBend.type === Bend.UP) {
                    renderRelease(start.x, start.y, lastDrawnWidth, bendHeight);
                }
                if (lastBend && lastBend.type === Bend.DOWN) {
                    renderArrowHead(start.x, start.y, -1);
                    renderRelease(start.x, start.y, lastDrawnWidth, bendHeight);
                }
                if (!lastBend) {
                    lastDrawnWidth = bend.drawWidth;
                    renderRelease(start.x, start.y, lastDrawnWidth, bendHeight);
                }
            }
            renderText(start.x + lastDrawnWidth, bend.text);
            lastBend = bend;
            lastBendDrawWidth = bend.drawWidth;
            lastBend.x = start.x;
            start.x += lastDrawnWidth;
        }
        if (!lastBend || lastBend.x === undefined) {
            throw new _util__WEBPACK_IMPORTED_MODULE_3__.RuntimeError('NoLastBendForBend', 'Internal error.');
        }
        // Final arrowhead and text
        if (lastBend.type === Bend.UP) {
            renderArrowHead(lastBend.x + lastDrawnWidth, bendHeight, +1);
        }
        else if (lastBend.type === Bend.DOWN) {
            renderArrowHead(lastBend.x + lastDrawnWidth, start.y, -1);
        }
    }
}


/***/ }),

/***/ "./src/boundingbox.ts":
/*!****************************!*\
  !*** ./src/boundingbox.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BoundingBox: () => (/* binding */ BoundingBox)
/* harmony export */ });
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
class BoundingBox {
    /**
     * Create a new copy.
     */
    static copy(that) {
        return new BoundingBox(that.x, that.y, that.w, that.h);
    }
    constructor(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }
    /** Get x position. */
    getX() {
        return this.x;
    }
    /** Get y position. */
    getY() {
        return this.y;
    }
    /** Get width. */
    getW() {
        return this.w;
    }
    /** Get height. */
    getH() {
        return this.h;
    }
    /** Set x position. */
    setX(x) {
        this.x = x;
        return this;
    }
    /** Set y position. */
    setY(y) {
        this.y = y;
        return this;
    }
    /** Set width. */
    setW(w) {
        this.w = w;
        return this;
    }
    /** Set height. */
    setH(h) {
        this.h = h;
        return this;
    }
    /** Move to position. */
    move(x, y) {
        this.x += x;
        this.y += y;
        return this;
    }
    /** Clone. */
    clone() {
        return BoundingBox.copy(this);
    }
    /**
     * Merge my box with given box. Creates a bigger bounding box unless
     * the given box is contained in this one.
     */
    mergeWith(boundingBox) {
        const that = boundingBox;
        const newX = this.x < that.x ? this.x : that.x;
        const newY = this.y < that.y ? this.y : that.y;
        const newW = Math.max(this.x + this.w, that.x + that.w) - newX;
        const newH = Math.max(this.y + this.h, that.y + that.h) - newY;
        this.x = newX;
        this.y = newY;
        this.w = newW;
        this.h = newH;
        return this;
    }
}


/***/ }),

/***/ "./src/canvascontext.ts":
/*!******************************!*\
  !*** ./src/canvascontext.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CanvasContext: () => (/* binding */ CanvasContext)
/* harmony export */ });
/* harmony import */ var _font__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./font */ "./src/font.ts");
/* harmony import */ var _rendercontext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rendercontext */ "./src/rendercontext.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./src/util.ts");
/* harmony import */ var _web__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./web */ "./src/web.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License




/**
 * A rendering context for the Canvas backend. This class serves as a proxy for the
 * underlying CanvasRenderingContext2D object, part of the browser's API.
 */
class CanvasContext extends _rendercontext__WEBPACK_IMPORTED_MODULE_1__.RenderContext {
    static get WIDTH() {
        return 600;
    }
    static get HEIGHT() {
        return 400;
    }
    static get CANVAS_BROWSER_SIZE_LIMIT() {
        return 32767; // Chrome/Firefox. Could be determined more precisely by npm module canvas-size.
    }
    /**
     * Ensure that width and height do not exceed the browser limit.
     * @returns array of [width, height] clamped to the browser limit.
     */
    static sanitizeCanvasDims(width, height) {
        const limit = this.CANVAS_BROWSER_SIZE_LIMIT;
        if (Math.max(width, height) > limit) {
            (0,_util__WEBPACK_IMPORTED_MODULE_2__.warn)('Canvas dimensions exceed browser limit. Cropping to ' + limit);
            if (width > limit) {
                width = limit;
            }
            if (height > limit) {
                height = limit;
            }
        }
        return [width, height];
    }
    constructor(context) {
        super();
        /** Height of one line of text (in pixels). */
        this.textHeight = 0;
        this.context2D = context;
        this.curTransfrom = context.getTransform();
        if (!context.canvas) {
            this.canvas = {
                width: CanvasContext.WIDTH,
                height: CanvasContext.HEIGHT,
            };
        }
        else {
            this.canvas = context.canvas;
        }
    }
    /**
     * Set all pixels to transparent black rgba(0,0,0,0).
     */
    clear() {
        this.context2D.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    // eslint-disable-next-line
    openGroup(cls, id, attrs) {
        // Containers not implemented.
    }
    closeGroup() {
        // Containers not implemented.
    }
    openRotation(angleDegrees, x, y) {
        this.curTransfrom = this.context2D.getTransform();
        this.context2D.translate(x, y);
        this.context2D.rotate((angleDegrees * Math.PI) / 180);
        this.context2D.translate(-x, -y);
    }
    closeRotation() {
        this.context2D.setTransform(this.curTransfrom);
    }
    // eslint-disable-next-line
    add(child) {
        // Containers not implemented.
    }
    setFillStyle(style) {
        this.context2D.fillStyle = style;
        return this;
    }
    /** CanvasContext ignores `setBackgroundFillStyle()`. */
    // eslint-disable-next-line
    setBackgroundFillStyle(style) {
        // DO NOTHING
        return this;
    }
    setStrokeStyle(style) {
        this.context2D.strokeStyle = style;
        return this;
    }
    setShadowColor(color) {
        this.context2D.shadowColor = color;
        return this;
    }
    setShadowBlur(blur) {
        // CanvasRenderingContext2D does not scale the shadow blur by the current
        // transform, so we have to do it manually. We assume uniform scaling
        // (though allow for rotation) because the blur can only be scaled
        // uniformly anyway.
        const t = this.context2D.getTransform();
        const scale = Math.sqrt(t.a * t.a + t.b * t.b + t.c * t.c + t.d * t.d);
        this.context2D.shadowBlur = scale * blur;
        return this;
    }
    setLineWidth(width) {
        this.context2D.lineWidth = width;
        return this;
    }
    setLineCap(capType) {
        this.context2D.lineCap = capType;
        return this;
    }
    setLineDash(dash) {
        this.context2D.setLineDash(dash);
        return this;
    }
    scale(x, y) {
        this.context2D.scale(x, y);
        return this;
    }
    resize(width, height, devicePixelRatio) {
        var _a;
        const canvas = this.context2D.canvas;
        const dpr = (_a = devicePixelRatio !== null && devicePixelRatio !== void 0 ? devicePixelRatio : (0,_util__WEBPACK_IMPORTED_MODULE_2__.globalObject)().devicePixelRatio) !== null && _a !== void 0 ? _a : 1;
        // Scale the canvas size by the device pixel ratio clamping to the maximum supported size.
        [width, height] = CanvasContext.sanitizeCanvasDims(width * dpr, height * dpr);
        // Divide back down by the pixel ratio and convert to integers.
        width = (width / dpr) | 0;
        height = (height / dpr) | 0;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        // The canvas could be an instance of either HTMLCanvasElement or an OffscreenCanvas.
        // Only HTMLCanvasElement has a style attribute.
        if ((0,_web__WEBPACK_IMPORTED_MODULE_3__.isHTMLCanvas)(canvas)) {
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
        }
        return this.scale(dpr, dpr);
    }
    rect(x, y, width, height) {
        this.context2D.rect(x, y, width, height);
        return this;
    }
    fillRect(x, y, width, height) {
        this.context2D.fillRect(x, y, width, height);
        return this;
    }
    /**
     * Set the pixels in a rectangular area to transparent black rgba(0,0,0,0).
     */
    clearRect(x, y, width, height) {
        this.context2D.clearRect(x, y, width, height);
        return this;
    }
    beginPath() {
        this.context2D.beginPath();
        return this;
    }
    moveTo(x, y) {
        this.context2D.moveTo(x, y);
        return this;
    }
    lineTo(x, y) {
        this.context2D.lineTo(x, y);
        return this;
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        this.context2D.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
        return this;
    }
    quadraticCurveTo(cpx, cpy, x, y) {
        this.context2D.quadraticCurveTo(cpx, cpy, x, y);
        return this;
    }
    arc(x, y, radius, startAngle, endAngle, counterclockwise) {
        this.context2D.arc(x, y, radius, startAngle, endAngle, counterclockwise);
        return this;
    }
    fill() {
        this.context2D.fill();
        return this;
    }
    stroke() {
        this.context2D.stroke();
        return this;
    }
    closePath() {
        this.context2D.closePath();
        return this;
    }
    measureText(text) {
        const metrics = this.context2D.measureText(text);
        let y = 0;
        let height = 0;
        if (metrics.fontBoundingBoxAscent) {
            y = -metrics.fontBoundingBoxAscent;
            height = metrics.fontBoundingBoxDescent + metrics.fontBoundingBoxAscent;
        }
        else {
            y = -metrics.actualBoundingBoxAscent;
            height = metrics.actualBoundingBoxDescent + metrics.actualBoundingBoxAscent;
        }
        // Return x, y, width & height in the same manner as svg getBBox
        return {
            x: 0,
            y: y,
            width: metrics.width,
            height: height,
        };
    }
    fillText(text, x, y) {
        this.context2D.fillText(text, x, y);
        return this;
    }
    save() {
        this.context2D.save();
        return this;
    }
    restore() {
        this.context2D.restore();
        return this;
    }
    set fillStyle(style) {
        this.context2D.fillStyle = style;
    }
    get fillStyle() {
        return this.context2D.fillStyle;
    }
    set strokeStyle(style) {
        this.context2D.strokeStyle = style;
    }
    get strokeStyle() {
        return this.context2D.strokeStyle;
    }
    /**
     * @param f is 1) a `FontInfo` object or
     *             2) a string formatted as CSS font shorthand (e.g., 'bold 10pt Arial') or
     *             3) a string representing the font family (one of `size`, `weight`, or `style` must also be provided).
     * @param size a string specifying the font size and unit (e.g., '16pt'), or a number (the unit is assumed to be 'pt').
     * @param weight is a string (e.g., 'bold', 'normal') or a number (100, 200, ... 900).
     * @param style is a string (e.g., 'italic', 'normal').
     */
    setFont(f, size, weight, style) {
        const fontInfo = _font__WEBPACK_IMPORTED_MODULE_0__.Font.validate(f, size, weight, style);
        this.context2D.font = _font__WEBPACK_IMPORTED_MODULE_0__.Font.toCSSString(fontInfo);
        this.textHeight = _font__WEBPACK_IMPORTED_MODULE_0__.Font.convertSizeToPixelValue(fontInfo.size);
        return this;
    }
    /** Return a string of the form `'italic bold 15pt Arial'` */
    getFont() {
        return this.context2D.font;
    }
}


/***/ }),

/***/ "./src/chordsymbol.ts":
/*!****************************!*\
  !*** ./src/chordsymbol.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ChordSymbol: () => (/* binding */ ChordSymbol),
/* harmony export */   ChordSymbolBlock: () => (/* binding */ ChordSymbolBlock),
/* harmony export */   ChordSymbolHorizontalJustify: () => (/* binding */ ChordSymbolHorizontalJustify),
/* harmony export */   ChordSymbolVerticalJustify: () => (/* binding */ ChordSymbolVerticalJustify),
/* harmony export */   SymbolModifiers: () => (/* binding */ SymbolModifiers)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _font__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./font */ "./src/font.ts");
/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./metrics */ "./src/metrics.ts");
/* harmony import */ var _modifier__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifier */ "./src/modifier.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
//
// @author Aaron (@AaronDavidNewman)
//
// This implements chord symbols above/below a chord.
// Chord symbols are modifiers that can be attached to notes.
// They can contain multiple 'blocks' which represent text or
// glyphs with various positioning options.
//
// See `tests/chordsymbol_tests.ts` for usage examples.







// To enable logging for this class. Set `Vex.Flow.ChordSymbol.DEBUG` to `true`.
// eslint-disable-next-line
function L(...args) {
    if (ChordSymbol.DEBUG)
        (0,_util__WEBPACK_IMPORTED_MODULE_6__.log)('Vex.Flow.ChordSymbol', args);
}
class ChordSymbolBlock extends _element__WEBPACK_IMPORTED_MODULE_0__.Element {
    constructor(text, symbolModifier, xShift, yShift, vAlign) {
        super();
        this.text = text;
        this.symbolModifier = symbolModifier;
        this.xShift = xShift;
        this.yShift = yShift;
        this.vAlign = vAlign;
    }
    isSuperscript() {
        return this.symbolModifier === SymbolModifiers.SUPERSCRIPT;
    }
    isSubscript() {
        return this.symbolModifier === SymbolModifiers.SUBSCRIPT;
    }
}
var ChordSymbolHorizontalJustify;
(function (ChordSymbolHorizontalJustify) {
    ChordSymbolHorizontalJustify[ChordSymbolHorizontalJustify["LEFT"] = 1] = "LEFT";
    ChordSymbolHorizontalJustify[ChordSymbolHorizontalJustify["CENTER"] = 2] = "CENTER";
    ChordSymbolHorizontalJustify[ChordSymbolHorizontalJustify["RIGHT"] = 3] = "RIGHT";
    ChordSymbolHorizontalJustify[ChordSymbolHorizontalJustify["CENTER_STEM"] = 4] = "CENTER_STEM";
})(ChordSymbolHorizontalJustify || (ChordSymbolHorizontalJustify = {}));
var ChordSymbolVerticalJustify;
(function (ChordSymbolVerticalJustify) {
    ChordSymbolVerticalJustify[ChordSymbolVerticalJustify["TOP"] = 1] = "TOP";
    ChordSymbolVerticalJustify[ChordSymbolVerticalJustify["BOTTOM"] = 2] = "BOTTOM";
})(ChordSymbolVerticalJustify || (ChordSymbolVerticalJustify = {}));
var SymbolModifiers;
(function (SymbolModifiers) {
    SymbolModifiers[SymbolModifiers["NONE"] = 1] = "NONE";
    SymbolModifiers[SymbolModifiers["SUBSCRIPT"] = 2] = "SUBSCRIPT";
    SymbolModifiers[SymbolModifiers["SUPERSCRIPT"] = 3] = "SUPERSCRIPT";
})(SymbolModifiers || (SymbolModifiers = {}));
/**
 * ChordSymbol is a modifier that creates a chord symbol above/below a chord.
 * As a modifier, it is attached to an existing note.
 */
class ChordSymbol extends _modifier__WEBPACK_IMPORTED_MODULE_3__.Modifier {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_5__.Category.ChordSymbol;
    }
    static get superSubRatio() {
        return _metrics__WEBPACK_IMPORTED_MODULE_2__.Metrics.get('ChordSymbol.superSubRatio');
    }
    static get spacingBetweenBlocks() {
        return _metrics__WEBPACK_IMPORTED_MODULE_2__.Metrics.get('ChordSymbol.spacing');
    }
    static get superscriptOffset() {
        return _metrics__WEBPACK_IMPORTED_MODULE_2__.Metrics.get('ChordSymbol.superscriptOffset');
    }
    static get subscriptOffset() {
        return _metrics__WEBPACK_IMPORTED_MODULE_2__.Metrics.get('ChordSymbol.subscriptOffset');
    }
    static get minPadding() {
        return _metrics__WEBPACK_IMPORTED_MODULE_2__.Metrics.get('NoteHead.minPadding');
    }
    /**
     * Estimate the width of the whole chord symbol, based on the sum of the widths of the individual blocks.
     * Estimate how many lines above/below the staff we need.
     */
    static format(symbols, state) {
        if (!symbols || symbols.length === 0)
            return false;
        let width = 0;
        let leftWidth = 0;
        let rightWidth = 0;
        let maxLeftGlyphWidth = 0;
        let maxRightGlyphWidth = 0;
        for (const symbol of symbols) {
            const note = symbol.checkAttachedNote();
            let lineSpaces = 1;
            for (let j = 0; j < symbol.symbolBlocks.length; ++j) {
                const block = symbol.symbolBlocks[j];
                const sup = block.isSuperscript();
                const sub = block.isSubscript();
                block.setXShift(width);
                // If there are super/subscripts, they extend beyond the line so
                // assume they take up 2 lines
                if (sup || sub) {
                    lineSpaces = 2;
                }
                // If a subscript immediately follows a superscript block, try to
                // overlay them.
                if (sub && j > 0) {
                    const prev = symbol.symbolBlocks[j - 1];
                    if (prev.isSuperscript()) {
                        // slide the symbol over so it lines up with superscript
                        block.setXShift(width - prev.getWidth() - ChordSymbol.minPadding);
                        block.vAlign = true;
                        width +=
                            -prev.getWidth() -
                                ChordSymbol.minPadding +
                                (prev.getWidth() > block.getWidth() ? prev.getWidth() - block.getWidth() : 0);
                    }
                }
                width += block.getWidth() + ChordSymbol.minPadding;
            }
            if (symbol.getVertical() === ChordSymbolVerticalJustify.TOP) {
                symbol.setTextLine(state.topTextLine);
                state.topTextLine += lineSpaces;
            }
            else {
                symbol.setTextLine(state.textLine + 1);
                state.textLine += lineSpaces + 1;
            }
            if (symbol.getReportWidth()) {
                if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_5__.isStemmableNote)(note)) {
                    const glyphWidth = note.getGlyphWidth();
                    if (symbol.getHorizontal() === ChordSymbolHorizontalJustify.LEFT) {
                        maxLeftGlyphWidth = Math.max(glyphWidth, maxLeftGlyphWidth);
                        leftWidth = Math.max(leftWidth, width) + ChordSymbol.minPadding;
                    }
                    else if (symbol.getHorizontal() === ChordSymbolHorizontalJustify.RIGHT) {
                        maxRightGlyphWidth = Math.max(glyphWidth, maxRightGlyphWidth);
                        rightWidth = Math.max(rightWidth, width);
                    }
                    else {
                        leftWidth = Math.max(leftWidth, width / 2) + ChordSymbol.minPadding;
                        rightWidth = Math.max(rightWidth, width / 2);
                        maxLeftGlyphWidth = Math.max(glyphWidth / 2, maxLeftGlyphWidth);
                        maxRightGlyphWidth = Math.max(glyphWidth / 2, maxRightGlyphWidth);
                    }
                }
                symbol.width = width;
            }
            width = 0; // reset symbol width
        }
        const rightOverlap = Math.min(Math.max(rightWidth - maxRightGlyphWidth, 0), Math.max(rightWidth - state.rightShift, 0));
        const leftOverlap = Math.min(Math.max(leftWidth - maxLeftGlyphWidth, 0), Math.max(leftWidth - state.leftShift, 0));
        state.leftShift += leftOverlap;
        state.rightShift += rightOverlap;
        return true;
    }
    constructor() {
        super();
        this.symbolBlocks = [];
        this.horizontal = ChordSymbolHorizontalJustify.LEFT;
        this.vertical = ChordSymbolVerticalJustify.TOP;
        this.reportWidth = true;
    }
    /**
     * The offset is specified in `em`. Scale this value by the font size in pixels.
     */
    get superscriptOffset() {
        return ChordSymbol.superscriptOffset * _font__WEBPACK_IMPORTED_MODULE_1__.Font.convertSizeToPixelValue(this.fontInfo.size);
    }
    get subscriptOffset() {
        return ChordSymbol.subscriptOffset * _font__WEBPACK_IMPORTED_MODULE_1__.Font.convertSizeToPixelValue(this.fontInfo.size);
    }
    setReportWidth(value) {
        this.reportWidth = value;
        return this;
    }
    getReportWidth() {
        return this.reportWidth;
    }
    /**
     * ChordSymbol allows multiple blocks so we can mix glyphs and font text.
     * Each block can have its own vertical orientation.
     */
    getSymbolBlock(params = {}) {
        var _a, _b;
        const symbolBlock = new ChordSymbolBlock((_a = params.text) !== null && _a !== void 0 ? _a : '', (_b = params.symbolModifier) !== null && _b !== void 0 ? _b : SymbolModifiers.NONE, 0, 0, false);
        if (symbolBlock.isSubscript()) {
            symbolBlock.setYShift(this.subscriptOffset);
        }
        if (symbolBlock.isSuperscript()) {
            symbolBlock.setYShift(this.superscriptOffset);
        }
        if (symbolBlock.isSubscript() || symbolBlock.isSuperscript()) {
            const { family, size, weight, style } = this.fontInfo;
            const smallerFontSize = _font__WEBPACK_IMPORTED_MODULE_1__.Font.scaleSize(size, ChordSymbol.superSubRatio);
            symbolBlock.setFont(family, smallerFontSize, weight, style);
        }
        else {
            symbolBlock.setFont(this.fontInfo);
        }
        return symbolBlock;
    }
    /** Add a symbol to this chord, could be text, glyph or line. */
    addSymbolBlock(parameters) {
        this.symbolBlocks.push(this.getSymbolBlock(parameters));
        return this;
    }
    // ### Convenience functions for creating different types of chord symbol parts.
    /** Add a text block. */
    addText(text, parameters = {}) {
        return this.addSymbolBlock(Object.assign(Object.assign({}, parameters), { text }));
    }
    /** Add a text block with superscript modifier. */
    addTextSuperscript(text) {
        const symbolModifier = SymbolModifiers.SUPERSCRIPT;
        return this.addSymbolBlock({ text, symbolModifier });
    }
    /** Add a text block with subscript modifier. */
    addTextSubscript(text) {
        const symbolModifier = SymbolModifiers.SUBSCRIPT;
        return this.addSymbolBlock({ text, symbolModifier });
    }
    /** Add a glyph block with superscript modifier. */
    addGlyphSuperscript(glyph) {
        return this.addTextSuperscript(ChordSymbol.glyphs[glyph]);
    }
    /** Add a glyph block. */
    addGlyph(glyph, params = {}) {
        return this.addText(ChordSymbol.glyphs[glyph], params);
    }
    /**
     * Add a glyph for each character in 'text'. If the glyph is not available, use text from the font.
     * e.g. `addGlyphOrText('(+5#11)')` will use text for the '5' and '11', and glyphs for everything else.
     */
    addGlyphOrText(text, params = {}) {
        let str = '';
        for (let i = 0; i < text.length; ++i) {
            const char = text[i];
            const glyph = ChordSymbol.glyphs[char];
            if (glyph) {
                str += glyph;
            }
            else {
                // Collect consecutive characters with no glyphs.
                str += char;
            }
        }
        if (str.length > 0) {
            this.addText(str, params);
        }
        return this;
    }
    /** Add a line of the given width, used as a continuation of the previous symbol in analysis, or lyrics, etc. */
    addLine(params = {}) {
        // Two csymMinor glyphs next to each other.
        return this.addText('\ue874\ue874' /*{csymMinor}{csymMinor}*/, params);
    }
    /** Set vertical position of text (above or below stave). */
    setVertical(vj) {
        this.vertical = typeof vj === 'string' ? ChordSymbol.VerticalJustifyString[vj] : vj;
        return this;
    }
    getVertical() {
        return this.vertical;
    }
    /** Set horizontal justification. */
    setHorizontal(hj) {
        this.horizontal = typeof hj === 'string' ? ChordSymbol.HorizontalJustifyString[hj] : hj;
        return this;
    }
    getHorizontal() {
        return this.horizontal;
    }
    /** Render text and glyphs above/below the note. */
    draw() {
        const ctx = this.checkContext();
        const note = this.checkAttachedNote();
        this.setRendered();
        // We're changing context parameters. Save current state.
        ctx.save();
        this.applyStyle();
        ctx.openGroup('chordsymbol', this.getAttribute('id'));
        const start = note.getModifierStartXY(_modifier__WEBPACK_IMPORTED_MODULE_3__.Modifier.Position.ABOVE, this.index);
        ctx.setFont(this.fontInfo);
        let y;
        // The position of the text varies based on whether or not the note
        // has a stem.
        const hasStem = note.hasStem();
        const stave = note.checkStave();
        if (this.vertical === ChordSymbolVerticalJustify.BOTTOM) {
            // HACK: We need to compensate for the text's height since its origin is bottom-right.
            y = stave.getYForBottomText(this.textLine + _tables__WEBPACK_IMPORTED_MODULE_4__.Tables.TEXT_HEIGHT_OFFSET_HACK);
            if (hasStem) {
                const stemExt = note.checkStem().getExtents();
                const spacing = stave.getSpacingBetweenLines();
                const stemBase = note.getStemDirection() === 1 ? stemExt.baseY : stemExt.topY;
                y = Math.max(y, stemBase + spacing * (this.textLine + 2));
            }
        }
        else {
            // (this.vertical === VerticalJustify.TOP)
            const topY = Math.min(...note.getYs());
            y = Math.min(stave.getYForTopText(this.textLine), topY - 10);
            if (hasStem) {
                const stemExt = note.checkStem().getExtents();
                const spacing = stave.getSpacingBetweenLines();
                y = Math.min(y, stemExt.topY - 5 - spacing * this.textLine);
            }
        }
        let x = start.x;
        if (this.horizontal === ChordSymbolHorizontalJustify.LEFT) {
            x = start.x;
        }
        else if (this.horizontal === ChordSymbolHorizontalJustify.RIGHT) {
            x = start.x + this.getWidth();
        }
        else if (this.horizontal === ChordSymbolHorizontalJustify.CENTER) {
            x = start.x - this.getWidth() / 2;
        }
        else {
            // HorizontalJustify.CENTER_STEM
            x = note.getStemX() - this.getWidth() / 2;
        }
        L('Rendering ChordSymbol: ', x, y);
        this.symbolBlocks.forEach((symbol) => {
            L('Rendering Text: ', symbol.getText(), x + symbol.getXShift(), y + symbol.getYShift());
            symbol.renderText(ctx, x, y);
        });
        ctx.closeGroup();
        this.restoreStyle();
        ctx.restore();
    }
}
ChordSymbol.DEBUG = false;
// Chord symbols can be positioned and justified relative to the note.
ChordSymbol.HorizontalJustify = ChordSymbolHorizontalJustify;
ChordSymbol.HorizontalJustifyString = {
    left: ChordSymbolHorizontalJustify.LEFT,
    right: ChordSymbolHorizontalJustify.RIGHT,
    center: ChordSymbolHorizontalJustify.CENTER,
    centerStem: ChordSymbolHorizontalJustify.CENTER_STEM,
};
ChordSymbol.VerticalJustify = ChordSymbolVerticalJustify;
ChordSymbol.VerticalJustifyString = {
    top: ChordSymbolVerticalJustify.TOP,
    above: ChordSymbolVerticalJustify.TOP,
    below: ChordSymbolVerticalJustify.BOTTOM,
    bottom: ChordSymbolVerticalJustify.BOTTOM,
};
// Glyph data
ChordSymbol.glyphs = {
    diminished: '\ue870' /*csymDiminished*/,
    dim: '\ue870' /*csymDiminished*/,
    halfDiminished: '\ue871' /*csymHalfDiminished*/,
    '+': '\ue872' /*csymAugmented*/,
    augmented: '\ue872' /*csymAugmented*/,
    majorSeventh: '\ue873' /*csymMajorSeventh*/,
    minor: '\ue874' /*csymMinor*/,
    '-': '\ue874' /*csymMinor*/,
    '(': '\u0028' /*csymParensLeftTall*/,
    leftParen: '\u0028' /*csymParensLeftTall*/,
    ')': '\u0029' /*csymParensRightTall*/,
    rightParen: '\u0029' /*csymParensRightTall*/,
    leftBracket: '\ue877' /*csymBracketLeftTall*/,
    rightBracket: '\ue878' /*csymBracketRightTall*/,
    leftParenTall: '\u0028' /*csymParensLeftVeryTall*/,
    rightParenTall: '\u0029' /*csymParensRightVeryTall*/,
    '/': '\ue87c' /*csymDiagonalArrangementSlash*/,
    over: '\ue87c' /*csymDiagonalArrangementSlash*/,
    '#': '\ued62' /*csymAccidentalSharp*/,
    b: '\ued60' /*csymAccidentalFlat*/,
};
ChordSymbol.symbolModifiers = SymbolModifiers;


/***/ }),

/***/ "./src/clef.ts":
/*!*********************!*\
  !*** ./src/clef.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Clef: () => (/* binding */ Clef)
/* harmony export */ });
/* harmony import */ var _glyphs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glyphs */ "./src/glyphs.ts");
/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./metrics */ "./src/metrics.ts");
/* harmony import */ var _stavemodifier__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stavemodifier */ "./src/stavemodifier.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
// Co-author: Benjamin W. Bohl





// eslint-disable-next-line
function L(...args) {
    if (Clef.DEBUG)
        (0,_util__WEBPACK_IMPORTED_MODULE_4__.log)('Vex.Flow.Clef', args);
}
/**
 * Clef implements various types of clefs that can be rendered on a stave.
 *
 * See `tests/clef_tests.ts` for usage examples.
 */
class Clef extends _stavemodifier__WEBPACK_IMPORTED_MODULE_2__.StaveModifier {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_3__.Category.Clef;
    }
    /**
     * Every clef name is associated with a glyph code from the font file
     * and a default stave line number.
     */
    static get types() {
        const { gClef, fClef, cClef, unpitchedPercussionClef1, sixStringTabClef } = _glyphs__WEBPACK_IMPORTED_MODULE_0__.Glyphs;
        return {
            treble: {
                code: gClef,
                line: 3,
            },
            bass: {
                code: fClef,
                line: 1,
            },
            alto: {
                code: cClef,
                line: 2,
            },
            tenor: {
                code: cClef,
                line: 1,
            },
            percussion: {
                code: unpitchedPercussionClef1,
                line: 2,
            },
            soprano: {
                code: cClef,
                line: 4,
            },
            'mezzo-soprano': {
                code: cClef,
                line: 3,
            },
            'baritone-c': {
                code: cClef,
                line: 0,
            },
            'baritone-f': {
                code: fClef,
                line: 2,
            },
            subbass: {
                code: fClef,
                line: 0,
            },
            french: {
                code: gClef,
                line: 4,
            },
            tab: {
                code: sixStringTabClef,
                line: 2.5,
            },
        };
    }
    /** Create a new clef. */
    constructor(type, size, annotation) {
        super();
        /**
         * The attribute `clef` must be a key from
         * `Clef.types`
         */
        this.code = Clef.types['treble'].code;
        this.line = Clef.types['treble'].line;
        this.size = 'default';
        this.type = 'treble';
        this.setPosition(_stavemodifier__WEBPACK_IMPORTED_MODULE_2__.StaveModifierPosition.BEGIN);
        this.setType(type, size, annotation);
        L('Creating clef:', type);
    }
    /** Set clef type, size and annotation. */
    setType(type, size = 'default', annotation) {
        this.type = type;
        this.code = Clef.types[type].code;
        this.line = Clef.types[type].line;
        this.size = size !== null && size !== void 0 ? size : 'default';
        // If an annotation, such as 8va, is specified, add it to the Clef object.
        if (annotation === '8va') {
            if (this.code === _glyphs__WEBPACK_IMPORTED_MODULE_0__.Glyphs.gClef) {
                this.code = _glyphs__WEBPACK_IMPORTED_MODULE_0__.Glyphs.gClef8va;
            }
            if (this.code === _glyphs__WEBPACK_IMPORTED_MODULE_0__.Glyphs.fClef) {
                this.code = _glyphs__WEBPACK_IMPORTED_MODULE_0__.Glyphs.fClef8va;
            }
        }
        if (annotation === '8vb') {
            if (this.code === _glyphs__WEBPACK_IMPORTED_MODULE_0__.Glyphs.gClef) {
                this.code = _glyphs__WEBPACK_IMPORTED_MODULE_0__.Glyphs.gClef8vb;
            }
            if (this.code === _glyphs__WEBPACK_IMPORTED_MODULE_0__.Glyphs.fClef) {
                this.code = _glyphs__WEBPACK_IMPORTED_MODULE_0__.Glyphs.fClef8vb;
            }
        }
        this.text = this.code;
        this.fontInfo.size = Math.floor(Clef.getPoint(this.size));
        return this;
    }
    /** Get point for clefs. */
    static getPoint(size) {
        // for sizes other than 'default', clef is 2/3 of the default value
        return size === 'default' ? _metrics__WEBPACK_IMPORTED_MODULE_1__.Metrics.get('fontSize') : (_metrics__WEBPACK_IMPORTED_MODULE_1__.Metrics.get('fontSize') * 2) / 3;
    }
    /** Set associated stave. */
    setStave(stave) {
        this.stave = stave;
        return this;
    }
    /** Render clef. */
    draw() {
        const stave = this.checkStave();
        const ctx = stave.checkContext();
        this.setRendered();
        this.applyStyle(ctx);
        ctx.openGroup('clef', this.getAttribute('id'));
        this.renderText(ctx, 0, stave.getYForLine(this.line));
        ctx.closeGroup();
        this.restoreStyle(ctx);
    }
}
/** To enable logging for this class, set `Vex.Flow.Clef.DEBUG` to `true`. */
Clef.DEBUG = false;


/***/ }),

/***/ "./src/clefnote.ts":
/*!*************************!*\
  !*** ./src/clefnote.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ClefNote: () => (/* binding */ ClefNote)
/* harmony export */ });
/* harmony import */ var _clef__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./clef */ "./src/clef.ts");
/* harmony import */ var _note__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./note */ "./src/note.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// @author: Taehoon Moon 2014
// MIT License



/** ClefNote implements clef annotations in measures. */
class ClefNote extends _note__WEBPACK_IMPORTED_MODULE_1__.Note {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_2__.Category.ClefNote;
    }
    constructor(type, size = 'default', annotation) {
        super({ duration: 'b' });
        this.setType(type, size, annotation);
        this.ignoreTicks = true;
    }
    /** Set clef type, size and annotation. */
    setType(type, size, annotation) {
        this.clef = new _clef__WEBPACK_IMPORTED_MODULE_0__.Clef(type, size, annotation);
        this.setWidth(this.clef.getWidth());
        return this;
    }
    /** Get associated clef. */
    getClef() {
        return this.clef;
    }
    preFormat() {
        this.preFormatted = true;
        return this;
    }
    /** Render clef note. */
    draw() {
        const stave = this.checkStave();
        const ctx = this.checkContext();
        this.setRendered();
        this.clef.renderText(ctx, this.getAbsoluteX() - this.x, stave.getYForLine(this.clef.line));
    }
}


/***/ }),

/***/ "./src/crescendo.ts":
/*!**************************!*\
  !*** ./src/crescendo.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Crescendo: () => (/* binding */ Crescendo)
/* harmony export */ });
/* harmony import */ var _note__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./note */ "./src/note.ts");
/* harmony import */ var _tickcontext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tickcontext */ "./src/tickcontext.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
//
// This file implements the `Crescendo` object which draws crescendos and
// decrescendo dynamics markings. A `Crescendo` is initialized with a
// duration and formatted as part of a `Voice` like any other `Note`
// type in VexFlow. This object would most likely be formatted in a Voice
// with `TextNotes` - which are used to represent other dynamics markings.




// To enable logging for this class. Set `Vex.Flow.Crescendo.DEBUG` to `true`.
// eslint-disable-next-line
function L(...args) {
    if (Crescendo.DEBUG)
        (0,_util__WEBPACK_IMPORTED_MODULE_3__.log)('Vex.Flow.Crescendo', args);
}
// Helper to draw the hairpin.
function renderHairpin(ctx, params) {
    const beginX = params.beginX;
    const endX = params.endX;
    const y = params.y;
    const halfHeight = params.height / 2;
    ctx.beginPath();
    if (params.reverse) {
        ctx.moveTo(beginX, y - halfHeight);
        ctx.lineTo(endX, y);
        ctx.lineTo(beginX, y + halfHeight);
    }
    else {
        ctx.moveTo(endX, y - halfHeight);
        ctx.lineTo(beginX, y);
        ctx.lineTo(endX, y + halfHeight);
    }
    ctx.stroke();
    ctx.closePath();
}
class Crescendo extends _note__WEBPACK_IMPORTED_MODULE_0__.Note {
    /** Crescendo category string. */
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_2__.Category.Crescendo;
    }
    // Initialize the crescendo's properties
    constructor(noteStruct) {
        var _a;
        super(noteStruct);
        this.options = {
            // Extensions to the length of the crescendo on either side
            extendLeft: 0,
            extendRight: 0,
            // Vertical shift
            yShift: 0,
        };
        // Whether the object is a decrescendo
        this.decrescendo = false;
        // The staff line to be placed on
        this.line = (_a = noteStruct.line) !== null && _a !== void 0 ? _a : 0;
        // The height at the open end of the cresc/decresc
        this.height = 15;
    }
    // Set the line to center the element on
    setLine(line) {
        this.line = line;
        return this;
    }
    // Set the full height at the open end
    setHeight(height) {
        this.height = height;
        return this;
    }
    // Set whether the sign should be a descresendo by passing a bool
    // to `decresc`
    setDecrescendo(decresc) {
        this.decrescendo = decresc;
        return this;
    }
    // Preformat the note
    preFormat() {
        this.preFormatted = true;
        return this;
    }
    // Render the Crescendo object onto the canvas
    draw() {
        const ctx = this.checkContext();
        const stave = this.checkStave();
        this.setRendered();
        const tickContext = this.getTickContext();
        const nextContext = _tickcontext__WEBPACK_IMPORTED_MODULE_1__.TickContext.getNextContext(tickContext);
        const beginX = this.getAbsoluteX();
        const endX = nextContext ? nextContext.getX() : stave.getX() + stave.getWidth();
        const y = stave.getYForLine(this.line + -3) + 1;
        L('Drawing ', this.decrescendo ? 'decrescendo ' : 'crescendo ', this.height, 'x', beginX - endX);
        renderHairpin(ctx, {
            beginX: beginX - this.options.extendLeft,
            endX: endX + this.options.extendRight,
            y: y + this.options.yShift,
            height: this.height,
            reverse: this.decrescendo,
        });
    }
}
Crescendo.DEBUG = false;


/***/ }),

/***/ "./src/curve.ts":
/*!**********************!*\
  !*** ./src/curve.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Curve: () => (/* binding */ Curve),
/* harmony export */   CurvePosition: () => (/* binding */ CurvePosition)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
//
// This class implements curves (for slurs)



var CurvePosition;
(function (CurvePosition) {
    CurvePosition[CurvePosition["NEAR_HEAD"] = 1] = "NEAR_HEAD";
    CurvePosition[CurvePosition["NEAR_TOP"] = 2] = "NEAR_TOP";
})(CurvePosition || (CurvePosition = {}));
class Curve extends _element__WEBPACK_IMPORTED_MODULE_0__.Element {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_1__.Category.Curve;
    }
    static get Position() {
        return CurvePosition;
    }
    static get PositionString() {
        return {
            nearHead: CurvePosition.NEAR_HEAD,
            nearTop: CurvePosition.NEAR_TOP,
        };
    }
    // from: Start note
    // to: End note
    // options:
    //    cps: List of control points
    //    xShift: pixels to shift
    //    yShift: pixels to shift
    constructor(from, to, options) {
        super();
        this.renderOptions = Object.assign({ thickness: 2, xShift: 0, yShift: 10, position: CurvePosition.NEAR_HEAD, positionEnd: CurvePosition.NEAR_HEAD, invert: false, cps: [
                { x: 0, y: 10 },
                { x: 0, y: 10 },
            ] }, options);
        this.from = from;
        this.to = to;
    }
    setNotes(from, to) {
        if (!from && !to) {
            throw new _util__WEBPACK_IMPORTED_MODULE_2__.RuntimeError('BadArguments', 'Curve needs to have either `from` or `to` set.');
        }
        this.from = from;
        this.to = to;
        return this;
    }
    /**
     * @return {boolean} Returns true if this is a partial bar.
     */
    isPartial() {
        return !this.from || !this.to;
    }
    renderCurve(params) {
        const ctx = this.checkContext();
        const xShift = this.renderOptions.xShift;
        const yShift = this.renderOptions.yShift * params.direction;
        const firstX = params.firstX + xShift;
        const firstY = params.firstY + yShift;
        const lastX = params.lastX - xShift;
        const lastY = params.lastY + yShift;
        const thickness = this.renderOptions.thickness;
        const cps = this.renderOptions.cps;
        const { x: cp0x, y: cp0y } = cps[0];
        const { x: cp1x, y: cp1y } = cps[1];
        const controlPointSpacing = (lastX - firstX) / (cps.length + 2);
        ctx.beginPath();
        ctx.moveTo(firstX, firstY);
        ctx.bezierCurveTo(firstX + controlPointSpacing + cp0x, firstY + cp0y * params.direction, lastX - controlPointSpacing + cp1x, lastY + cp1y * params.direction, lastX, lastY);
        ctx.bezierCurveTo(lastX - controlPointSpacing + cp1x, lastY + (cp1y + thickness) * params.direction, firstX + controlPointSpacing + cp0x, firstY + (cp0y + thickness) * params.direction, firstX, firstY);
        ctx.stroke();
        ctx.closePath();
        ctx.fill();
    }
    draw() {
        this.checkContext();
        this.setRendered();
        const firstNote = this.from;
        const lastNote = this.to;
        let firstX;
        let lastX;
        let firstY;
        let lastY;
        let stemDirection = 0;
        let metric = 'baseY';
        let endMetric = 'baseY';
        function getPosition(position) {
            return typeof position === 'string' ? Curve.PositionString[position] : position;
        }
        const position = getPosition(this.renderOptions.position);
        const positionEnd = getPosition(this.renderOptions.positionEnd);
        if (position === CurvePosition.NEAR_TOP) {
            metric = 'topY';
            endMetric = 'topY';
        }
        if (positionEnd === CurvePosition.NEAR_HEAD) {
            endMetric = 'baseY';
        }
        else if (positionEnd === CurvePosition.NEAR_TOP) {
            endMetric = 'topY';
        }
        if (firstNote) {
            firstX = firstNote.getTieRightX();
            stemDirection = firstNote.getStemDirection();
            firstY = firstNote.getStemExtents()[metric];
        }
        else {
            const stave = lastNote.checkStave();
            firstX = stave.getTieStartX();
            firstY = lastNote.getStemExtents()[metric];
        }
        if (lastNote) {
            lastX = lastNote.getTieLeftX();
            stemDirection = lastNote.getStemDirection();
            lastY = lastNote.getStemExtents()[endMetric];
        }
        else {
            const stave = firstNote.checkStave();
            lastX = stave.getTieEndX();
            lastY = firstNote.getStemExtents()[endMetric];
        }
        this.renderCurve({
            firstX,
            lastX,
            firstY,
            lastY,
            direction: stemDirection * (this.renderOptions.invert === true ? -1 : 1),
        });
        return true;
    }
}


/***/ }),

/***/ "./src/dot.ts":
/*!********************!*\
  !*** ./src/dot.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dot: () => (/* binding */ Dot)
/* harmony export */ });
/* harmony import */ var _modifier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modifier */ "./src/modifier.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
//
// This class implements dot modifiers for notes.



class Dot extends _modifier__WEBPACK_IMPORTED_MODULE_0__.Modifier {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_1__.Category.Dot;
    }
    /** Returns the dots associated to a Note. */
    static getDots(note) {
        return note.getModifiersByType(Dot.CATEGORY);
    }
    /** Add a dot on the specified keys to the notes. */
    static buildAndAttach(notes, options) {
        for (const note of notes) {
            if (options === null || options === void 0 ? void 0 : options.all) {
                for (let i = 0; i < note.keys.length; i++) {
                    const dot = new Dot();
                    note.addModifier(dot, i);
                }
            }
            else if ((options === null || options === void 0 ? void 0 : options.index) !== undefined) {
                const dot = new Dot();
                note.addModifier(dot, options === null || options === void 0 ? void 0 : options.index);
            }
            else {
                const dot = new Dot();
                note.addModifier(dot, 0);
            }
        }
    }
    // Arrange dots inside a ModifierContext.
    static format(dots, state) {
        const rightShift = state.rightShift;
        const dotSpacing = 1;
        if (!dots || dots.length === 0)
            return false;
        const dotList = [];
        const maxShiftMap = {};
        for (let i = 0; i < dots.length; ++i) {
            const dot = dots[i];
            const note = dot.getNote();
            let props;
            let shift;
            if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_1__.isStaveNote)(note)) {
                const index = dot.checkIndex();
                props = note.getKeyProps()[index];
                // consider right displaced head with no previous modifier
                shift = note.getFirstDotPx();
            }
            else if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_1__.isTabNote)(note)) {
                props = { line: 0.5 }; // Shim key props for dot placement
                shift = rightShift;
            }
            else {
                // note object is not StaveNote or TabNote.
                throw new _util__WEBPACK_IMPORTED_MODULE_2__.RuntimeError('Internal', 'Unexpected instance.');
            }
            const noteId = note.getAttribute('id');
            dotList.push({ line: props.line, note, noteId, dot });
            maxShiftMap[noteId] = Math.max(maxShiftMap[noteId] || shift, shift);
        }
        // Sort dots by line number.
        dotList.sort((a, b) => b.line - a.line);
        let dotShift = rightShift;
        let xWidth = 0;
        let lastLine = null;
        let lastNote = null;
        let prevDottedSpace = null;
        let halfShiftY = 0;
        for (let i = 0; i < dotList.length; ++i) {
            const { dot, note, noteId, line } = dotList[i];
            // Reset the position of the dot every line.
            if (line !== lastLine || note !== lastNote) {
                dotShift = maxShiftMap[noteId];
            }
            if (!note.isRest() && line !== lastLine) {
                if (Math.abs(line % 1) === 0.5) {
                    // note is on a space, so no dot shift
                    halfShiftY = 0;
                }
                else {
                    // note is on a line, so shift dot to space above the line
                    halfShiftY = 0.5;
                    if (lastNote !== null && !lastNote.isRest() && lastLine !== null && lastLine - line === 0.5) {
                        // previous note on a space, so shift dot to space below the line
                        halfShiftY = -0.5;
                    }
                    else if (line + halfShiftY === prevDottedSpace) {
                        // previous space is dotted, so shift dot to space below the line
                        halfShiftY = -0.5;
                    }
                }
            }
            // Convert halfShiftY to a multiplier for dots.draw().
            if (note.isRest()) {
                dot.dotShiftY += -halfShiftY;
            }
            else {
                dot.dotShiftY = -halfShiftY;
            }
            prevDottedSpace = line + halfShiftY;
            dot.setXShift(dotShift);
            dotShift += dot.getWidth() + dotSpacing; // spacing
            xWidth = dotShift > xWidth ? dotShift : xWidth;
            lastLine = line;
            lastNote = note;
        }
        // Update state.
        state.rightShift += xWidth;
        return true;
    }
    constructor() {
        super();
        this.position = _modifier__WEBPACK_IMPORTED_MODULE_0__.Modifier.Position.RIGHT;
        this.radius = 2;
        this.setWidth(5);
        this.dotShiftY = 0;
    }
    setNote(note) {
        this.note = note;
        if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_1__.isGraceNote)(note)) {
            this.radius *= 0.5;
            this.setWidth(3);
        }
        return this;
    }
    setDotShiftY(y) {
        this.dotShiftY = y;
        return this;
    }
    draw() {
        const ctx = this.checkContext();
        const note = this.checkAttachedNote();
        this.setRendered();
        const stave = note.checkStave();
        const lineSpace = stave.getSpacingBetweenLines();
        const start = note.getModifierStartXY(this.position, this.index, { forceFlagRight: true });
        // Set the starting y coordinate to the base of the stem for TabNotes.
        if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_1__.isTabNote)(note)) {
            start.y = note.getStemExtents().baseY;
        }
        const x = start.x + this.xShift + this.width - this.radius;
        const y = start.y + this.yShift + this.dotShiftY * lineSpace;
        ctx.beginPath();
        ctx.arc(x, y, this.radius, 0, Math.PI * 2, false);
        ctx.fill();
    }
}


/***/ }),

/***/ "./src/easyscore.ts":
/*!**************************!*\
  !*** ./src/easyscore.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Builder: () => (/* binding */ Builder),
/* harmony export */   EasyScore: () => (/* binding */ EasyScore),
/* harmony export */   EasyScoreGrammar: () => (/* binding */ EasyScoreGrammar),
/* harmony export */   Piece: () => (/* binding */ Piece)
/* harmony export */ });
/* harmony import */ var _articulation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./articulation */ "./src/articulation.ts");
/* harmony import */ var _dot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dot */ "./src/dot.ts");
/* harmony import */ var _frethandfinger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./frethandfinger */ "./src/frethandfinger.ts");
/* harmony import */ var _music__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./music */ "./src/music.ts");
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parser */ "./src/parser.ts");
/* harmony import */ var _stem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./stem */ "./src/stem.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License







// To enable logging for this class. Set `Vex.Flow.EasyScore.DEBUG` to `true`.
// eslint-disable-next-line
function L(...args) {
    if (EasyScore.DEBUG)
        (0,_util__WEBPACK_IMPORTED_MODULE_6__.log)('Vex.Flow.EasyScore', args);
}
class EasyScoreGrammar {
    constructor(builder) {
        this.builder = builder;
    }
    begin() {
        return this.LINE;
    }
    LINE() {
        return {
            expect: [this.PIECE, this.PIECES, this.EOL],
        };
    }
    PIECE() {
        return {
            expect: [this.CHORDORNOTE, this.PARAMS],
            run: () => this.builder.commitPiece(),
        };
    }
    PIECES() {
        return {
            expect: [this.COMMA, this.PIECE],
            zeroOrMore: true,
        };
    }
    PARAMS() {
        return {
            expect: [this.DURATION, this.TYPE, this.DOTS, this.OPTS],
        };
    }
    CHORDORNOTE() {
        return {
            expect: [this.CHORD, this.SINGLENOTE],
            or: true,
        };
    }
    CHORD() {
        return {
            expect: [this.LPAREN, this.NOTES, this.RPAREN],
            // eslint-disable-next-line
            run: (state) => this.builder.addChord(state.matches[1]),
        };
    }
    NOTES() {
        return {
            expect: [this.NOTE],
            oneOrMore: true,
        };
    }
    NOTE() {
        return {
            expect: [this.NOTENAME, this.ACCIDENTAL, this.OCTAVE],
        };
    }
    SINGLENOTE() {
        return {
            expect: [this.NOTENAME, this.ACCIDENTAL, this.OCTAVE],
            run: (state) => {
                // eslint-disable-next-line
                const s = state;
                this.builder.addSingleNote(s.matches[0], s.matches[1], s.matches[2]);
            },
        };
    }
    ACCIDENTAL() {
        return {
            expect: [this.MICROTONES, this.ACCIDENTALS],
            maybe: true,
            or: true,
        };
    }
    DOTS() {
        return {
            expect: [this.DOT],
            zeroOrMore: true,
            // eslint-disable-next-line
            run: (state) => this.builder.setNoteDots(state.matches),
        };
    }
    TYPE() {
        return {
            expect: [this.SLASH, this.MAYBESLASH, this.TYPES],
            maybe: true,
            // eslint-disable-next-line
            run: (state) => this.builder.setNoteType(state.matches[2]),
        };
    }
    DURATION() {
        return {
            expect: [this.SLASH, this.DURATIONS],
            maybe: true,
            // eslint-disable-next-line
            run: (state) => this.builder.setNoteDuration(state.matches[1]),
        };
    }
    OPTS() {
        return {
            expect: [this.LBRACKET, this.KEYVAL, this.KEYVALS, this.RBRACKET],
            maybe: true,
        };
    }
    KEYVALS() {
        return {
            expect: [this.COMMA, this.KEYVAL],
            zeroOrMore: true,
        };
    }
    KEYVAL() {
        const unquote = (str) => str.slice(1, -1);
        return {
            expect: [this.KEY, this.EQUALS, this.VAL],
            // eslint-disable-next-line
            run: (state) => this.builder.addNoteOption(state.matches[0], unquote(state.matches[2])),
        };
    }
    VAL() {
        return {
            expect: [this.SVAL, this.DVAL],
            or: true,
        };
    }
    KEY() {
        return { token: '[a-zA-Z][a-zA-Z0-9]*' };
    }
    DVAL() {
        return { token: '["][^"]*["]' };
    }
    SVAL() {
        return { token: "['][^']*[']" };
    }
    NOTENAME() {
        return { token: '[a-gA-G]' };
    }
    OCTAVE() {
        return { token: '[0-9]+' };
    }
    ACCIDENTALS() {
        return { token: 'bb|b|##|#|n' };
    }
    MICROTONES() {
        return { token: 'bbs|bss|bs|db|d|\\+\\+-|\\+-|\\+\\+|\\+|k|o' };
    }
    DURATIONS() {
        return { token: '[0-9whq]+' };
    }
    TYPES() {
        return { token: '[rRsSmMhHgG]' };
    }
    LPAREN() {
        return { token: '[(]' };
    }
    RPAREN() {
        return { token: '[)]' };
    }
    COMMA() {
        return { token: '[,]' };
    }
    DOT() {
        return { token: '[.]' };
    }
    SLASH() {
        return { token: '[/]' };
    }
    MAYBESLASH() {
        return { token: '[/]?' };
    }
    EQUALS() {
        return { token: '[=]' };
    }
    LBRACKET() {
        return { token: '\\[' };
    }
    RBRACKET() {
        return { token: '\\]' };
    }
    EOL() {
        return { token: '$' };
    }
}
class Piece {
    constructor(duration) {
        this.chord = [];
        this.dots = 0;
        this.options = {};
        this.duration = duration;
    }
}
class Builder {
    constructor(factory) {
        this.commitHooks = [];
        this.factory = factory;
        this.reset();
    }
    reset(options) {
        this.options = Object.assign({ stem: 'auto', clef: 'treble' }, options);
        this.elements = { notes: [], accidentals: [] };
        this.rollingDuration = '8';
        this.resetPiece();
    }
    getFactory() {
        return this.factory;
    }
    getElements() {
        return this.elements;
    }
    addCommitHook(commitHook) {
        this.commitHooks.push(commitHook);
    }
    resetPiece() {
        L('resetPiece');
        this.piece = new Piece(this.rollingDuration);
    }
    setNoteDots(dots) {
        L('setNoteDots:', dots);
        if (dots)
            this.piece.dots = dots.length;
    }
    setNoteDuration(duration) {
        L('setNoteDuration:', duration);
        this.rollingDuration = this.piece.duration = duration || this.rollingDuration;
    }
    setNoteType(type) {
        L('setNoteType:', type);
        if (type)
            this.piece.type = type;
    }
    addNoteOption(key, value) {
        L('addNoteOption: key:', key, 'value:', value);
        this.piece.options[key] = value;
    }
    addNote(key, accid, octave) {
        L('addNote:', key, accid, octave);
        this.piece.chord.push({
            key: key,
            accid,
            octave,
        });
    }
    addSingleNote(key, accid, octave) {
        L('addSingleNote:', key, accid, octave);
        this.addNote(key, accid, octave);
    }
    // notes is an array with 3 entries
    addChord(notes) {
        L('startChord');
        if (typeof notes[0] !== 'object') {
            this.addSingleNote(notes[0]);
        }
        else {
            notes.forEach((n) => {
                if (n)
                    this.addNote(...n); // n => [string, string | null, string]
            });
        }
        L('endChord');
    }
    commitPiece() {
        L('commitPiece');
        const { factory } = this;
        if (!factory)
            return;
        const options = Object.assign(Object.assign({}, this.options), this.piece.options);
        // reset() sets this.options.stem & this.options.clef but we check to make sure nothing has changed.
        // e.g., auto | up | down
        const stem = (0,_util__WEBPACK_IMPORTED_MODULE_6__.defined)(options.stem, 'BadArguments', 'options.stem is not defined').toLowerCase();
        // e.g., treble | bass
        const clef = (0,_util__WEBPACK_IMPORTED_MODULE_6__.defined)(options.clef, 'BadArguments', 'options.clef is not defined').toLowerCase();
        const { chord, duration, dots, type } = this.piece;
        // Create a string[] that will be assigned to the .keys property of the StaveNote.
        // Each string in the array represents a note pitch and is of the form: {NoteName}{Accidental}/{Octave}
        // Only standard accidentals are included in the .keys property. Microtonal accidentals are not included.
        const standardAccidentals = _music__WEBPACK_IMPORTED_MODULE_3__.Music.accidentals;
        const keys = chord.map((notePiece) => {
            var _a;
            return notePiece.key +
                (standardAccidentals.includes((_a = notePiece.accid) !== null && _a !== void 0 ? _a : '') ? notePiece.accid : '') +
                '/' +
                notePiece.octave;
        });
        const autoStem = stem === 'auto'; // StaveNoteStruct expects the underscore & lowercase.
        // Build a GhostNote or StaveNote using the information we gathered.
        const note = (type === null || type === void 0 ? void 0 : type.toLowerCase()) === 'g'
            ? factory.GhostNote({ duration, dots })
            : factory.StaveNote({ keys, duration, dots, type, clef, autoStem });
        if (!autoStem)
            note.setStemDirection(stem === 'up' ? _stem__WEBPACK_IMPORTED_MODULE_5__.Stem.UP : _stem__WEBPACK_IMPORTED_MODULE_5__.Stem.DOWN);
        // Attach accidentals.
        const accidentals = [];
        chord.forEach((notePiece, index) => {
            const accid = notePiece.accid;
            if (typeof accid === 'string') {
                const accidental = factory.Accidental({ type: accid });
                note.addModifier(accidental, index);
                accidentals.push(accidental);
            }
            else {
                accidentals.push(undefined);
            }
        });
        // Attach dots.
        for (let i = 0; i < dots; i++)
            _dot__WEBPACK_IMPORTED_MODULE_1__.Dot.buildAndAttach([note], { all: true });
        this.commitHooks.forEach((commitHook) => commitHook(options, note, this));
        this.elements.notes.push(note);
        this.elements.accidentals.push(accidentals);
        this.resetPiece();
    }
}
/**
 * Commit hook used by EasyScore.setOptions().
 */
function setId(options, note) {
    if (options.id === undefined)
        return;
    note.setAttribute('id', options.id);
}
// Used by setClass() below.
const commaSeparatedRegex = /\s*,\s*/;
/**
 * Commit hook used by EasyScore.setOptions().
 */
function setClass(options, note) {
    if (options.class === undefined)
        return;
    options.class.split(commaSeparatedRegex).forEach((className) => note.addClass(className));
}
/**
 * EasyScore implements a parser for a simple language to generate VexFlow objects.
 */
class EasyScore {
    constructor(options = {}) {
        this.defaults = {
            clef: 'treble',
            time: '4/4',
            stem: 'auto',
        };
        this.setOptions(options);
    }
    /**
     * Set the score defaults.
     * clef must be set appropriately to avoid errors when adding Staves.
     * @param defaults.clef default clef ( treble | bass ...) see {@link Clef.types}
     * @param defaults.time default time signature ( 4/4 | 9/8 ...)
     * @param defaults.stem default stem arrangement (auto | up | down)
     * @returns this
     */
    set(defaults) {
        this.defaults = Object.assign(Object.assign({}, this.defaults), defaults);
        return this;
    }
    /**
     * @param options.factory is required.
     * @returns this
     */
    setOptions(options) {
        var _a, _b;
        // eslint-disable-next-line
        const factory = options.factory; // ! operator, because options.factory was set in Factory.EasyScore().
        const builder = (_a = options.builder) !== null && _a !== void 0 ? _a : new Builder(factory);
        this.options = Object.assign(Object.assign({ commitHooks: [setId, setClass, _articulation__WEBPACK_IMPORTED_MODULE_0__.Articulation.easyScoreHook, _frethandfinger__WEBPACK_IMPORTED_MODULE_2__.FretHandFinger.easyScoreHook], throwOnError: false }, options), { factory,
            builder });
        this.factory = factory;
        this.builder = builder;
        this.grammar = new EasyScoreGrammar(this.builder);
        this.parser = new _parser__WEBPACK_IMPORTED_MODULE_4__.Parser(this.grammar);
        (_b = this.options.commitHooks) === null || _b === void 0 ? void 0 : _b.forEach((commitHook) => this.addCommitHook(commitHook));
        return this;
    }
    setContext(context) {
        this.factory.setContext(context);
        return this;
    }
    parse(line, options = {}) {
        this.builder.reset(options);
        const result = this.parser.parse(line);
        if (!result.success && this.options.throwOnError) {
            L(result);
            throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('Error parsing line: ' + line);
        }
        return result;
    }
    beam(notes, options) {
        this.factory.Beam({ notes, options });
        return notes;
    }
    tuplet(notes, options) {
        this.factory.Tuplet({ notes, options });
        return notes;
    }
    notes(line, options = {}) {
        options = Object.assign({ clef: this.defaults.clef, stem: this.defaults.stem }, options);
        this.parse(line, options);
        return this.builder.getElements().notes;
    }
    voice(notes, options = {}) {
        options = Object.assign({ time: this.defaults.time }, options);
        return this.factory.Voice(options).addTickables(notes);
    }
    addCommitHook(commitHook) {
        this.builder.addCommitHook(commitHook);
    }
}
EasyScore.DEBUG = false;


/***/ }),

/***/ "./src/element.ts":
/*!************************!*\
  !*** ./src/element.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Element: () => (/* binding */ Element)
/* harmony export */ });
/* harmony import */ var _boundingbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boundingbox */ "./src/boundingbox.ts");
/* harmony import */ var _font__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./font */ "./src/font.ts");
/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./metrics */ "./src/metrics.ts");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./registry */ "./src/registry.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
// @author Mohit Cheppudira
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _a, _Element_context, _Element_attrs, _Element_fontInfo, _Element_fontScale, _Element_text, _Element_metricsValid, _Element_textMetrics, _Element_height, _Element_width, _Element_txtCanvas;






/**
 * Element implements a generic base class for VexFlow, with implementations
 * of general functions and properties that can be inherited by all VexFlow elements.
 *
 * The Element handles style and font properties for the Element and any child
 * elements, along with working with the Registry to create unique ids.
 *
 * The `text` is a series of unicode characters (including SMuFL codes).
 * The `textFont` property contains information required to style the text (i.e., font family, size, weight, and style).
 * This font family is a comma separated list of fonts.
 * The method `measureText` calculates the `textMetrics`, `boundingBox`, `height` and `width` of the `text`.
 * The method `renderText(...)` will render the text using the provided context and coordinates,
 * taking `xShift` and `yShift` into account.
 */
class Element {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_4__.Category.Element;
    }
    static newID() {
        return `auto${Element.ID++}`;
    }
    constructor(category) {
        var _b;
        // Element objects keep a list of children that they are responsible for.
        // Children inherit the style from their parents (see: setGroupStyle(s)).
        this.children = [];
        _Element_context.set(this, void 0);
        _Element_attrs.set(this, void 0);
        _Element_fontInfo.set(this, void 0);
        _Element_fontScale.set(this, void 0);
        _Element_text.set(this, '');
        _Element_metricsValid.set(this, false);
        _Element_textMetrics.set(this, {
            fontBoundingBoxAscent: 0,
            fontBoundingBoxDescent: 0,
            actualBoundingBoxAscent: 0,
            actualBoundingBoxDescent: 0,
            actualBoundingBoxLeft: 0,
            actualBoundingBoxRight: 0,
            width: 0,
        });
        _Element_height.set(this, 0);
        _Element_width.set(this, 0);
        this.xShift = 0;
        this.yShift = 0;
        this.x = 0;
        this.y = 0;
        __classPrivateFieldSet(this, _Element_attrs, {
            id: Element.newID(),
            type: category !== null && category !== void 0 ? category : this.constructor.CATEGORY,
            class: '',
        }, "f");
        this.rendered = false;
        __classPrivateFieldSet(this, _Element_fontInfo, _metrics__WEBPACK_IMPORTED_MODULE_2__.Metrics.getFontInfo(__classPrivateFieldGet(this, _Element_attrs, "f").type), "f");
        __classPrivateFieldSet(this, _Element_fontScale, _metrics__WEBPACK_IMPORTED_MODULE_2__.Metrics.get(`${__classPrivateFieldGet(this, _Element_attrs, "f").type}.fontScale`), "f");
        // If a default registry exist, then register with it right away.
        (_b = _registry__WEBPACK_IMPORTED_MODULE_3__.Registry.getDefaultRegistry()) === null || _b === void 0 ? void 0 : _b.register(this);
    }
    /**
     * Adds a child Element to the Element, which lets it inherit the
     * same style as the parent when setGroupStyle() is called.
     *
     * Examples of children are noteheads and stems.  Modifiers such
     * as Accidentals are generally not set as children.
     *
     * Note that StaveNote calls setGroupStyle() when setStyle() is called.
     */
    addChildElement(child) {
        this.children.push(child);
        return this;
    }
    getCategory() {
        return __classPrivateFieldGet(this, _Element_attrs, "f").type;
    }
    /**
     * Set the element style used to render.
     *
     * Example:
     * ```typescript
     * element.setStyle({ fillStyle: 'red', strokeStyle: 'red' });
     * element.draw();
     * ```
     * Note: If the element draws additional sub-elements (ie.: Modifiers in a Stave),
     * the style can be applied to all of them by means of the context:
     * ```typescript
     * element.setStyle({ fillStyle: 'red', strokeStyle: 'red' });
     * element.getContext().setFillStyle('red');
     * element.getContext().setStrokeStyle('red');
     * element.draw();
     * ```
     * or using drawWithStyle:
     * ```typescript
     * element.setStyle({ fillStyle: 'red', strokeStyle: 'red' });
     * element.drawWithStyle();
     * ```
     */
    setStyle(style) {
        this.style = style;
        return this;
    }
    /** Set the element & associated children style used for rendering. */
    setGroupStyle(style) {
        this.style = style;
        this.children.forEach((child) => child.setGroupStyle(style));
        return this;
    }
    /** Get the element style used for rendering. */
    getStyle() {
        return this.style;
    }
    /** Apply the element style to `context`. */
    applyStyle(context = __classPrivateFieldGet(this, _Element_context, "f"), style = this.getStyle()) {
        if (!style)
            return this;
        if (!context)
            return this;
        context.save();
        if (style.shadowColor)
            context.setShadowColor(style.shadowColor);
        if (style.shadowBlur)
            context.setShadowBlur(style.shadowBlur);
        if (style.fillStyle)
            context.setFillStyle(style.fillStyle);
        if (style.strokeStyle)
            context.setStrokeStyle(style.strokeStyle);
        if (style.lineWidth)
            context.setLineWidth(style.lineWidth);
        return this;
    }
    /** Restore the style of `context`. */
    restoreStyle(context = __classPrivateFieldGet(this, _Element_context, "f"), style = this.getStyle()) {
        if (!style)
            return this;
        if (!context)
            return this;
        context.restore();
        return this;
    }
    /**
     * Draw the element and all its sub-elements (ie.: Modifiers in a Stave)
     * with the element's style (see `getStyle()` and `setStyle()`)
     */
    drawWithStyle() {
        this.checkContext();
        this.applyStyle();
        this.draw();
        this.restoreStyle();
    }
    /** Draw an element. */
    draw() {
        throw new _util__WEBPACK_IMPORTED_MODULE_5__.RuntimeError('Element', 'Draw not defined');
    }
    /** Check if it has a class label (An element can have multiple class labels). */
    hasClass(className) {
        var _b;
        if (!__classPrivateFieldGet(this, _Element_attrs, "f").class)
            return false;
        return ((_b = __classPrivateFieldGet(this, _Element_attrs, "f").class) === null || _b === void 0 ? void 0 : _b.split(' ').indexOf(className)) !== -1;
    }
    /** Add a class label (An element can have multiple class labels). */
    addClass(className) {
        var _b;
        if (this.hasClass(className))
            return this;
        if (!__classPrivateFieldGet(this, _Element_attrs, "f").class)
            __classPrivateFieldGet(this, _Element_attrs, "f").class = `${className}`;
        else
            __classPrivateFieldGet(this, _Element_attrs, "f").class = `${__classPrivateFieldGet(this, _Element_attrs, "f").class} ${className}`;
        (_b = this.registry) === null || _b === void 0 ? void 0 : _b.onUpdate({
            id: __classPrivateFieldGet(this, _Element_attrs, "f").id,
            name: 'class',
            value: className,
            oldValue: undefined,
        });
        return this;
    }
    /** Remove a class label (An element can have multiple class labels). */
    removeClass(className) {
        var _b, _c;
        if (!this.hasClass(className))
            return this;
        const arr = (_b = __classPrivateFieldGet(this, _Element_attrs, "f").class) === null || _b === void 0 ? void 0 : _b.split(' ');
        if (arr) {
            arr.splice(arr.indexOf(className));
            __classPrivateFieldGet(this, _Element_attrs, "f").class = arr.join(' ');
        }
        (_c = this.registry) === null || _c === void 0 ? void 0 : _c.onUpdate({
            id: __classPrivateFieldGet(this, _Element_attrs, "f").id,
            name: 'class',
            value: undefined,
            oldValue: className,
        });
        return this;
    }
    /** Call back from registry after the element is registered. */
    onRegister(registry) {
        this.registry = registry;
        return this;
    }
    /** Return the rendered status. */
    isRendered() {
        return this.rendered;
    }
    /** Set the rendered status. */
    setRendered(rendered = true) {
        this.rendered = rendered;
        return this;
    }
    /** Return the element attributes. */
    getAttributes() {
        return __classPrivateFieldGet(this, _Element_attrs, "f");
    }
    /** Return an attribute, such as 'id', 'type' or 'class'. */
    // eslint-disable-next-line
    getAttribute(name) {
        return __classPrivateFieldGet(this, _Element_attrs, "f")[name];
    }
    /** Return associated SVGElement. */
    getSVGElement(suffix = '') {
        const id = (0,_util__WEBPACK_IMPORTED_MODULE_5__.prefix)(__classPrivateFieldGet(this, _Element_attrs, "f").id + suffix);
        const element = document.getElementById(id);
        if (element)
            return element;
    }
    /** Set an attribute such as 'id', 'class', or 'type'. */
    setAttribute(name, value) {
        var _b;
        const oldID = __classPrivateFieldGet(this, _Element_attrs, "f").id;
        const oldValue = __classPrivateFieldGet(this, _Element_attrs, "f")[name];
        __classPrivateFieldGet(this, _Element_attrs, "f")[name] = value;
        // Register with old id to support id changes.
        (_b = this.registry) === null || _b === void 0 ? void 0 : _b.onUpdate({ id: oldID, name, value, oldValue });
        return this;
    }
    /** Get the boundingBox. */
    getBoundingBox() {
        return new _boundingbox__WEBPACK_IMPORTED_MODULE_0__.BoundingBox(0, -this.textMetrics.actualBoundingBoxAscent, this.width, this.height);
    }
    /** Return the context, such as an SVGContext or CanvasContext object. */
    getContext() {
        return __classPrivateFieldGet(this, _Element_context, "f");
    }
    /** Set the context to an SVGContext or CanvasContext object */
    setContext(context) {
        __classPrivateFieldSet(this, _Element_context, context, "f");
        return this;
    }
    /** Validate and return the rendering context. */
    checkContext() {
        return (0,_util__WEBPACK_IMPORTED_MODULE_5__.defined)(__classPrivateFieldGet(this, _Element_context, "f"), 'NoContext', 'No rendering context attached to instance.');
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////
    // Font Handling
    /**
     * Provide a CSS compatible font string (e.g., 'bold 16px Arial') that will be applied
     * to text (not glyphs).
     */
    set font(f) {
        this.setFont(f);
    }
    /** Returns the CSS compatible font string for the text font. */
    get font() {
        return _font__WEBPACK_IMPORTED_MODULE_1__.Font.toCSSString(__classPrivateFieldGet(this, _Element_fontInfo, "f"));
    }
    /**
     * Set the element's text font family, size, weight, style
     * (e.g., `Arial`, `10pt`, `bold`, `italic`).
     *
     * This attribute does not determine the font used for musical Glyphs like treble clefs.
     *
     * @param font is 1) a `FontInfo` object or
     *                2) a string formatted as CSS font shorthand (e.g., 'bold 10pt Arial') or
     *                3) a string representing the font family (at least one of `size`, `weight`, or `style` must also be provided).
     * @param size a string specifying the font size and unit (e.g., '16pt'), or a number (the unit is assumed to be 'pt').
     * @param weight is a string (e.g., 'bold', 'normal') or a number (100, 200, ... 900).
     * @param style is a string (e.g., 'italic', 'normal').
     * If no arguments are provided, then the font is set to the default font.
     * Each Element subclass may specify its own default by overriding the static `TEXT_FONT` property.
     */
    setFont(font, size, weight, style) {
        const defaultTextFont = _metrics__WEBPACK_IMPORTED_MODULE_2__.Metrics.getFontInfo(__classPrivateFieldGet(this, _Element_attrs, "f").type);
        const fontIsObject = typeof font === 'object';
        const fontIsString = typeof font === 'string';
        const sizeWeightStyleAreUndefined = size === undefined && weight === undefined && style === undefined;
        __classPrivateFieldSet(this, _Element_metricsValid, false, "f");
        if (fontIsObject) {
            // `font` is case 1) a FontInfo object
            __classPrivateFieldSet(this, _Element_fontInfo, Object.assign(Object.assign({}, defaultTextFont), font), "f");
        }
        else if (fontIsString && sizeWeightStyleAreUndefined) {
            // `font` is case 2) CSS font shorthand.
            __classPrivateFieldSet(this, _Element_fontInfo, _font__WEBPACK_IMPORTED_MODULE_1__.Font.fromCSSString(font), "f");
        }
        else {
            // `font` is case 3) a font family string (e.g., 'Times New Roman').
            // The other parameters represent the size, weight, and style.
            // It is okay for `font` to be undefined while one or more of the other arguments is provided.
            // Following CSS conventions, unspecified params are reset to the default.
            __classPrivateFieldSet(this, _Element_fontInfo, _font__WEBPACK_IMPORTED_MODULE_1__.Font.validate(font !== null && font !== void 0 ? font : defaultTextFont.family, size !== null && size !== void 0 ? size : defaultTextFont.size, weight !== null && weight !== void 0 ? weight : defaultTextFont.weight, style !== null && style !== void 0 ? style : defaultTextFont.style), "f");
        }
        return this;
    }
    /**
     * Get the css string describing this Element's text font. e.g.,
     * 'bold 10pt Arial'.
     */
    getFont() {
        return _font__WEBPACK_IMPORTED_MODULE_1__.Font.toCSSString(__classPrivateFieldGet(this, _Element_fontInfo, "f"));
    }
    /** Return a copy of the current FontInfo object. */
    get fontInfo() {
        // We can cast to Required<FontInfo> here, because
        // we just called resetFont() above to ensure this.fontInfo is set.
        return __classPrivateFieldGet(this, _Element_fontInfo, "f");
    }
    /** Set the current FontInfo object. */
    set fontInfo(fontInfo) {
        this.setFont(fontInfo);
    }
    /** Change the font size, while keeping everything else the same. */
    setFontSize(size) {
        const fontInfo = this.fontInfo;
        this.setFont(fontInfo.family, size, fontInfo.weight, fontInfo.style);
        return this;
    }
    /**
     * @returns a CSS font-size string (e.g., '18pt', '12px', '1em').
     * See Element.fontSizeInPixels or Element.fontSizeInPoints if you need to get a number for calculation purposes.
     */
    getFontSize() {
        return this.fontSize;
    }
    getFontScale() {
        return __classPrivateFieldGet(this, _Element_fontScale, "f");
    }
    /**
     * The size is 1) a string of the form '10pt' or '16px', compatible with the CSS font-size property.
     *          or 2) a number, which is interpreted as a point size (i.e. 12 == '12pt').
     */
    set fontSize(size) {
        this.setFontSize(size);
    }
    /** @returns a CSS font-size string (e.g., '18pt', '12px', '1em'). */
    get fontSize() {
        let size = this.fontInfo.size;
        if (typeof size === 'number') {
            size = `${size}pt`;
        }
        return size;
    }
    /** @returns the font size in `pt`. */
    get fontSizeInPoints() {
        return _font__WEBPACK_IMPORTED_MODULE_1__.Font.convertSizeToPointValue(this.fontSize);
    }
    /** @returns the font size in `px`. */
    get fontSizeInPixels() {
        return _font__WEBPACK_IMPORTED_MODULE_1__.Font.convertSizeToPixelValue(this.fontSize);
    }
    /** @returns a CSS font-style string (e.g., 'italic'). */
    get fontStyle() {
        return this.fontInfo.style;
    }
    /** Set the font style. */
    set fontStyle(style) {
        const fontInfo = this.fontInfo;
        this.setFont(fontInfo.family, fontInfo.size, fontInfo.weight, style);
    }
    /**
     * @returns a CSS font-weight string (e.g., 'bold').
     * As in CSS, font-weight is always returned as a string, even if it was set as a number.
     */
    get fontWeight() {
        return this.fontInfo.weight + '';
    }
    /** Set the font weight. */
    set fontWeight(weight) {
        const fontInfo = this.fontInfo;
        this.setFont(fontInfo.family, fontInfo.size, weight, fontInfo.style);
    }
    /** Get element width. */
    getWidth() {
        return this.width;
    }
    get width() {
        if (!__classPrivateFieldGet(this, _Element_metricsValid, "f"))
            this.measureText();
        return __classPrivateFieldGet(this, _Element_width, "f");
    }
    /** Set element width. */
    setWidth(width) {
        this.width = width;
        return this;
    }
    set width(width) {
        if (!__classPrivateFieldGet(this, _Element_metricsValid, "f"))
            this.measureText();
        __classPrivateFieldSet(this, _Element_width, width, "f");
    }
    /** Set the X coordinate. */
    setX(x) {
        this.x = x;
        return this;
    }
    /** Get the X coordinate. */
    getX() {
        return this.x;
    }
    /** Get the Y coordinate. */
    getY() {
        return this.y;
    }
    /** Set the Y coordinate. */
    setY(y) {
        this.y = y;
        return this;
    }
    /** Shift element down `yShift` pixels. Negative values shift up. */
    setYShift(yShift) {
        this.yShift = yShift;
        return this;
    }
    /** Get shift element `yShift`. */
    getYShift() {
        return this.yShift;
    }
    /** Set shift element right `xShift` pixels. Negative values shift left. */
    setXShift(xShift) {
        this.xShift = xShift;
        return this;
    }
    /** Get shift element `xShift`. */
    getXShift() {
        return this.xShift;
    }
    /** Set element text. */
    setText(text) {
        this.text = text;
        return this;
    }
    set text(text) {
        __classPrivateFieldSet(this, _Element_metricsValid, false, "f");
        __classPrivateFieldSet(this, _Element_text, text, "f");
    }
    /** Get element text. */
    getText() {
        return __classPrivateFieldGet(this, _Element_text, "f");
    }
    get text() {
        return __classPrivateFieldGet(this, _Element_text, "f");
    }
    /** Render the element text. */
    renderText(ctx, xPos, yPos) {
        ctx.save();
        ctx.setFont(__classPrivateFieldGet(this, _Element_fontInfo, "f"));
        ctx.fillText(__classPrivateFieldGet(this, _Element_text, "f"), xPos + this.x + this.xShift, yPos + this.y + this.yShift);
        this.children.forEach((child) => {
            ctx.setFont(__classPrivateFieldGet(child, _Element_fontInfo, "f"));
            ctx.fillText(__classPrivateFieldGet(child, _Element_text, "f"), xPos + child.x + child.xShift, yPos + child.y + child.yShift);
        });
        ctx.restore();
    }
    /** Measure the text using the textFont. */
    measureText() {
        let txtCanvas = __classPrivateFieldGet(Element, _a, "f", _Element_txtCanvas);
        if (!txtCanvas) {
            // Create the canvas element that will be used to measure text in the event
            // of a cache miss.
            txtCanvas = document.createElement('canvas');
            __classPrivateFieldSet(Element, _a, txtCanvas, "f", _Element_txtCanvas);
        }
        const context = txtCanvas.getContext('2d');
        if (!context)
            throw new _util__WEBPACK_IMPORTED_MODULE_5__.RuntimeError('Font', 'No txt context');
        context.font = _font__WEBPACK_IMPORTED_MODULE_1__.Font.toCSSString(_font__WEBPACK_IMPORTED_MODULE_1__.Font.validate(__classPrivateFieldGet(this, _Element_fontInfo, "f")));
        __classPrivateFieldSet(this, _Element_textMetrics, context.measureText(__classPrivateFieldGet(this, _Element_text, "f")), "f");
        __classPrivateFieldSet(this, _Element_height, __classPrivateFieldGet(this, _Element_textMetrics, "f").actualBoundingBoxAscent + __classPrivateFieldGet(this, _Element_textMetrics, "f").actualBoundingBoxDescent, "f");
        __classPrivateFieldSet(this, _Element_width, __classPrivateFieldGet(this, _Element_textMetrics, "f").width, "f");
        __classPrivateFieldSet(this, _Element_metricsValid, true, "f");
        return __classPrivateFieldGet(this, _Element_textMetrics, "f");
    }
    /** Get the text metrics. */
    getTextMetrics() {
        return this.textMetrics;
    }
    get textMetrics() {
        if (!__classPrivateFieldGet(this, _Element_metricsValid, "f"))
            this.measureText();
        return __classPrivateFieldGet(this, _Element_textMetrics, "f");
    }
    /** Get the text height. */
    getHeight() {
        return this.height;
    }
    get height() {
        if (!__classPrivateFieldGet(this, _Element_metricsValid, "f"))
            this.measureText();
        return __classPrivateFieldGet(this, _Element_height, "f");
    }
    set height(height) {
        if (!__classPrivateFieldGet(this, _Element_metricsValid, "f"))
            this.measureText();
        __classPrivateFieldSet(this, _Element_height, height, "f");
    }
    setOriginX(x) {
        const bbox = this.getBoundingBox();
        const originX = Math.abs(bbox.getX() / bbox.getW());
        const xShift = (x - originX) * bbox.getW();
        this.xShift = -xShift;
    }
    setOriginY(y) {
        const bbox = this.getBoundingBox();
        const originY = Math.abs(bbox.getY() / bbox.getH());
        const yShift = (y - originY) * bbox.getH();
        this.yShift = -yShift;
    }
    setOrigin(x, y) {
        this.setOriginX(x);
        this.setOriginY(y);
    }
}
_a = Element, _Element_context = new WeakMap(), _Element_attrs = new WeakMap(), _Element_fontInfo = new WeakMap(), _Element_fontScale = new WeakMap(), _Element_text = new WeakMap(), _Element_metricsValid = new WeakMap(), _Element_textMetrics = new WeakMap(), _Element_height = new WeakMap(), _Element_width = new WeakMap();
Element.ID = 1000;
/** Canvas used to measure text. */
_Element_txtCanvas = { value: void 0 };


/***/ }),

/***/ "./src/factory.ts":
/*!************************!*\
  !*** ./src/factory.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Factory: () => (/* binding */ Factory)
/* harmony export */ });
/* harmony import */ var _accidental__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./accidental */ "./src/accidental.ts");
/* harmony import */ var _annotation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./annotation */ "./src/annotation.ts");
/* harmony import */ var _articulation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./articulation */ "./src/articulation.ts");
/* harmony import */ var _barnote__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./barnote */ "./src/barnote.ts");
/* harmony import */ var _beam__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./beam */ "./src/beam.ts");
/* harmony import */ var _chordsymbol__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./chordsymbol */ "./src/chordsymbol.ts");
/* harmony import */ var _clefnote__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./clefnote */ "./src/clefnote.ts");
/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./curve */ "./src/curve.ts");
/* harmony import */ var _easyscore__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./easyscore */ "./src/easyscore.ts");
/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./formatter */ "./src/formatter.ts");
/* harmony import */ var _frethandfinger__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./frethandfinger */ "./src/frethandfinger.ts");
/* harmony import */ var _ghostnote__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ghostnote */ "./src/ghostnote.ts");
/* harmony import */ var _glyphnote__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./glyphnote */ "./src/glyphnote.ts");
/* harmony import */ var _gracenote__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./gracenote */ "./src/gracenote.ts");
/* harmony import */ var _gracenotegroup__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./gracenotegroup */ "./src/gracenotegroup.ts");
/* harmony import */ var _keysignote__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./keysignote */ "./src/keysignote.ts");
/* harmony import */ var _modifiercontext__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./modifiercontext */ "./src/modifiercontext.ts");
/* harmony import */ var _multimeasurerest__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./multimeasurerest */ "./src/multimeasurerest.ts");
/* harmony import */ var _notesubgroup__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./notesubgroup */ "./src/notesubgroup.ts");
/* harmony import */ var _ornament__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./ornament */ "./src/ornament.ts");
/* harmony import */ var _pedalmarking__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./pedalmarking */ "./src/pedalmarking.ts");
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./renderer */ "./src/renderer.ts");
/* harmony import */ var _repeatnote__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./repeatnote */ "./src/repeatnote.ts");
/* harmony import */ var _stave__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./stave */ "./src/stave.ts");
/* harmony import */ var _staveconnector__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./staveconnector */ "./src/staveconnector.ts");
/* harmony import */ var _staveline__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./staveline */ "./src/staveline.ts");
/* harmony import */ var _stavenote__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./stavenote */ "./src/stavenote.ts");
/* harmony import */ var _stavetie__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./stavetie */ "./src/stavetie.ts");
/* harmony import */ var _stringnumber__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./stringnumber */ "./src/stringnumber.ts");
/* harmony import */ var _system__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./system */ "./src/system.ts");
/* harmony import */ var _tabnote__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./tabnote */ "./src/tabnote.ts");
/* harmony import */ var _tabstave__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./tabstave */ "./src/tabstave.ts");
/* harmony import */ var _textbracket__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./textbracket */ "./src/textbracket.ts");
/* harmony import */ var _textdynamics__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./textdynamics */ "./src/textdynamics.ts");
/* harmony import */ var _textnote__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./textnote */ "./src/textnote.ts");
/* harmony import */ var _tickcontext__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./tickcontext */ "./src/tickcontext.ts");
/* harmony import */ var _timesignote__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./timesignote */ "./src/timesignote.ts");
/* harmony import */ var _tuplet__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./tuplet */ "./src/tuplet.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./util */ "./src/util.ts");
/* harmony import */ var _vibratobracket__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./vibratobracket */ "./src/vibratobracket.ts");
/* harmony import */ var _voice__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./voice */ "./src/voice.ts");
/* harmony import */ var _web__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./web */ "./src/web.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
// @author Mohit Cheppudira
// MIT License










































// eslint-disable-next-line
function L(...args) {
    if (Factory.DEBUG)
        (0,_util__WEBPACK_IMPORTED_MODULE_38__.log)('Vex.Flow.Factory', args);
}
/**
 * Factory implements a high level API around VexFlow.
 */
class Factory {
    /**
     * Static simplified function to access constructor without providing FactoryOptions
     *
     * Example:
     *
     * Create an SVG renderer and attach it to the DIV element named "boo" to render using <page-width> 1200 and <page-height> 600
     *
     * `const vf: Factory = Vex.Flow.Factory.newFromElementId('boo', 1200, 600 );`
     */
    static newFromElementId(elementId, width = 500, height = 200) {
        return new Factory({ renderer: { elementId, width, height } });
    }
    /**
     * Example:
     *
     * Create an SVG renderer and attach it to the DIV element named "boo" to render using <page-width> 1200 and <page-height> 600
     *
     * `const vf: Factory = new Vex.Flow.Factory({renderer: { elementId: 'boo', width: 1200, height: 600 }});`
     */
    constructor(options = {}) {
        L('New factory: ', options);
        this.options = {
            stave: {
                space: 10,
            },
            renderer: {
                elementId: '',
                width: 500,
                height: 200,
                background: '#FFF',
            },
        };
        this.setOptions(options);
    }
    reset() {
        this.renderQ = [];
        this.systems = [];
        this.staves = [];
        this.voices = [];
        this.stave = undefined; // current stave
    }
    setOptions(options) {
        this.options = Object.assign(Object.assign({}, this.options), options);
        this.initRenderer();
        this.reset();
    }
    initRenderer() {
        const { elementId, width, height, background } = this.options.renderer;
        if (elementId === null) {
            return;
        }
        if (elementId === '') {
            L(this);
            throw new _util__WEBPACK_IMPORTED_MODULE_38__.RuntimeError('renderer.elementId not set in FactoryOptions');
        }
        let backend = this.options.renderer.backend;
        if (backend === undefined) {
            const elem = document.getElementById(elementId);
            // We use a custom type check here, because node-canvas mimics canvas,
            // but is not an instance of window.HTMLCanvasElement.
            // In fact, `window` might be undefined here.
            // See: https://www.npmjs.com/package/canvas
            if ((0,_web__WEBPACK_IMPORTED_MODULE_41__.isHTMLCanvas)(elem)) {
                backend = _renderer__WEBPACK_IMPORTED_MODULE_21__.Renderer.Backends.CANVAS;
            }
            else {
                backend = _renderer__WEBPACK_IMPORTED_MODULE_21__.Renderer.Backends.SVG;
            }
        }
        this.context = _renderer__WEBPACK_IMPORTED_MODULE_21__.Renderer.buildContext(elementId, backend, width, height, background);
    }
    getContext() {
        return this.context;
    }
    setContext(context) {
        this.context = context;
        return this;
    }
    getStave() {
        return this.stave;
    }
    getVoices() {
        return this.voices;
    }
    /** Return pixels from current stave spacing. */
    Stave(params) {
        const staveSpace = this.options.stave.space;
        const p = Object.assign({ x: 0, y: 0, width: this.options.renderer.width - staveSpace * 1.0, options: { spacingBetweenLinesPx: staveSpace * 1.0 } }, params);
        const stave = new _stave__WEBPACK_IMPORTED_MODULE_23__.Stave(p.x, p.y, p.width, p.options);
        this.staves.push(stave);
        stave.setContext(this.context);
        this.stave = stave;
        return stave;
    }
    TabStave(params) {
        const staveSpace = this.options.stave.space;
        const p = Object.assign({ x: 0, y: 0, width: this.options.renderer.width - staveSpace * 1.0, options: { spacingBetweenLinesPx: staveSpace * 1.3 } }, params);
        const stave = new _tabstave__WEBPACK_IMPORTED_MODULE_31__.TabStave(p.x, p.y, p.width, p.options);
        this.staves.push(stave);
        stave.setContext(this.context);
        this.stave = stave;
        return stave;
    }
    StaveNote(noteStruct) {
        const note = new _stavenote__WEBPACK_IMPORTED_MODULE_26__.StaveNote(noteStruct);
        if (this.stave)
            note.setStave(this.stave);
        note.setContext(this.context);
        this.renderQ.push(note);
        return note;
    }
    GlyphNote(glyph, noteStruct, options) {
        const note = new _glyphnote__WEBPACK_IMPORTED_MODULE_12__.GlyphNote(glyph, noteStruct, options);
        if (this.stave)
            note.setStave(this.stave);
        note.setContext(this.context);
        this.renderQ.push(note);
        return note;
    }
    RepeatNote(type, noteStruct, options) {
        const note = new _repeatnote__WEBPACK_IMPORTED_MODULE_22__.RepeatNote(type, noteStruct, options);
        if (this.stave)
            note.setStave(this.stave);
        note.setContext(this.context);
        this.renderQ.push(note);
        return note;
    }
    GhostNote(noteStruct) {
        const ghostNote = new _ghostnote__WEBPACK_IMPORTED_MODULE_11__.GhostNote(noteStruct);
        if (this.stave)
            ghostNote.setStave(this.stave);
        ghostNote.setContext(this.context);
        this.renderQ.push(ghostNote);
        return ghostNote;
    }
    TextNote(noteStruct) {
        const textNote = new _textnote__WEBPACK_IMPORTED_MODULE_34__.TextNote(noteStruct);
        if (this.stave)
            textNote.setStave(this.stave);
        textNote.setContext(this.context);
        this.renderQ.push(textNote);
        return textNote;
    }
    BarNote(params = {}) {
        const barNote = new _barnote__WEBPACK_IMPORTED_MODULE_3__.BarNote(params.type);
        if (this.stave)
            barNote.setStave(this.stave);
        barNote.setContext(this.context);
        this.renderQ.push(barNote);
        return barNote;
    }
    ClefNote(params) {
        const p = Object.assign({ type: 'treble', options: {
                size: 'default',
                annotation: undefined,
            } }, params);
        const clefNote = new _clefnote__WEBPACK_IMPORTED_MODULE_6__.ClefNote(p.type, p.options.size, p.options.annotation);
        if (this.stave)
            clefNote.setStave(this.stave);
        clefNote.setContext(this.context);
        this.renderQ.push(clefNote);
        return clefNote;
    }
    TimeSigNote(params) {
        const p = Object.assign({ time: '4/4' }, params);
        const timeSigNote = new _timesignote__WEBPACK_IMPORTED_MODULE_36__.TimeSigNote(p.time);
        if (this.stave)
            timeSigNote.setStave(this.stave);
        timeSigNote.setContext(this.context);
        this.renderQ.push(timeSigNote);
        return timeSigNote;
    }
    KeySigNote(params) {
        const keySigNote = new _keysignote__WEBPACK_IMPORTED_MODULE_15__.KeySigNote(params.key, params.cancelKey, params.alterKey);
        if (this.stave)
            keySigNote.setStave(this.stave);
        keySigNote.setContext(this.context);
        this.renderQ.push(keySigNote);
        return keySigNote;
    }
    TabNote(noteStruct) {
        const note = new _tabnote__WEBPACK_IMPORTED_MODULE_30__.TabNote(noteStruct);
        if (this.stave)
            note.setStave(this.stave);
        note.setContext(this.context);
        this.renderQ.push(note);
        return note;
    }
    GraceNote(noteStruct) {
        const note = new _gracenote__WEBPACK_IMPORTED_MODULE_13__.GraceNote(noteStruct);
        if (this.stave)
            note.setStave(this.stave);
        note.setContext(this.context);
        return note;
    }
    GraceNoteGroup(params) {
        const group = new _gracenotegroup__WEBPACK_IMPORTED_MODULE_14__.GraceNoteGroup(params.notes, params.slur);
        group.setContext(this.context);
        return group;
    }
    Accidental(params) {
        const accid = new _accidental__WEBPACK_IMPORTED_MODULE_0__.Accidental(params.type);
        accid.setContext(this.context);
        return accid;
    }
    Annotation(params) {
        const p = Object.assign({ text: 'p', hJustify: _annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationHorizontalJustify.CENTER, vJustify: _annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.BOTTOM }, params);
        const annotation = new _annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation(p.text);
        annotation.setJustification(p.hJustify);
        annotation.setVerticalJustification(p.vJustify);
        annotation.setFont(p.font);
        annotation.setContext(this.context);
        return annotation;
    }
    ChordSymbol(params) {
        const p = Object.assign({ vJustify: 'top', hJustify: 'center' }, params);
        const chordSymbol = new _chordsymbol__WEBPACK_IMPORTED_MODULE_5__.ChordSymbol();
        chordSymbol.setHorizontal(p.hJustify);
        chordSymbol.setVertical(p.vJustify);
        // There is a default font based on the engraving font.  Only set then
        // font if it is specific, else use the default
        if (typeof p.fontFamily === 'string' && typeof p.fontSize === 'number') {
            if (typeof p.fontWeight === 'string')
                chordSymbol.setFont(p.fontFamily, p.fontSize, p.fontWeight);
            else
                chordSymbol.setFont(p.fontFamily, p.fontSize, '');
        }
        else if (typeof p.fontSize === 'number') {
            chordSymbol.setFontSize(p.fontSize);
        }
        chordSymbol.setContext(this.context);
        return chordSymbol;
    }
    Articulation(params) {
        var _a;
        const articulation = new _articulation__WEBPACK_IMPORTED_MODULE_2__.Articulation((_a = params === null || params === void 0 ? void 0 : params.type) !== null && _a !== void 0 ? _a : 'a.');
        if ((params === null || params === void 0 ? void 0 : params.position) !== undefined)
            articulation.setPosition(params.position);
        if ((params === null || params === void 0 ? void 0 : params.betweenLines) !== undefined)
            articulation.setBetweenLines(params.betweenLines);
        articulation.setContext(this.context);
        return articulation;
    }
    Ornament(type, params) {
        const options = Object.assign({ type, accidental: '' }, params);
        const ornament = new _ornament__WEBPACK_IMPORTED_MODULE_19__.Ornament(type);
        if ((params === null || params === void 0 ? void 0 : params.position) !== undefined) {
            ornament.setPosition(params.position);
        }
        if (options.upperAccidental) {
            ornament.setUpperAccidental(options.upperAccidental);
        }
        if (options.lowerAccidental) {
            ornament.setLowerAccidental(options.lowerAccidental);
        }
        if (typeof options.delayed !== 'undefined') {
            ornament.setDelayed(options.delayed);
        }
        ornament.setContext(this.context);
        return ornament;
    }
    TextDynamics(params) {
        const p = Object.assign({ text: 'p', duration: 'q', dots: 0, line: 0 }, params);
        const text = new _textdynamics__WEBPACK_IMPORTED_MODULE_33__.TextDynamics({
            text: p.text,
            line: p.line,
            duration: p.duration,
            dots: p.dots,
        });
        if (this.stave)
            text.setStave(this.stave);
        text.setContext(this.context);
        this.renderQ.push(text);
        return text;
    }
    Fingering(params) {
        const p = Object.assign({ number: '0', position: 'left' }, params);
        const fingering = new _frethandfinger__WEBPACK_IMPORTED_MODULE_10__.FretHandFinger(p.number);
        fingering.setPosition(p.position);
        fingering.setContext(this.context);
        return fingering;
    }
    StringNumber(params, drawCircle = true) {
        const stringNumber = new _stringnumber__WEBPACK_IMPORTED_MODULE_28__.StringNumber(params.number);
        stringNumber.setPosition(params.position);
        stringNumber.setContext(this.context);
        stringNumber.setDrawCircle(drawCircle);
        return stringNumber;
    }
    TickContext() {
        return new _tickcontext__WEBPACK_IMPORTED_MODULE_35__.TickContext();
    }
    ModifierContext() {
        return new _modifiercontext__WEBPACK_IMPORTED_MODULE_16__.ModifierContext();
    }
    MultiMeasureRest(params) {
        const numMeasures = (0,_util__WEBPACK_IMPORTED_MODULE_38__.defined)(params.numberOfMeasures, 'NoNumberOfMeasures');
        const multiMeasureRest = new _multimeasurerest__WEBPACK_IMPORTED_MODULE_17__.MultiMeasureRest(numMeasures, params);
        multiMeasureRest.setContext(this.context);
        this.renderQ.push(multiMeasureRest);
        return multiMeasureRest;
    }
    Voice(params) {
        const p = Object.assign({ time: '4/4' }, params);
        const voice = new _voice__WEBPACK_IMPORTED_MODULE_40__.Voice(p.time);
        this.voices.push(voice);
        return voice;
    }
    StaveConnector(params) {
        const connector = new _staveconnector__WEBPACK_IMPORTED_MODULE_24__.StaveConnector(params.topStave, params.bottomStave);
        connector.setType(params.type).setContext(this.context);
        this.renderQ.push(connector);
        return connector;
    }
    Formatter(options) {
        return new _formatter__WEBPACK_IMPORTED_MODULE_9__.Formatter(options);
    }
    Tuplet(params) {
        const p = Object.assign({ notes: [], options: {} }, params);
        const tuplet = new _tuplet__WEBPACK_IMPORTED_MODULE_37__.Tuplet(p.notes, p.options).setContext(this.context);
        this.renderQ.push(tuplet);
        return tuplet;
    }
    Beam(params) {
        var _a, _b, _c, _d, _e;
        const beam = new _beam__WEBPACK_IMPORTED_MODULE_4__.Beam(params.notes, (_a = params.options) === null || _a === void 0 ? void 0 : _a.autoStem).setContext(this.context);
        beam.breakSecondaryAt((_c = (_b = params.options) === null || _b === void 0 ? void 0 : _b.secondaryBeamBreaks) !== null && _c !== void 0 ? _c : []);
        if ((_d = params.options) === null || _d === void 0 ? void 0 : _d.partialBeamDirections) {
            Object.entries((_e = params.options) === null || _e === void 0 ? void 0 : _e.partialBeamDirections).forEach(([noteIndex, direction]) => {
                beam.setPartialBeamSideAt(Number(noteIndex), direction);
            });
        }
        this.renderQ.push(beam);
        return beam;
    }
    Curve(params) {
        const curve = new _curve__WEBPACK_IMPORTED_MODULE_7__.Curve(params.from, params.to, params.options).setContext(this.context);
        this.renderQ.push(curve);
        return curve;
    }
    StaveTie(params) {
        var _a;
        const tie = new _stavetie__WEBPACK_IMPORTED_MODULE_27__.StaveTie({
            firstNote: params.from,
            lastNote: params.to,
            firstIndexes: params.firstIndexes,
            lastIndexes: params.lastIndexes,
        }, params.text);
        if ((_a = params.options) === null || _a === void 0 ? void 0 : _a.direction)
            tie.setDirection(params.options.direction);
        tie.setContext(this.context);
        this.renderQ.push(tie);
        return tie;
    }
    StaveLine(params) {
        var _a, _b;
        const line = new _staveline__WEBPACK_IMPORTED_MODULE_25__.StaveLine({
            firstNote: params.from,
            lastNote: params.to,
            firstIndexes: params.firstIndexes,
            lastIndexes: params.lastIndexes,
        });
        if ((_a = params.options) === null || _a === void 0 ? void 0 : _a.text)
            line.setText(params.options.text);
        if ((_b = params.options) === null || _b === void 0 ? void 0 : _b.font)
            line.setFont(params.options.font);
        line.setContext(this.context);
        this.renderQ.push(line);
        return line;
    }
    VibratoBracket(params) {
        const vibratoBracket = new _vibratobracket__WEBPACK_IMPORTED_MODULE_39__.VibratoBracket({
            start: params.from,
            stop: params.to,
        });
        if (params.options.line)
            vibratoBracket.setLine(params.options.line);
        if (params.options.code)
            vibratoBracket.setVibratoCode(params.options.code);
        vibratoBracket.setContext(this.context);
        this.renderQ.push(vibratoBracket);
        return vibratoBracket;
    }
    TextBracket(params) {
        const textBracket = new _textbracket__WEBPACK_IMPORTED_MODULE_32__.TextBracket({
            start: params.from,
            stop: params.to,
            text: params.text,
            superscript: params.options.superscript,
            position: params.options.position,
        });
        if (params.options.line)
            textBracket.setLine(params.options.line);
        if (params.options.font)
            textBracket.setFont(params.options.font);
        textBracket.setContext(this.context);
        this.renderQ.push(textBracket);
        return textBracket;
    }
    System(params = {}) {
        params.factory = this;
        const system = new _system__WEBPACK_IMPORTED_MODULE_29__.System(params).setContext(this.context);
        this.systems.push(system);
        return system;
    }
    /**
     * Creates EasyScore. Normally the first step after constructing a Factory. For example:
     * ```
     * const vf: Factory = new Vex.Flow.Factory({renderer: { elementId: 'boo', width: 1200, height: 600 }});
     * const score: EasyScore = vf.EasyScore();
     * ```
     * @param options.factory optional instance of Factory
     * @param options.builder instance of Builder
     * @param options.commitHooks function to call after a note element is created
     * @param options.throwOnError throw error in case of parsing error
     */
    EasyScore(options = {}) {
        options.factory = this;
        return new _easyscore__WEBPACK_IMPORTED_MODULE_8__.EasyScore(options);
    }
    PedalMarking(params) {
        const p = Object.assign({ notes: [], options: {
                style: 'mixed',
            } }, params);
        const pedal = new _pedalmarking__WEBPACK_IMPORTED_MODULE_20__.PedalMarking(p.notes);
        pedal.setType(_pedalmarking__WEBPACK_IMPORTED_MODULE_20__.PedalMarking.typeString[p.options.style]);
        pedal.setContext(this.context);
        this.renderQ.push(pedal);
        return pedal;
    }
    NoteSubGroup(params) {
        const p = Object.assign({ notes: [] }, params);
        const group = new _notesubgroup__WEBPACK_IMPORTED_MODULE_18__.NoteSubGroup(p.notes);
        group.setContext(this.context);
        return group;
    }
    /** Render the score. */
    draw() {
        const ctx = this.context;
        this.systems.forEach((s) => s.setContext(ctx).format());
        this.staves.forEach((s) => s.setContext(ctx).draw());
        this.voices.forEach((v) => v.setContext(ctx).draw());
        this.renderQ.forEach((e) => {
            if (!e.isRendered())
                e.setContext(ctx).draw();
        });
        this.systems.forEach((s) => s.setContext(ctx).draw());
        this.reset();
    }
}
/** To enable logging for this class. Set `Vex.Flow.Factory.DEBUG` to `true`. */
Factory.DEBUG = false;


/***/ }),

/***/ "./src/flow.ts":
/*!*********************!*\
  !*** ./src/flow.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Flow: () => (/* binding */ Flow)
/* harmony export */ });
/* harmony import */ var _accidental__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./accidental */ "./src/accidental.ts");
/* harmony import */ var _annotation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./annotation */ "./src/annotation.ts");
/* harmony import */ var _articulation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./articulation */ "./src/articulation.ts");
/* harmony import */ var _barnote__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./barnote */ "./src/barnote.ts");
/* harmony import */ var _beam__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./beam */ "./src/beam.ts");
/* harmony import */ var _bend__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./bend */ "./src/bend.ts");
/* harmony import */ var _boundingbox__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./boundingbox */ "./src/boundingbox.ts");
/* harmony import */ var _canvascontext__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./canvascontext */ "./src/canvascontext.ts");
/* harmony import */ var _chordsymbol__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./chordsymbol */ "./src/chordsymbol.ts");
/* harmony import */ var _clef__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./clef */ "./src/clef.ts");
/* harmony import */ var _clefnote__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./clefnote */ "./src/clefnote.ts");
/* harmony import */ var _crescendo__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./crescendo */ "./src/crescendo.ts");
/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./curve */ "./src/curve.ts");
/* harmony import */ var _dot__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./dot */ "./src/dot.ts");
/* harmony import */ var _easyscore__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./easyscore */ "./src/easyscore.ts");
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _factory__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./factory */ "./src/factory.ts");
/* harmony import */ var _font__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./font */ "./src/font.ts");
/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./formatter */ "./src/formatter.ts");
/* harmony import */ var _fraction__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./fraction */ "./src/fraction.ts");
/* harmony import */ var _frethandfinger__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./frethandfinger */ "./src/frethandfinger.ts");
/* harmony import */ var _ghostnote__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./ghostnote */ "./src/ghostnote.ts");
/* harmony import */ var _glyphnote__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./glyphnote */ "./src/glyphnote.ts");
/* harmony import */ var _glyphs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./glyphs */ "./src/glyphs.ts");
/* harmony import */ var _gracenote__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./gracenote */ "./src/gracenote.ts");
/* harmony import */ var _gracenotegroup__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./gracenotegroup */ "./src/gracenotegroup.ts");
/* harmony import */ var _gracetabnote__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./gracetabnote */ "./src/gracetabnote.ts");
/* harmony import */ var _keymanager__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./keymanager */ "./src/keymanager.ts");
/* harmony import */ var _keysignature__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./keysignature */ "./src/keysignature.ts");
/* harmony import */ var _keysignote__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./keysignote */ "./src/keysignote.ts");
/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./metrics */ "./src/metrics.ts");
/* harmony import */ var _modifier__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./modifier */ "./src/modifier.ts");
/* harmony import */ var _modifiercontext__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./modifiercontext */ "./src/modifiercontext.ts");
/* harmony import */ var _multimeasurerest__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./multimeasurerest */ "./src/multimeasurerest.ts");
/* harmony import */ var _music__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./music */ "./src/music.ts");
/* harmony import */ var _note__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./note */ "./src/note.ts");
/* harmony import */ var _notehead__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./notehead */ "./src/notehead.ts");
/* harmony import */ var _notesubgroup__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./notesubgroup */ "./src/notesubgroup.ts");
/* harmony import */ var _ornament__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./ornament */ "./src/ornament.ts");
/* harmony import */ var _parenthesis__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./parenthesis */ "./src/parenthesis.ts");
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./parser */ "./src/parser.ts");
/* harmony import */ var _pedalmarking__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./pedalmarking */ "./src/pedalmarking.ts");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./registry */ "./src/registry.ts");
/* harmony import */ var _rendercontext__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./rendercontext */ "./src/rendercontext.ts");
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./renderer */ "./src/renderer.ts");
/* harmony import */ var _repeatnote__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./repeatnote */ "./src/repeatnote.ts");
/* harmony import */ var _stave__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./stave */ "./src/stave.ts");
/* harmony import */ var _stavebarline__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./stavebarline */ "./src/stavebarline.ts");
/* harmony import */ var _staveconnector__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./staveconnector */ "./src/staveconnector.ts");
/* harmony import */ var _stavehairpin__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./stavehairpin */ "./src/stavehairpin.ts");
/* harmony import */ var _staveline__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./staveline */ "./src/staveline.ts");
/* harmony import */ var _stavemodifier__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./stavemodifier */ "./src/stavemodifier.ts");
/* harmony import */ var _stavenote__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./stavenote */ "./src/stavenote.ts");
/* harmony import */ var _staverepetition__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./staverepetition */ "./src/staverepetition.ts");
/* harmony import */ var _stavetempo__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./stavetempo */ "./src/stavetempo.ts");
/* harmony import */ var _stavetext__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./stavetext */ "./src/stavetext.ts");
/* harmony import */ var _stavetie__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./stavetie */ "./src/stavetie.ts");
/* harmony import */ var _stavevolta__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./stavevolta */ "./src/stavevolta.ts");
/* harmony import */ var _stem__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./stem */ "./src/stem.ts");
/* harmony import */ var _stringnumber__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./stringnumber */ "./src/stringnumber.ts");
/* harmony import */ var _strokes__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./strokes */ "./src/strokes.ts");
/* harmony import */ var _svgcontext__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./svgcontext */ "./src/svgcontext.ts");
/* harmony import */ var _system__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./system */ "./src/system.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _tabnote__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./tabnote */ "./src/tabnote.ts");
/* harmony import */ var _tabslide__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./tabslide */ "./src/tabslide.ts");
/* harmony import */ var _tabstave__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./tabstave */ "./src/tabstave.ts");
/* harmony import */ var _tabtie__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./tabtie */ "./src/tabtie.ts");
/* harmony import */ var _textbracket__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./textbracket */ "./src/textbracket.ts");
/* harmony import */ var _textdynamics__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./textdynamics */ "./src/textdynamics.ts");
/* harmony import */ var _textnote__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./textnote */ "./src/textnote.ts");
/* harmony import */ var _tickcontext__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./tickcontext */ "./src/tickcontext.ts");
/* harmony import */ var _timesignature__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./timesignature */ "./src/timesignature.ts");
/* harmony import */ var _timesignote__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./timesignote */ "./src/timesignote.ts");
/* harmony import */ var _tremolo__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./tremolo */ "./src/tremolo.ts");
/* harmony import */ var _tuning__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./tuning */ "./src/tuning.ts");
/* harmony import */ var _tuplet__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./tuplet */ "./src/tuplet.ts");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./version */ "./src/version.ts");
/* harmony import */ var _vibrato__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./vibrato */ "./src/vibrato.ts");
/* harmony import */ var _vibratobracket__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./vibratobracket */ "./src/vibratobracket.ts");
/* harmony import */ var _voice__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./voice */ "./src/voice.ts");

















































































class Flow {
    static get BUILD() {
        return {
            /** version number. */
            VERSION: _version__WEBPACK_IMPORTED_MODULE_77__.VERSION,
            /** git commit ID that this library was built from. */
            ID: _version__WEBPACK_IMPORTED_MODULE_77__.ID,
            /** The date when this library was compiled. */
            DATE: _version__WEBPACK_IMPORTED_MODULE_77__.DATE,
        };
    }
    /**
     * Examples:
     * ```
     * Vex.Flow.setMusicFont('Petaluma');
     * Vex.Flow.setMusicFont('Bravura', 'Gonville');
     * ```
     *
     * **CASE 1**: You are using `vexflow.js`, which includes all music fonts (Bravura, Gonville, Petaluma, Custom).
     * In this case, calling this method is optional, since VexFlow already defaults to a music font stack of:
     * 'Bravura', 'Gonville', 'Custom'.
     *
     * **CASE 2**: You are using `vexflow-bravura.js` or `vexflow-petaluma.js` or `vexflow-gonville.js`,
     * which includes a single music font. Calling this method is unnecessary.
     *
     * **CASE 3**: You are using the light weight `vexflow-core.js` to take advantage of lazy loading for fonts.
     * In this case, the default music font stack is empty.
     * Example:
     * ```
     * await Vex.Flow.fetchMusicFont('Petaluma');
     * Vex.Flow.setMusicFont('Petaluma');
     * ... (do VexFlow stuff) ...
     * ```
     * See `demos/fonts/` for more examples.
     *
     * @returns an array of Font objects corresponding to the provided `fontNames`.
     */
    static setMusicFont(...fontNames) {
        // Convert the array of font names into an array of Font objects.
        _metrics__WEBPACK_IMPORTED_MODULE_30__.MetricsDefaults.fontFamily = fontNames.join(',');
    }
    static getMusicFont() {
        return _metrics__WEBPACK_IMPORTED_MODULE_30__.Metrics.get('fontFamily').split(',');
    }
    static get RENDER_PRECISION_PLACES() {
        return _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.RENDER_PRECISION_PLACES;
    }
    static set RENDER_PRECISION_PLACES(precision) {
        _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.RENDER_PRECISION_PLACES = precision;
    }
    static get SOFTMAX_FACTOR() {
        return _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.SOFTMAX_FACTOR;
    }
    static set SOFTMAX_FACTOR(factor) {
        _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.SOFTMAX_FACTOR = factor;
    }
    static get UNISON() {
        return _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.UNISON;
    }
    static set UNISON(unison) {
        _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.UNISON = unison;
    }
    static get NOTATION_FONT_SCALE() {
        return _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.NOTATION_FONT_SCALE;
    }
    static set NOTATION_FONT_SCALE(value) {
        _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.NOTATION_FONT_SCALE = value;
    }
    static get TABLATURE_FONT_SCALE() {
        return _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.TABLATURE_FONT_SCALE;
    }
    static set TABLATURE_FONT_SCALE(value) {
        _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.TABLATURE_FONT_SCALE = value;
    }
    static get RESOLUTION() {
        return _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.RESOLUTION;
    }
    static set RESOLUTION(value) {
        _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.RESOLUTION = value;
    }
    static get SLASH_NOTEHEAD_WIDTH() {
        return _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.SLASH_NOTEHEAD_WIDTH;
    }
    static set SLASH_NOTEHEAD_WIDTH(value) {
        _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.SLASH_NOTEHEAD_WIDTH = value;
    }
    static get STAVE_LINE_DISTANCE() {
        return _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.STAVE_LINE_DISTANCE;
    }
    static set STAVE_LINE_DISTANCE(value) {
        _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.STAVE_LINE_DISTANCE = value;
    }
    static get STAVE_LINE_THICKNESS() {
        return _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.STAVE_LINE_THICKNESS;
    }
    static set STAVE_LINE_THICKNESS(value) {
        _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.STAVE_LINE_THICKNESS = value;
    }
    static get STEM_HEIGHT() {
        return _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.STEM_HEIGHT;
    }
    static set STEM_HEIGHT(value) {
        _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.STEM_HEIGHT = value;
    }
    static get STEM_WIDTH() {
        return _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.STEM_WIDTH;
    }
    static set STEM_WIDTH(value) {
        _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.STEM_WIDTH = value;
    }
    static get TIME4_4() {
        return _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.TIME4_4;
    }
    static get unicode() {
        return _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.unicode;
    }
    static keySignature(spec) {
        return _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.keySignature(spec);
    }
    static hasKeySignature(spec) {
        return _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.hasKeySignature(spec);
    }
    static getKeySignatures() {
        return _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.getKeySignatures();
    }
    static clefProperties(clef) {
        return _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.clefProperties(clef);
    }
    // eslint-disable-next-line
    static keyProperties(key, clef, params) {
        return _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.keyProperties(key, clef, params);
    }
    static durationToTicks(duration) {
        return _tables__WEBPACK_IMPORTED_MODULE_63__.Tables.durationToTicks(duration);
    }
}
Flow.Accidental = _accidental__WEBPACK_IMPORTED_MODULE_0__.Accidental;
Flow.Annotation = _annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation;
Flow.Articulation = _articulation__WEBPACK_IMPORTED_MODULE_2__.Articulation;
Flow.Barline = _stavebarline__WEBPACK_IMPORTED_MODULE_47__.Barline;
Flow.BarNote = _barnote__WEBPACK_IMPORTED_MODULE_3__.BarNote;
Flow.Beam = _beam__WEBPACK_IMPORTED_MODULE_4__.Beam;
Flow.Bend = _bend__WEBPACK_IMPORTED_MODULE_5__.Bend;
Flow.BoundingBox = _boundingbox__WEBPACK_IMPORTED_MODULE_6__.BoundingBox;
Flow.CanvasContext = _canvascontext__WEBPACK_IMPORTED_MODULE_7__.CanvasContext;
Flow.ChordSymbol = _chordsymbol__WEBPACK_IMPORTED_MODULE_8__.ChordSymbol;
Flow.Clef = _clef__WEBPACK_IMPORTED_MODULE_9__.Clef;
Flow.ClefNote = _clefnote__WEBPACK_IMPORTED_MODULE_10__.ClefNote;
Flow.Crescendo = _crescendo__WEBPACK_IMPORTED_MODULE_11__.Crescendo;
Flow.Curve = _curve__WEBPACK_IMPORTED_MODULE_12__.Curve;
Flow.Dot = _dot__WEBPACK_IMPORTED_MODULE_13__.Dot;
Flow.EasyScore = _easyscore__WEBPACK_IMPORTED_MODULE_14__.EasyScore;
Flow.Element = _element__WEBPACK_IMPORTED_MODULE_15__.Element;
Flow.Factory = _factory__WEBPACK_IMPORTED_MODULE_16__.Factory;
Flow.Font = _font__WEBPACK_IMPORTED_MODULE_17__.Font;
Flow.Formatter = _formatter__WEBPACK_IMPORTED_MODULE_18__.Formatter;
Flow.Fraction = _fraction__WEBPACK_IMPORTED_MODULE_19__.Fraction;
Flow.FretHandFinger = _frethandfinger__WEBPACK_IMPORTED_MODULE_20__.FretHandFinger;
Flow.GhostNote = _ghostnote__WEBPACK_IMPORTED_MODULE_21__.GhostNote;
Flow.GlyphNote = _glyphnote__WEBPACK_IMPORTED_MODULE_22__.GlyphNote;
Flow.Glyphs = _glyphs__WEBPACK_IMPORTED_MODULE_23__.Glyphs;
Flow.GraceNote = _gracenote__WEBPACK_IMPORTED_MODULE_24__.GraceNote;
Flow.GraceNoteGroup = _gracenotegroup__WEBPACK_IMPORTED_MODULE_25__.GraceNoteGroup;
Flow.GraceTabNote = _gracetabnote__WEBPACK_IMPORTED_MODULE_26__.GraceTabNote;
Flow.KeyManager = _keymanager__WEBPACK_IMPORTED_MODULE_27__.KeyManager;
Flow.KeySignature = _keysignature__WEBPACK_IMPORTED_MODULE_28__.KeySignature;
Flow.KeySigNote = _keysignote__WEBPACK_IMPORTED_MODULE_29__.KeySigNote;
Flow.Modifier = _modifier__WEBPACK_IMPORTED_MODULE_31__.Modifier;
Flow.ModifierContext = _modifiercontext__WEBPACK_IMPORTED_MODULE_32__.ModifierContext;
Flow.MultiMeasureRest = _multimeasurerest__WEBPACK_IMPORTED_MODULE_33__.MultiMeasureRest;
Flow.Music = _music__WEBPACK_IMPORTED_MODULE_34__.Music;
Flow.Note = _note__WEBPACK_IMPORTED_MODULE_35__.Note;
Flow.NoteHead = _notehead__WEBPACK_IMPORTED_MODULE_36__.NoteHead;
Flow.NoteSubGroup = _notesubgroup__WEBPACK_IMPORTED_MODULE_37__.NoteSubGroup;
Flow.Ornament = _ornament__WEBPACK_IMPORTED_MODULE_38__.Ornament;
Flow.Parenthesis = _parenthesis__WEBPACK_IMPORTED_MODULE_39__.Parenthesis;
Flow.Parser = _parser__WEBPACK_IMPORTED_MODULE_40__.Parser;
Flow.PedalMarking = _pedalmarking__WEBPACK_IMPORTED_MODULE_41__.PedalMarking;
Flow.Registry = _registry__WEBPACK_IMPORTED_MODULE_42__.Registry;
Flow.RenderContext = _rendercontext__WEBPACK_IMPORTED_MODULE_43__.RenderContext;
Flow.Renderer = _renderer__WEBPACK_IMPORTED_MODULE_44__.Renderer;
Flow.RepeatNote = _repeatnote__WEBPACK_IMPORTED_MODULE_45__.RepeatNote;
Flow.Repetition = _staverepetition__WEBPACK_IMPORTED_MODULE_53__.Repetition;
Flow.Stave = _stave__WEBPACK_IMPORTED_MODULE_46__.Stave;
Flow.StaveConnector = _staveconnector__WEBPACK_IMPORTED_MODULE_48__.StaveConnector;
Flow.StaveHairpin = _stavehairpin__WEBPACK_IMPORTED_MODULE_49__.StaveHairpin;
Flow.StaveLine = _staveline__WEBPACK_IMPORTED_MODULE_50__.StaveLine;
Flow.StaveModifier = _stavemodifier__WEBPACK_IMPORTED_MODULE_51__.StaveModifier;
Flow.StaveNote = _stavenote__WEBPACK_IMPORTED_MODULE_52__.StaveNote;
Flow.StaveTempo = _stavetempo__WEBPACK_IMPORTED_MODULE_54__.StaveTempo;
Flow.StaveText = _stavetext__WEBPACK_IMPORTED_MODULE_55__.StaveText;
Flow.StaveTie = _stavetie__WEBPACK_IMPORTED_MODULE_56__.StaveTie;
Flow.Stem = _stem__WEBPACK_IMPORTED_MODULE_58__.Stem;
Flow.StringNumber = _stringnumber__WEBPACK_IMPORTED_MODULE_59__.StringNumber;
Flow.Stroke = _strokes__WEBPACK_IMPORTED_MODULE_60__.Stroke;
Flow.SVGContext = _svgcontext__WEBPACK_IMPORTED_MODULE_61__.SVGContext;
Flow.System = _system__WEBPACK_IMPORTED_MODULE_62__.System;
Flow.TabNote = _tabnote__WEBPACK_IMPORTED_MODULE_64__.TabNote;
Flow.TabSlide = _tabslide__WEBPACK_IMPORTED_MODULE_65__.TabSlide;
Flow.TabStave = _tabstave__WEBPACK_IMPORTED_MODULE_66__.TabStave;
Flow.TabTie = _tabtie__WEBPACK_IMPORTED_MODULE_67__.TabTie;
Flow.TextBracket = _textbracket__WEBPACK_IMPORTED_MODULE_68__.TextBracket;
Flow.TextDynamics = _textdynamics__WEBPACK_IMPORTED_MODULE_69__.TextDynamics;
Flow.TextNote = _textnote__WEBPACK_IMPORTED_MODULE_70__.TextNote;
Flow.TickContext = _tickcontext__WEBPACK_IMPORTED_MODULE_71__.TickContext;
Flow.TimeSignature = _timesignature__WEBPACK_IMPORTED_MODULE_72__.TimeSignature;
Flow.TimeSigNote = _timesignote__WEBPACK_IMPORTED_MODULE_73__.TimeSigNote;
Flow.Tremolo = _tremolo__WEBPACK_IMPORTED_MODULE_74__.Tremolo;
Flow.Tuning = _tuning__WEBPACK_IMPORTED_MODULE_75__.Tuning;
Flow.Tuplet = _tuplet__WEBPACK_IMPORTED_MODULE_76__.Tuplet;
Flow.Vibrato = _vibrato__WEBPACK_IMPORTED_MODULE_78__.Vibrato;
Flow.VibratoBracket = _vibratobracket__WEBPACK_IMPORTED_MODULE_79__.VibratoBracket;
Flow.Voice = _voice__WEBPACK_IMPORTED_MODULE_80__.Voice;
Flow.Volta = _stavevolta__WEBPACK_IMPORTED_MODULE_57__.Volta;
// Exported Enums.
// Sorted by the module / file they are exported from.
Flow.AnnotationHorizontalJustify = _annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationHorizontalJustify;
Flow.AnnotationVerticalJustify = _annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify;
Flow.ChordSymbolHorizontalJustify = _chordsymbol__WEBPACK_IMPORTED_MODULE_8__.ChordSymbolHorizontalJustify;
Flow.ChordSymbolVerticalJustify = _chordsymbol__WEBPACK_IMPORTED_MODULE_8__.ChordSymbolVerticalJustify;
Flow.SymbolModifiers = _chordsymbol__WEBPACK_IMPORTED_MODULE_8__.SymbolModifiers;
Flow.CurvePosition = _curve__WEBPACK_IMPORTED_MODULE_12__.CurvePosition;
Flow.FontWeight = _font__WEBPACK_IMPORTED_MODULE_17__.FontWeight;
Flow.FontStyle = _font__WEBPACK_IMPORTED_MODULE_17__.FontStyle;
Flow.ModifierPosition = _modifier__WEBPACK_IMPORTED_MODULE_31__.ModifierPosition;
Flow.RendererBackends = _renderer__WEBPACK_IMPORTED_MODULE_44__.RendererBackends;
Flow.RendererLineEndType = _renderer__WEBPACK_IMPORTED_MODULE_44__.RendererLineEndType;
Flow.BarlineType = _stavebarline__WEBPACK_IMPORTED_MODULE_47__.BarlineType;
Flow.StaveModifierPosition = _stavemodifier__WEBPACK_IMPORTED_MODULE_51__.StaveModifierPosition;
Flow.VoltaType = _stavevolta__WEBPACK_IMPORTED_MODULE_57__.VoltaType;
Flow.TextBracketPosition = _textbracket__WEBPACK_IMPORTED_MODULE_68__.TextBracketPosition;
Flow.TextJustification = _textnote__WEBPACK_IMPORTED_MODULE_70__.TextJustification;
Flow.VoiceMode = _voice__WEBPACK_IMPORTED_MODULE_80__.VoiceMode;


/***/ }),

/***/ "./src/font.ts":
/*!*********************!*\
  !*** ./src/font.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Font: () => (/* binding */ Font),
/* harmony export */   FontStyle: () => (/* binding */ FontStyle),
/* harmony export */   FontWeight: () => (/* binding */ FontWeight)
/* harmony export */ });
/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./metrics */ "./src/metrics.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

var FontWeight;
(function (FontWeight) {
    FontWeight["NORMAL"] = "normal";
    FontWeight["BOLD"] = "bold";
})(FontWeight || (FontWeight = {}));
var FontStyle;
(function (FontStyle) {
    FontStyle["NORMAL"] = "normal";
    FontStyle["ITALIC"] = "italic";
})(FontStyle || (FontStyle = {}));
// Internal <span></span> element for parsing CSS font shorthand strings.
let fontParser;
class Font {
    /**
     * @param fontSize a font size to convert. Can be specified as a CSS length string (e.g., '16pt', '1em')
     * or as a number (the unit is assumed to be 'pt'). See `Font.scaleToPxFrom` for the supported
     * units (e.g., pt, em, %).
     * @returns the number of pixels that is equivalent to `fontSize`
     */
    static convertSizeToPixelValue(fontSize) {
        var _a;
        if (typeof fontSize === 'number') {
            // Assume the numeric fontSize is specified in pt.
            return fontSize * Font.scaleToPxFrom.pt;
        }
        else {
            const value = parseFloat(fontSize);
            if (isNaN(value)) {
                return 0;
            }
            const unit = fontSize.replace(/[\d.\s]/g, '').toLowerCase(); // Extract the unit by removing all numbers, dots, spaces.
            const conversionFactor = (_a = Font.scaleToPxFrom[unit]) !== null && _a !== void 0 ? _a : 1;
            return value * conversionFactor;
        }
    }
    /**
     * @param fontSize a font size to convert. Can be specified as a CSS length string (e.g., '16pt', '1em')
     * or as a number (the unit is assumed to be 'pt'). See `Font.scaleToPxFrom` for the supported
     * units (e.g., pt, em, %).
     * @returns the number of points that is equivalent to `fontSize`
     */
    static convertSizeToPointValue(fontSize) {
        var _a;
        if (typeof fontSize === 'number') {
            // Assume the numeric fontSize is specified in pt.
            return fontSize;
        }
        else {
            const value = parseFloat(fontSize);
            if (isNaN(value)) {
                return 0;
            }
            const unit = fontSize.replace(/[\d.\s]/g, '').toLowerCase(); // Extract the unit by removing all numbers, dots, spaces.
            const conversionFactor = ((_a = Font.scaleToPxFrom[unit]) !== null && _a !== void 0 ? _a : 1) / Font.scaleToPxFrom.pt;
            return value * conversionFactor;
        }
    }
    /**
     * @param f
     * @param size
     * @param weight
     * @param style
     * @returns the `size` field will include the units (e.g., '12pt', '16px').
     */
    static validate(f, size, weight, style) {
        // If f is a string but all other arguments are undefined, we assume that
        // f is CSS font shorthand (e.g., 'italic bold 10pt Arial').
        if (typeof f === 'string' && size === undefined && weight === undefined && style === undefined) {
            return Font.fromCSSString(f);
        }
        let family;
        if (typeof f === 'object') {
            // f is a FontInfo object, so we extract its fields.
            family = f.family;
            size = f.size;
            weight = f.weight;
            style = f.style;
        }
        else {
            // f is a string representing the font family name or undefined.
            family = f;
        }
        family = family !== null && family !== void 0 ? family : _metrics__WEBPACK_IMPORTED_MODULE_0__.Metrics.get('fontFamily');
        size = size !== null && size !== void 0 ? size : _metrics__WEBPACK_IMPORTED_MODULE_0__.Metrics.get('fontSize') + 'pt';
        weight = weight !== null && weight !== void 0 ? weight : FontWeight.NORMAL;
        style = style !== null && style !== void 0 ? style : FontStyle.NORMAL;
        if (weight === '') {
            weight = FontWeight.NORMAL;
        }
        if (style === '') {
            style = FontStyle.NORMAL;
        }
        // If size is a number, we assume the unit is `pt`.
        if (typeof size === 'number') {
            size = `${size}pt`;
        }
        // If weight is a number (e.g., 900), turn it into a string representation of that number.
        if (typeof weight === 'number') {
            weight = weight.toString();
        }
        // At this point, `family`, `size`, `weight`, and `style` are all strings.
        return { family, size, weight, style };
    }
    /**
     * @param cssFontShorthand a string formatted as CSS font shorthand (e.g., 'italic bold 15pt Arial').
     */
    static fromCSSString(cssFontShorthand) {
        // Let the browser parse this string for us.
        // First, create a span element.
        // Then, set its style.font and extract it back out.
        if (!fontParser) {
            fontParser = document.createElement('span');
        }
        fontParser.style.font = cssFontShorthand;
        const { fontFamily, fontSize, fontWeight, fontStyle } = fontParser.style;
        return { family: fontFamily, size: fontSize, weight: fontWeight, style: fontStyle };
    }
    /**
     * @returns a CSS font shorthand string of the form `italic bold 16pt Arial`.
     */
    static toCSSString(fontInfo) {
        var _a;
        if (!fontInfo) {
            return '';
        }
        let style;
        const st = fontInfo.style;
        if (st === FontStyle.NORMAL || st === '' || st === undefined) {
            style = ''; // no space! Omit the style section.
        }
        else {
            style = st.trim() + ' ';
        }
        let weight;
        const wt = fontInfo.weight;
        if (wt === FontWeight.NORMAL || wt === '' || wt === undefined) {
            weight = ''; // no space! Omit the weight section.
        }
        else if (typeof wt === 'number') {
            weight = wt + ' ';
        }
        else {
            weight = wt.trim() + ' ';
        }
        let size;
        const sz = fontInfo.size;
        if (sz === undefined) {
            size = _metrics__WEBPACK_IMPORTED_MODULE_0__.Metrics.get('fontSize') + 'pt';
        }
        else if (typeof sz === 'number') {
            size = sz + 'pt ';
        }
        else {
            // size is already a string.
            size = sz.trim() + ' ';
        }
        const family = (_a = fontInfo.family) !== null && _a !== void 0 ? _a : _metrics__WEBPACK_IMPORTED_MODULE_0__.Metrics.get('fontFamily');
        return `${style}${weight}${size}${family}`;
    }
    /**
     * @param fontSize a number representing a font size, or a string font size with units.
     * @param scaleFactor multiply the size by this factor.
     * @returns size * scaleFactor (e.g., 16pt * 3 = 48pt, 8px * 0.5 = 4px, 24 * 2 = 48).
     * If the fontSize argument was a number, the return value will be a number.
     * If the fontSize argument was a string, the return value will be a string.
     */
    static scaleSize(fontSize, scaleFactor) {
        if (typeof fontSize === 'number') {
            return (fontSize * scaleFactor);
        }
        else {
            const value = parseFloat(fontSize);
            const unit = fontSize.replace(/[\d.\s]/g, ''); // Remove all numbers, dots, spaces.
            return `${value * scaleFactor}${unit}`;
        }
    }
    /**
     * @param weight a string (e.g., 'bold') or a number (e.g., 600 / semi-bold in the OpenType spec).
     * @returns true if the font weight indicates bold.
     */
    static isBold(weight) {
        if (!weight) {
            return false;
        }
        else if (typeof weight === 'number') {
            return weight >= 600;
        }
        else {
            // a string can be 'bold' or '700'
            const parsedWeight = parseInt(weight, 10);
            if (isNaN(parsedWeight)) {
                return weight.toLowerCase() === 'bold';
            }
            else {
                return parsedWeight >= 600;
            }
        }
    }
    /**
     * @param style
     * @returns true if the font style indicates 'italic'.
     */
    static isItalic(style) {
        if (!style) {
            return false;
        }
        else {
            return style.toLowerCase() === FontStyle.ITALIC;
        }
    }
    /**
     * @param fontName
     * @param woffURL The absolute or relative URL to the woff file.
     * @param includeWoff2 If true, we assume that a woff2 file is in
     * the same folder as the woff file, and will append a `2` to the url.
     */
    // Support distributions of the typescript compiler that do not yet include the FontFace API declarations.
    // eslint-disable-next-line
    // @ts-ignore
    static loadWebFont(fontName, woffURL) {
        return __awaiter(this, void 0, void 0, function* () {
            const fontFace = new FontFace(fontName, `url(${woffURL})`);
            yield fontFace.load();
            // eslint-disable-next-line
            // @ts-ignore
            document.fonts.add(fontFace);
            return fontFace;
        });
    }
    /**
     * Load the web fonts that are used by your app.
     * If fontNames is undefined, all fonts in Font.WEB_FONT_FILES will be loaded.
     *
     * For example, `flow.html` calls:
     *   `await Vex.Flow.Font.loadWebFonts();`
     * Alternatively, you may load web fonts with a stylesheet link (e.g., from Google Fonts),
     * and a @font-face { font-family: ... } rule in your CSS.
     *
     * You can customize `Font.WEB_FONT_HOST` and `Font.WEB_FONT_FILES` to load different fonts
     * for your app.
     */
    static loadWebFonts(fontNames) {
        return __awaiter(this, void 0, void 0, function* () {
            const allFiles = Font.WEB_FONT_FILES;
            if (!fontNames) {
                fontNames = Object.keys(allFiles);
            }
            const host = Font.WEB_FONT_HOST;
            for (const fontName of fontNames) {
                const fontPath = allFiles[fontName];
                if (fontPath) {
                    Font.loadWebFont(fontName, host + fontPath);
                }
            }
        });
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////////
// STATIC MEMBERS
// CSS Font Sizes: 36pt == 48px == 3em == 300% == 0.5in
/** Given a length (for units: pt, px, em, %, in, mm, cm) what is the scale factor to convert it to px? */
Font.scaleToPxFrom = {
    pt: 4 / 3,
    px: 1,
    em: 16,
    '%': 4 / 25,
    in: 96,
    mm: 96 / 25.4,
    cm: 96 / 2.54,
};
/**
 * Customize this field to specify a different CDN for delivering web fonts.
 * Discussion on GDPR concerns:
 * https://www.jsdelivr.com/blog/how-the-german-courts-ruling-on-google-fonts-affects-jsdelivr-and-why-it-is-safe-to-use/
 *
 * You can also self host, and specify your own server URL here.
 */
Font.WEB_FONT_HOST = 'https://cdn.jsdelivr.net/npm/vexflow-fonts@1.0.6/';
/**
 * These font files will be loaded from the CDN specified by `Font.WEB_FONT_HOST` when
 * `await Font.loadWebFonts()` is called. Customize this field to specify a different
 * set of fonts to load. See: `Font.loadWebFonts()`.
 */
Font.WEB_FONT_FILES = {
    Academico: 'academico/Academico_0.902.woff2',
    Bravura: 'bravura/Bravura_1.392.woff2',
    BravuraText: 'bravura/BravuraText_1.393.woff2',
    GonvilleSmufl: 'gonvillesmufl/GonvilleSmufl_1.100.woff2',
    Gootville: 'gootville/Gootville_1.3.woff2',
    GootvilleText: 'gootville/GootvilleText_1.2.woff2',
    Leland: 'leland/Leland_0.75.woff2',
    LelandText: 'leland/LelandText_0.75.woff2',
    Petaluma: 'petaluma/Petaluma_1.065.woff2',
    'Petaluma Script': 'petaluma/PetalumaScript_1.10_FS.woff2',
    MuseJazz: 'musejazz/MuseJazz_1.0.woff2',
    MuseJazzText: 'musejazz/MuseJazzText_1.0.woff2',
    'Roboto Slab': 'robotoslab/RobotoSlab-Medium_2.001.woff2',
    FinaleAsh: 'finale/FinaleAsh_1.7.woff2',
    FinaleAshText: 'finale/FinaleAshText_1.3.woff2',
    FinaleJazz: 'finale/FinaleJazz_1.9.woff2',
    FinaleJazzText: 'finale/FinaleJazzText_1.3.woff2',
    FinaleBroadway: 'finale/FinaleBroadway_1.4.woff2',
    FinaleBroadwayText: 'finale/FinaleBroadwayText_1.1.woff2',
    FinaleMaestro: 'finale/FinaleMaestro_2.7.woff2',
    FinaleMaestroText: 'finale/FinaleMaestroText-Regular_1.6.woff2',
};


/***/ }),

/***/ "./src/formatter.ts":
/*!**************************!*\
  !*** ./src/formatter.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Formatter: () => (/* binding */ Formatter)
/* harmony export */ });
/* harmony import */ var _beam__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./beam */ "./src/beam.ts");
/* harmony import */ var _fraction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fraction */ "./src/fraction.ts");
/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./metrics */ "./src/metrics.ts");
/* harmony import */ var _modifiercontext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiercontext */ "./src/modifiercontext.ts");
/* harmony import */ var _stave__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stave */ "./src/stave.ts");
/* harmony import */ var _staveconnector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./staveconnector */ "./src/staveconnector.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _tickcontext__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tickcontext */ "./src/tickcontext.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./util */ "./src/util.ts");
/* harmony import */ var _voice__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./voice */ "./src/voice.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License











/**
 * Create `Alignment`s for each tick in `voices`. Also calculate the
 * total number of ticks in voices.
 */
function createContexts(voices, makeContext, addToContext) {
    if (voices.length === 0)
        return {
            map: {},
            array: [],
            list: [],
            resolutionMultiplier: 0,
        };
    // Initialize tick maps.
    const tickToContextMap = {};
    const tickList = [];
    const contexts = [];
    const resolutionMultiplier = Formatter.getResolutionMultiplier(voices);
    // For each voice, extract notes and create a context for every
    // new tick that hasn't been seen before.
    voices.forEach((voice, voiceIndex) => {
        // Use resolution multiplier as denominator so that no additional expansion
        // of fractional tick values is needed.
        const ticksUsed = new _fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction(0, resolutionMultiplier);
        voice.getTickables().forEach((tickable) => {
            const integerTicks = ticksUsed.numerator;
            // If we have no tick context for this tick, create one.
            if (!tickToContextMap[integerTicks]) {
                const newContext = makeContext({ tickID: integerTicks });
                contexts.push(newContext);
                tickToContextMap[integerTicks] = newContext;
                // Maintain a list of unique integerTicks.
                tickList.push(integerTicks);
            }
            // Add this tickable to the TickContext.
            addToContext(tickable, tickToContextMap[integerTicks], voiceIndex);
            ticksUsed.add(tickable.getTicks());
        });
    });
    return {
        map: tickToContextMap,
        array: contexts,
        list: tickList.sort((a, b) => a - b),
        resolutionMultiplier,
    };
}
// eslint-disable-next-line
function L(...args) {
    if (Formatter.DEBUG)
        (0,_util__WEBPACK_IMPORTED_MODULE_9__.log)('Vex.Flow.Formatter', args);
}
/**
 * Get the rest line number of the next non-rest note(s).
 * @param notes array of Notes
 * @param currRestLine
 * @param currNoteIndex current note index
 * @param compare if true, return the midpoint between the current rest line and the next rest line
 * @returns a line number, which determines the vertical position of a rest.
 */
function getRestLineForNextNoteGroup(notes, currRestLine, currNoteIndex, compare) {
    // If no valid next note group, nextRestLine is same as current.
    let nextRestLine = currRestLine;
    // Start with the next note and keep going until we find a valid non-rest note group.
    for (let noteIndex = currNoteIndex + 1; noteIndex < notes.length; noteIndex++) {
        const note = notes[noteIndex];
        if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_8__.isNote)(note) && !note.isRest() && !note.shouldIgnoreTicks()) {
            nextRestLine = note.getLineForRest();
            break;
        }
    }
    // Locate the mid point between two lines.
    if (compare && currRestLine !== nextRestLine) {
        const top = Math.max(currRestLine, nextRestLine);
        const bot = Math.min(currRestLine, nextRestLine);
        nextRestLine = (0,_util__WEBPACK_IMPORTED_MODULE_9__.midLine)(top, bot);
    }
    return nextRestLine;
}
/**
 * Format implements the formatting and layout algorithms that are used
 * to position notes in a voice. The algorithm can align multiple voices both
 * within a stave, and across multiple staves.
 *
 * To do this, the formatter breaks up voices into a grid of rational-valued
 * `ticks`, to which each note is assigned. Then, minimum widths are assigned
 * to each tick based on the widths of the notes and modifiers in that tick. This
 * establishes the smallest amount of space required for each tick.
 *
 * Finally, the formatter distributes the left over space proportionally to
 * all the ticks, setting the `x` values of the notes in each tick.
 *
 * See `tests/formatter_tests.ts` for usage examples. The helper functions included
 * here (`FormatAndDraw`, `FormatAndDrawTab`) also serve as useful usage examples.
 */
class Formatter {
    /**
     * Helper function to layout "notes" one after the other without
     * regard for proportions. Useful for tests and debugging.
     */
    static SimpleFormat(notes, x = 0, { paddingBetween = 10 } = {}) {
        notes.reduce((accumulator, note) => {
            note.addToModifierContext(new _modifiercontext__WEBPACK_IMPORTED_MODULE_3__.ModifierContext());
            const tick = new _tickcontext__WEBPACK_IMPORTED_MODULE_7__.TickContext().addTickable(note).preFormat();
            const metrics = tick.getMetrics();
            tick.setX(accumulator + metrics.totalLeftPx);
            return accumulator + tick.getWidth() + metrics.totalRightPx + paddingBetween;
        }, x);
    }
    /** Helper function to plot formatter debug info. */
    static plotDebugging(ctx, formatter, xPos, y1, y2, options) {
        var _a, _b;
        options = Object.assign({ stavePadding: _metrics__WEBPACK_IMPORTED_MODULE_2__.Metrics.get('Stave.padding') }, options);
        const x = xPos + options.stavePadding;
        const contextGaps = formatter.contextGaps;
        function stroke(x1, x2, color) {
            ctx.beginPath();
            ctx.setStrokeStyle(color);
            ctx.setFillStyle(color);
            ctx.setLineWidth(1);
            ctx.fillRect(x1, y1, Math.max(x2 - x1, 0), y2 - y1);
        }
        ctx.save();
        ctx.setFont(_metrics__WEBPACK_IMPORTED_MODULE_2__.Metrics.get('fontFamily'), 8);
        contextGaps.gaps.forEach((gap) => {
            stroke(x + gap.x1, x + gap.x2, 'rgba(100,200,100,0.4)');
            ctx.setFillStyle('green');
            ctx.fillText(Math.round(gap.x2 - gap.x1).toString(), x + gap.x1, y2 + 12);
        });
        ctx.setFillStyle('red');
        ctx.fillText(`Loss: ${((_a = formatter.totalCost) !== null && _a !== void 0 ? _a : 0).toFixed(2)} Shift: ${((_b = formatter.totalShift) !== null && _b !== void 0 ? _b : 0).toFixed(2)} Gap: ${contextGaps.total.toFixed(2)}`, x - 20, y2 + 27);
        ctx.restore();
    }
    /**
     * Helper function to format and draw a single voice. Returns a bounding
     * box for the notation.
     * @param ctx  the rendering context
     * @param stave the stave to which to draw (`Stave` or `TabStave`)
     * @param notes array of `Note` instances (`Note`, `TextNote`, `TabNote`, etc.)
     * @param params one of below:
     *    * Setting `autoBeam` only `(context, stave, notes, true)` or
     *      `(ctx, stave, notes, {autoBeam: true})`
     *    * Setting `alignRests` a struct is needed `(context, stave, notes, {alignRests: true})`
     *    * Setting both a struct is needed `(context, stave, notes, {
     *      autoBeam: true, alignRests: true})`
     *    * `autoBeam` automatically generates beams for the notes.
     *    * `alignRests` aligns rests with nearby notes.
     */
    static FormatAndDraw(ctx, stave, notes, params) {
        let options = {
            autoBeam: false,
            alignRests: false,
        };
        if (typeof params === 'object') {
            options = Object.assign(Object.assign({}, options), params);
        }
        else if (typeof params === 'boolean') {
            options.autoBeam = params;
        }
        // Start by creating a voice and adding all the notes to it.
        const voice = new _voice__WEBPACK_IMPORTED_MODULE_10__.Voice(_tables__WEBPACK_IMPORTED_MODULE_6__.Tables.TIME4_4).setMode(_voice__WEBPACK_IMPORTED_MODULE_10__.Voice.Mode.SOFT).addTickables(notes);
        // Then create beams, if requested.
        const beams = options.autoBeam ? _beam__WEBPACK_IMPORTED_MODULE_0__.Beam.applyAndGetBeams(voice) : [];
        // Instantiate a `Formatter` and format the notes.
        new Formatter()
            .joinVoices([voice]) // , { alignRests: options.alignRests })
            .formatToStave([voice], stave, { alignRests: options.alignRests, stave });
        // Render the voice and beams to the stave.
        voice.setStave(stave).draw(ctx, stave);
        beams.forEach((beam) => beam.setContext(ctx).draw());
        // Return the bounding box of the voice.
        return voice.getBoundingBox();
    }
    /**
     * Helper function to format and draw aligned tab and stave notes in two
     * separate staves.
     * @param ctx the rendering context
     * @param tabstave a `TabStave` instance on which to render `TabNote`s.
     * @param stave a `Stave` instance on which to render `Note`s.
     * @param notes array of `Note` instances for the stave (`Note`, `BarNote`, etc.)
     * @param tabnotes array of `Note` instances for the tab stave (`TabNote`, `BarNote`, etc.)
     * @param autoBeam automatically generate beams.
     * @param params a configuration object:
     *    * `autoBeam` automatically generates beams for the notes.
     *    * `alignRests` aligns rests with nearby notes.
     */
    static FormatAndDrawTab(ctx, tabstave, stave, tabnotes, notes, autoBeam, params) {
        let opts = {
            autoBeam,
            alignRests: false,
        };
        if (typeof params === 'object') {
            opts = Object.assign(Object.assign({}, opts), params);
        }
        else if (typeof params === 'boolean') {
            opts.autoBeam = params;
        }
        // Create a `4/4` voice for `notes`.
        const notevoice = new _voice__WEBPACK_IMPORTED_MODULE_10__.Voice(_tables__WEBPACK_IMPORTED_MODULE_6__.Tables.TIME4_4).setMode(_voice__WEBPACK_IMPORTED_MODULE_10__.Voice.Mode.SOFT).addTickables(notes);
        // Create a `4/4` voice for `tabnotes`.
        const tabvoice = new _voice__WEBPACK_IMPORTED_MODULE_10__.Voice(_tables__WEBPACK_IMPORTED_MODULE_6__.Tables.TIME4_4).setMode(_voice__WEBPACK_IMPORTED_MODULE_10__.Voice.Mode.SOFT).addTickables(tabnotes);
        // Then create beams, if requested.
        const beams = opts.autoBeam ? _beam__WEBPACK_IMPORTED_MODULE_0__.Beam.applyAndGetBeams(notevoice) : [];
        // Instantiate a `Formatter` and align tab and stave notes.
        new Formatter()
            .joinVoices([notevoice]) // , { alignRests: opts.alignRests })
            .joinVoices([tabvoice])
            .formatToStave([notevoice, tabvoice], stave, { alignRests: opts.alignRests });
        // Render voices and beams to staves.
        notevoice.draw(ctx, stave);
        tabvoice.draw(ctx, tabstave);
        beams.forEach((beam) => beam.setContext(ctx).draw());
        // Draw a connector between tab and note staves.
        new _staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave, tabstave).setContext(ctx).draw();
    }
    /**
     * Automatically set the vertical position of rests based on previous/next note positions.
     * @param tickables an array of Tickables.
     * @param alignAllNotes If `false`, only align rests that are within a group of beamed notes.
     * @param alignTuplets If `false`, ignores tuplets.
     */
    static AlignRestsToNotes(tickables, alignAllNotes, alignTuplets) {
        tickables.forEach((currTickable, index) => {
            if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_8__.isStaveNote)(currTickable) && currTickable.isRest()) {
                if (currTickable.getTuplet() && !alignTuplets) {
                    return;
                }
                // If activated rests not on default can be rendered as specified.
                const line = currTickable.getLineForRest();
                if (line !== 3) {
                    return;
                }
                if (alignAllNotes || currTickable.getBeam()) {
                    // Align rests with previous/next notes.
                    const props = currTickable.getKeyProps()[0];
                    if (index === 0) {
                        props.line = getRestLineForNextNoteGroup(tickables, props.line, index, false);
                    }
                    else if (index > 0 && index < tickables.length) {
                        // If previous tickable is a rest, use its line number.
                        const prevTickable = tickables[index - 1];
                        if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_8__.isStaveNote)(prevTickable)) {
                            if (prevTickable.isRest()) {
                                props.line = prevTickable.getKeyProps()[0].line;
                            }
                            else {
                                const restLine = prevTickable.getLineForRest();
                                // Get the rest line for next valid non-rest note group.
                                props.line = getRestLineForNextNoteGroup(tickables, restLine, index, true);
                            }
                        }
                    }
                    currTickable.setKeyLine(0, props.line);
                }
            }
        });
    }
    constructor(options) {
        this.formatterOptions = Object.assign({ globalSoftmax: false, softmaxFactor: _tables__WEBPACK_IMPORTED_MODULE_6__.Tables.SOFTMAX_FACTOR, maxIterations: 5 }, options);
        this.justifyWidth = 0;
        this.totalCost = 0;
        this.totalShift = 0;
        this.durationStats = {};
        // Minimum width required to render all the notes in the voices.
        this.minTotalWidth = 0;
        // This is set to `true` after `minTotalWidth` is calculated.
        this.hasMinTotalWidth = false;
        // Arrays of tick and modifier contexts.
        this.tickContexts = {
            map: {},
            array: [],
            list: [],
            resolutionMultiplier: 0,
        };
        this.modifierContexts = [];
        // Gaps between contexts, for free movement of notes post
        // formatting.
        this.contextGaps = {
            total: 0,
            gaps: [],
        };
        this.voices = [];
        this.lossHistory = [];
    }
    /**
     * Find all the rests in each of the `voices` and align them to neighboring notes.
     *
     * @param voices
     * @param alignAllNotes If `false`, only align rests within beamed groups of notes. If `true`, align all rests.
     */
    alignRests(voices, alignAllNotes) {
        if (!voices || !voices.length) {
            throw new _util__WEBPACK_IMPORTED_MODULE_9__.RuntimeError('BadArgument', 'No voices to format rests');
        }
        voices.forEach((voice) => Formatter.AlignRestsToNotes(voice.getTickables(), alignAllNotes));
    }
    /**
     * Estimate the width required to render 'voices'.  This is done by:
     * 1. Sum the widths of all the tick contexts
     * 2. Estimate the padding.
     * The latter is done by calculating the padding 3 different ways, and taking the
     * greatest value:
     * 1. the padding required for unaligned notes in different voices
     * 2. the padding based on the stddev of the tickable widths
     * 3. the padding based on the stddev of the tickable durations.
     *
     * The last 2 quantities estimate a 'width entropy', where notes might need more
     * room than the proportional formatting gives them.  A measure of all same duration
     * and width will need no extra padding, and all these quantities will be
     * zero in that case.
     *
     * Note: joinVoices has to be called before calling preCalculateMinTotalWidth.
     *
     * @param voices the voices that contain the notes
     * @returns the estimated width in pixels
     */
    preCalculateMinTotalWidth(voices) {
        const unalignedPadding = _metrics__WEBPACK_IMPORTED_MODULE_2__.Metrics.get('Stave.unalignedNotePadding');
        // Calculate additional padding based on 3 methods:
        // 1) unaligned beats in voices, 2) variance of width, 3) variance of durations
        let unalignedCtxCount = 0;
        let wsum = 0;
        let dsum = 0;
        const widths = [];
        const durations = [];
        // Cache results.
        if (this.hasMinTotalWidth)
            return this.minTotalWidth;
        // Create tick contexts.
        if (!voices) {
            throw new _util__WEBPACK_IMPORTED_MODULE_9__.RuntimeError('BadArgument', "'voices' required to run preCalculateMinTotalWidth");
        }
        this.createTickContexts(voices);
        // eslint-disable-next-line
        const { list: contextList, map: contextMap } = this.tickContexts;
        this.minTotalWidth = 0;
        // Go through each tick context and calculate total width,
        // and also accumulate values used in padding hints
        contextList.forEach((tick) => {
            const context = contextMap[tick];
            context.preFormat();
            // If this TC doesn't have all the voices on it, it's unaligned.
            // so increment the unaligned padding accumulator
            if (context.getTickables().length < voices.length) {
                unalignedCtxCount += 1;
            }
            // Calculate the 'width entropy' over all the Tickables.
            context.getTickables().forEach((t) => {
                wsum += t.getMetrics().width;
                dsum += t.getTicks().value();
                widths.push(t.getMetrics().width);
                durations.push(t.getTicks().value());
            });
            const width = context.getWidth();
            this.minTotalWidth += width;
        });
        this.hasMinTotalWidth = true;
        // normalized (0-1) STDDEV of widths/durations gives us padding hints.
        const wavg = wsum > 0 ? wsum / widths.length : 1 / widths.length;
        const wvar = (0,_util__WEBPACK_IMPORTED_MODULE_9__.sumArray)(widths.map((ll) => Math.pow(ll - wavg, 2)));
        const wpads = Math.pow(wvar / widths.length, 0.5) / wavg;
        const davg = dsum / durations.length;
        const dvar = (0,_util__WEBPACK_IMPORTED_MODULE_9__.sumArray)(durations.map((ll) => Math.pow(ll - davg, 2)));
        const dpads = Math.pow(dvar / durations.length, 0.5) / davg;
        // Find max of 3 methods pad the width with that
        const padmax = Math.max(dpads, wpads) * contextList.length * unalignedPadding;
        const unalignedPad = unalignedPadding * unalignedCtxCount;
        return this.minTotalWidth + Math.max(unalignedPad, padmax);
    }
    /**
     * Get minimum width required to render all voices. Either `format` or
     * `preCalculateMinTotalWidth` must be called before this method.
     */
    getMinTotalWidth() {
        if (!this.hasMinTotalWidth) {
            throw new _util__WEBPACK_IMPORTED_MODULE_9__.RuntimeError('NoMinTotalWidth', "Call 'preCalculateMinTotalWidth' or 'preFormat' before calling 'getMinTotalWidth'");
        }
        return this.minTotalWidth;
    }
    /** Calculate the resolution multiplier for `voices`. */
    static getResolutionMultiplier(voices) {
        if (!voices || !voices.length) {
            throw new _util__WEBPACK_IMPORTED_MODULE_9__.RuntimeError('BadArgument', 'No voices to format');
        }
        const totalTicks = voices[0].getTotalTicks();
        const resolutionMultiplier = voices.reduce((accumulator, voice) => {
            if (!voice.getTotalTicks().equals(totalTicks)) {
                throw new _util__WEBPACK_IMPORTED_MODULE_9__.RuntimeError('TickMismatch', 'Voices should have same total note duration in ticks.');
            }
            if (voice.getMode() === _voice__WEBPACK_IMPORTED_MODULE_10__.Voice.Mode.STRICT && !voice.isComplete()) {
                throw new _util__WEBPACK_IMPORTED_MODULE_9__.RuntimeError('IncompleteVoice', 'Voice does not have enough notes.');
            }
            return Math.max(accumulator, _fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction.LCM(accumulator, voice.getResolutionMultiplier()));
        }, 1);
        return resolutionMultiplier;
    }
    /** Create a `ModifierContext` for each tick in `voices`. */
    createModifierContexts(voices) {
        if (voices.length === 0)
            return;
        const resolutionMultiplier = Formatter.getResolutionMultiplier(voices);
        // Initialize tick maps.
        const tickToContextMap = new Map();
        const contexts = [];
        // For each voice, extract notes and create a context for every
        // new tick that hasn't been seen before.
        voices.forEach((voice) => {
            // Use resolution multiplier as denominator so that no additional expansion
            // of fractional tick values is needed.
            const ticksUsed = new _fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction(0, resolutionMultiplier);
            voice.getTickables().forEach((tickable) => {
                const integerTicks = ticksUsed.numerator;
                let staveTickToContextMap = tickToContextMap.get(tickable.getStave());
                // If we have no tick context for this tick, create one.
                if (!staveTickToContextMap) {
                    tickToContextMap.set(tickable.getStave(), {});
                    staveTickToContextMap = tickToContextMap.get(tickable.getStave());
                }
                if (!(staveTickToContextMap ? staveTickToContextMap[integerTicks] : undefined)) {
                    const newContext = new _modifiercontext__WEBPACK_IMPORTED_MODULE_3__.ModifierContext();
                    contexts.push(newContext);
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    staveTickToContextMap[integerTicks] = newContext;
                }
                // Add this tickable to the TickContext.
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                tickable.addToModifierContext(staveTickToContextMap[integerTicks]);
                ticksUsed.add(tickable.getTicks());
            });
        });
        this.modifierContexts.push({
            map: tickToContextMap,
            array: contexts,
            resolutionMultiplier,
        });
    }
    /**
     * Create a `TickContext` for each tick in `voices`. Also calculate the
     * total number of ticks in voices.
     */
    createTickContexts(voices) {
        const fn = (tickable, context, voiceIndex) => context.addTickable(tickable, voiceIndex);
        const contexts = createContexts(voices, (tick) => new _tickcontext__WEBPACK_IMPORTED_MODULE_7__.TickContext(tick), fn);
        this.tickContexts = contexts;
        const contextArray = this.tickContexts.array;
        contextArray.forEach((context) => {
            context.tContexts = contextArray;
        });
        return contexts;
    }
    /**
     * Get the AlignmentContexts of TickContexts that were created by createTickContexts.
     * Returns undefined if createTickContexts has not yet been run.
     */
    getTickContexts() {
        return this.tickContexts;
    }
    /**
     * This is the core formatter logic. Format voices and justify them
     * to `justifyWidth` pixels. `renderingContext` is required to justify elements
     * that can't retrieve widths without a canvas. This method sets the `x` positions
     * of all the tickables/notes in the formatter.
     */
    preFormat(justifyWidth = 0, renderingContext, voicesParam, stave) {
        // Initialize context maps.
        const contexts = this.tickContexts;
        if (!contexts) {
            throw new _util__WEBPACK_IMPORTED_MODULE_9__.RuntimeError('NoTickContexts', 'preFormat requires TickContexts');
        }
        const { list: contextList, map: contextMap } = contexts;
        // Reset loss history for evaluator.
        this.lossHistory = [];
        // If voices and a stave were provided, set the Stave for each voice
        // and preFormat to apply Y values to the notes;
        if (voicesParam && stave) {
            voicesParam.forEach((voice) => voice.setStave(stave).preFormat());
        }
        // Now distribute the ticks to each tick context, and assign them their
        // own X positions.
        let x = 0;
        let shift = 0;
        this.minTotalWidth = 0;
        let totalTicks = 0;
        // Pass 1: Give each note maximum width requested by context.
        contextList.forEach((tick) => {
            const context = contextMap[tick];
            // Make sure that all tickables in this context have calculated their
            // space requirements.
            context.preFormat();
            const width = context.getWidth();
            this.minTotalWidth += width;
            const maxTicks = context.getMaxTicks().value();
            totalTicks += maxTicks;
            const metrics = context.getMetrics();
            x = x + shift + metrics.totalLeftPx;
            context.setX(x);
            // Calculate shift for the next tick.
            shift = width - metrics.totalLeftPx;
        });
        // Use softmax based on all notes across all staves. (options.globalSoftmax)
        const { globalSoftmax, softmaxFactor, maxIterations } = this.formatterOptions;
        const exp = (tick) => Math.pow(softmaxFactor, (contextMap[tick].getMaxTicks().value() / totalTicks));
        const expTicksUsed = (0,_util__WEBPACK_IMPORTED_MODULE_9__.sumArray)(contextList.map(exp));
        this.minTotalWidth = x + shift;
        this.hasMinTotalWidth = true;
        // No justification needed. End formatting.
        if (justifyWidth <= 0)
            return this.evaluate();
        // Start justification. Subtract the right extra pixels of the final context because the formatter
        // justifies based on the context's X position, which is the left-most part of the note head.
        const firstContext = contextMap[contextList[0]];
        const lastContext = contextMap[contextList[contextList.length - 1]];
        // Calculate the "distance error" between the tick contexts. The expected distance is the spacing proportional to
        // the softmax of the ticks.
        function calculateIdealDistances(adjustedJustifyWidth) {
            const distances = contextList.map((tick, i) => {
                const context = contextMap[tick];
                const voices = context.getTickablesByVoice();
                let backTickable;
                if (i > 0) {
                    const prevContext = contextMap[contextList[i - 1]];
                    // Go through each tickable and search backwards for another tickable
                    // in the same voice. If found, use that duration (ticks) to calculate
                    // the expected distance.
                    for (let j = i - 1; j >= 0; j--) {
                        const backTick = contextMap[contextList[j]];
                        const backVoices = backTick.getTickablesByVoice();
                        // Look for matching voices between tick contexts.
                        const matchingVoices = [];
                        Object.keys(voices).forEach((v) => {
                            if (backVoices[v]) {
                                matchingVoices.push(v);
                            }
                        });
                        if (matchingVoices.length > 0) {
                            // Found matching voices, get largest duration
                            let maxTicks = 0;
                            let maxNegativeShiftPx = Infinity;
                            let expectedDistance = 0;
                            matchingVoices.forEach((v) => {
                                const ticks = backVoices[v].getTicks().value();
                                if (ticks > maxTicks) {
                                    backTickable = backVoices[v];
                                    maxTicks = ticks;
                                }
                                // Calculate the limits of the shift based on modifiers, etc.
                                const thisTickable = voices[v];
                                const insideLeftEdge = thisTickable.getX() -
                                    (thisTickable.getMetrics().modLeftPx + thisTickable.getMetrics().leftDisplacedHeadPx);
                                const backMetrics = backVoices[v].getMetrics();
                                const insideRightEdge = backVoices[v].getX() + backMetrics.notePx + backMetrics.modRightPx + backMetrics.rightDisplacedHeadPx;
                                // Don't allow shifting if notes in the same voice can collide
                                maxNegativeShiftPx = Math.min(maxNegativeShiftPx, insideLeftEdge - insideRightEdge);
                            });
                            // Don't shift further left than the notehead of the last context. Actually, stay at most 5% to the right
                            // so that two different tick contexts don't align across staves.
                            maxNegativeShiftPx = Math.min(maxNegativeShiftPx, context.getX() - (prevContext.getX() + adjustedJustifyWidth * 0.05));
                            // Calculate the expected distance of the current context from the last matching tickable. The
                            // distance is scaled down by the softmax for the voice.
                            if (globalSoftmax) {
                                const t = totalTicks;
                                expectedDistance = (Math.pow(softmaxFactor, (maxTicks / t)) / expTicksUsed) * adjustedJustifyWidth;
                            }
                            else if (typeof backTickable !== 'undefined') {
                                expectedDistance = backTickable.getVoice().softmax(maxTicks) * adjustedJustifyWidth;
                            }
                            return {
                                expectedDistance,
                                maxNegativeShiftPx,
                                fromTickable: backTickable,
                            };
                        }
                    }
                }
                return { expectedDistance: 0, fromTickablePx: 0, maxNegativeShiftPx: 0 };
            });
            return distances;
        }
        function shiftToIdealDistances(idealDistances) {
            // Distribute ticks to the contexts based on the calculated distance error.
            const centerX = adjustedJustifyWidth / 2;
            let spaceAccum = 0;
            contextList.forEach((tick, index) => {
                const context = contextMap[tick];
                if (index > 0) {
                    const contextX = context.getX();
                    const ideal = idealDistances[index];
                    const errorPx = (0,_util__WEBPACK_IMPORTED_MODULE_9__.defined)(ideal.fromTickable).getX() + ideal.expectedDistance - (contextX + spaceAccum);
                    let negativeShiftPx = 0;
                    if (errorPx > 0) {
                        spaceAccum += errorPx;
                    }
                    else if (errorPx < 0) {
                        negativeShiftPx = Math.min(ideal.maxNegativeShiftPx, Math.abs(errorPx));
                        spaceAccum += -negativeShiftPx;
                    }
                    context.setX(contextX + spaceAccum);
                }
                // Move center aligned tickables to middle
                context.getCenterAlignedTickables().forEach((tickable) => {
                    tickable.setCenterXShift(centerX - context.getX());
                });
            });
            return lastContext.getX() - firstContext.getX();
        }
        const adjustedJustifyWidth = justifyWidth -
            lastContext.getMetrics().notePx -
            lastContext.getMetrics().totalRightPx -
            firstContext.getMetrics().totalLeftPx;
        const configMinPadding = _metrics__WEBPACK_IMPORTED_MODULE_2__.Metrics.get('Stave.endPaddingMin');
        const configMaxPadding = _metrics__WEBPACK_IMPORTED_MODULE_2__.Metrics.get('Stave.endPaddingMax');
        const leftPadding = _metrics__WEBPACK_IMPORTED_MODULE_2__.Metrics.get('Stave.padding');
        let targetWidth = adjustedJustifyWidth;
        const distances = calculateIdealDistances(targetWidth);
        let actualWidth = shiftToIdealDistances(distances);
        // Just one context. Done formatting.
        if (contextList.length === 1)
            return 0;
        const calcMinDistance = (targetWidth, distances) => {
            let mdCalc = targetWidth / 2;
            if (distances.length > 1) {
                for (let di = 1; di < distances.length; ++di) {
                    mdCalc = Math.min(distances[di].expectedDistance / 2, mdCalc);
                }
            }
            return mdCalc;
        };
        const minDistance = calcMinDistance(targetWidth, distances);
        // right justify to either the configured padding, or the min distance between notes, whichever is greatest.
        // This * 2 keeps the existing formatting unless there is 'a lot' of extra whitespace, which won't break
        // existing visual regression tests.
        const paddingMaxCalc = (curTargetWidth) => {
            let lastTickablePadding = 0;
            const lastTickable = lastContext && lastContext.getMaxTickable();
            if (lastTickable) {
                const voice = lastTickable.getVoice();
                // If the number of actual ticks in the measure <> configured ticks, right-justify
                // because the softmax won't yield the correct value
                if (voice.getTicksUsed().value() > voice.getTotalTicks().value()) {
                    return configMaxPadding * 2 < minDistance ? minDistance : configMaxPadding;
                }
                const tickWidth = lastTickable.getWidth();
                lastTickablePadding =
                    voice.softmax(lastContext.getMaxTicks().value()) * curTargetWidth - (tickWidth + leftPadding);
            }
            return configMaxPadding * 2 < lastTickablePadding ? lastTickablePadding : configMaxPadding;
        };
        let paddingMax = paddingMaxCalc(targetWidth);
        let paddingMin = paddingMax - (configMaxPadding - configMinPadding);
        const maxX = adjustedJustifyWidth - paddingMin;
        let iterations = maxIterations;
        // Adjust justification width until the right margin is as close as possible to the calculated padding,
        // without going over
        while ((actualWidth > maxX && iterations > 0) || (actualWidth + paddingMax < maxX && iterations > 1)) {
            targetWidth -= actualWidth - maxX;
            paddingMax = paddingMaxCalc(targetWidth);
            paddingMin = paddingMax - (configMaxPadding - configMinPadding);
            actualWidth = shiftToIdealDistances(calculateIdealDistances(targetWidth));
            iterations--;
        }
        this.justifyWidth = justifyWidth;
        return this.evaluate();
    }
    /** Calculate the total cost of this formatting decision. */
    evaluate() {
        const contexts = this.tickContexts;
        const justifyWidth = this.justifyWidth;
        // Calculate available slack per tick context. This works out how much freedom
        // to move a context has in either direction, without affecting other notes.
        this.contextGaps = { total: 0, gaps: [] };
        contexts.list.forEach((tick, index) => {
            if (index === 0)
                return;
            const prevTick = contexts.list[index - 1];
            const prevContext = contexts.map[prevTick];
            const context = contexts.map[tick];
            const prevMetrics = prevContext.getMetrics();
            const currMetrics = context.getMetrics();
            // Calculate X position of right edge of previous note
            const insideRightEdge = prevContext.getX() + prevMetrics.notePx + prevMetrics.totalRightPx;
            // Calculate X position of left edge of current note
            const insideLeftEdge = context.getX() - currMetrics.totalLeftPx;
            const gap = insideLeftEdge - insideRightEdge;
            this.contextGaps.total += gap;
            this.contextGaps.gaps.push({ x1: insideRightEdge, x2: insideLeftEdge });
            // Tell the tick contexts how much they can reposition themselves.
            context.getFormatterMetrics().freedom.left = gap;
            prevContext.getFormatterMetrics().freedom.right = gap;
        });
        // Calculate mean distance in each voice for each duration type, then calculate
        // how far each note is from the mean.
        this.durationStats = {};
        const durationStats = this.durationStats;
        function updateStats(duration, space) {
            const stats = durationStats[duration];
            if (stats === undefined) {
                durationStats[duration] = { mean: space, count: 1 };
            }
            else {
                stats.count += 1;
                stats.mean = (stats.mean + space) / 2;
            }
        }
        this.voices.forEach((voice) => {
            voice.getTickables().forEach((note, i, notes) => {
                const duration = note.getTicks().clone().simplify().toString();
                const metrics = note.getMetrics();
                const formatterMetrics = note.getFormatterMetrics();
                const leftNoteEdge = note.getX() + metrics.notePx + metrics.modRightPx + metrics.rightDisplacedHeadPx;
                let space = 0;
                if (i < notes.length - 1) {
                    const rightNote = notes[i + 1];
                    const rightMetrics = rightNote.getMetrics();
                    const rightNoteEdge = rightNote.getX() - rightMetrics.modLeftPx - rightMetrics.leftDisplacedHeadPx;
                    space = rightNoteEdge - leftNoteEdge;
                    formatterMetrics.space.used = rightNote.getX() - note.getX();
                    rightNote.getFormatterMetrics().freedom.left = space;
                }
                else {
                    space = justifyWidth - leftNoteEdge;
                    formatterMetrics.space.used = justifyWidth - note.getX();
                }
                formatterMetrics.freedom.right = space;
                updateStats(duration, formatterMetrics.space.used);
            });
        });
        // Calculate how much each note deviates from the mean. Loss function is square
        // root of the sum of squared deviations.
        let totalDeviation = 0;
        this.voices.forEach((voice) => {
            voice.getTickables().forEach((note) => {
                const duration = note.getTicks().clone().simplify().toString();
                const metrics = note.getFormatterMetrics();
                metrics.space.mean = durationStats[duration].mean;
                metrics.duration = duration;
                metrics.iterations += 1;
                metrics.space.deviation = metrics.space.used - metrics.space.mean;
                totalDeviation += Math.pow(metrics.space.deviation, 2);
            });
        });
        this.totalCost = Math.sqrt(totalDeviation);
        this.lossHistory.push(this.totalCost);
        return this.totalCost;
    }
    /**
     * Run a single iteration of rejustification. At a high level, this method calculates
     * the overall "loss" (or cost) of this layout, and repositions tickcontexts in an
     * attempt to reduce the cost. You can call this method multiple times until it finds
     * and oscillates around a global minimum.
     * @param options[alpha] the "learning rate" for the formatter. It determines how much of a shift
     * the formatter should make based on its cost function.
     */
    tune(options) {
        var _a;
        const contexts = this.tickContexts;
        if (!contexts) {
            return 0;
        }
        const alpha = (_a = options === null || options === void 0 ? void 0 : options.alpha) !== null && _a !== void 0 ? _a : 0.5;
        // Move `current` tickcontext by `shift` pixels, and adjust the freedom
        // on adjacent tickcontexts.
        function move(current, shift, prev, next) {
            current.setX(current.getX() + shift);
            current.getFormatterMetrics().freedom.left += shift;
            current.getFormatterMetrics().freedom.right -= shift;
            if (prev)
                prev.getFormatterMetrics().freedom.right += shift;
            if (next)
                next.getFormatterMetrics().freedom.left -= shift;
        }
        let shift = 0;
        this.totalShift = 0;
        contexts.list.forEach((tick, index, list) => {
            const context = contexts.map[tick];
            const prevContext = index > 0 ? contexts.map[list[index - 1]] : undefined;
            const nextContext = index < list.length - 1 ? contexts.map[list[index + 1]] : undefined;
            move(context, shift, prevContext, nextContext);
            const cost = -(0,_util__WEBPACK_IMPORTED_MODULE_9__.sumArray)(context.getTickables().map((t) => t.getFormatterMetrics().space.deviation));
            if (cost > 0) {
                shift = -Math.min(context.getFormatterMetrics().freedom.right, Math.abs(cost));
            }
            else if (cost < 0) {
                if (nextContext) {
                    shift = Math.min(nextContext.getFormatterMetrics().freedom.right, Math.abs(cost));
                }
                else {
                    shift = 0;
                }
            }
            shift *= alpha;
            this.totalShift += shift;
        });
        return this.evaluate();
    }
    /**
     * This is the top-level call for all formatting logic completed
     * after `x` *and* `y` values have been computed for the notes
     * in the voices.
     */
    postFormat() {
        this.modifierContexts.forEach((modifierContexts) => {
            modifierContexts.array.forEach((mc) => mc.postFormat());
        });
        this.tickContexts.list.forEach((tick) => {
            this.tickContexts.map[tick].postFormat();
        });
        return this;
    }
    /**
     * Take all `voices` and create `ModifierContext`s out of them. This tells
     * the formatters that the voices belong on a single stave.
     */
    joinVoices(voices) {
        this.createModifierContexts(voices);
        this.hasMinTotalWidth = false;
        return this;
    }
    /**
     * Align rests in voices, justify the contexts, and position the notes
     * so voices are aligned and ready to render onto the stave. This method
     * mutates the `x` positions of all tickables in `voices`.
     *
     * Voices are full justified to fit in `justifyWidth` pixels.
     *
     * Set `options.context` to the rendering context. Set `options.alignRests`
     * to true to enable rest alignment.
     */
    format(voices, justifyWidth, options) {
        const opts = Object.assign({ alignRests: false }, options);
        this.voices = voices;
        const softmaxFactor = this.formatterOptions.softmaxFactor;
        if (softmaxFactor) {
            this.voices.forEach((v) => v.setSoftmaxFactor(softmaxFactor));
        }
        this.alignRests(voices, opts.alignRests);
        this.createTickContexts(voices);
        this.preFormat(justifyWidth, opts.context, voices, opts.stave);
        // Only postFormat if a stave was supplied for y value formatting
        if (opts.stave)
            this.postFormat();
        return this;
    }
    // This method is just like `format` except that the `justifyWidth` is inferred from the `stave`.
    formatToStave(voices, stave, optionsParam) {
        const options = Object.assign({ context: stave.getContext() }, optionsParam);
        // eslint-disable-next-line
        const justifyWidth = stave.getNoteEndX() - stave.getNoteStartX() - _stave__WEBPACK_IMPORTED_MODULE_4__.Stave.defaultPadding;
        L('Formatting voices to width: ', justifyWidth);
        return this.format(voices, justifyWidth, options);
    }
    getTickContext(tick) {
        var _a;
        return (_a = this.tickContexts) === null || _a === void 0 ? void 0 : _a.map[tick];
    }
}
// To enable logging for this class. Set `Vex.Flow.Formatter.DEBUG` to `true`.
Formatter.DEBUG = false;


/***/ }),

/***/ "./src/fraction.ts":
/*!*************************!*\
  !*** ./src/fraction.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Fraction: () => (/* binding */ Fraction)
/* harmony export */ });
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// @author Joshua Koo / @zz85
// @author @incompleteopus
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _a, _Fraction_fractionA, _Fraction_fractionB;


/** Fraction represents a rational number. */
class Fraction {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_0__.Category.Fraction;
    }
    /**
     * GCD: Greatest common divisor using the Euclidean algorithm.
     * Note: GCD(0, 0) => 0 and GCD(0, n) => n.
     */
    static GCD(a, b) {
        if (typeof a !== 'number' || Number.isNaN(a) || typeof b !== 'number' || Number.isNaN(b)) {
            throw new _util__WEBPACK_IMPORTED_MODULE_1__.RuntimeError('BadArgument', `Invalid numbers: ${a}, ${b}`);
        }
        let t;
        while (b !== 0) {
            t = b;
            b = a % b;
            a = t;
        }
        return a;
    }
    /** LCM: Lowest common multiple. */
    static LCM(a, b) {
        return (a * b) / Fraction.GCD(a, b);
    }
    /** Lowest common multiple for more than two numbers. */
    static LCMM(args) {
        if (args.length === 0) {
            return 0;
        }
        else if (args.length === 1) {
            return args[0];
        }
        else if (args.length === 2) {
            return Fraction.LCM(args[0], args[1]);
        }
        else {
            // args.shift() removes the first number.
            // LCM the first number with the rest of the numbers.
            return Fraction.LCM(args.shift(), Fraction.LCMM(args));
        }
    }
    /** Set the numerator and denominator. */
    constructor(numerator, denominator) {
        this.numerator = 1;
        this.denominator = 1;
        this.set(numerator, denominator);
    }
    /** Set the numerator and denominator. */
    set(numerator = 1, denominator = 1) {
        this.numerator = numerator;
        this.denominator = denominator;
        return this;
    }
    /** Return the value of the fraction. */
    value() {
        return this.numerator / this.denominator;
    }
    /** Simplify numerator and denominator using GCD. */
    simplify() {
        let u = this.numerator;
        let d = this.denominator;
        const gcd = Fraction.GCD(u, d);
        u /= gcd;
        d /= gcd;
        if (d < 0) {
            d = -d;
            u = -u;
        }
        return this.set(u, d);
    }
    /** Add value of another fraction. */
    add(param1 = 0, param2 = 1) {
        const [otherNumerator, otherDenominator] = getNumeratorAndDenominator(param1, param2);
        const lcm = Fraction.LCM(this.denominator, otherDenominator);
        const a = lcm / this.denominator;
        const b = lcm / otherDenominator;
        const u = this.numerator * a + otherNumerator * b;
        return this.set(u, lcm);
    }
    /** Substract value of another fraction. */
    subtract(param1 = 0, param2 = 1) {
        const [otherNumerator, otherDenominator] = getNumeratorAndDenominator(param1, param2);
        const lcm = Fraction.LCM(this.denominator, otherDenominator);
        const a = lcm / this.denominator;
        const b = lcm / otherDenominator;
        const u = this.numerator * a - otherNumerator * b;
        return this.set(u, lcm);
    }
    /** Multiply by value of another fraction. */
    multiply(param1 = 1, param2 = 1) {
        const [otherNumerator, otherDenominator] = getNumeratorAndDenominator(param1, param2);
        return this.set(this.numerator * otherNumerator, this.denominator * otherDenominator);
    }
    /** Divide by value of another Fraction. */
    divide(param1 = 1, param2 = 1) {
        const [otherNumerator, otherDenominator] = getNumeratorAndDenominator(param1, param2);
        return this.set(this.numerator * otherDenominator, this.denominator * otherNumerator);
    }
    /** Simplify both sides and check if they are equal. */
    equals(compare) {
        const a = __classPrivateFieldGet(Fraction, _a, "f", _Fraction_fractionA).copy(compare).simplify();
        const b = __classPrivateFieldGet(Fraction, _a, "f", _Fraction_fractionB).copy(this).simplify();
        return a.numerator === b.numerator && a.denominator === b.denominator;
    }
    /** Greater than operator. */
    greaterThan(compare) {
        const a = __classPrivateFieldGet(Fraction, _a, "f", _Fraction_fractionA).copy(this);
        a.subtract(compare);
        return a.numerator > 0;
    }
    /** Greater than or equals operator. */
    greaterThanEquals(compare) {
        const a = __classPrivateFieldGet(Fraction, _a, "f", _Fraction_fractionA).copy(this);
        a.subtract(compare);
        return a.numerator >= 0;
    }
    /** Less than operator. */
    lessThan(compare) {
        return !this.greaterThanEquals(compare);
    }
    /** Less than or equals operator. */
    lessThanEquals(compare) {
        return !this.greaterThan(compare);
    }
    /** Return a new copy with current values. */
    clone() {
        return new Fraction(this.numerator, this.denominator);
    }
    /** Copy value of another fraction. */
    copy(other) {
        if (typeof other === 'number') {
            return this.set(other);
        }
        else {
            return this.set(other.numerator, other.denominator);
        }
    }
    /** Return the integer component (eg. 5/2 => 2). */
    quotient() {
        return Math.floor(this.numerator / this.denominator);
    }
    /** Return the remainder component (eg. 5/2 => 1). */
    remainder() {
        return this.numerator % this.denominator;
    }
    /** Calculate absolute value. */
    makeAbs() {
        this.denominator = Math.abs(this.denominator);
        this.numerator = Math.abs(this.numerator);
        return this;
    }
    /** Return a raw string representation (eg. "5/2"). */
    toString() {
        return `${this.numerator}/${this.denominator}`;
    }
    /** Return a simplified string respresentation. */
    toSimplifiedString() {
        return __classPrivateFieldGet(Fraction, _a, "f", _Fraction_fractionA).copy(this).simplify().toString();
    }
    /** Return string representation in mixed form. */
    toMixedString() {
        let s = '';
        const q = this.quotient();
        const f = __classPrivateFieldGet(Fraction, _a, "f", _Fraction_fractionA).copy(this);
        if (q < 0) {
            f.makeAbs();
        }
        if (q !== 0) {
            s += q;
            if (f.numerator !== 0) {
                s += ` ${f.toSimplifiedString()}`;
            }
        }
        else if (f.numerator === 0) {
            s = '0';
        }
        else {
            s = f.toSimplifiedString();
        }
        return s;
    }
    /** Parse a fraction string. */
    parse(str) {
        const i = str.split('/');
        const n = parseInt(i[0], 10);
        const d = i[1] ? parseInt(i[1], 10) : 1;
        return this.set(n, d);
    }
}
_a = Fraction;
// Cached objects for comparisons.
_Fraction_fractionA = { value: new Fraction() };
_Fraction_fractionB = { value: new Fraction() };
/** Helper function to extract the numerator and denominator from another fraction. */
function getNumeratorAndDenominator(n, d = 1) {
    if (typeof n === 'number') {
        // Both params are numbers, so we return them as [numerator, denominator].
        return [n, d];
    }
    else {
        // First param is a Fraction object. We ignore the second param.
        return [n.numerator, n.denominator];
    }
}


/***/ }),

/***/ "./src/frethandfinger.ts":
/*!*******************************!*\
  !*** ./src/frethandfinger.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FretHandFinger: () => (/* binding */ FretHandFinger)
/* harmony export */ });
/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./metrics */ "./src/metrics.ts");
/* harmony import */ var _modifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifier */ "./src/modifier.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// @author Larry Kuhns 2013
// Class to draws string numbers into the notation.





class FretHandFinger extends _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_3__.Category.FretHandFinger;
    }
    // Arrange fingerings inside a ModifierContext.
    static format(nums, state) {
        const { leftShift, rightShift } = state;
        const numSpacing = 1;
        if (!nums || nums.length === 0)
            return false;
        const numsList = [];
        let prevNote = null;
        let shiftLeft = 0;
        let shiftRight = 0;
        for (let i = 0; i < nums.length; ++i) {
            const num = nums[i];
            const note = num.getNote();
            const pos = num.getPosition();
            const index = num.checkIndex();
            const props = note.getKeyProps()[index];
            const textHeight = _metrics__WEBPACK_IMPORTED_MODULE_0__.Metrics.get('FretHandFinger.fontSize');
            if (num.position === _modifier__WEBPACK_IMPORTED_MODULE_1__.ModifierPosition.ABOVE) {
                state.topTextLine += textHeight / _tables__WEBPACK_IMPORTED_MODULE_2__.Tables.STAVE_LINE_DISTANCE + 0.5;
            }
            if (num.position === _modifier__WEBPACK_IMPORTED_MODULE_1__.ModifierPosition.BELOW) {
                state.textLine += textHeight / _tables__WEBPACK_IMPORTED_MODULE_2__.Tables.STAVE_LINE_DISTANCE + 0.5;
            }
            if (note !== prevNote) {
                for (let n = 0; n < note.keys.length; ++n) {
                    if (leftShift === 0) {
                        shiftLeft = Math.max(note.getLeftDisplacedHeadPx(), shiftLeft);
                    }
                    if (rightShift === 0) {
                        shiftRight = Math.max(note.getRightDisplacedHeadPx(), shiftRight);
                    }
                }
                prevNote = note;
            }
            numsList.push({
                note,
                num,
                pos,
                line: props.line,
                shiftL: shiftLeft,
                shiftR: shiftRight,
            });
        }
        // Sort fingernumbers by line number.
        numsList.sort((a, b) => b.line - a.line);
        let numShiftL = 0;
        let numShiftR = 0;
        let xWidthL = 0;
        let xWidthR = 0;
        let lastLine = null;
        let lastNote = null;
        for (let i = 0; i < numsList.length; ++i) {
            let numShift = 0;
            const { note, pos, num, line, shiftL, shiftR } = numsList[i];
            // Reset the position of the string number every line.
            if (line !== lastLine || note !== lastNote) {
                numShiftL = leftShift + shiftL;
                numShiftR = rightShift + shiftR;
            }
            const numWidth = num.getWidth() + numSpacing;
            if (pos === _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.LEFT) {
                num.setXShift(leftShift + numShiftL);
                numShift = leftShift + numWidth; // spacing
                xWidthL = numShift > xWidthL ? numShift : xWidthL;
            }
            else if (pos === _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.RIGHT) {
                num.setXShift(numShiftR);
                numShift = shiftRight + numWidth; // spacing
                xWidthR = numShift > xWidthR ? numShift : xWidthR;
            }
            lastLine = line;
            lastNote = note;
        }
        state.leftShift += xWidthL;
        state.rightShift += xWidthR;
        return true;
    }
    static easyScoreHook({ fingerings } = {}, note, builder) {
        fingerings === null || fingerings === void 0 ? void 0 : fingerings.split(',').map((fingeringString) => {
            const split = fingeringString.trim().split('.');
            const params = { number: split[0] };
            if (split[1])
                params.position = split[1];
            return builder.getFactory().Fingering(params);
        }).map((fingering, index) => note.addModifier(fingering, index));
    }
    constructor(finger) {
        super();
        this.setFretHandFinger(finger);
        this.position = _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.LEFT; // Default position above stem or note head
        this.xOffset = 0; // Horizontal offset from default
        this.yOffset = 0; // Vertical offset from default
    }
    setFretHandFinger(finger) {
        this.text = finger;
        return this;
    }
    getFretHandFinger() {
        return this.text;
    }
    setOffsetX(x) {
        this.xOffset = x;
        return this;
    }
    setOffsetY(y) {
        this.yOffset = y;
        return this;
    }
    draw() {
        const ctx = this.checkContext();
        const note = this.checkAttachedNote();
        this.setRendered();
        const start = note.getModifierStartXY(this.position, this.index);
        let dotX = start.x + this.xOffset;
        let dotY = start.y + this.yOffset + 5;
        switch (this.position) {
            case _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.ABOVE:
                dotX -= 4;
                dotY -= 12;
                break;
            case _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.BELOW:
                dotX -= 2;
                dotY += 10;
                break;
            case _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.LEFT:
                dotX -= this.width;
                break;
            case _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.RIGHT:
                dotX += 1;
                break;
            default:
                throw new _util__WEBPACK_IMPORTED_MODULE_4__.RuntimeError('InvalidPosition', `The position ${this.position} does not exist`);
        }
        this.renderText(ctx, dotX, dotY);
    }
}


/***/ }),

/***/ "./src/ghostnote.ts":
/*!**************************!*\
  !*** ./src/ghostnote.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GhostNote: () => (/* binding */ GhostNote)
/* harmony export */ });
/* harmony import */ var _stemmablenote__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stemmablenote */ "./src/stemmablenote.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
//
// ## Description



const ERROR_MSG = 'Ghost note must have valid initialization data to identify duration.';
class GhostNote extends _stemmablenote__WEBPACK_IMPORTED_MODULE_0__.StemmableNote {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_1__.Category.GhostNote;
    }
    constructor(parameter) {
        if (!parameter) {
            throw new _util__WEBPACK_IMPORTED_MODULE_2__.RuntimeError('BadArguments', ERROR_MSG);
        }
        let noteStruct;
        if (typeof parameter === 'string') {
            // Preserve backwards-compatibility
            noteStruct = { duration: parameter };
        }
        else if (typeof parameter === 'object') {
            noteStruct = parameter;
        }
        else {
            throw new _util__WEBPACK_IMPORTED_MODULE_2__.RuntimeError('BadArguments', ERROR_MSG);
        }
        super(noteStruct);
        // Note properties
        this.setWidth(0);
    }
    /**
     * @returns true if this note is a type of rest. Rests don't have pitches, but take up space in the score.
     */
    isRest() {
        return true;
    }
    setStave(stave) {
        super.setStave(stave);
        return this;
    }
    /* Overridden to ignore */
    // eslint-disable-next-line
    addToModifierContext(mc) {
        // DO NOTHING.
        return this;
    }
    preFormat() {
        this.preFormatted = true;
        return this;
    }
    draw() {
        // Draw Annotations
        this.setRendered();
        for (let i = 0; i < this.modifiers.length; ++i) {
            const modifier = this.modifiers[i];
            if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_1__.isAnnotation)(modifier)) {
                modifier.setContext(this.getContext());
                modifier.drawWithStyle();
            }
        }
    }
}


/***/ }),

/***/ "./src/glyphnote.ts":
/*!**************************!*\
  !*** ./src/glyphnote.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlyphNote: () => (/* binding */ GlyphNote)
/* harmony export */ });
/* harmony import */ var _note__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./note */ "./src/note.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
//
// Any glyph that is set to appear on a Stave and take up musical time and graphical space.


class GlyphNote extends _note__WEBPACK_IMPORTED_MODULE_0__.Note {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_1__.Category.GlyphNote;
    }
    constructor(glyph, noteStruct, options) {
        super(noteStruct);
        this.options = Object.assign({ ignoreTicks: false, line: 2 }, options);
        // Note properties
        this.ignoreTicks = this.options.ignoreTicks;
        this.setGlyph(glyph);
    }
    setGlyph(glyph) {
        this.text = glyph;
        return this;
    }
    preFormat() {
        if (!this.preFormatted && this.modifierContext) {
            this.modifierContext.preFormat();
        }
        this.preFormatted = true;
        return this;
    }
    drawModifiers() {
        const ctx = this.checkContext();
        for (let i = 0; i < this.modifiers.length; i++) {
            const modifier = this.modifiers[i];
            modifier.setContext(ctx);
            modifier.drawWithStyle();
        }
    }
    draw() {
        const stave = this.checkStave();
        const ctx = stave.checkContext();
        this.setRendered();
        this.applyStyle(ctx);
        ctx.openGroup('glyphNote', this.getAttribute('id'));
        const x = this.isCenterAligned() ? this.getAbsoluteX() - this.getWidth() / 2 : this.getAbsoluteX();
        this.renderText(ctx, x, stave.getYForLine(this.options.line));
        this.drawModifiers();
        ctx.closeGroup();
        this.restoreStyle(ctx);
    }
}


/***/ }),

/***/ "./src/glyphs.ts":
/*!***********************!*\
  !*** ./src/glyphs.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Glyphs: () => (/* binding */ Glyphs)
/* harmony export */ });
// This file was generated by `glyph_codes.js'
// The enum includes all SMuFL glyphs, and a few others that VexFlow uses.
// See the list of SMuFL glyphs:
//   https://w3c.github.io/smufl/latest/tables/
//   https://raw.githubusercontent.com/w3c/smufl/gh-pages/metadata/glyphnames.json
// We renamed the two SMuFL names that start with a digit:
//   4stringTabClef => fourStringTabClef
//   6stringTabClef => sixStringTabClef
//
var Glyphs;
(function (Glyphs) {
    ////// SPECIAL GLYPHS ///////////////////////////////////////
    // Null character
    Glyphs["null"] = "\0";
    ////// SMuFL GLYPHS /////////////////////////////////////////
    // U+E06E  4-string tab clef
    Glyphs["fourStringTabClef"] = "\uE06E";
    // U+E06D  6-string tab clef
    Glyphs["sixStringTabClef"] = "\uE06D";
    // U+E30D  11 large diesis down, 3 down [46 EDO]
    Glyphs["accSagittal11LargeDiesisDown"] = "\uE30D";
    // U+E30C  11 large diesis up, (11L), (sharp less 11M), 3 up [46 EDO]
    Glyphs["accSagittal11LargeDiesisUp"] = "\uE30C";
    // U+E30B  11 medium diesis down, 1[17 31] 246 down, 1/4-tone down
    Glyphs["accSagittal11MediumDiesisDown"] = "\uE30B";
    // U+E30A  11 medium diesis up, (11M), 1[17 31] 246 up, 1/4-tone up
    Glyphs["accSagittal11MediumDiesisUp"] = "\uE30A";
    // U+E3AB  11:19 large diesis down
    Glyphs["accSagittal11v19LargeDiesisDown"] = "\uE3AB";
    // U+E3AA  11:19 large diesis up, (11:19L, apotome less 11:19M)
    Glyphs["accSagittal11v19LargeDiesisUp"] = "\uE3AA";
    // U+E3A3  11:19 medium diesis down
    Glyphs["accSagittal11v19MediumDiesisDown"] = "\uE3A3";
    // U+E3A2  11:19 medium diesis up, (11:19M, 11M plus 19s)
    Glyphs["accSagittal11v19MediumDiesisUp"] = "\uE3A2";
    // U+E397  11:49 comma down
    Glyphs["accSagittal11v49CommaDown"] = "\uE397";
    // U+E396  11:49 comma up, (11:49C, 11M less 49C)
    Glyphs["accSagittal11v49CommaUp"] = "\uE396";
    // U+E395  143 comma down
    Glyphs["accSagittal143CommaDown"] = "\uE395";
    // U+E394  143 comma up, (143C, 13L less 11M)
    Glyphs["accSagittal143CommaUp"] = "\uE394";
    // U+E343  17 comma down
    Glyphs["accSagittal17CommaDown"] = "\uE343";
    // U+E342  17 comma up, (17C)
    Glyphs["accSagittal17CommaUp"] = "\uE342";
    // U+E393  17 kleisma down
    Glyphs["accSagittal17KleismaDown"] = "\uE393";
    // U+E392  17 kleisma up, (17k)
    Glyphs["accSagittal17KleismaUp"] = "\uE392";
    // U+E399  19 comma down
    Glyphs["accSagittal19CommaDown"] = "\uE399";
    // U+E398  19 comma up, (19C)
    Glyphs["accSagittal19CommaUp"] = "\uE398";
    // U+E391  19 schisma down
    Glyphs["accSagittal19SchismaDown"] = "\uE391";
    // U+E390  19 schisma up, (19s)
    Glyphs["accSagittal19SchismaUp"] = "\uE390";
    // U+E3F5  1 mina down, 1/(5713)-schismina down, 0.42 cents down
    Glyphs["accSagittal1MinaDown"] = "\uE3F5";
    // U+E3F4  1 mina up, 1/(5713)-schismina up, 0.42 cents up
    Glyphs["accSagittal1MinaUp"] = "\uE3F4";
    // U+E3F9  1 tina down, 71119/5-schismina down, 0.17 cents down
    Glyphs["accSagittal1TinaDown"] = "\uE3F9";
    // U+E3F8  1 tina up, 71119/5-schismina up, 0.17 cents up
    Glyphs["accSagittal1TinaUp"] = "\uE3F8";
    // U+E371  23 comma down, 2 down [96 EDO], 1/8-tone down
    Glyphs["accSagittal23CommaDown"] = "\uE371";
    // U+E370  23 comma up, (23C), 2 up [96 EDO], 1/8-tone up
    Glyphs["accSagittal23CommaUp"] = "\uE370";
    // U+E39F  23 small diesis down
    Glyphs["accSagittal23SmallDiesisDown"] = "\uE39F";
    // U+E39E  23 small diesis up, (23S)
    Glyphs["accSagittal23SmallDiesisUp"] = "\uE39E";
    // U+E307  25 small diesis down, 2 down [53 EDO]
    Glyphs["accSagittal25SmallDiesisDown"] = "\uE307";
    // U+E306  25 small diesis up, (25S, ~5:13S, ~37S, 5C plus 5C), 2 up [53 EDO]
    Glyphs["accSagittal25SmallDiesisUp"] = "\uE306";
    // U+E3F7  2 minas down, 65/77-schismina down, 0.83 cents down
    Glyphs["accSagittal2MinasDown"] = "\uE3F7";
    // U+E3F6  2 minas up, 65/77-schismina up, 0.83 cents up
    Glyphs["accSagittal2MinasUp"] = "\uE3F6";
    // U+E3FB  2 tinas down, 1/(717)-schismina down, 0.30 cents down
    Glyphs["accSagittal2TinasDown"] = "\uE3FB";
    // U+E3FA  2 tinas up, 1/(717)-schismina up, 0.30 cents up
    Glyphs["accSagittal2TinasUp"] = "\uE3FA";
    // U+E30F  35 large diesis down, 2 down [50 EDO], 5/18-tone down
    Glyphs["accSagittal35LargeDiesisDown"] = "\uE30F";
    // U+E30E  35 large diesis up, (35L, ~13L, ~125L, sharp less 35M), 250 up
    Glyphs["accSagittal35LargeDiesisUp"] = "\uE30E";
    // U+E309  35 medium diesis down, 1[50] 2[27] down, 2/9-tone down
    Glyphs["accSagittal35MediumDiesisDown"] = "\uE309";
    // U+E308  35 medium diesis up, (35M, ~13M, ~125M, 5C plus 7C), 2/9-tone up
    Glyphs["accSagittal35MediumDiesisUp"] = "\uE308";
    // U+E3FD  3 tinas down, 1 mina down, 1/(5713)-schismina down, 0.42 cents down
    Glyphs["accSagittal3TinasDown"] = "\uE3FD";
    // U+E3FC  3 tinas up, 1 mina up, 1/(5713)-schismina up, 0.42 cents up
    Glyphs["accSagittal3TinasUp"] = "\uE3FC";
    // U+E3A9  49 large diesis down
    Glyphs["accSagittal49LargeDiesisDown"] = "\uE3A9";
    // U+E3A8  49 large diesis up, (49L, ~31L, apotome less 49M)
    Glyphs["accSagittal49LargeDiesisUp"] = "\uE3A8";
    // U+E3A5  49 medium diesis down
    Glyphs["accSagittal49MediumDiesisDown"] = "\uE3A5";
    // U+E3A4  49 medium diesis up, (49M, ~31M, 7C plus 7C)
    Glyphs["accSagittal49MediumDiesisUp"] = "\uE3A4";
    // U+E39D  49 small diesis down
    Glyphs["accSagittal49SmallDiesisDown"] = "\uE39D";
    // U+E39C  49 small diesis up, (49S, ~31S)
    Glyphs["accSagittal49SmallDiesisUp"] = "\uE39C";
    // U+E3FF  4 tinas down, 511/7-schismina down, 0.57 cents down
    Glyphs["accSagittal4TinasDown"] = "\uE3FF";
    // U+E3FE  4 tinas up, 511/7-schismina up, 0.57 cents up
    Glyphs["accSagittal4TinasUp"] = "\uE3FE";
    // U+E345  55 comma down, 3 down [96 EDO], 3/16-tone down
    Glyphs["accSagittal55CommaDown"] = "\uE345";
    // U+E344  55 comma up, (55C, 11M less 5C), 3up [96 EDO], 3/16-tone up
    Glyphs["accSagittal55CommaUp"] = "\uE344";
    // U+E303  5 comma down, 1 down [22 27 29 34 41 46 53 96 EDOs], 1/12-tone down
    Glyphs["accSagittal5CommaDown"] = "\uE303";
    // U+E302  5 comma up, (5C), 1 up [22 27 29 34 41 46 53 96 EDOs], 1/12-tone up
    Glyphs["accSagittal5CommaUp"] = "\uE302";
    // U+E401  5 tinas down, 7/25-schismina down, 0.72 cents down
    Glyphs["accSagittal5TinasDown"] = "\uE401";
    // U+E400  5 tinas up, 7/25-schismina up, 0.72 cents up
    Glyphs["accSagittal5TinasUp"] = "\uE400";
    // U+E349  5:11 small diesis down
    Glyphs["accSagittal5v11SmallDiesisDown"] = "\uE349";
    // U+E348  5:11 small diesis up, (5:11S, ~7:13S, ~11:17S, 5:7k plus 7:11C)
    Glyphs["accSagittal5v11SmallDiesisUp"] = "\uE348";
    // U+E3AD  5:13 large diesis down
    Glyphs["accSagittal5v13LargeDiesisDown"] = "\uE3AD";
    // U+E3AC  5:13 large diesis up, (5:13L, ~37L, apotome less 5:13M)
    Glyphs["accSagittal5v13LargeDiesisUp"] = "\uE3AC";
    // U+E3A1  5:13 medium diesis down
    Glyphs["accSagittal5v13MediumDiesisDown"] = "\uE3A1";
    // U+E3A0  5:13 medium diesis up, (5:13M, ~37M, 5C plus 13C)
    Glyphs["accSagittal5v13MediumDiesisUp"] = "\uE3A0";
    // U+E373  5:19 comma down, 1/20-tone down
    Glyphs["accSagittal5v19CommaDown"] = "\uE373";
    // U+E372  5:19 comma up, (5:19C, 5C plus 19s), 1/20-tone up
    Glyphs["accSagittal5v19CommaUp"] = "\uE372";
    // U+E375  5:23 small diesis down, 2 down [60 EDO], 1/5-tone down
    Glyphs["accSagittal5v23SmallDiesisDown"] = "\uE375";
    // U+E374  5:23 small diesis up, (5:23S, 5C plus 23C), 2 up [60 EDO], 1/5-tone up
    Glyphs["accSagittal5v23SmallDiesisUp"] = "\uE374";
    // U+E3A7  5:49 medium diesis down
    Glyphs["accSagittal5v49MediumDiesisDown"] = "\uE3A7";
    // U+E3A6  5:49 medium diesis up, (5:49M, half apotome)
    Glyphs["accSagittal5v49MediumDiesisUp"] = "\uE3A6";
    // U+E301  5:7 kleisma down
    Glyphs["accSagittal5v7KleismaDown"] = "\uE301";
    // U+E300  5:7 kleisma up, (5:7k, ~11:13k, 7C less 5C)
    Glyphs["accSagittal5v7KleismaUp"] = "\uE300";
    // U+E403  6 tinas down, 2 minas down, 65/77-schismina down, 0.83 cents down
    Glyphs["accSagittal6TinasDown"] = "\uE403";
    // U+E402  6 tinas up, 2 minas up, 65/77-schismina up, 0.83 cents up
    Glyphs["accSagittal6TinasUp"] = "\uE402";
    // U+E305  7 comma down, 1 down [43 EDO], 2 down [72 EDO], 1/6-tone down
    Glyphs["accSagittal7CommaDown"] = "\uE305";
    // U+E304  7 comma up, (7C), 1 up [43 EDO], 2 up [72 EDO], 1/6-tone up
    Glyphs["accSagittal7CommaUp"] = "\uE304";
    // U+E405  7 tinas down, 7/(517)-schismina down, 1.02 cents down
    Glyphs["accSagittal7TinasDown"] = "\uE405";
    // U+E404  7 tinas up, 7/(517)-schismina up, 1.02 cents up
    Glyphs["accSagittal7TinasUp"] = "\uE404";
    // U+E347  7:11 comma down, 1 down [60 EDO], 1/10-tone down
    Glyphs["accSagittal7v11CommaDown"] = "\uE347";
    // U+E346  7:11 comma up, (7:11C, ~13:17S, ~29S, 11L less 7C), 1 up [60 EDO]
    Glyphs["accSagittal7v11CommaUp"] = "\uE346";
    // U+E341  7:11 kleisma down
    Glyphs["accSagittal7v11KleismaDown"] = "\uE341";
    // U+E340  7:11 kleisma up, (7:11k, ~29k)
    Glyphs["accSagittal7v11KleismaUp"] = "\uE340";
    // U+E39B  7:19 comma down
    Glyphs["accSagittal7v19CommaDown"] = "\uE39B";
    // U+E39A  7:19 comma up, (7:19C, 7C less 19s)
    Glyphs["accSagittal7v19CommaUp"] = "\uE39A";
    // U+E407  8 tinas down, 1117/(57)-schismina down, 1.14 cents down
    Glyphs["accSagittal8TinasDown"] = "\uE407";
    // U+E406  8 tinas up, 1117/(57)-schismina up, 1.14 cents up
    Glyphs["accSagittal8TinasUp"] = "\uE406";
    // U+E409  9 tinas down, 1/(711)-schismina down, 1.26 cents down
    Glyphs["accSagittal9TinasDown"] = "\uE409";
    // U+E408  9 tinas up, 1/(711)-schismina up, 1.26 cents up
    Glyphs["accSagittal9TinasUp"] = "\uE408";
    // U+E3F2  Acute, 5 schisma up (5s), 2 cents up
    Glyphs["accSagittalAcute"] = "\uE3F2";
    // U+E335  Double flat, (2 apotomes down)[almost all EDOs], whole-tone down
    Glyphs["accSagittalDoubleFlat"] = "\uE335";
    // U+E3E9  Double flat 11:49C-up
    Glyphs["accSagittalDoubleFlat11v49CUp"] = "\uE3E9";
    // U+E3EB  Double flat 143C-up
    Glyphs["accSagittalDoubleFlat143CUp"] = "\uE3EB";
    // U+E365  Double flat 17C-up
    Glyphs["accSagittalDoubleFlat17CUp"] = "\uE365";
    // U+E3ED  Double flat 17k-up
    Glyphs["accSagittalDoubleFlat17kUp"] = "\uE3ED";
    // U+E3E7  Double flat 19C-up
    Glyphs["accSagittalDoubleFlat19CUp"] = "\uE3E7";
    // U+E3EF  Double flat 19s-up
    Glyphs["accSagittalDoubleFlat19sUp"] = "\uE3EF";
    // U+E387  Double flat 23C-up, 14 down [96 EDO], 7/8-tone down
    Glyphs["accSagittalDoubleFlat23CUp"] = "\uE387";
    // U+E3E1  Double flat 23S-up
    Glyphs["accSagittalDoubleFlat23SUp"] = "\uE3E1";
    // U+E32D  Double flat 25S-up, 8down [53 EDO]
    Glyphs["accSagittalDoubleFlat25SUp"] = "\uE32D";
    // U+E3E3  Double flat 49S-up
    Glyphs["accSagittalDoubleFlat49SUp"] = "\uE3E3";
    // U+E363  Double flat 55C-up, 13 down [96 EDO], 13/16-tone down
    Glyphs["accSagittalDoubleFlat55CUp"] = "\uE363";
    // U+E331  Double flat 5C-up, 5[22 29] 7[34 41] 953 down, 11/12 tone down
    Glyphs["accSagittalDoubleFlat5CUp"] = "\uE331";
    // U+E35F  Double flat 5:11S-up
    Glyphs["accSagittalDoubleFlat5v11SUp"] = "\uE35F";
    // U+E385  Double flat 5:19C-up, 19/20-tone down
    Glyphs["accSagittalDoubleFlat5v19CUp"] = "\uE385";
    // U+E383  Double flat 5:23S-up, 8 down [60 EDO], 4/5-tone down
    Glyphs["accSagittalDoubleFlat5v23SUp"] = "\uE383";
    // U+E333  Double flat 5:7k-up
    Glyphs["accSagittalDoubleFlat5v7kUp"] = "\uE333";
    // U+E32F  Double flat 7C-up, 5 down [43 EDO], 10 down [72 EDO], 5/6-tone down
    Glyphs["accSagittalDoubleFlat7CUp"] = "\uE32F";
    // U+E361  Double flat 7:11C-up, 9 down [60 EDO], 9/10-tone down
    Glyphs["accSagittalDoubleFlat7v11CUp"] = "\uE361";
    // U+E367  Double flat 7:11k-up
    Glyphs["accSagittalDoubleFlat7v11kUp"] = "\uE367";
    // U+E3E5  Double flat 7:19C-up
    Glyphs["accSagittalDoubleFlat7v19CUp"] = "\uE3E5";
    // U+E334  Double sharp, (2 apotomes up)[almost all EDOs], whole-tone up
    Glyphs["accSagittalDoubleSharp"] = "\uE334";
    // U+E3E8  Double sharp 11:49C-down
    Glyphs["accSagittalDoubleSharp11v49CDown"] = "\uE3E8";
    // U+E3EA  Double sharp 143C-down
    Glyphs["accSagittalDoubleSharp143CDown"] = "\uE3EA";
    // U+E364  Double sharp 17C-down
    Glyphs["accSagittalDoubleSharp17CDown"] = "\uE364";
    // U+E3EC  Double sharp 17k-down
    Glyphs["accSagittalDoubleSharp17kDown"] = "\uE3EC";
    // U+E3E6  Double sharp 19C-down
    Glyphs["accSagittalDoubleSharp19CDown"] = "\uE3E6";
    // U+E3EE  Double sharp 19s-down
    Glyphs["accSagittalDoubleSharp19sDown"] = "\uE3EE";
    // U+E386  Double sharp 23C-down, 14up [96 EDO], 7/8-tone up
    Glyphs["accSagittalDoubleSharp23CDown"] = "\uE386";
    // U+E3E0  Double sharp 23S-down
    Glyphs["accSagittalDoubleSharp23SDown"] = "\uE3E0";
    // U+E32C  Double sharp 25S-down, 8up [53 EDO]
    Glyphs["accSagittalDoubleSharp25SDown"] = "\uE32C";
    // U+E3E2  Double sharp 49S-down
    Glyphs["accSagittalDoubleSharp49SDown"] = "\uE3E2";
    // U+E362  Double sharp 55C-down, 13 up [96 EDO], 13/16-tone up
    Glyphs["accSagittalDoubleSharp55CDown"] = "\uE362";
    // U+E330  Double sharp 5C-down, 5[22 29] 7[34 41] 953 up, 11/12 tone up
    Glyphs["accSagittalDoubleSharp5CDown"] = "\uE330";
    // U+E35E  Double sharp 5:11S-down
    Glyphs["accSagittalDoubleSharp5v11SDown"] = "\uE35E";
    // U+E384  Double sharp 5:19C-down, 19/20-tone up
    Glyphs["accSagittalDoubleSharp5v19CDown"] = "\uE384";
    // U+E382  Double sharp 5:23S-down, 8 up [60 EDO], 4/5-tone up
    Glyphs["accSagittalDoubleSharp5v23SDown"] = "\uE382";
    // U+E332  Double sharp 5:7k-down
    Glyphs["accSagittalDoubleSharp5v7kDown"] = "\uE332";
    // U+E32E  Double sharp 7C-down, 5[43] 10[72] up, 5/6-tone up
    Glyphs["accSagittalDoubleSharp7CDown"] = "\uE32E";
    // U+E360  Double sharp 7:11C-down, 9 up [60 EDO], 9/10-tone up
    Glyphs["accSagittalDoubleSharp7v11CDown"] = "\uE360";
    // U+E366  Double sharp 7:11k-down
    Glyphs["accSagittalDoubleSharp7v11kDown"] = "\uE366";
    // U+E3E4  Double sharp 7:19C-down
    Glyphs["accSagittalDoubleSharp7v19CDown"] = "\uE3E4";
    // U+E319  Flat, (apotome down)[almost all EDOs], 1/2-tone down
    Glyphs["accSagittalFlat"] = "\uE319";
    // U+E329  Flat 11L-down, 8 up [46 EDO]
    Glyphs["accSagittalFlat11LDown"] = "\uE329";
    // U+E327  Flat 11M-down, 3 down [17 31 EDOs], 7 down [46 EDO], 3/4-tone down
    Glyphs["accSagittalFlat11MDown"] = "\uE327";
    // U+E3DB  Flat 11:19L-down
    Glyphs["accSagittalFlat11v19LDown"] = "\uE3DB";
    // U+E3D3  Flat 11:19M-down
    Glyphs["accSagittalFlat11v19MDown"] = "\uE3D3";
    // U+E3C7  Flat 11:49C-down
    Glyphs["accSagittalFlat11v49CDown"] = "\uE3C7";
    // U+E3B9  Flat 11:49C-up
    Glyphs["accSagittalFlat11v49CUp"] = "\uE3B9";
    // U+E3C5  Flat 143C-down
    Glyphs["accSagittalFlat143CDown"] = "\uE3C5";
    // U+E3BB  Flat 143C-up
    Glyphs["accSagittalFlat143CUp"] = "\uE3BB";
    // U+E357  Flat 17C-down
    Glyphs["accSagittalFlat17CDown"] = "\uE357";
    // U+E351  Flat 17C-up
    Glyphs["accSagittalFlat17CUp"] = "\uE351";
    // U+E3C3  Flat 17k-down
    Glyphs["accSagittalFlat17kDown"] = "\uE3C3";
    // U+E3BD  Flat 17k-up
    Glyphs["accSagittalFlat17kUp"] = "\uE3BD";
    // U+E3C9  Flat 19C-down
    Glyphs["accSagittalFlat19CDown"] = "\uE3C9";
    // U+E3B7  Flat 19C-up
    Glyphs["accSagittalFlat19CUp"] = "\uE3B7";
    // U+E3C1  Flat 19s-down
    Glyphs["accSagittalFlat19sDown"] = "\uE3C1";
    // U+E3BF  Flat 19s-up
    Glyphs["accSagittalFlat19sUp"] = "\uE3BF";
    // U+E37D  Flat 23C-down, 10 down [96 EDO], 5/8-tone down
    Glyphs["accSagittalFlat23CDown"] = "\uE37D";
    // U+E37B  Flat 23C-up, 6 down [96 EDO], 3/8-tone down
    Glyphs["accSagittalFlat23CUp"] = "\uE37B";
    // U+E3CF  Flat 23S-down
    Glyphs["accSagittalFlat23SDown"] = "\uE3CF";
    // U+E3B1  Flat 23S-up
    Glyphs["accSagittalFlat23SUp"] = "\uE3B1";
    // U+E323  Flat 25S-down, 7 down [53 EDO]
    Glyphs["accSagittalFlat25SDown"] = "\uE323";
    // U+E311  Flat 25S-up, 3 down [53 EDO]
    Glyphs["accSagittalFlat25SUp"] = "\uE311";
    // U+E32B  Flat 35L-down, 5 down [50 EDO]
    Glyphs["accSagittalFlat35LDown"] = "\uE32B";
    // U+E325  Flat 35M-down, 4 down [50 EDO], 6 down [27 EDO], 13/18-tone down
    Glyphs["accSagittalFlat35MDown"] = "\uE325";
    // U+E3D9  Flat 49L-down
    Glyphs["accSagittalFlat49LDown"] = "\uE3D9";
    // U+E3D5  Flat 49M-down
    Glyphs["accSagittalFlat49MDown"] = "\uE3D5";
    // U+E3CD  Flat 49S-down
    Glyphs["accSagittalFlat49SDown"] = "\uE3CD";
    // U+E3B3  Flat 49S-up
    Glyphs["accSagittalFlat49SUp"] = "\uE3B3";
    // U+E359  Flat 55C-down, 11 down [96 EDO], 11/16-tone down
    Glyphs["accSagittalFlat55CDown"] = "\uE359";
    // U+E34F  Flat 55C-up, 5 down [96 EDO], 5/16-tone down
    Glyphs["accSagittalFlat55CUp"] = "\uE34F";
    // U+E31F  Flat 5C-down, 4[22 29] 5[27 34 41] 6[39 46 53] down, 7/12-tone down
    Glyphs["accSagittalFlat5CDown"] = "\uE31F";
    // U+E315  Flat 5C-up, 2[22 29] 3[27 34 41] 4[39 46 53] 572 7[96] down, 5/12-tone down
    Glyphs["accSagittalFlat5CUp"] = "\uE315";
    // U+E35D  Flat 5:11S-down
    Glyphs["accSagittalFlat5v11SDown"] = "\uE35D";
    // U+E34B  Flat 5:11S-up
    Glyphs["accSagittalFlat5v11SUp"] = "\uE34B";
    // U+E3DD  Flat 5:13L-down
    Glyphs["accSagittalFlat5v13LDown"] = "\uE3DD";
    // U+E3D1  Flat 5:13M-down
    Glyphs["accSagittalFlat5v13MDown"] = "\uE3D1";
    // U+E37F  Flat 5:19C-down, 11/20-tone down
    Glyphs["accSagittalFlat5v19CDown"] = "\uE37F";
    // U+E379  Flat 5:19C-up, 9/20-tone down
    Glyphs["accSagittalFlat5v19CUp"] = "\uE379";
    // U+E381  Flat 5:23S-down, 7 down [60 EDO], 7/10-tone down
    Glyphs["accSagittalFlat5v23SDown"] = "\uE381";
    // U+E377  Flat 5:23S-up, 3 down [60 EDO], 3/10-tone down
    Glyphs["accSagittalFlat5v23SUp"] = "\uE377";
    // U+E3D7  Flat 5:49M-down
    Glyphs["accSagittalFlat5v49MDown"] = "\uE3D7";
    // U+E31D  Flat 5:7k-down
    Glyphs["accSagittalFlat5v7kDown"] = "\uE31D";
    // U+E317  Flat 5:7k-up
    Glyphs["accSagittalFlat5v7kUp"] = "\uE317";
    // U+E321  Flat 7C-down, 4 down [43 EDO], 8 down [72 EDO], 2/3-tone down
    Glyphs["accSagittalFlat7CDown"] = "\uE321";
    // U+E313  Flat 7C-up, 2 down [43 EDO], 4 down [72 EDO], 1/3-tone down
    Glyphs["accSagittalFlat7CUp"] = "\uE313";
    // U+E35B  Flat 7:11C-down, 6 down [60 EDO], 3/5- tone down
    Glyphs["accSagittalFlat7v11CDown"] = "\uE35B";
    // U+E34D  Flat 7:11C-up, 4 down [60 EDO], 2/5-tone down
    Glyphs["accSagittalFlat7v11CUp"] = "\uE34D";
    // U+E355  Flat 7:11k-down
    Glyphs["accSagittalFlat7v11kDown"] = "\uE355";
    // U+E353  Flat 7:11k-up
    Glyphs["accSagittalFlat7v11kUp"] = "\uE353";
    // U+E3CB  Flat 7:19C-down
    Glyphs["accSagittalFlat7v19CDown"] = "\uE3CB";
    // U+E3B5  Flat 7:19C-up
    Glyphs["accSagittalFlat7v19CUp"] = "\uE3B5";
    // U+E40B  Fractional tina down, 77/(537)-schismina down, 0.08 cents down
    Glyphs["accSagittalFractionalTinaDown"] = "\uE40B";
    // U+E40A  Fractional tina up, 77/(537)-schismina up, 0.08 cents up
    Glyphs["accSagittalFractionalTinaUp"] = "\uE40A";
    // U+E3F3  Grave, 5 schisma down, 2 cents down
    Glyphs["accSagittalGrave"] = "\uE3F3";
    // U+E3F1  Shaft down, (natural for use with only diacritics down)
    Glyphs["accSagittalShaftDown"] = "\uE3F1";
    // U+E3F0  Shaft up, (natural for use with only diacritics up)
    Glyphs["accSagittalShaftUp"] = "\uE3F0";
    // U+E318  Sharp, (apotome up)[almost all EDOs], 1/2-tone up
    Glyphs["accSagittalSharp"] = "\uE318";
    // U+E328  Sharp 11L-up, 8 up [46 EDO]
    Glyphs["accSagittalSharp11LUp"] = "\uE328";
    // U+E326  Sharp 11M-up, 3 up [17 31 EDOs], 7 up [46 EDO], 3/4-tone up
    Glyphs["accSagittalSharp11MUp"] = "\uE326";
    // U+E3DA  Sharp 11:19L-up
    Glyphs["accSagittalSharp11v19LUp"] = "\uE3DA";
    // U+E3D2  Sharp 11:19M-up
    Glyphs["accSagittalSharp11v19MUp"] = "\uE3D2";
    // U+E3B8  Sharp 11:49C-down
    Glyphs["accSagittalSharp11v49CDown"] = "\uE3B8";
    // U+E3C6  Sharp 11:49C-up
    Glyphs["accSagittalSharp11v49CUp"] = "\uE3C6";
    // U+E3BA  Sharp 143C-down
    Glyphs["accSagittalSharp143CDown"] = "\uE3BA";
    // U+E3C4  Sharp 143C-up
    Glyphs["accSagittalSharp143CUp"] = "\uE3C4";
    // U+E350  Sharp 17C-down
    Glyphs["accSagittalSharp17CDown"] = "\uE350";
    // U+E356  Sharp 17C-up
    Glyphs["accSagittalSharp17CUp"] = "\uE356";
    // U+E3BC  Sharp 17k-down
    Glyphs["accSagittalSharp17kDown"] = "\uE3BC";
    // U+E3C2  Sharp 17k-up
    Glyphs["accSagittalSharp17kUp"] = "\uE3C2";
    // U+E3B6  Sharp 19C-down
    Glyphs["accSagittalSharp19CDown"] = "\uE3B6";
    // U+E3C8  Sharp 19C-up
    Glyphs["accSagittalSharp19CUp"] = "\uE3C8";
    // U+E3BE  Sharp 19s-down
    Glyphs["accSagittalSharp19sDown"] = "\uE3BE";
    // U+E3C0  Sharp 19s-up
    Glyphs["accSagittalSharp19sUp"] = "\uE3C0";
    // U+E37A  Sharp 23C-down, 6 up [96 EDO], 3/8-tone up
    Glyphs["accSagittalSharp23CDown"] = "\uE37A";
    // U+E37C  Sharp 23C-up, 10 up [96 EDO], 5/8-tone up
    Glyphs["accSagittalSharp23CUp"] = "\uE37C";
    // U+E3B0  Sharp 23S-down
    Glyphs["accSagittalSharp23SDown"] = "\uE3B0";
    // U+E3CE  Sharp 23S-up
    Glyphs["accSagittalSharp23SUp"] = "\uE3CE";
    // U+E310  Sharp 25S-down, 3 up [53 EDO]
    Glyphs["accSagittalSharp25SDown"] = "\uE310";
    // U+E322  Sharp 25S-up, 7 up [53 EDO]
    Glyphs["accSagittalSharp25SUp"] = "\uE322";
    // U+E32A  Sharp 35L-up, 5 up [50 EDO]
    Glyphs["accSagittalSharp35LUp"] = "\uE32A";
    // U+E324  Sharp 35M-up, 4 up [50 EDO], 6 up [27 EDO], 13/18-tone up
    Glyphs["accSagittalSharp35MUp"] = "\uE324";
    // U+E3D8  Sharp 49L-up
    Glyphs["accSagittalSharp49LUp"] = "\uE3D8";
    // U+E3D4  Sharp 49M-up
    Glyphs["accSagittalSharp49MUp"] = "\uE3D4";
    // U+E3B2  Sharp 49S-down
    Glyphs["accSagittalSharp49SDown"] = "\uE3B2";
    // U+E3CC  Sharp 49S-up
    Glyphs["accSagittalSharp49SUp"] = "\uE3CC";
    // U+E34E  Sharp 55C-down, 5 up [96 EDO], 5/16-tone up
    Glyphs["accSagittalSharp55CDown"] = "\uE34E";
    // U+E358  Sharp 55C-up, 11 up [96 EDO], 11/16-tone up
    Glyphs["accSagittalSharp55CUp"] = "\uE358";
    // U+E314  Sharp 5C-down, 2[22 29] 3[27 34 41] 4[39 46 53] 5[72] 7[96] up, 5/12-tone up
    Glyphs["accSagittalSharp5CDown"] = "\uE314";
    // U+E31E  Sharp 5C-up, 4[22 29] 5[27 34 41] 6[39 46 53] up, 7/12-tone up
    Glyphs["accSagittalSharp5CUp"] = "\uE31E";
    // U+E34A  Sharp 5:11S-down
    Glyphs["accSagittalSharp5v11SDown"] = "\uE34A";
    // U+E35C  Sharp 5:11S-up
    Glyphs["accSagittalSharp5v11SUp"] = "\uE35C";
    // U+E3DC  Sharp 5:13L-up
    Glyphs["accSagittalSharp5v13LUp"] = "\uE3DC";
    // U+E3D0  Sharp 5:13M-up
    Glyphs["accSagittalSharp5v13MUp"] = "\uE3D0";
    // U+E378  Sharp 5:19C-down, 9/20-tone up
    Glyphs["accSagittalSharp5v19CDown"] = "\uE378";
    // U+E37E  Sharp 5:19C-up, 11/20-tone up
    Glyphs["accSagittalSharp5v19CUp"] = "\uE37E";
    // U+E376  Sharp 5:23S-down, 3 up [60 EDO], 3/10-tone up
    Glyphs["accSagittalSharp5v23SDown"] = "\uE376";
    // U+E380  Sharp 5:23S-up, 7 up [60 EDO], 7/10-tone up
    Glyphs["accSagittalSharp5v23SUp"] = "\uE380";
    // U+E3D6  Sharp 5:49M-up, (one and a half apotomes)
    Glyphs["accSagittalSharp5v49MUp"] = "\uE3D6";
    // U+E316  Sharp 5:7k-down
    Glyphs["accSagittalSharp5v7kDown"] = "\uE316";
    // U+E31C  Sharp 5:7k-up
    Glyphs["accSagittalSharp5v7kUp"] = "\uE31C";
    // U+E312  Sharp 7C-down, 2 up [43 EDO], 4 up [72 EDO], 1/3-tone up
    Glyphs["accSagittalSharp7CDown"] = "\uE312";
    // U+E320  Sharp 7C-up, 4 up [43 EDO], 8 up [72 EDO], 2/3-tone up
    Glyphs["accSagittalSharp7CUp"] = "\uE320";
    // U+E34C  Sharp 7:11C-down, 4 up [60 EDO], 2/5-tone up
    Glyphs["accSagittalSharp7v11CDown"] = "\uE34C";
    // U+E35A  Sharp 7:11C-up, 6 up [60 EDO], 3/5- tone up
    Glyphs["accSagittalSharp7v11CUp"] = "\uE35A";
    // U+E352  Sharp 7:11k-down
    Glyphs["accSagittalSharp7v11kDown"] = "\uE352";
    // U+E354  Sharp 7:11k-up
    Glyphs["accSagittalSharp7v11kUp"] = "\uE354";
    // U+E3B4  Sharp 7:19C-down
    Glyphs["accSagittalSharp7v19CDown"] = "\uE3B4";
    // U+E3CA  Sharp 7:19C-up
    Glyphs["accSagittalSharp7v19CUp"] = "\uE3CA";
    // U+E31A  Unused
    Glyphs["accSagittalUnused1"] = "\uE31A";
    // U+E31B  Unused
    Glyphs["accSagittalUnused2"] = "\uE31B";
    // U+E3DE  Unused
    Glyphs["accSagittalUnused3"] = "\uE3DE";
    // U+E3DF  Unused
    Glyphs["accSagittalUnused4"] = "\uE3DF";
    // U+E8CA  Combining accordion coupler dot
    Glyphs["accdnCombDot"] = "\uE8CA";
    // U+E8C8  Combining left hand, 2 ranks, empty
    Glyphs["accdnCombLH2RanksEmpty"] = "\uE8C8";
    // U+E8C9  Combining left hand, 3 ranks, empty (square)
    Glyphs["accdnCombLH3RanksEmptySquare"] = "\uE8C9";
    // U+E8C6  Combining right hand, 3 ranks, empty
    Glyphs["accdnCombRH3RanksEmpty"] = "\uE8C6";
    // U+E8C7  Combining right hand, 4 ranks, empty
    Glyphs["accdnCombRH4RanksEmpty"] = "\uE8C7";
    // U+E079  Diatonic accordion clef
    Glyphs["accdnDiatonicClef"] = "\uE079";
    // U+E8BC  Left hand, 2 ranks, 16' stop (round)
    Glyphs["accdnLH2Ranks16Round"] = "\uE8BC";
    // U+E8BD  Left hand, 2 ranks, 8' stop + 16' stop (round)
    Glyphs["accdnLH2Ranks8Plus16Round"] = "\uE8BD";
    // U+E8BB  Left hand, 2 ranks, 8' stop (round)
    Glyphs["accdnLH2Ranks8Round"] = "\uE8BB";
    // U+E8C0  Left hand, 2 ranks, full master (round)
    Glyphs["accdnLH2RanksFullMasterRound"] = "\uE8C0";
    // U+E8BF  Left hand, 2 ranks, master + 16' stop (round)
    Glyphs["accdnLH2RanksMasterPlus16Round"] = "\uE8BF";
    // U+E8BE  Left hand, 2 ranks, master (round)
    Glyphs["accdnLH2RanksMasterRound"] = "\uE8BE";
    // U+E8C4  Left hand, 3 ranks, 2' stop + 8' stop (square)
    Glyphs["accdnLH3Ranks2Plus8Square"] = "\uE8C4";
    // U+E8C2  Left hand, 3 ranks, 2' stop (square)
    Glyphs["accdnLH3Ranks2Square"] = "\uE8C2";
    // U+E8C1  Left hand, 3 ranks, 8' stop (square)
    Glyphs["accdnLH3Ranks8Square"] = "\uE8C1";
    // U+E8C3  Left hand, 3 ranks, double 8' stop (square)
    Glyphs["accdnLH3RanksDouble8Square"] = "\uE8C3";
    // U+E8C5  Left hand, 3 ranks, 2' stop + double 8' stop (tutti) (square)
    Glyphs["accdnLH3RanksTuttiSquare"] = "\uE8C5";
    // U+E8CC  Pull
    Glyphs["accdnPull"] = "\uE8CC";
    // U+E8CB  Push
    Glyphs["accdnPush"] = "\uE8CB";
    // U+E8AC  Right hand, 3 ranks, 8' stop + upper tremolo 8' stop + 16' stop (accordion)
    Glyphs["accdnRH3RanksAccordion"] = "\uE8AC";
    // U+E8A8  Right hand, 3 ranks, lower tremolo 8' stop + 8' stop + upper tremolo 8' stop (authentic musette)
    Glyphs["accdnRH3RanksAuthenticMusette"] = "\uE8A8";
    // U+E8AB  Right hand, 3 ranks, 8' stop + 16' stop (bandonen)
    Glyphs["accdnRH3RanksBandoneon"] = "\uE8AB";
    // U+E8A4  Right hand, 3 ranks, 16' stop (bassoon)
    Glyphs["accdnRH3RanksBassoon"] = "\uE8A4";
    // U+E8A1  Right hand, 3 ranks, 8' stop (clarinet)
    Glyphs["accdnRH3RanksClarinet"] = "\uE8A1";
    // U+E8B1  Right hand, 3 ranks, lower tremolo 8' stop + 8' stop + upper tremolo 8' stop + 16' stop
    Glyphs["accdnRH3RanksDoubleTremoloLower8ve"] = "\uE8B1";
    // U+E8B2  Right hand, 3 ranks, 4' stop + lower tremolo 8' stop + 8' stop + upper tremolo 8' stop
    Glyphs["accdnRH3RanksDoubleTremoloUpper8ve"] = "\uE8B2";
    // U+E8B3  Right hand, 3 ranks, 4' stop + lower tremolo 8' stop + 8' stop + upper tremolo 8' stop + 16' stop
    Glyphs["accdnRH3RanksFullFactory"] = "\uE8B3";
    // U+E8AA  Right hand, 3 ranks, 4' stop + 8' stop + 16' stop (harmonium)
    Glyphs["accdnRH3RanksHarmonium"] = "\uE8AA";
    // U+E8A7  Right hand, 3 ranks, 4' stop + 8' stop + upper tremolo 8' stop (imitation musette)
    Glyphs["accdnRH3RanksImitationMusette"] = "\uE8A7";
    // U+E8A3  Right hand, 3 ranks, lower tremolo 8' stop
    Glyphs["accdnRH3RanksLowerTremolo8"] = "\uE8A3";
    // U+E8AD  Right hand, 3 ranks, 4' stop + lower tremolo 8' stop + upper tremolo 8' stop + 16' stop (master)
    Glyphs["accdnRH3RanksMaster"] = "\uE8AD";
    // U+E8A5  Right hand, 3 ranks, 4' stop + 8' stop (oboe)
    Glyphs["accdnRH3RanksOboe"] = "\uE8A5";
    // U+E8A9  Right hand, 3 ranks, 4' stop + 16' stop (organ)
    Glyphs["accdnRH3RanksOrgan"] = "\uE8A9";
    // U+E8A0  Right hand, 3 ranks, 4' stop (piccolo)
    Glyphs["accdnRH3RanksPiccolo"] = "\uE8A0";
    // U+E8AF  Right hand, 3 ranks, lower tremolo 8' stop + upper tremolo 8' stop + 16' stop
    Glyphs["accdnRH3RanksTremoloLower8ve"] = "\uE8AF";
    // U+E8B0  Right hand, 3 ranks, 4' stop + lower tremolo 8' stop + upper tremolo 8' stop
    Glyphs["accdnRH3RanksTremoloUpper8ve"] = "\uE8B0";
    // U+E8AE  Right hand, 3 ranks, lower tremolo 8' stop + upper tremolo 8' stop
    Glyphs["accdnRH3RanksTwoChoirs"] = "\uE8AE";
    // U+E8A2  Right hand, 3 ranks, upper tremolo 8' stop
    Glyphs["accdnRH3RanksUpperTremolo8"] = "\uE8A2";
    // U+E8A6  Right hand, 3 ranks, 8' stop + upper tremolo 8' stop (violin)
    Glyphs["accdnRH3RanksViolin"] = "\uE8A6";
    // U+E8B5  Right hand, 4 ranks, alto
    Glyphs["accdnRH4RanksAlto"] = "\uE8B5";
    // U+E8BA  Right hand, 4 ranks, bass/alto
    Glyphs["accdnRH4RanksBassAlto"] = "\uE8BA";
    // U+E8B7  Right hand, 4 ranks, master
    Glyphs["accdnRH4RanksMaster"] = "\uE8B7";
    // U+E8B8  Right hand, 4 ranks, soft bass
    Glyphs["accdnRH4RanksSoftBass"] = "\uE8B8";
    // U+E8B9  Right hand, 4 ranks, soft tenor
    Glyphs["accdnRH4RanksSoftTenor"] = "\uE8B9";
    // U+E8B4  Right hand, 4 ranks, soprano
    Glyphs["accdnRH4RanksSoprano"] = "\uE8B4";
    // U+E8B6  Right hand, 4 ranks, tenor
    Glyphs["accdnRH4RanksTenor"] = "\uE8B6";
    // U+E8CD  Ricochet (2 tones)
    Glyphs["accdnRicochet2"] = "\uE8CD";
    // U+E8CE  Ricochet (3 tones)
    Glyphs["accdnRicochet3"] = "\uE8CE";
    // U+E8CF  Ricochet (4 tones)
    Glyphs["accdnRicochet4"] = "\uE8CF";
    // U+E8D0  Ricochet (5 tones)
    Glyphs["accdnRicochet5"] = "\uE8D0";
    // U+E8D1  Ricochet (6 tones)
    Glyphs["accdnRicochet6"] = "\uE8D1";
    // U+E8D2  Combining ricochet for stem (2 tones)
    Glyphs["accdnRicochetStem2"] = "\uE8D2";
    // U+E8D3  Combining ricochet for stem (3 tones)
    Glyphs["accdnRicochetStem3"] = "\uE8D3";
    // U+E8D4  Combining ricochet for stem (4 tones)
    Glyphs["accdnRicochetStem4"] = "\uE8D4";
    // U+E8D5  Combining ricochet for stem (5 tones)
    Glyphs["accdnRicochetStem5"] = "\uE8D5";
    // U+E8D6  Combining ricochet for stem (6 tones)
    Glyphs["accdnRicochetStem6"] = "\uE8D6";
    // U+E454  1-comma flat
    Glyphs["accidental1CommaFlat"] = "\uE454";
    // U+E450  1-comma sharp
    Glyphs["accidental1CommaSharp"] = "\uE450";
    // U+E455  2-comma flat
    Glyphs["accidental2CommaFlat"] = "\uE455";
    // U+E451  2-comma sharp
    Glyphs["accidental2CommaSharp"] = "\uE451";
    // U+E456  3-comma flat
    Glyphs["accidental3CommaFlat"] = "\uE456";
    // U+E452  3-comma sharp
    Glyphs["accidental3CommaSharp"] = "\uE452";
    // U+E457  4-comma flat
    Glyphs["accidental4CommaFlat"] = "\uE457";
    // U+E453  5-comma sharp
    Glyphs["accidental5CommaSharp"] = "\uE453";
    // U+E27B  Arrow down (lower by one quarter-tone)
    Glyphs["accidentalArrowDown"] = "\uE27B";
    // U+E27A  Arrow up (raise by one quarter-tone)
    Glyphs["accidentalArrowUp"] = "\uE27A";
    // U+E442  Bakiye (flat)
    Glyphs["accidentalBakiyeFlat"] = "\uE442";
    // U+E445  Bakiye (sharp)
    Glyphs["accidentalBakiyeSharp"] = "\uE445";
    // U+E26C  Accidental bracket, left
    Glyphs["accidentalBracketLeft"] = "\uE26C";
    // U+E26D  Accidental bracket, right
    Glyphs["accidentalBracketRight"] = "\uE26D";
    // U+E440  Byk mcenneb (flat)
    Glyphs["accidentalBuyukMucennebFlat"] = "\uE440";
    // U+E447  Byk mcenneb (sharp)
    Glyphs["accidentalBuyukMucennebSharp"] = "\uE447";
    // U+E2EF  Combining close curly brace
    Glyphs["accidentalCombiningCloseCurlyBrace"] = "\uE2EF";
    // U+E2E6  Combining lower by one 17-limit schisma
    Glyphs["accidentalCombiningLower17Schisma"] = "\uE2E6";
    // U+E2E8  Combining lower by one 19-limit schisma
    Glyphs["accidentalCombiningLower19Schisma"] = "\uE2E8";
    // U+E2EA  Combining lower by one 23-limit comma
    Glyphs["accidentalCombiningLower23Limit29LimitComma"] = "\uE2EA";
    // U+EE50  Combining lower by one 29-limit comma
    Glyphs["accidentalCombiningLower29LimitComma"] = "\uEE50";
    // U+E2EC  Combining lower by one 31-limit schisma
    Glyphs["accidentalCombiningLower31Schisma"] = "\uE2EC";
    // U+EE52  Combining lower by one 37-limit quartertone
    Glyphs["accidentalCombiningLower37Quartertone"] = "\uEE52";
    // U+EE54  Combining lower by one 41-limit comma
    Glyphs["accidentalCombiningLower41Comma"] = "\uEE54";
    // U+EE56  Combining lower by one 43-limit comma
    Glyphs["accidentalCombiningLower43Comma"] = "\uEE56";
    // U+EE58  Combining lower by one 47-limit quartertone
    Glyphs["accidentalCombiningLower47Quartertone"] = "\uEE58";
    // U+E2F7  Combining lower by one 53-limit comma
    Glyphs["accidentalCombiningLower53LimitComma"] = "\uE2F7";
    // U+E2EE  Combining open curly brace
    Glyphs["accidentalCombiningOpenCurlyBrace"] = "\uE2EE";
    // U+E2E7  Combining raise by one 17-limit schisma
    Glyphs["accidentalCombiningRaise17Schisma"] = "\uE2E7";
    // U+E2E9  Combining raise by one 19-limit schisma
    Glyphs["accidentalCombiningRaise19Schisma"] = "\uE2E9";
    // U+E2EB  Combining raise by one 23-limit comma
    Glyphs["accidentalCombiningRaise23Limit29LimitComma"] = "\uE2EB";
    // U+EE51  Combining raise by one 29-limit comma
    Glyphs["accidentalCombiningRaise29LimitComma"] = "\uEE51";
    // U+E2ED  Combining raise by one 31-limit schisma
    Glyphs["accidentalCombiningRaise31Schisma"] = "\uE2ED";
    // U+EE53  Combining raise by one 37-limit quartertone
    Glyphs["accidentalCombiningRaise37Quartertone"] = "\uEE53";
    // U+EE55  Combining raise by one 41-limit comma
    Glyphs["accidentalCombiningRaise41Comma"] = "\uEE55";
    // U+EE57  Combining raise by one 43-limit comma
    Glyphs["accidentalCombiningRaise43Comma"] = "\uEE57";
    // U+EE59  Combining raise by one 47-limit quartertone
    Glyphs["accidentalCombiningRaise47Quartertone"] = "\uEE59";
    // U+E2F8  Combining raise by one 53-limit comma
    Glyphs["accidentalCombiningRaise53LimitComma"] = "\uE2F8";
    // U+E47A  Syntonic/Didymus comma (80:81) down (Bosanquet)
    Glyphs["accidentalCommaSlashDown"] = "\uE47A";
    // U+E479  Syntonic/Didymus comma (80:81) up (Bosanquet)
    Glyphs["accidentalCommaSlashUp"] = "\uE479";
    // U+E264  Double flat
    Glyphs["accidentalDoubleFlat"] = "\uE264";
    // U+ED30  Arabic double flat
    Glyphs["accidentalDoubleFlatArabic"] = "\uED30";
    // U+E2F0  Double flat equal tempered semitone
    Glyphs["accidentalDoubleFlatEqualTempered"] = "\uE2F0";
    // U+E2C0  Double flat lowered by one syntonic comma
    Glyphs["accidentalDoubleFlatOneArrowDown"] = "\uE2C0";
    // U+E2C5  Double flat raised by one syntonic comma
    Glyphs["accidentalDoubleFlatOneArrowUp"] = "\uE2C5";
    // U+E483  Reversed double flat
    Glyphs["accidentalDoubleFlatReversed"] = "\uE483";
    // U+E2D4  Double flat lowered by three syntonic commas
    Glyphs["accidentalDoubleFlatThreeArrowsDown"] = "\uE2D4";
    // U+E2D9  Double flat raised by three syntonic commas
    Glyphs["accidentalDoubleFlatThreeArrowsUp"] = "\uE2D9";
    // U+E485  Turned double flat
    Glyphs["accidentalDoubleFlatTurned"] = "\uE485";
    // U+E2CA  Double flat lowered by two syntonic commas
    Glyphs["accidentalDoubleFlatTwoArrowsDown"] = "\uE2CA";
    // U+E2CF  Double flat raised by two syntonic commas
    Glyphs["accidentalDoubleFlatTwoArrowsUp"] = "\uE2CF";
    // U+E263  Double sharp
    Glyphs["accidentalDoubleSharp"] = "\uE263";
    // U+ED38  Arabic double sharp
    Glyphs["accidentalDoubleSharpArabic"] = "\uED38";
    // U+E2F4  Double sharp equal tempered semitone
    Glyphs["accidentalDoubleSharpEqualTempered"] = "\uE2F4";
    // U+E2C4  Double sharp lowered by one syntonic comma
    Glyphs["accidentalDoubleSharpOneArrowDown"] = "\uE2C4";
    // U+E2C9  Double sharp raised by one syntonic comma
    Glyphs["accidentalDoubleSharpOneArrowUp"] = "\uE2C9";
    // U+E2D8  Double sharp lowered by three syntonic commas
    Glyphs["accidentalDoubleSharpThreeArrowsDown"] = "\uE2D8";
    // U+E2DD  Double sharp raised by three syntonic commas
    Glyphs["accidentalDoubleSharpThreeArrowsUp"] = "\uE2DD";
    // U+E2CE  Double sharp lowered by two syntonic commas
    Glyphs["accidentalDoubleSharpTwoArrowsDown"] = "\uE2CE";
    // U+E2D3  Double sharp raised by two syntonic commas
    Glyphs["accidentalDoubleSharpTwoArrowsUp"] = "\uE2D3";
    // U+E2FA  Enharmonically reinterpret accidental almost equal to
    Glyphs["accidentalEnharmonicAlmostEqualTo"] = "\uE2FA";
    // U+E2FB  Enharmonically reinterpret accidental equals
    Glyphs["accidentalEnharmonicEquals"] = "\uE2FB";
    // U+E2F9  Enharmonically reinterpret accidental tilde
    Glyphs["accidentalEnharmonicTilde"] = "\uE2F9";
    // U+E296  Filled reversed flat and flat
    Glyphs["accidentalFilledReversedFlatAndFlat"] = "\uE296";
    // U+E298  Filled reversed flat and flat with arrow down
    Glyphs["accidentalFilledReversedFlatAndFlatArrowDown"] = "\uE298";
    // U+E297  Filled reversed flat and flat with arrow up
    Glyphs["accidentalFilledReversedFlatAndFlatArrowUp"] = "\uE297";
    // U+E293  Filled reversed flat with arrow down
    Glyphs["accidentalFilledReversedFlatArrowDown"] = "\uE293";
    // U+E292  Filled reversed flat with arrow up
    Glyphs["accidentalFilledReversedFlatArrowUp"] = "\uE292";
    // U+E279  Five-quarter-tones flat
    Glyphs["accidentalFiveQuarterTonesFlatArrowDown"] = "\uE279";
    // U+E276  Five-quarter-tones sharp
    Glyphs["accidentalFiveQuarterTonesSharpArrowUp"] = "\uE276";
    // U+E260  Flat
    Glyphs["accidentalFlat"] = "\uE260";
    // U+ED32  Arabic half-tone flat
    Glyphs["accidentalFlatArabic"] = "\uED32";
    // U+E2F1  Flat equal tempered semitone
    Glyphs["accidentalFlatEqualTempered"] = "\uE2F1";
    // U+ED53  Lowered flat (Stockhausen)
    Glyphs["accidentalFlatLoweredStockhausen"] = "\uED53";
    // U+E2C1  Flat lowered by one syntonic comma
    Glyphs["accidentalFlatOneArrowDown"] = "\uE2C1";
    // U+E2C6  Flat raised by one syntonic comma
    Glyphs["accidentalFlatOneArrowUp"] = "\uE2C6";
    // U+ED52  Raised flat (Stockhausen)
    Glyphs["accidentalFlatRaisedStockhausen"] = "\uED52";
    // U+ED5C  Repeated flat, note on line (Stockhausen)
    Glyphs["accidentalFlatRepeatedLineStockhausen"] = "\uED5C";
    // U+ED5B  Repeated flat, note in space (Stockhausen)
    Glyphs["accidentalFlatRepeatedSpaceStockhausen"] = "\uED5B";
    // U+E2D5  Flat lowered by three syntonic commas
    Glyphs["accidentalFlatThreeArrowsDown"] = "\uE2D5";
    // U+E2DA  Flat raised by three syntonic commas
    Glyphs["accidentalFlatThreeArrowsUp"] = "\uE2DA";
    // U+E484  Turned flat
    Glyphs["accidentalFlatTurned"] = "\uE484";
    // U+E2CB  Flat lowered by two syntonic commas
    Glyphs["accidentalFlatTwoArrowsDown"] = "\uE2CB";
    // U+E2D0  Flat raised by two syntonic commas
    Glyphs["accidentalFlatTwoArrowsUp"] = "\uE2D0";
    // U+EE65  Quarter-tone higher (Alois Hba)
    Glyphs["accidentalHabaFlatQuarterToneHigher"] = "\uEE65";
    // U+EE69  Three quarter-tones lower (Alois Hba)
    Glyphs["accidentalHabaFlatThreeQuarterTonesLower"] = "\uEE69";
    // U+EE64  Quarter-tone higher (Alois Hba)
    Glyphs["accidentalHabaQuarterToneHigher"] = "\uEE64";
    // U+EE67  Quarter-tone lower (Alois Hba)
    Glyphs["accidentalHabaQuarterToneLower"] = "\uEE67";
    // U+EE68  Quarter-tone lower (Alois Hba)
    Glyphs["accidentalHabaSharpQuarterToneLower"] = "\uEE68";
    // U+EE66  Three quarter-tones higher (Alois Hba)
    Glyphs["accidentalHabaSharpThreeQuarterTonesHigher"] = "\uEE66";
    // U+E29A  Half sharp with arrow down
    Glyphs["accidentalHalfSharpArrowDown"] = "\uE29A";
    // U+E299  Half sharp with arrow up
    Glyphs["accidentalHalfSharpArrowUp"] = "\uE299";
    // U+E2B6  Thirteen (raise by 65:64)
    Glyphs["accidentalJohnston13"] = "\uE2B6";
    // U+E2B7  Inverted 13 (lower by 65:64)
    Glyphs["accidentalJohnston31"] = "\uE2B7";
    // U+E2B5  Down arrow (lower by 33:32)
    Glyphs["accidentalJohnstonDown"] = "\uE2B5";
    // U+E2B2  Inverted seven (raise by 36:35)
    Glyphs["accidentalJohnstonEl"] = "\uE2B2";
    // U+E2B1  Minus (lower by 81:80)
    Glyphs["accidentalJohnstonMinus"] = "\uE2B1";
    // U+E2B0  Plus (raise by 81:80)
    Glyphs["accidentalJohnstonPlus"] = "\uE2B0";
    // U+E2B3  Seven (lower by 36:35)
    Glyphs["accidentalJohnstonSeven"] = "\uE2B3";
    // U+E2B4  Up arrow (raise by 33:32)
    Glyphs["accidentalJohnstonUp"] = "\uE2B4";
    // U+E443  Koma (flat)
    Glyphs["accidentalKomaFlat"] = "\uE443";
    // U+E444  Koma (sharp)
    Glyphs["accidentalKomaSharp"] = "\uE444";
    // U+E460  Koron (quarter tone flat)
    Glyphs["accidentalKoron"] = "\uE460";
    // U+E441  Kk mcenneb (flat)
    Glyphs["accidentalKucukMucennebFlat"] = "\uE441";
    // U+E446  Kk mcenneb (sharp)
    Glyphs["accidentalKucukMucennebSharp"] = "\uE446";
    // U+E47D  Large double sharp
    Glyphs["accidentalLargeDoubleSharp"] = "\uE47D";
    // U+E2DE  Lower by one septimal comma
    Glyphs["accidentalLowerOneSeptimalComma"] = "\uE2DE";
    // U+E2E4  Lower by one tridecimal quartertone
    Glyphs["accidentalLowerOneTridecimalQuartertone"] = "\uE2E4";
    // U+E2E2  Lower by one undecimal quartertone
    Glyphs["accidentalLowerOneUndecimalQuartertone"] = "\uE2E2";
    // U+E2E0  Lower by two septimal commas
    Glyphs["accidentalLowerTwoSeptimalCommas"] = "\uE2E0";
    // U+ED51  Lowered (Stockhausen)
    Glyphs["accidentalLoweredStockhausen"] = "\uED51";
    // U+E284  Narrow reversed flat(quarter-tone flat)
    Glyphs["accidentalNarrowReversedFlat"] = "\uE284";
    // U+E285  Narrow reversed flat and flat(three-quarter-tones flat)
    Glyphs["accidentalNarrowReversedFlatAndFlat"] = "\uE285";
    // U+E261  Natural
    Glyphs["accidentalNatural"] = "\uE261";
    // U+ED34  Arabic natural
    Glyphs["accidentalNaturalArabic"] = "\uED34";
    // U+E2F2  Natural equal tempered semitone
    Glyphs["accidentalNaturalEqualTempered"] = "\uE2F2";
    // U+E267  Natural flat
    Glyphs["accidentalNaturalFlat"] = "\uE267";
    // U+ED55  Lowered natural (Stockhausen)
    Glyphs["accidentalNaturalLoweredStockhausen"] = "\uED55";
    // U+E2C2  Natural lowered by one syntonic comma
    Glyphs["accidentalNaturalOneArrowDown"] = "\uE2C2";
    // U+E2C7  Natural raised by one syntonic comma
    Glyphs["accidentalNaturalOneArrowUp"] = "\uE2C7";
    // U+ED54  Raised natural (Stockhausen)
    Glyphs["accidentalNaturalRaisedStockhausen"] = "\uED54";
    // U+E482  Reversed natural
    Glyphs["accidentalNaturalReversed"] = "\uE482";
    // U+E268  Natural sharp
    Glyphs["accidentalNaturalSharp"] = "\uE268";
    // U+E2D6  Natural lowered by three syntonic commas
    Glyphs["accidentalNaturalThreeArrowsDown"] = "\uE2D6";
    // U+E2DB  Natural raised by three syntonic commas
    Glyphs["accidentalNaturalThreeArrowsUp"] = "\uE2DB";
    // U+E2CC  Natural lowered by two syntonic commas
    Glyphs["accidentalNaturalTwoArrowsDown"] = "\uE2CC";
    // U+E2D1  Natural raised by two syntonic commas
    Glyphs["accidentalNaturalTwoArrowsUp"] = "\uE2D1";
    // U+E29C  One and a half sharps with arrow down
    Glyphs["accidentalOneAndAHalfSharpsArrowDown"] = "\uE29C";
    // U+E29B  One and a half sharps with arrow up
    Glyphs["accidentalOneAndAHalfSharpsArrowUp"] = "\uE29B";
    // U+E48F  One-quarter-tone flat (Ferneyhough)
    Glyphs["accidentalOneQuarterToneFlatFerneyhough"] = "\uE48F";
    // U+ED59  One-quarter-tone flat (Stockhausen)
    Glyphs["accidentalOneQuarterToneFlatStockhausen"] = "\uED59";
    // U+E48E  One-quarter-tone sharp (Ferneyhough)
    Glyphs["accidentalOneQuarterToneSharpFerneyhough"] = "\uE48E";
    // U+ED58  One-quarter-tone sharp (Stockhausen)
    Glyphs["accidentalOneQuarterToneSharpStockhausen"] = "\uED58";
    // U+E48B  One-third-tone flat (Ferneyhough)
    Glyphs["accidentalOneThirdToneFlatFerneyhough"] = "\uE48B";
    // U+E48A  One-third-tone sharp (Ferneyhough)
    Glyphs["accidentalOneThirdToneSharpFerneyhough"] = "\uE48A";
    // U+E26A  Accidental parenthesis, left
    Glyphs["accidentalParensLeft"] = "\uE26A";
    // U+E26B  Accidental parenthesis, right
    Glyphs["accidentalParensRight"] = "\uE26B";
    // U+E2F5  Lower by one equal tempered quarter-tone
    Glyphs["accidentalQuarterFlatEqualTempered"] = "\uE2F5";
    // U+E2F6  Raise by one equal tempered quarter tone
    Glyphs["accidentalQuarterSharpEqualTempered"] = "\uE2F6";
    // U+E47F  Quarter-tone flat
    Glyphs["accidentalQuarterToneFlat4"] = "\uE47F";
    // U+ED33  Arabic quarter-tone flat
    Glyphs["accidentalQuarterToneFlatArabic"] = "\uED33";
    // U+E270  Quarter-tone flat
    Glyphs["accidentalQuarterToneFlatArrowUp"] = "\uE270";
    // U+E480  Filled reversed flat (quarter-tone flat)
    Glyphs["accidentalQuarterToneFlatFilledReversed"] = "\uE480";
    // U+E273  Quarter-tone flat
    Glyphs["accidentalQuarterToneFlatNaturalArrowDown"] = "\uE273";
    // U+E478  Quarter tone flat (Penderecki)
    Glyphs["accidentalQuarterToneFlatPenderecki"] = "\uE478";
    // U+E280  Reversed flat (quarter-tone flat) (Stein)
    Glyphs["accidentalQuarterToneFlatStein"] = "\uE280";
    // U+E488  Quarter-tone flat (van Blankenburg)
    Glyphs["accidentalQuarterToneFlatVanBlankenburg"] = "\uE488";
    // U+E47E  Quarter-tone sharp
    Glyphs["accidentalQuarterToneSharp4"] = "\uE47E";
    // U+ED35  Arabic quarter-tone sharp
    Glyphs["accidentalQuarterToneSharpArabic"] = "\uED35";
    // U+E275  Quarter-tone sharp
    Glyphs["accidentalQuarterToneSharpArrowDown"] = "\uE275";
    // U+E472  Quarter tone sharp (Bussotti)
    Glyphs["accidentalQuarterToneSharpBusotti"] = "\uE472";
    // U+E272  Quarter-tone sharp
    Glyphs["accidentalQuarterToneSharpNaturalArrowUp"] = "\uE272";
    // U+E282  Half sharp (quarter-tone sharp) (Stein)
    Glyphs["accidentalQuarterToneSharpStein"] = "\uE282";
    // U+E475  Quarter tone sharp with wiggly tail
    Glyphs["accidentalQuarterToneSharpWiggle"] = "\uE475";
    // U+E2DF  Raise by one septimal comma
    Glyphs["accidentalRaiseOneSeptimalComma"] = "\uE2DF";
    // U+E2E5  Raise by one tridecimal quartertone
    Glyphs["accidentalRaiseOneTridecimalQuartertone"] = "\uE2E5";
    // U+E2E3  Raise by one undecimal quartertone
    Glyphs["accidentalRaiseOneUndecimalQuartertone"] = "\uE2E3";
    // U+E2E1  Raise by two septimal commas
    Glyphs["accidentalRaiseTwoSeptimalCommas"] = "\uE2E1";
    // U+ED50  Raised (Stockhausen)
    Glyphs["accidentalRaisedStockhausen"] = "\uED50";
    // U+E295  Reversed flat and flat with arrow down
    Glyphs["accidentalReversedFlatAndFlatArrowDown"] = "\uE295";
    // U+E294  Reversed flat and flat with arrow up
    Glyphs["accidentalReversedFlatAndFlatArrowUp"] = "\uE294";
    // U+E291  Reversed flat with arrow down
    Glyphs["accidentalReversedFlatArrowDown"] = "\uE291";
    // U+E290  Reversed flat with arrow up
    Glyphs["accidentalReversedFlatArrowUp"] = "\uE290";
    // U+E262  Sharp
    Glyphs["accidentalSharp"] = "\uE262";
    // U+ED36  Arabic half-tone sharp
    Glyphs["accidentalSharpArabic"] = "\uED36";
    // U+E2F3  Sharp equal tempered semitone
    Glyphs["accidentalSharpEqualTempered"] = "\uE2F3";
    // U+ED57  Lowered sharp (Stockhausen)
    Glyphs["accidentalSharpLoweredStockhausen"] = "\uED57";
    // U+E2C3  Sharp lowered by one syntonic comma
    Glyphs["accidentalSharpOneArrowDown"] = "\uE2C3";
    // U+E2C8  Sharp raised by one syntonic comma
    Glyphs["accidentalSharpOneArrowUp"] = "\uE2C8";
    // U+E473  One or three quarter tones sharp
    Glyphs["accidentalSharpOneHorizontalStroke"] = "\uE473";
    // U+ED56  Raised sharp (Stockhausen)
    Glyphs["accidentalSharpRaisedStockhausen"] = "\uED56";
    // U+ED5E  Repeated sharp, note on line (Stockhausen)
    Glyphs["accidentalSharpRepeatedLineStockhausen"] = "\uED5E";
    // U+ED5D  Repeated sharp, note in space (Stockhausen)
    Glyphs["accidentalSharpRepeatedSpaceStockhausen"] = "\uED5D";
    // U+E481  Reversed sharp
    Glyphs["accidentalSharpReversed"] = "\uE481";
    // U+E269  Sharp sharp
    Glyphs["accidentalSharpSharp"] = "\uE269";
    // U+E2D7  Sharp lowered by three syntonic commas
    Glyphs["accidentalSharpThreeArrowsDown"] = "\uE2D7";
    // U+E2DC  Sharp raised by three syntonic commas
    Glyphs["accidentalSharpThreeArrowsUp"] = "\uE2DC";
    // U+E2CD  Sharp lowered by two syntonic commas
    Glyphs["accidentalSharpTwoArrowsDown"] = "\uE2CD";
    // U+E2D2  Sharp raised by two syntonic commas
    Glyphs["accidentalSharpTwoArrowsUp"] = "\uE2D2";
    // U+E2A0  1/12 tone low
    Glyphs["accidentalSims12Down"] = "\uE2A0";
    // U+E2A3  1/12 tone high
    Glyphs["accidentalSims12Up"] = "\uE2A3";
    // U+E2A2  1/4 tone low
    Glyphs["accidentalSims4Down"] = "\uE2A2";
    // U+E2A5  1/4 tone high
    Glyphs["accidentalSims4Up"] = "\uE2A5";
    // U+E2A1  1/6 tone low
    Glyphs["accidentalSims6Down"] = "\uE2A1";
    // U+E2A4  1/6 tone high
    Glyphs["accidentalSims6Up"] = "\uE2A4";
    // U+E461  Sori (quarter tone sharp)
    Glyphs["accidentalSori"] = "\uE461";
    // U+E477  Byzantine-style Bakiye flat (Tavener)
    Glyphs["accidentalTavenerFlat"] = "\uE477";
    // U+E476  Byzantine-style Buyuk mucenneb sharp (Tavener)
    Glyphs["accidentalTavenerSharp"] = "\uE476";
    // U+ED31  Arabic three-quarter-tones flat
    Glyphs["accidentalThreeQuarterTonesFlatArabic"] = "\uED31";
    // U+E271  Three-quarter-tones flat
    Glyphs["accidentalThreeQuarterTonesFlatArrowDown"] = "\uE271";
    // U+E278  Three-quarter-tones flat
    Glyphs["accidentalThreeQuarterTonesFlatArrowUp"] = "\uE278";
    // U+E489  Three-quarter-tones flat (Couper)
    Glyphs["accidentalThreeQuarterTonesFlatCouper"] = "\uE489";
    // U+E486  Three-quarter-tones flat (Grisey)
    Glyphs["accidentalThreeQuarterTonesFlatGrisey"] = "\uE486";
    // U+E487  Three-quarter-tones flat (Tartini)
    Glyphs["accidentalThreeQuarterTonesFlatTartini"] = "\uE487";
    // U+E281  Reversed flat and flat (three-quarter-tones flat) (Zimmermann)
    Glyphs["accidentalThreeQuarterTonesFlatZimmermann"] = "\uE281";
    // U+ED37  Arabic three-quarter-tones sharp
    Glyphs["accidentalThreeQuarterTonesSharpArabic"] = "\uED37";
    // U+E277  Three-quarter-tones sharp
    Glyphs["accidentalThreeQuarterTonesSharpArrowDown"] = "\uE277";
    // U+E274  Three-quarter-tones sharp
    Glyphs["accidentalThreeQuarterTonesSharpArrowUp"] = "\uE274";
    // U+E474  Three quarter tones sharp (Bussotti)
    Glyphs["accidentalThreeQuarterTonesSharpBusotti"] = "\uE474";
    // U+E283  One and a half sharps (three-quarter-tones sharp) (Stein)
    Glyphs["accidentalThreeQuarterTonesSharpStein"] = "\uE283";
    // U+ED5A  Three-quarter-tones sharp (Stockhausen)
    Glyphs["accidentalThreeQuarterTonesSharpStockhausen"] = "\uED5A";
    // U+E266  Triple flat
    Glyphs["accidentalTripleFlat"] = "\uE266";
    // U+E265  Triple sharp
    Glyphs["accidentalTripleSharp"] = "\uE265";
    // U+E48D  Two-third-tones flat (Ferneyhough)
    Glyphs["accidentalTwoThirdTonesFlatFerneyhough"] = "\uE48D";
    // U+E48C  Two-third-tones sharp (Ferneyhough)
    Glyphs["accidentalTwoThirdTonesSharpFerneyhough"] = "\uE48C";
    // U+EE61  Accidental down
    Glyphs["accidentalUpsAndDownsDown"] = "\uEE61";
    // U+EE63  Accidental less
    Glyphs["accidentalUpsAndDownsLess"] = "\uEE63";
    // U+EE62  Accidental more
    Glyphs["accidentalUpsAndDownsMore"] = "\uEE62";
    // U+EE60  Accidental up
    Glyphs["accidentalUpsAndDownsUp"] = "\uEE60";
    // U+E47C  Wilson minus (5 comma down)
    Glyphs["accidentalWilsonMinus"] = "\uE47C";
    // U+E47B  Wilson plus (5 comma up)
    Glyphs["accidentalWilsonPlus"] = "\uE47B";
    // U+E434  5/6 tone flat
    Glyphs["accidentalWyschnegradsky10TwelfthsFlat"] = "\uE434";
    // U+E429  5/6 tone sharp
    Glyphs["accidentalWyschnegradsky10TwelfthsSharp"] = "\uE429";
    // U+E435  11/12 tone flat
    Glyphs["accidentalWyschnegradsky11TwelfthsFlat"] = "\uE435";
    // U+E42A  11/12 tone sharp
    Glyphs["accidentalWyschnegradsky11TwelfthsSharp"] = "\uE42A";
    // U+E42B  1/12 tone flat
    Glyphs["accidentalWyschnegradsky1TwelfthsFlat"] = "\uE42B";
    // U+E420  1/12 tone sharp
    Glyphs["accidentalWyschnegradsky1TwelfthsSharp"] = "\uE420";
    // U+E42C  1/6 tone flat
    Glyphs["accidentalWyschnegradsky2TwelfthsFlat"] = "\uE42C";
    // U+E421  1/6 tone sharp
    Glyphs["accidentalWyschnegradsky2TwelfthsSharp"] = "\uE421";
    // U+E42D  1/4 tone flat
    Glyphs["accidentalWyschnegradsky3TwelfthsFlat"] = "\uE42D";
    // U+E422  1/4 tone sharp
    Glyphs["accidentalWyschnegradsky3TwelfthsSharp"] = "\uE422";
    // U+E42E  1/3 tone flat
    Glyphs["accidentalWyschnegradsky4TwelfthsFlat"] = "\uE42E";
    // U+E423  1/3 tone sharp
    Glyphs["accidentalWyschnegradsky4TwelfthsSharp"] = "\uE423";
    // U+E42F  5/12 tone flat
    Glyphs["accidentalWyschnegradsky5TwelfthsFlat"] = "\uE42F";
    // U+E424  5/12 tone sharp
    Glyphs["accidentalWyschnegradsky5TwelfthsSharp"] = "\uE424";
    // U+E430  1/2 tone flat
    Glyphs["accidentalWyschnegradsky6TwelfthsFlat"] = "\uE430";
    // U+E425  1/2 tone sharp
    Glyphs["accidentalWyschnegradsky6TwelfthsSharp"] = "\uE425";
    // U+E431  7/12 tone flat
    Glyphs["accidentalWyschnegradsky7TwelfthsFlat"] = "\uE431";
    // U+E426  7/12 tone sharp
    Glyphs["accidentalWyschnegradsky7TwelfthsSharp"] = "\uE426";
    // U+E432  2/3 tone flat
    Glyphs["accidentalWyschnegradsky8TwelfthsFlat"] = "\uE432";
    // U+E427  2/3 tone sharp
    Glyphs["accidentalWyschnegradsky8TwelfthsSharp"] = "\uE427";
    // U+E433  3/4 tone flat
    Glyphs["accidentalWyschnegradsky9TwelfthsFlat"] = "\uE433";
    // U+E428  3/4 tone sharp
    Glyphs["accidentalWyschnegradsky9TwelfthsSharp"] = "\uE428";
    // U+E470  One-third-tone sharp (Xenakis)
    Glyphs["accidentalXenakisOneThirdToneSharp"] = "\uE470";
    // U+E471  Two-third-tones sharp (Xenakis)
    Glyphs["accidentalXenakisTwoThirdTonesSharp"] = "\uE471";
    // U+E86A  Choralmelodie (Berg)
    Glyphs["analyticsChoralmelodie"] = "\uE86A";
    // U+E863  End of stimme
    Glyphs["analyticsEndStimme"] = "\uE863";
    // U+E86B  Hauptrhythmus (Berg)
    Glyphs["analyticsHauptrhythmus"] = "\uE86B";
    // U+E860  Hauptstimme
    Glyphs["analyticsHauptstimme"] = "\uE860";
    // U+E869  Inversion 1
    Glyphs["analyticsInversion1"] = "\uE869";
    // U+E861  Nebenstimme
    Glyphs["analyticsNebenstimme"] = "\uE861";
    // U+E862  Start of stimme
    Glyphs["analyticsStartStimme"] = "\uE862";
    // U+E864  Theme
    Glyphs["analyticsTheme"] = "\uE864";
    // U+E868  Theme 1
    Glyphs["analyticsTheme1"] = "\uE868";
    // U+E867  Inversion of theme
    Glyphs["analyticsThemeInversion"] = "\uE867";
    // U+E865  Retrograde of theme
    Glyphs["analyticsThemeRetrograde"] = "\uE865";
    // U+E866  Retrograde inversion of theme
    Glyphs["analyticsThemeRetrogradeInversion"] = "\uE866";
    // U+E63C  Arpeggiato
    Glyphs["arpeggiato"] = "\uE63C";
    // U+E635  Arpeggiato down
    Glyphs["arpeggiatoDown"] = "\uE635";
    // U+E634  Arpeggiato up
    Glyphs["arpeggiatoUp"] = "\uE634";
    // U+EB64  Black arrow down (S)
    Glyphs["arrowBlackDown"] = "\uEB64";
    // U+EB65  Black arrow down-left (SW)
    Glyphs["arrowBlackDownLeft"] = "\uEB65";
    // U+EB63  Black arrow down-right (SE)
    Glyphs["arrowBlackDownRight"] = "\uEB63";
    // U+EB66  Black arrow left (W)
    Glyphs["arrowBlackLeft"] = "\uEB66";
    // U+EB62  Black arrow right (E)
    Glyphs["arrowBlackRight"] = "\uEB62";
    // U+EB60  Black arrow up (N)
    Glyphs["arrowBlackUp"] = "\uEB60";
    // U+EB67  Black arrow up-left (NW)
    Glyphs["arrowBlackUpLeft"] = "\uEB67";
    // U+EB61  Black arrow up-right (NE)
    Glyphs["arrowBlackUpRight"] = "\uEB61";
    // U+EB74  Open arrow down (S)
    Glyphs["arrowOpenDown"] = "\uEB74";
    // U+EB75  Open arrow down-left (SW)
    Glyphs["arrowOpenDownLeft"] = "\uEB75";
    // U+EB73  Open arrow down-right (SE)
    Glyphs["arrowOpenDownRight"] = "\uEB73";
    // U+EB76  Open arrow left (W)
    Glyphs["arrowOpenLeft"] = "\uEB76";
    // U+EB72  Open arrow right (E)
    Glyphs["arrowOpenRight"] = "\uEB72";
    // U+EB70  Open arrow up (N)
    Glyphs["arrowOpenUp"] = "\uEB70";
    // U+EB77  Open arrow up-left (NW)
    Glyphs["arrowOpenUpLeft"] = "\uEB77";
    // U+EB71  Open arrow up-right (NE)
    Glyphs["arrowOpenUpRight"] = "\uEB71";
    // U+EB6C  White arrow down (S)
    Glyphs["arrowWhiteDown"] = "\uEB6C";
    // U+EB6D  White arrow down-left (SW)
    Glyphs["arrowWhiteDownLeft"] = "\uEB6D";
    // U+EB6B  White arrow down-right (SE)
    Glyphs["arrowWhiteDownRight"] = "\uEB6B";
    // U+EB6E  White arrow left (W)
    Glyphs["arrowWhiteLeft"] = "\uEB6E";
    // U+EB6A  White arrow right (E)
    Glyphs["arrowWhiteRight"] = "\uEB6A";
    // U+EB68  White arrow up (N)
    Glyphs["arrowWhiteUp"] = "\uEB68";
    // U+EB6F  White arrow up-left (NW)
    Glyphs["arrowWhiteUpLeft"] = "\uEB6F";
    // U+EB69  White arrow up-right (NE)
    Glyphs["arrowWhiteUpRight"] = "\uEB69";
    // U+EB7C  Black arrowhead down (S)
    Glyphs["arrowheadBlackDown"] = "\uEB7C";
    // U+EB7D  Black arrowhead down-left (SW)
    Glyphs["arrowheadBlackDownLeft"] = "\uEB7D";
    // U+EB7B  Black arrowhead down-right (SE)
    Glyphs["arrowheadBlackDownRight"] = "\uEB7B";
    // U+EB7E  Black arrowhead left (W)
    Glyphs["arrowheadBlackLeft"] = "\uEB7E";
    // U+EB7A  Black arrowhead right (E)
    Glyphs["arrowheadBlackRight"] = "\uEB7A";
    // U+EB78  Black arrowhead up (N)
    Glyphs["arrowheadBlackUp"] = "\uEB78";
    // U+EB7F  Black arrowhead up-left (NW)
    Glyphs["arrowheadBlackUpLeft"] = "\uEB7F";
    // U+EB79  Black arrowhead up-right (NE)
    Glyphs["arrowheadBlackUpRight"] = "\uEB79";
    // U+EB8C  Open arrowhead down (S)
    Glyphs["arrowheadOpenDown"] = "\uEB8C";
    // U+EB8D  Open arrowhead down-left (SW)
    Glyphs["arrowheadOpenDownLeft"] = "\uEB8D";
    // U+EB8B  Open arrowhead down-right (SE)
    Glyphs["arrowheadOpenDownRight"] = "\uEB8B";
    // U+EB8E  Open arrowhead left (W)
    Glyphs["arrowheadOpenLeft"] = "\uEB8E";
    // U+EB8A  Open arrowhead right (E)
    Glyphs["arrowheadOpenRight"] = "\uEB8A";
    // U+EB88  Open arrowhead up (N)
    Glyphs["arrowheadOpenUp"] = "\uEB88";
    // U+EB8F  Open arrowhead up-left (NW)
    Glyphs["arrowheadOpenUpLeft"] = "\uEB8F";
    // U+EB89  Open arrowhead up-right (NE)
    Glyphs["arrowheadOpenUpRight"] = "\uEB89";
    // U+EB84  White arrowhead down (S)
    Glyphs["arrowheadWhiteDown"] = "\uEB84";
    // U+EB85  White arrowhead down-left (SW)
    Glyphs["arrowheadWhiteDownLeft"] = "\uEB85";
    // U+EB83  White arrowhead down-right (SE)
    Glyphs["arrowheadWhiteDownRight"] = "\uEB83";
    // U+EB86  White arrowhead left (W)
    Glyphs["arrowheadWhiteLeft"] = "\uEB86";
    // U+EB82  White arrowhead right (E)
    Glyphs["arrowheadWhiteRight"] = "\uEB82";
    // U+EB80  White arrowhead up (N)
    Glyphs["arrowheadWhiteUp"] = "\uEB80";
    // U+EB87  White arrowhead up-left (NW)
    Glyphs["arrowheadWhiteUpLeft"] = "\uEB87";
    // U+EB81  White arrowhead up-right (NE)
    Glyphs["arrowheadWhiteUpRight"] = "\uEB81";
    // U+E4A0  Accent above
    Glyphs["articAccentAbove"] = "\uE4A0";
    // U+E4A1  Accent below
    Glyphs["articAccentBelow"] = "\uE4A1";
    // U+E4B0  Accent-staccato above
    Glyphs["articAccentStaccatoAbove"] = "\uE4B0";
    // U+E4B1  Accent-staccato below
    Glyphs["articAccentStaccatoBelow"] = "\uE4B1";
    // U+E4BA  Laissez vibrer (l.v.) above
    Glyphs["articLaissezVibrerAbove"] = "\uE4BA";
    // U+E4BB  Laissez vibrer (l.v.) below
    Glyphs["articLaissezVibrerBelow"] = "\uE4BB";
    // U+E4AC  Marcato above
    Glyphs["articMarcatoAbove"] = "\uE4AC";
    // U+E4AD  Marcato below
    Glyphs["articMarcatoBelow"] = "\uE4AD";
    // U+E4AE  Marcato-staccato above
    Glyphs["articMarcatoStaccatoAbove"] = "\uE4AE";
    // U+E4AF  Marcato-staccato below
    Glyphs["articMarcatoStaccatoBelow"] = "\uE4AF";
    // U+E4BC  Marcato-tenuto above
    Glyphs["articMarcatoTenutoAbove"] = "\uE4BC";
    // U+E4BD  Marcato-tenuto below
    Glyphs["articMarcatoTenutoBelow"] = "\uE4BD";
    // U+ED40  Soft accent above
    Glyphs["articSoftAccentAbove"] = "\uED40";
    // U+ED41  Soft accent below
    Glyphs["articSoftAccentBelow"] = "\uED41";
    // U+ED42  Soft accent-staccato above
    Glyphs["articSoftAccentStaccatoAbove"] = "\uED42";
    // U+ED43  Soft accent-staccato below
    Glyphs["articSoftAccentStaccatoBelow"] = "\uED43";
    // U+ED44  Soft accent-tenuto above
    Glyphs["articSoftAccentTenutoAbove"] = "\uED44";
    // U+ED45  Soft accent-tenuto below
    Glyphs["articSoftAccentTenutoBelow"] = "\uED45";
    // U+ED46  Soft accent-tenuto-staccato above
    Glyphs["articSoftAccentTenutoStaccatoAbove"] = "\uED46";
    // U+ED47  Soft accent-tenuto-staccato below
    Glyphs["articSoftAccentTenutoStaccatoBelow"] = "\uED47";
    // U+E4A6  Staccatissimo above
    Glyphs["articStaccatissimoAbove"] = "\uE4A6";
    // U+E4A7  Staccatissimo below
    Glyphs["articStaccatissimoBelow"] = "\uE4A7";
    // U+E4AA  Staccatissimo stroke above
    Glyphs["articStaccatissimoStrokeAbove"] = "\uE4AA";
    // U+E4AB  Staccatissimo stroke below
    Glyphs["articStaccatissimoStrokeBelow"] = "\uE4AB";
    // U+E4A8  Staccatissimo wedge above
    Glyphs["articStaccatissimoWedgeAbove"] = "\uE4A8";
    // U+E4A9  Staccatissimo wedge below
    Glyphs["articStaccatissimoWedgeBelow"] = "\uE4A9";
    // U+E4A2  Staccato above
    Glyphs["articStaccatoAbove"] = "\uE4A2";
    // U+E4A3  Staccato below
    Glyphs["articStaccatoBelow"] = "\uE4A3";
    // U+E4B6  Stress above
    Glyphs["articStressAbove"] = "\uE4B6";
    // U+E4B7  Stress below
    Glyphs["articStressBelow"] = "\uE4B7";
    // U+E4A4  Tenuto above
    Glyphs["articTenutoAbove"] = "\uE4A4";
    // U+E4B4  Tenuto-accent above
    Glyphs["articTenutoAccentAbove"] = "\uE4B4";
    // U+E4B5  Tenuto-accent below
    Glyphs["articTenutoAccentBelow"] = "\uE4B5";
    // U+E4A5  Tenuto below
    Glyphs["articTenutoBelow"] = "\uE4A5";
    // U+E4B2  Lour (tenuto-staccato) above
    Glyphs["articTenutoStaccatoAbove"] = "\uE4B2";
    // U+E4B3  Lour (tenuto-staccato) below
    Glyphs["articTenutoStaccatoBelow"] = "\uE4B3";
    // U+E4B8  Unstress above
    Glyphs["articUnstressAbove"] = "\uE4B8";
    // U+E4B9  Unstress below
    Glyphs["articUnstressBelow"] = "\uE4B9";
    // U+E1E7  Augmentation dot
    Glyphs["augmentationDot"] = "\uE1E7";
    // U+E036  Dashed barline
    Glyphs["barlineDashed"] = "\uE036";
    // U+E037  Dotted barline
    Glyphs["barlineDotted"] = "\uE037";
    // U+E031  Double barline
    Glyphs["barlineDouble"] = "\uE031";
    // U+E032  Final barline
    Glyphs["barlineFinal"] = "\uE032";
    // U+E034  Heavy barline
    Glyphs["barlineHeavy"] = "\uE034";
    // U+E035  Heavy double barline
    Glyphs["barlineHeavyHeavy"] = "\uE035";
    // U+E033  Reverse final barline
    Glyphs["barlineReverseFinal"] = "\uE033";
    // U+E038  Short barline
    Glyphs["barlineShort"] = "\uE038";
    // U+E030  Single barline
    Glyphs["barlineSingle"] = "\uE030";
    // U+E039  Tick barline
    Glyphs["barlineTick"] = "\uE039";
    // U+EAF4  Accel./rit. beam 1 (widest)
    Glyphs["beamAccelRit1"] = "\uEAF4";
    // U+EAFD  Accel./rit. beam 10
    Glyphs["beamAccelRit10"] = "\uEAFD";
    // U+EAFE  Accel./rit. beam 11
    Glyphs["beamAccelRit11"] = "\uEAFE";
    // U+EAFF  Accel./rit. beam 12
    Glyphs["beamAccelRit12"] = "\uEAFF";
    // U+EB00  Accel./rit. beam 13
    Glyphs["beamAccelRit13"] = "\uEB00";
    // U+EB01  Accel./rit. beam 14
    Glyphs["beamAccelRit14"] = "\uEB01";
    // U+EB02  Accel./rit. beam 15 (narrowest)
    Glyphs["beamAccelRit15"] = "\uEB02";
    // U+EAF5  Accel./rit. beam 2
    Glyphs["beamAccelRit2"] = "\uEAF5";
    // U+EAF6  Accel./rit. beam 3
    Glyphs["beamAccelRit3"] = "\uEAF6";
    // U+EAF7  Accel./rit. beam 4
    Glyphs["beamAccelRit4"] = "\uEAF7";
    // U+EAF8  Accel./rit. beam 5
    Glyphs["beamAccelRit5"] = "\uEAF8";
    // U+EAF9  Accel./rit. beam 6
    Glyphs["beamAccelRit6"] = "\uEAF9";
    // U+EAFA  Accel./rit. beam 7
    Glyphs["beamAccelRit7"] = "\uEAFA";
    // U+EAFB  Accel./rit. beam 8
    Glyphs["beamAccelRit8"] = "\uEAFB";
    // U+EAFC  Accel./rit. beam 9
    Glyphs["beamAccelRit9"] = "\uEAFC";
    // U+EB03  Accel./rit. beam terminating line
    Glyphs["beamAccelRitFinal"] = "\uEB03";
    // U+E000  Brace
    Glyphs["brace"] = "\uE000";
    // U+E002  Bracket
    Glyphs["bracket"] = "\uE002";
    // U+E004  Bracket bottom
    Glyphs["bracketBottom"] = "\uE004";
    // U+E003  Bracket top
    Glyphs["bracketTop"] = "\uE003";
    // U+E5E3  Bend
    Glyphs["brassBend"] = "\uE5E3";
    // U+E5D6  Doit, long
    Glyphs["brassDoitLong"] = "\uE5D6";
    // U+E5D5  Doit, medium
    Glyphs["brassDoitMedium"] = "\uE5D5";
    // U+E5D4  Doit, short
    Glyphs["brassDoitShort"] = "\uE5D4";
    // U+E5D9  Lip fall, long
    Glyphs["brassFallLipLong"] = "\uE5D9";
    // U+E5D8  Lip fall, medium
    Glyphs["brassFallLipMedium"] = "\uE5D8";
    // U+E5D7  Lip fall, short
    Glyphs["brassFallLipShort"] = "\uE5D7";
    // U+E5DF  Rough fall, long
    Glyphs["brassFallRoughLong"] = "\uE5DF";
    // U+E5DE  Rough fall, medium
    Glyphs["brassFallRoughMedium"] = "\uE5DE";
    // U+E5DD  Rough fall, short
    Glyphs["brassFallRoughShort"] = "\uE5DD";
    // U+E5DC  Smooth fall, long
    Glyphs["brassFallSmoothLong"] = "\uE5DC";
    // U+E5DB  Smooth fall, medium
    Glyphs["brassFallSmoothMedium"] = "\uE5DB";
    // U+E5DA  Smooth fall, short
    Glyphs["brassFallSmoothShort"] = "\uE5DA";
    // U+E5E1  Flip
    Glyphs["brassFlip"] = "\uE5E1";
    // U+E5E8  Harmon mute, stem in
    Glyphs["brassHarmonMuteClosed"] = "\uE5E8";
    // U+E5E9  Harmon mute, stem extended, left
    Glyphs["brassHarmonMuteStemHalfLeft"] = "\uE5E9";
    // U+E5EA  Harmon mute, stem extended, right
    Glyphs["brassHarmonMuteStemHalfRight"] = "\uE5EA";
    // U+E5EB  Harmon mute, stem out
    Glyphs["brassHarmonMuteStemOpen"] = "\uE5EB";
    // U+E5E4  Jazz turn
    Glyphs["brassJazzTurn"] = "\uE5E4";
    // U+E5D3  Lift, long
    Glyphs["brassLiftLong"] = "\uE5D3";
    // U+E5D2  Lift, medium
    Glyphs["brassLiftMedium"] = "\uE5D2";
    // U+E5D1  Lift, short
    Glyphs["brassLiftShort"] = "\uE5D1";
    // U+E5EE  Smooth lift, long
    Glyphs["brassLiftSmoothLong"] = "\uE5EE";
    // U+E5ED  Smooth lift, medium
    Glyphs["brassLiftSmoothMedium"] = "\uE5ED";
    // U+E5EC  Smooth lift, short
    Glyphs["brassLiftSmoothShort"] = "\uE5EC";
    // U+E5E5  Muted (closed)
    Glyphs["brassMuteClosed"] = "\uE5E5";
    // U+E5E6  Half-muted (half-closed)
    Glyphs["brassMuteHalfClosed"] = "\uE5E6";
    // U+E5E7  Open
    Glyphs["brassMuteOpen"] = "\uE5E7";
    // U+E5E0  Plop
    Glyphs["brassPlop"] = "\uE5E0";
    // U+E5D0  Scoop
    Glyphs["brassScoop"] = "\uE5D0";
    // U+E5E2  Smear
    Glyphs["brassSmear"] = "\uE5E2";
    // U+E5EF  Valve trill
    Glyphs["brassValveTrill"] = "\uE5EF";
    // U+E4CE  Breath mark (comma)
    Glyphs["breathMarkComma"] = "\uE4CE";
    // U+E4D5  Breath mark (Salzedo)
    Glyphs["breathMarkSalzedo"] = "\uE4D5";
    // U+E4CF  Breath mark (tick-like)
    Glyphs["breathMarkTick"] = "\uE4CF";
    // U+E4D0  Breath mark (upbow-like)
    Glyphs["breathMarkUpbow"] = "\uE4D0";
    // U+E078  Bridge clef
    Glyphs["bridgeClef"] = "\uE078";
    // U+E22A  Buzz roll
    Glyphs["buzzRoll"] = "\uE22A";
    // U+E05C  C clef
    Glyphs["cClef"] = "\uE05C";
    // U+E05D  C clef ottava bassa
    Glyphs["cClef8vb"] = "\uE05D";
    // U+E05F  C clef, arrow down
    Glyphs["cClefArrowDown"] = "\uE05F";
    // U+E05E  C clef, arrow up
    Glyphs["cClefArrowUp"] = "\uE05E";
    // U+E07B  C clef change
    Glyphs["cClefChange"] = "\uE07B";
    // U+E061  Combining C clef
    Glyphs["cClefCombining"] = "\uE061";
    // U+E075  Reversed C clef
    Glyphs["cClefReversed"] = "\uE075";
    // U+E060  C clef (19th century)
    Glyphs["cClefSquare"] = "\uE060";
    // U+E4D1  Caesura
    Glyphs["caesura"] = "\uE4D1";
    // U+E4D4  Curved caesura
    Glyphs["caesuraCurved"] = "\uE4D4";
    // U+E4D3  Short caesura
    Glyphs["caesuraShort"] = "\uE4D3";
    // U+E4D7  Single stroke caesura
    Glyphs["caesuraSingleStroke"] = "\uE4D7";
    // U+E4D2  Thick caesura
    Glyphs["caesuraThick"] = "\uE4D2";
    // U+E9D6  Accentus above
    Glyphs["chantAccentusAbove"] = "\uE9D6";
    // U+E9D7  Accentus below
    Glyphs["chantAccentusBelow"] = "\uE9D7";
    // U+E994  Punctum auctum, ascending
    Glyphs["chantAuctumAsc"] = "\uE994";
    // U+E995  Punctum auctum, descending
    Glyphs["chantAuctumDesc"] = "\uE995";
    // U+E9D9  Augmentum (mora)
    Glyphs["chantAugmentum"] = "\uE9D9";
    // U+E8F8  Caesura
    Glyphs["chantCaesura"] = "\uE8F8";
    // U+E906  Plainchant C clef
    Glyphs["chantCclef"] = "\uE906";
    // U+E9D2  Circulus above
    Glyphs["chantCirculusAbove"] = "\uE9D2";
    // U+E9D3  Circulus below
    Glyphs["chantCirculusBelow"] = "\uE9D3";
    // U+E9BD  Connecting line, ascending 2nd
    Glyphs["chantConnectingLineAsc2nd"] = "\uE9BD";
    // U+E9BE  Connecting line, ascending 3rd
    Glyphs["chantConnectingLineAsc3rd"] = "\uE9BE";
    // U+E9BF  Connecting line, ascending 4th
    Glyphs["chantConnectingLineAsc4th"] = "\uE9BF";
    // U+E9C0  Connecting line, ascending 5th
    Glyphs["chantConnectingLineAsc5th"] = "\uE9C0";
    // U+E9C1  Connecting line, ascending 6th
    Glyphs["chantConnectingLineAsc6th"] = "\uE9C1";
    // U+EA08  Plainchant custos, stem down, high position
    Glyphs["chantCustosStemDownPosHigh"] = "\uEA08";
    // U+EA09  Plainchant custos, stem down, highest position
    Glyphs["chantCustosStemDownPosHighest"] = "\uEA09";
    // U+EA07  Plainchant custos, stem down, middle position
    Glyphs["chantCustosStemDownPosMiddle"] = "\uEA07";
    // U+EA05  Plainchant custos, stem up, low position
    Glyphs["chantCustosStemUpPosLow"] = "\uEA05";
    // U+EA04  Plainchant custos, stem up, lowest position
    Glyphs["chantCustosStemUpPosLowest"] = "\uEA04";
    // U+EA06  Plainchant custos, stem up, middle position
    Glyphs["chantCustosStemUpPosMiddle"] = "\uEA06";
    // U+E9B3  Punctum deminutum, lower
    Glyphs["chantDeminutumLower"] = "\uE9B3";
    // U+E9B2  Punctum deminutum, upper
    Glyphs["chantDeminutumUpper"] = "\uE9B2";
    // U+E8F6  Divisio finalis
    Glyphs["chantDivisioFinalis"] = "\uE8F6";
    // U+E8F4  Divisio maior
    Glyphs["chantDivisioMaior"] = "\uE8F4";
    // U+E8F5  Divisio maxima
    Glyphs["chantDivisioMaxima"] = "\uE8F5";
    // U+E8F3  Divisio minima
    Glyphs["chantDivisioMinima"] = "\uE8F3";
    // U+E9B4  Entry line, ascending 2nd
    Glyphs["chantEntryLineAsc2nd"] = "\uE9B4";
    // U+E9B5  Entry line, ascending 3rd
    Glyphs["chantEntryLineAsc3rd"] = "\uE9B5";
    // U+E9B6  Entry line, ascending 4th
    Glyphs["chantEntryLineAsc4th"] = "\uE9B6";
    // U+E9B7  Entry line, ascending 5th
    Glyphs["chantEntryLineAsc5th"] = "\uE9B7";
    // U+E9B8  Entry line, ascending 6th
    Glyphs["chantEntryLineAsc6th"] = "\uE9B8";
    // U+E9D8  Episema
    Glyphs["chantEpisema"] = "\uE9D8";
    // U+E902  Plainchant F clef
    Glyphs["chantFclef"] = "\uE902";
    // U+E9D0  Ictus above
    Glyphs["chantIctusAbove"] = "\uE9D0";
    // U+E9D1  Ictus below
    Glyphs["chantIctusBelow"] = "\uE9D1";
    // U+E9B9  Ligated stroke, descending 2nd
    Glyphs["chantLigaturaDesc2nd"] = "\uE9B9";
    // U+E9BA  Ligated stroke, descending 3rd
    Glyphs["chantLigaturaDesc3rd"] = "\uE9BA";
    // U+E9BB  Ligated stroke, descending 4th
    Glyphs["chantLigaturaDesc4th"] = "\uE9BB";
    // U+E9BC  Ligated stroke, descending 5th
    Glyphs["chantLigaturaDesc5th"] = "\uE9BC";
    // U+E99C  Oriscus ascending
    Glyphs["chantOriscusAscending"] = "\uE99C";
    // U+E99D  Oriscus descending
    Glyphs["chantOriscusDescending"] = "\uE99D";
    // U+E99E  Oriscus liquescens
    Glyphs["chantOriscusLiquescens"] = "\uE99E";
    // U+E9B0  Podatus, lower
    Glyphs["chantPodatusLower"] = "\uE9B0";
    // U+E9B1  Podatus, upper
    Glyphs["chantPodatusUpper"] = "\uE9B1";
    // U+E990  Punctum
    Glyphs["chantPunctum"] = "\uE990";
    // U+E998  Punctum cavum
    Glyphs["chantPunctumCavum"] = "\uE998";
    // U+E9A1  Punctum deminutum
    Glyphs["chantPunctumDeminutum"] = "\uE9A1";
    // U+E991  Punctum inclinatum
    Glyphs["chantPunctumInclinatum"] = "\uE991";
    // U+E992  Punctum inclinatum auctum
    Glyphs["chantPunctumInclinatumAuctum"] = "\uE992";
    // U+E993  Punctum inclinatum deminutum
    Glyphs["chantPunctumInclinatumDeminutum"] = "\uE993";
    // U+E999  Punctum linea
    Glyphs["chantPunctumLinea"] = "\uE999";
    // U+E99A  Punctum linea cavum
    Glyphs["chantPunctumLineaCavum"] = "\uE99A";
    // U+E996  Punctum virga
    Glyphs["chantPunctumVirga"] = "\uE996";
    // U+E997  Punctum virga, reversed
    Glyphs["chantPunctumVirgaReversed"] = "\uE997";
    // U+E99B  Quilisma
    Glyphs["chantQuilisma"] = "\uE99B";
    // U+E9D4  Semicirculus above
    Glyphs["chantSemicirculusAbove"] = "\uE9D4";
    // U+E9D5  Semicirculus below
    Glyphs["chantSemicirculusBelow"] = "\uE9D5";
    // U+E8F0  Plainchant staff
    Glyphs["chantStaff"] = "\uE8F0";
    // U+E8F2  Plainchant staff (narrow)
    Glyphs["chantStaffNarrow"] = "\uE8F2";
    // U+E8F1  Plainchant staff (wide)
    Glyphs["chantStaffWide"] = "\uE8F1";
    // U+E99F  Strophicus
    Glyphs["chantStrophicus"] = "\uE99F";
    // U+E9A0  Strophicus auctus
    Glyphs["chantStrophicusAuctus"] = "\uE9A0";
    // U+E9C2  Strophicus liquescens, 2nd
    Glyphs["chantStrophicusLiquescens2nd"] = "\uE9C2";
    // U+E9C3  Strophicus liquescens, 3rd
    Glyphs["chantStrophicusLiquescens3rd"] = "\uE9C3";
    // U+E9C4  Strophicus liquescens, 4th
    Glyphs["chantStrophicusLiquescens4th"] = "\uE9C4";
    // U+E9C5  Strophicus liquescens, 5th
    Glyphs["chantStrophicusLiquescens5th"] = "\uE9C5";
    // U+E8F7  Virgula
    Glyphs["chantVirgula"] = "\uE8F7";
    // U+E07E  15 for clefs
    Glyphs["clef15"] = "\uE07E";
    // U+E07D  8 for clefs
    Glyphs["clef8"] = "\uE07D";
    // U+E07F  Combining clef change
    Glyphs["clefChangeCombining"] = "\uE07F";
    // U+E048  Coda
    Glyphs["coda"] = "\uE048";
    // U+E049  Square coda
    Glyphs["codaSquare"] = "\uE049";
    // U+E897  Beat 2, compound time
    Glyphs["conductorBeat2Compound"] = "\uE897";
    // U+E894  Beat 2, simple time
    Glyphs["conductorBeat2Simple"] = "\uE894";
    // U+E898  Beat 3, compound time
    Glyphs["conductorBeat3Compound"] = "\uE898";
    // U+E895  Beat 3, simple time
    Glyphs["conductorBeat3Simple"] = "\uE895";
    // U+E899  Beat 4, compound time
    Glyphs["conductorBeat4Compound"] = "\uE899";
    // U+E896  Beat 4, simple time
    Glyphs["conductorBeat4Simple"] = "\uE896";
    // U+E891  Left-hand beat or cue
    Glyphs["conductorLeftBeat"] = "\uE891";
    // U+E892  Right-hand beat or cue
    Glyphs["conductorRightBeat"] = "\uE892";
    // U+E890  Strong beat or cue
    Glyphs["conductorStrongBeat"] = "\uE890";
    // U+E89A  Unconducted/free passages
    Glyphs["conductorUnconducted"] = "\uE89A";
    // U+E893  Weak beat or cue
    Glyphs["conductorWeakBeat"] = "\uE893";
    // U+E8E0  Begin beam
    Glyphs["controlBeginBeam"] = "\uE8E0";
    // U+E8E6  Begin phrase
    Glyphs["controlBeginPhrase"] = "\uE8E6";
    // U+E8E4  Begin slur
    Glyphs["controlBeginSlur"] = "\uE8E4";
    // U+E8E2  Begin tie
    Glyphs["controlBeginTie"] = "\uE8E2";
    // U+E8E1  End beam
    Glyphs["controlEndBeam"] = "\uE8E1";
    // U+E8E7  End phrase
    Glyphs["controlEndPhrase"] = "\uE8E7";
    // U+E8E5  End slur
    Glyphs["controlEndSlur"] = "\uE8E5";
    // U+E8E3  End tie
    Glyphs["controlEndTie"] = "\uE8E3";
    // U+ED64  Double flat
    Glyphs["csymAccidentalDoubleFlat"] = "\uED64";
    // U+ED63  Double sharp
    Glyphs["csymAccidentalDoubleSharp"] = "\uED63";
    // U+ED60  Flat
    Glyphs["csymAccidentalFlat"] = "\uED60";
    // U+ED61  Natural
    Glyphs["csymAccidentalNatural"] = "\uED61";
    // U+ED62  Sharp
    Glyphs["csymAccidentalSharp"] = "\uED62";
    // U+ED66  Triple flat
    Glyphs["csymAccidentalTripleFlat"] = "\uED66";
    // U+ED65  Triple sharp
    Glyphs["csymAccidentalTripleSharp"] = "\uED65";
    // U+E87B  Slash for altered bass note
    Glyphs["csymAlteredBassSlash"] = "\uE87B";
    // U+E872  Augmented
    Glyphs["csymAugmented"] = "\uE872";
    // U+E877  Double-height left bracket
    Glyphs["csymBracketLeftTall"] = "\uE877";
    // U+E878  Double-height right bracket
    Glyphs["csymBracketRightTall"] = "\uE878";
    // U+E87C  Slash for chord symbols arranged diagonally
    Glyphs["csymDiagonalArrangementSlash"] = "\uE87C";
    // U+E870  Diminished
    Glyphs["csymDiminished"] = "\uE870";
    // U+E871  Half-diminished
    Glyphs["csymHalfDiminished"] = "\uE871";
    // U+E873  Major seventh
    Glyphs["csymMajorSeventh"] = "\uE873";
    // U+E874  Minor
    Glyphs["csymMinor"] = "\uE874";
    // U+E875  Double-height left parenthesis
    Glyphs["csymParensLeftTall"] = "\uE875";
    // U+E879  Triple-height left parenthesis
    Glyphs["csymParensLeftVeryTall"] = "\uE879";
    // U+E876  Double-height right parenthesis
    Glyphs["csymParensRightTall"] = "\uE876";
    // U+E87A  Triple-height right parenthesis
    Glyphs["csymParensRightVeryTall"] = "\uE87A";
    // U+E4D6  Curlew (Britten)
    Glyphs["curlewSign"] = "\uE4D6";
    // U+E046  Da capo
    Glyphs["daCapo"] = "\uE046";
    // U+E045  Dal segno
    Glyphs["dalSegno"] = "\uE045";
    // U+EA3C  Daseian excellentes 1
    Glyphs["daseianExcellentes1"] = "\uEA3C";
    // U+EA3D  Daseian excellentes 2
    Glyphs["daseianExcellentes2"] = "\uEA3D";
    // U+EA3E  Daseian excellentes 3
    Glyphs["daseianExcellentes3"] = "\uEA3E";
    // U+EA3F  Daseian excellentes 4
    Glyphs["daseianExcellentes4"] = "\uEA3F";
    // U+EA34  Daseian finales 1
    Glyphs["daseianFinales1"] = "\uEA34";
    // U+EA35  Daseian finales 2
    Glyphs["daseianFinales2"] = "\uEA35";
    // U+EA36  Daseian finales 3
    Glyphs["daseianFinales3"] = "\uEA36";
    // U+EA37  Daseian finales 4
    Glyphs["daseianFinales4"] = "\uEA37";
    // U+EA30  Daseian graves 1
    Glyphs["daseianGraves1"] = "\uEA30";
    // U+EA31  Daseian graves 2
    Glyphs["daseianGraves2"] = "\uEA31";
    // U+EA32  Daseian graves 3
    Glyphs["daseianGraves3"] = "\uEA32";
    // U+EA33  Daseian graves 4
    Glyphs["daseianGraves4"] = "\uEA33";
    // U+EA40  Daseian residua 1
    Glyphs["daseianResidua1"] = "\uEA40";
    // U+EA41  Daseian residua 2
    Glyphs["daseianResidua2"] = "\uEA41";
    // U+EA38  Daseian superiores 1
    Glyphs["daseianSuperiores1"] = "\uEA38";
    // U+EA39  Daseian superiores 2
    Glyphs["daseianSuperiores2"] = "\uEA39";
    // U+EA3A  Daseian superiores 3
    Glyphs["daseianSuperiores3"] = "\uEA3A";
    // U+EA3B  Daseian superiores 4
    Glyphs["daseianSuperiores4"] = "\uEA3B";
    // U+E234  Double lateral roll (Stevens)
    Glyphs["doubleLateralRollStevens"] = "\uE234";
    // U+E5F0  Double-tongue above
    Glyphs["doubleTongueAbove"] = "\uE5F0";
    // U+E5F1  Double-tongue below
    Glyphs["doubleTongueBelow"] = "\uE5F1";
    // U+E546  Colon separator for combined dynamics
    Glyphs["dynamicCombinedSeparatorColon"] = "\uE546";
    // U+E547  Hyphen separator for combined dynamics
    Glyphs["dynamicCombinedSeparatorHyphen"] = "\uE547";
    // U+E549  Slash separator for combined dynamics
    Glyphs["dynamicCombinedSeparatorSlash"] = "\uE549";
    // U+E548  Space separator for combined dynamics
    Glyphs["dynamicCombinedSeparatorSpace"] = "\uE548";
    // U+E53E  Crescendo
    Glyphs["dynamicCrescendoHairpin"] = "\uE53E";
    // U+E53F  Diminuendo
    Glyphs["dynamicDiminuendoHairpin"] = "\uE53F";
    // U+E52F  ff
    Glyphs["dynamicFF"] = "\uE52F";
    // U+E530  fff
    Glyphs["dynamicFFF"] = "\uE530";
    // U+E531  ffff
    Glyphs["dynamicFFFF"] = "\uE531";
    // U+E532  fffff
    Glyphs["dynamicFFFFF"] = "\uE532";
    // U+E533  ffffff
    Glyphs["dynamicFFFFFF"] = "\uE533";
    // U+E522  Forte
    Glyphs["dynamicForte"] = "\uE522";
    // U+E534  Forte-piano
    Glyphs["dynamicFortePiano"] = "\uE534";
    // U+E535  Forzando
    Glyphs["dynamicForzando"] = "\uE535";
    // U+E544  Left bracket (for hairpins)
    Glyphs["dynamicHairpinBracketLeft"] = "\uE544";
    // U+E545  Right bracket (for hairpins)
    Glyphs["dynamicHairpinBracketRight"] = "\uE545";
    // U+E542  Left parenthesis (for hairpins)
    Glyphs["dynamicHairpinParenthesisLeft"] = "\uE542";
    // U+E543  Right parenthesis (for hairpins)
    Glyphs["dynamicHairpinParenthesisRight"] = "\uE543";
    // U+E52D  mf
    Glyphs["dynamicMF"] = "\uE52D";
    // U+E52C  mp
    Glyphs["dynamicMP"] = "\uE52C";
    // U+E540  Messa di voce
    Glyphs["dynamicMessaDiVoce"] = "\uE540";
    // U+E521  Mezzo
    Glyphs["dynamicMezzo"] = "\uE521";
    // U+E526  Niente
    Glyphs["dynamicNiente"] = "\uE526";
    // U+E541  Niente (for hairpins)
    Glyphs["dynamicNienteForHairpin"] = "\uE541";
    // U+E52E  pf
    Glyphs["dynamicPF"] = "\uE52E";
    // U+E52B  pp
    Glyphs["dynamicPP"] = "\uE52B";
    // U+E52A  ppp
    Glyphs["dynamicPPP"] = "\uE52A";
    // U+E529  pppp
    Glyphs["dynamicPPPP"] = "\uE529";
    // U+E528  ppppp
    Glyphs["dynamicPPPPP"] = "\uE528";
    // U+E527  pppppp
    Glyphs["dynamicPPPPPP"] = "\uE527";
    // U+E520  Piano
    Glyphs["dynamicPiano"] = "\uE520";
    // U+E523  Rinforzando
    Glyphs["dynamicRinforzando"] = "\uE523";
    // U+E53C  Rinforzando 1
    Glyphs["dynamicRinforzando1"] = "\uE53C";
    // U+E53D  Rinforzando 2
    Glyphs["dynamicRinforzando2"] = "\uE53D";
    // U+E524  Sforzando
    Glyphs["dynamicSforzando"] = "\uE524";
    // U+E536  Sforzando 1
    Glyphs["dynamicSforzando1"] = "\uE536";
    // U+E538  Sforzando-pianissimo
    Glyphs["dynamicSforzandoPianissimo"] = "\uE538";
    // U+E537  Sforzando-piano
    Glyphs["dynamicSforzandoPiano"] = "\uE537";
    // U+E539  Sforzato
    Glyphs["dynamicSforzato"] = "\uE539";
    // U+E53B  Sforzatissimo
    Glyphs["dynamicSforzatoFF"] = "\uE53B";
    // U+E53A  Sforzato-piano
    Glyphs["dynamicSforzatoPiano"] = "\uE53A";
    // U+E525  Z
    Glyphs["dynamicZ"] = "\uE525";
    // U+EB46  Eight channels (7.1 surround)
    Glyphs["elecAudioChannelsEight"] = "\uEB46";
    // U+EB43  Five channels
    Glyphs["elecAudioChannelsFive"] = "\uEB43";
    // U+EB42  Four channels
    Glyphs["elecAudioChannelsFour"] = "\uEB42";
    // U+EB3E  One channel (mono)
    Glyphs["elecAudioChannelsOne"] = "\uEB3E";
    // U+EB45  Seven channels
    Glyphs["elecAudioChannelsSeven"] = "\uEB45";
    // U+EB44  Six channels (5.1 surround)
    Glyphs["elecAudioChannelsSix"] = "\uEB44";
    // U+EB40  Three channels (frontal)
    Glyphs["elecAudioChannelsThreeFrontal"] = "\uEB40";
    // U+EB41  Three channels (surround)
    Glyphs["elecAudioChannelsThreeSurround"] = "\uEB41";
    // U+EB3F  Two channels (stereo)
    Glyphs["elecAudioChannelsTwo"] = "\uEB3F";
    // U+EB49  Audio in
    Glyphs["elecAudioIn"] = "\uEB49";
    // U+EB3C  Mono audio setup
    Glyphs["elecAudioMono"] = "\uEB3C";
    // U+EB4A  Audio out
    Glyphs["elecAudioOut"] = "\uEB4A";
    // U+EB3D  Stereo audio setup
    Glyphs["elecAudioStereo"] = "\uEB3D";
    // U+EB1B  Camera
    Glyphs["elecCamera"] = "\uEB1B";
    // U+EB4D  Data in
    Glyphs["elecDataIn"] = "\uEB4D";
    // U+EB4E  Data out
    Glyphs["elecDataOut"] = "\uEB4E";
    // U+EB13  Disc
    Glyphs["elecDisc"] = "\uEB13";
    // U+EB4F  Download
    Glyphs["elecDownload"] = "\uEB4F";
    // U+EB2B  Eject
    Glyphs["elecEject"] = "\uEB2B";
    // U+EB1F  Fast-forward
    Glyphs["elecFastForward"] = "\uEB1F";
    // U+EB11  Headphones
    Glyphs["elecHeadphones"] = "\uEB11";
    // U+EB12  Headset
    Glyphs["elecHeadset"] = "\uEB12";
    // U+EB47  Line in
    Glyphs["elecLineIn"] = "\uEB47";
    // U+EB48  Line out
    Glyphs["elecLineOut"] = "\uEB48";
    // U+EB23  Loop
    Glyphs["elecLoop"] = "\uEB23";
    // U+EB1A  Loudspeaker
    Glyphs["elecLoudspeaker"] = "\uEB1A";
    // U+EB36  MIDI controller 0%
    Glyphs["elecMIDIController0"] = "\uEB36";
    // U+EB3B  MIDI controller 100%
    Glyphs["elecMIDIController100"] = "\uEB3B";
    // U+EB37  MIDI controller 20%
    Glyphs["elecMIDIController20"] = "\uEB37";
    // U+EB38  MIDI controller 40%
    Glyphs["elecMIDIController40"] = "\uEB38";
    // U+EB39  MIDI controller 60%
    Glyphs["elecMIDIController60"] = "\uEB39";
    // U+EB3A  MIDI controller 80%
    Glyphs["elecMIDIController80"] = "\uEB3A";
    // U+EB34  MIDI in
    Glyphs["elecMIDIIn"] = "\uEB34";
    // U+EB35  MIDI out
    Glyphs["elecMIDIOut"] = "\uEB35";
    // U+EB10  Microphone
    Glyphs["elecMicrophone"] = "\uEB10";
    // U+EB28  Mute microphone
    Glyphs["elecMicrophoneMute"] = "\uEB28";
    // U+EB29  Unmute microphone
    Glyphs["elecMicrophoneUnmute"] = "\uEB29";
    // U+EB15  Mixing console
    Glyphs["elecMixingConsole"] = "\uEB15";
    // U+EB18  Monitor
    Glyphs["elecMonitor"] = "\uEB18";
    // U+EB26  Mute
    Glyphs["elecMute"] = "\uEB26";
    // U+EB1E  Pause
    Glyphs["elecPause"] = "\uEB1E";
    // U+EB1C  Play
    Glyphs["elecPlay"] = "\uEB1C";
    // U+EB2A  Power on/off
    Glyphs["elecPowerOnOff"] = "\uEB2A";
    // U+EB19  Projector
    Glyphs["elecProjector"] = "\uEB19";
    // U+EB24  Replay
    Glyphs["elecReplay"] = "\uEB24";
    // U+EB20  Rewind
    Glyphs["elecRewind"] = "\uEB20";
    // U+EB25  Shuffle
    Glyphs["elecShuffle"] = "\uEB25";
    // U+EB22  Skip backwards
    Glyphs["elecSkipBackwards"] = "\uEB22";
    // U+EB21  Skip forwards
    Glyphs["elecSkipForwards"] = "\uEB21";
    // U+EB1D  Stop
    Glyphs["elecStop"] = "\uEB1D";
    // U+EB14  Tape
    Glyphs["elecTape"] = "\uEB14";
    // U+EB16  USB connection
    Glyphs["elecUSB"] = "\uEB16";
    // U+EB27  Unmute
    Glyphs["elecUnmute"] = "\uEB27";
    // U+EB50  Upload
    Glyphs["elecUpload"] = "\uEB50";
    // U+EB17  Video camera
    Glyphs["elecVideoCamera"] = "\uEB17";
    // U+EB4B  Video in
    Glyphs["elecVideoIn"] = "\uEB4B";
    // U+EB4C  Video out
    Glyphs["elecVideoOut"] = "\uEB4C";
    // U+EB2C  Combining volume fader
    Glyphs["elecVolumeFader"] = "\uEB2C";
    // U+EB2D  Combining volume fader thumb
    Glyphs["elecVolumeFaderThumb"] = "\uEB2D";
    // U+EB2E  Volume level 0%
    Glyphs["elecVolumeLevel0"] = "\uEB2E";
    // U+EB33  Volume level 100%
    Glyphs["elecVolumeLevel100"] = "\uEB33";
    // U+EB2F  Volume level 20%
    Glyphs["elecVolumeLevel20"] = "\uEB2F";
    // U+EB30  Volume level 40%
    Glyphs["elecVolumeLevel40"] = "\uEB30";
    // U+EB31  Volume level 60%
    Glyphs["elecVolumeLevel60"] = "\uEB31";
    // U+EB32  Volume level 80%
    Glyphs["elecVolumeLevel80"] = "\uEB32";
    // U+E062  F clef
    Glyphs["fClef"] = "\uE062";
    // U+E066  F clef quindicesima alta
    Glyphs["fClef15ma"] = "\uE066";
    // U+E063  F clef quindicesima bassa
    Glyphs["fClef15mb"] = "\uE063";
    // U+E065  F clef ottava alta
    Glyphs["fClef8va"] = "\uE065";
    // U+E064  F clef ottava bassa
    Glyphs["fClef8vb"] = "\uE064";
    // U+E068  F clef, arrow down
    Glyphs["fClefArrowDown"] = "\uE068";
    // U+E067  F clef, arrow up
    Glyphs["fClefArrowUp"] = "\uE067";
    // U+E07C  F clef change
    Glyphs["fClefChange"] = "\uE07C";
    // U+E076  Reversed F clef
    Glyphs["fClefReversed"] = "\uE076";
    // U+E077  Turned F clef
    Glyphs["fClefTurned"] = "\uE077";
    // U+E4C0  Fermata above
    Glyphs["fermataAbove"] = "\uE4C0";
    // U+E4C1  Fermata below
    Glyphs["fermataBelow"] = "\uE4C1";
    // U+E4C6  Long fermata above
    Glyphs["fermataLongAbove"] = "\uE4C6";
    // U+E4C7  Long fermata below
    Glyphs["fermataLongBelow"] = "\uE4C7";
    // U+E4CA  Long fermata (Henze) above
    Glyphs["fermataLongHenzeAbove"] = "\uE4CA";
    // U+E4CB  Long fermata (Henze) below
    Glyphs["fermataLongHenzeBelow"] = "\uE4CB";
    // U+E4C4  Short fermata above
    Glyphs["fermataShortAbove"] = "\uE4C4";
    // U+E4C5  Short fermata below
    Glyphs["fermataShortBelow"] = "\uE4C5";
    // U+E4CC  Short fermata (Henze) above
    Glyphs["fermataShortHenzeAbove"] = "\uE4CC";
    // U+E4CD  Short fermata (Henze) below
    Glyphs["fermataShortHenzeBelow"] = "\uE4CD";
    // U+E4C8  Very long fermata above
    Glyphs["fermataVeryLongAbove"] = "\uE4C8";
    // U+E4C9  Very long fermata below
    Glyphs["fermataVeryLongBelow"] = "\uE4C9";
    // U+E4C2  Very short fermata above
    Glyphs["fermataVeryShortAbove"] = "\uE4C2";
    // U+E4C3  Very short fermata below
    Glyphs["fermataVeryShortBelow"] = "\uE4C3";
    // U+EA50  Figured bass 0
    Glyphs["figbass0"] = "\uEA50";
    // U+EA51  Figured bass 1
    Glyphs["figbass1"] = "\uEA51";
    // U+EA52  Figured bass 2
    Glyphs["figbass2"] = "\uEA52";
    // U+EA53  Figured bass 2 raised by half-step
    Glyphs["figbass2Raised"] = "\uEA53";
    // U+EA54  Figured bass 3
    Glyphs["figbass3"] = "\uEA54";
    // U+EA55  Figured bass 4
    Glyphs["figbass4"] = "\uEA55";
    // U+EA56  Figured bass 4 raised by half-step
    Glyphs["figbass4Raised"] = "\uEA56";
    // U+EA57  Figured bass 5
    Glyphs["figbass5"] = "\uEA57";
    // U+EA58  Figured bass 5 raised by half-step
    Glyphs["figbass5Raised1"] = "\uEA58";
    // U+EA59  Figured bass 5 raised by half-step 2
    Glyphs["figbass5Raised2"] = "\uEA59";
    // U+EA5A  Figured bass diminished 5
    Glyphs["figbass5Raised3"] = "\uEA5A";
    // U+EA5B  Figured bass 6
    Glyphs["figbass6"] = "\uEA5B";
    // U+EA5C  Figured bass 6 raised by half-step
    Glyphs["figbass6Raised"] = "\uEA5C";
    // U+EA6F  Figured bass 6 raised by half-step 2
    Glyphs["figbass6Raised2"] = "\uEA6F";
    // U+EA5D  Figured bass 7
    Glyphs["figbass7"] = "\uEA5D";
    // U+ECC0  Figured bass 7 diminished
    Glyphs["figbass7Diminished"] = "\uECC0";
    // U+EA5E  Figured bass 7 raised by half-step
    Glyphs["figbass7Raised1"] = "\uEA5E";
    // U+EA5F  Figured bass 7 lowered by a half-step
    Glyphs["figbass7Raised2"] = "\uEA5F";
    // U+EA60  Figured bass 8
    Glyphs["figbass8"] = "\uEA60";
    // U+EA61  Figured bass 9
    Glyphs["figbass9"] = "\uEA61";
    // U+EA62  Figured bass 9 raised by half-step
    Glyphs["figbass9Raised"] = "\uEA62";
    // U+EA68  Figured bass [
    Glyphs["figbassBracketLeft"] = "\uEA68";
    // U+EA69  Figured bass ]
    Glyphs["figbassBracketRight"] = "\uEA69";
    // U+EA6E  Combining lower
    Glyphs["figbassCombiningLowering"] = "\uEA6E";
    // U+EA6D  Combining raise
    Glyphs["figbassCombiningRaising"] = "\uEA6D";
    // U+EA63  Figured bass double flat
    Glyphs["figbassDoubleFlat"] = "\uEA63";
    // U+EA67  Figured bass double sharp
    Glyphs["figbassDoubleSharp"] = "\uEA67";
    // U+EA64  Figured bass flat
    Glyphs["figbassFlat"] = "\uEA64";
    // U+EA65  Figured bass natural
    Glyphs["figbassNatural"] = "\uEA65";
    // U+EA6A  Figured bass (
    Glyphs["figbassParensLeft"] = "\uEA6A";
    // U+EA6B  Figured bass )
    Glyphs["figbassParensRight"] = "\uEA6B";
    // U+EA6C  Figured bass +
    Glyphs["figbassPlus"] = "\uEA6C";
    // U+EA66  Figured bass sharp
    Glyphs["figbassSharp"] = "\uEA66";
    // U+ECC1  Figured bass triple flat
    Glyphs["figbassTripleFlat"] = "\uECC1";
    // U+ECC2  Figured bass triple sharp
    Glyphs["figbassTripleSharp"] = "\uECC2";
    // U+ED10  Fingering 0 (open string)
    Glyphs["fingering0"] = "\uED10";
    // U+ED80  Fingering 0 italic (open string)
    Glyphs["fingering0Italic"] = "\uED80";
    // U+ED11  Fingering 1 (thumb)
    Glyphs["fingering1"] = "\uED11";
    // U+ED81  Fingering 1 italic (thumb)
    Glyphs["fingering1Italic"] = "\uED81";
    // U+ED12  Fingering 2 (index finger)
    Glyphs["fingering2"] = "\uED12";
    // U+ED82  Fingering 2 italic (index finger)
    Glyphs["fingering2Italic"] = "\uED82";
    // U+ED13  Fingering 3 (middle finger)
    Glyphs["fingering3"] = "\uED13";
    // U+ED83  Fingering 3 italic (middle finger)
    Glyphs["fingering3Italic"] = "\uED83";
    // U+ED14  Fingering 4 (ring finger)
    Glyphs["fingering4"] = "\uED14";
    // U+ED84  Fingering 4 italic (ring finger)
    Glyphs["fingering4Italic"] = "\uED84";
    // U+ED15  Fingering 5 (little finger)
    Glyphs["fingering5"] = "\uED15";
    // U+ED85  Fingering 5 italic (little finger)
    Glyphs["fingering5Italic"] = "\uED85";
    // U+ED24  Fingering 6
    Glyphs["fingering6"] = "\uED24";
    // U+ED86  Fingering 6 italic
    Glyphs["fingering6Italic"] = "\uED86";
    // U+ED25  Fingering 7
    Glyphs["fingering7"] = "\uED25";
    // U+ED87  Fingering 7 italic
    Glyphs["fingering7Italic"] = "\uED87";
    // U+ED26  Fingering 8
    Glyphs["fingering8"] = "\uED26";
    // U+ED88  Fingering 8 italic
    Glyphs["fingering8Italic"] = "\uED88";
    // U+ED27  Fingering 9
    Glyphs["fingering9"] = "\uED27";
    // U+ED89  Fingering 9 italic
    Glyphs["fingering9Italic"] = "\uED89";
    // U+ED1B  Fingering a (anular; right-hand ring finger for guitar)
    Glyphs["fingeringALower"] = "\uED1B";
    // U+ED1C  Fingering c (right-hand little finger for guitar)
    Glyphs["fingeringCLower"] = "\uED1C";
    // U+ED1E  Fingering e (right-hand little finger for guitar)
    Glyphs["fingeringELower"] = "\uED1E";
    // U+ED19  Fingering i (indicio; right-hand index finger for guitar)
    Glyphs["fingeringILower"] = "\uED19";
    // U+ED2A  Fingering left bracket
    Glyphs["fingeringLeftBracket"] = "\uED2A";
    // U+ED8C  Fingering left bracket italic
    Glyphs["fingeringLeftBracketItalic"] = "\uED8C";
    // U+ED28  Fingering left parenthesis
    Glyphs["fingeringLeftParenthesis"] = "\uED28";
    // U+ED8A  Fingering left parenthesis italic
    Glyphs["fingeringLeftParenthesisItalic"] = "\uED8A";
    // U+ED1A  Fingering m (medio; right-hand middle finger for guitar)
    Glyphs["fingeringMLower"] = "\uED1A";
    // U+ED23  Multiple notes played by thumb or single finger
    Glyphs["fingeringMultipleNotes"] = "\uED23";
    // U+ED1F  Fingering o (right-hand little finger for guitar)
    Glyphs["fingeringOLower"] = "\uED1F";
    // U+ED17  Fingering p (pulgar; right-hand thumb for guitar)
    Glyphs["fingeringPLower"] = "\uED17";
    // U+ED8E  Fingering q (right-hand little finger for guitar)
    Glyphs["fingeringQLower"] = "\uED8E";
    // U+ED2B  Fingering right bracket
    Glyphs["fingeringRightBracket"] = "\uED2B";
    // U+ED8D  Fingering right bracket italic
    Glyphs["fingeringRightBracketItalic"] = "\uED8D";
    // U+ED29  Fingering right parenthesis
    Glyphs["fingeringRightParenthesis"] = "\uED29";
    // U+ED8B  Fingering right parenthesis italic
    Glyphs["fingeringRightParenthesisItalic"] = "\uED8B";
    // U+ED8F  Fingering s (right-hand little finger for guitar)
    Glyphs["fingeringSLower"] = "\uED8F";
    // U+ED2C  Fingering middle dot separator
    Glyphs["fingeringSeparatorMiddleDot"] = "\uED2C";
    // U+ED2D  Fingering white middle dot separator
    Glyphs["fingeringSeparatorMiddleDotWhite"] = "\uED2D";
    // U+ED2E  Fingering forward slash separator
    Glyphs["fingeringSeparatorSlash"] = "\uED2E";
    // U+ED20  Finger substitution above
    Glyphs["fingeringSubstitutionAbove"] = "\uED20";
    // U+ED21  Finger substitution below
    Glyphs["fingeringSubstitutionBelow"] = "\uED21";
    // U+ED22  Finger substitution dash
    Glyphs["fingeringSubstitutionDash"] = "\uED22";
    // U+ED18  Fingering t (right-hand thumb for guitar)
    Glyphs["fingeringTLower"] = "\uED18";
    // U+ED16  Fingering T (left-hand thumb for guitar)
    Glyphs["fingeringTUpper"] = "\uED16";
    // U+ED1D  Fingering x (right-hand little finger for guitar)
    Glyphs["fingeringXLower"] = "\uED1D";
    // U+E24F  Combining flag 8 (1024th) below
    Glyphs["flag1024thDown"] = "\uE24F";
    // U+E24E  Combining flag 8 (1024th) above
    Glyphs["flag1024thUp"] = "\uE24E";
    // U+E249  Combining flag 5 (128th) below
    Glyphs["flag128thDown"] = "\uE249";
    // U+E248  Combining flag 5 (128th) above
    Glyphs["flag128thUp"] = "\uE248";
    // U+E243  Combining flag 2 (16th) below
    Glyphs["flag16thDown"] = "\uE243";
    // U+E242  Combining flag 2 (16th) above
    Glyphs["flag16thUp"] = "\uE242";
    // U+E24B  Combining flag 6 (256th) below
    Glyphs["flag256thDown"] = "\uE24B";
    // U+E24A  Combining flag 6 (256th) above
    Glyphs["flag256thUp"] = "\uE24A";
    // U+E245  Combining flag 3 (32nd) below
    Glyphs["flag32ndDown"] = "\uE245";
    // U+E244  Combining flag 3 (32nd) above
    Glyphs["flag32ndUp"] = "\uE244";
    // U+E24D  Combining flag 7 (512th) below
    Glyphs["flag512thDown"] = "\uE24D";
    // U+E24C  Combining flag 7 (512th) above
    Glyphs["flag512thUp"] = "\uE24C";
    // U+E247  Combining flag 4 (64th) below
    Glyphs["flag64thDown"] = "\uE247";
    // U+E246  Combining flag 4 (64th) above
    Glyphs["flag64thUp"] = "\uE246";
    // U+E241  Combining flag 1 (8th) below
    Glyphs["flag8thDown"] = "\uE241";
    // U+E240  Combining flag 1 (8th) above
    Glyphs["flag8thUp"] = "\uE240";
    // U+E251  Internal combining flag below
    Glyphs["flagInternalDown"] = "\uE251";
    // U+E250  Internal combining flag above
    Glyphs["flagInternalUp"] = "\uE250";
    // U+E850  3-string fretboard
    Glyphs["fretboard3String"] = "\uE850";
    // U+E851  3-string fretboard at nut
    Glyphs["fretboard3StringNut"] = "\uE851";
    // U+E852  4-string fretboard
    Glyphs["fretboard4String"] = "\uE852";
    // U+E853  4-string fretboard at nut
    Glyphs["fretboard4StringNut"] = "\uE853";
    // U+E854  5-string fretboard
    Glyphs["fretboard5String"] = "\uE854";
    // U+E855  5-string fretboard at nut
    Glyphs["fretboard5StringNut"] = "\uE855";
    // U+E856  6-string fretboard
    Glyphs["fretboard6String"] = "\uE856";
    // U+E857  6-string fretboard at nut
    Glyphs["fretboard6StringNut"] = "\uE857";
    // U+E858  Fingered fret (filled circle)
    Glyphs["fretboardFilledCircle"] = "\uE858";
    // U+E85A  Open string (O)
    Glyphs["fretboardO"] = "\uE85A";
    // U+E859  String not played (X)
    Glyphs["fretboardX"] = "\uE859";
    // U+EA93  Function theory angle bracket left
    Glyphs["functionAngleLeft"] = "\uEA93";
    // U+EA94  Function theory angle bracket right
    Glyphs["functionAngleRight"] = "\uEA94";
    // U+EA8F  Function theory bracket left
    Glyphs["functionBracketLeft"] = "\uEA8F";
    // U+EA90  Function theory bracket right
    Glyphs["functionBracketRight"] = "\uEA90";
    // U+EA81  Function theory dominant of dominant
    Glyphs["functionDD"] = "\uEA81";
    // U+EA80  Function theory minor dominant
    Glyphs["functionDLower"] = "\uEA80";
    // U+EA7F  Function theory major dominant
    Glyphs["functionDUpper"] = "\uEA7F";
    // U+EA78  Function theory 8
    Glyphs["functionEight"] = "\uEA78";
    // U+EA99  Function theory F
    Glyphs["functionFUpper"] = "\uEA99";
    // U+EA75  Function theory 5
    Glyphs["functionFive"] = "\uEA75";
    // U+EA74  Function theory 4
    Glyphs["functionFour"] = "\uEA74";
    // U+EA84  Function theory g
    Glyphs["functionGLower"] = "\uEA84";
    // U+EA83  Function theory G
    Glyphs["functionGUpper"] = "\uEA83";
    // U+EA7C  Function theory greater than
    Glyphs["functionGreaterThan"] = "\uEA7C";
    // U+EA9B  Function theory i
    Glyphs["functionILower"] = "\uEA9B";
    // U+EA9A  Function theory I
    Glyphs["functionIUpper"] = "\uEA9A";
    // U+EA9D  Function theory k
    Glyphs["functionKLower"] = "\uEA9D";
    // U+EA9C  Function theory K
    Glyphs["functionKUpper"] = "\uEA9C";
    // U+EA9F  Function theory l
    Glyphs["functionLLower"] = "\uEA9F";
    // U+EA9E  Function theory L
    Glyphs["functionLUpper"] = "\uEA9E";
    // U+EA7A  Function theory less than
    Glyphs["functionLessThan"] = "\uEA7A";
    // U+ED01  Function theory m
    Glyphs["functionMLower"] = "\uED01";
    // U+ED00  Function theory M
    Glyphs["functionMUpper"] = "\uED00";
    // U+EA7B  Function theory minus
    Glyphs["functionMinus"] = "\uEA7B";
    // U+EA86  Function theory n
    Glyphs["functionNLower"] = "\uEA86";
    // U+EA85  Function theory N
    Glyphs["functionNUpper"] = "\uEA85";
    // U+ED02  Function theory superscript N
    Glyphs["functionNUpperSuperscript"] = "\uED02";
    // U+EA79  Function theory 9
    Glyphs["functionNine"] = "\uEA79";
    // U+EA71  Function theory 1
    Glyphs["functionOne"] = "\uEA71";
    // U+EA88  Function theory p
    Glyphs["functionPLower"] = "\uEA88";
    // U+EA87  Function theory P
    Glyphs["functionPUpper"] = "\uEA87";
    // U+EA91  Function theory parenthesis left
    Glyphs["functionParensLeft"] = "\uEA91";
    // U+EA92  Function theory parenthesis right
    Glyphs["functionParensRight"] = "\uEA92";
    // U+EA98  Function theory prefix plus
    Glyphs["functionPlus"] = "\uEA98";
    // U+ED03  Function theory r
    Glyphs["functionRLower"] = "\uED03";
    // U+EA95  Function theory repetition 1
    Glyphs["functionRepetition1"] = "\uEA95";
    // U+EA96  Function theory repetition 2
    Glyphs["functionRepetition2"] = "\uEA96";
    // U+EA97  Function theory prefix ring
    Glyphs["functionRing"] = "\uEA97";
    // U+EA8A  Function theory minor subdominant
    Glyphs["functionSLower"] = "\uEA8A";
    // U+EA7E  Function theory minor subdominant of subdominant
    Glyphs["functionSSLower"] = "\uEA7E";
    // U+EA7D  Function theory major subdominant of subdominant
    Glyphs["functionSSUpper"] = "\uEA7D";
    // U+EA89  Function theory major subdominant
    Glyphs["functionSUpper"] = "\uEA89";
    // U+EA77  Function theory 7
    Glyphs["functionSeven"] = "\uEA77";
    // U+EA76  Function theory 6
    Glyphs["functionSix"] = "\uEA76";
    // U+EA82  Function theory double dominant seventh
    Glyphs["functionSlashedDD"] = "\uEA82";
    // U+EA8C  Function theory minor tonic
    Glyphs["functionTLower"] = "\uEA8C";
    // U+EA8B  Function theory tonic
    Glyphs["functionTUpper"] = "\uEA8B";
    // U+EA73  Function theory 3
    Glyphs["functionThree"] = "\uEA73";
    // U+EA72  Function theory 2
    Glyphs["functionTwo"] = "\uEA72";
    // U+EA8E  Function theory v
    Glyphs["functionVLower"] = "\uEA8E";
    // U+EA8D  Function theory V
    Glyphs["functionVUpper"] = "\uEA8D";
    // U+EA70  Function theory 0
    Glyphs["functionZero"] = "\uEA70";
    // U+E050  G clef
    Glyphs["gClef"] = "\uE050";
    // U+E054  G clef quindicesima alta
    Glyphs["gClef15ma"] = "\uE054";
    // U+E051  G clef quindicesima bassa
    Glyphs["gClef15mb"] = "\uE051";
    // U+E053  G clef ottava alta
    Glyphs["gClef8va"] = "\uE053";
    // U+E052  G clef ottava bassa
    Glyphs["gClef8vb"] = "\uE052";
    // U+E056  G clef ottava bassa with C clef
    Glyphs["gClef8vbCClef"] = "\uE056";
    // U+E055  G clef ottava bassa (old style)
    Glyphs["gClef8vbOld"] = "\uE055";
    // U+E057  G clef, optionally ottava bassa
    Glyphs["gClef8vbParens"] = "\uE057";
    // U+E05B  G clef, arrow down
    Glyphs["gClefArrowDown"] = "\uE05B";
    // U+E05A  G clef, arrow up
    Glyphs["gClefArrowUp"] = "\uE05A";
    // U+E07A  G clef change
    Glyphs["gClefChange"] = "\uE07A";
    // U+E059  Combining G clef, number above
    Glyphs["gClefLigatedNumberAbove"] = "\uE059";
    // U+E058  Combining G clef, number below
    Glyphs["gClefLigatedNumberBelow"] = "\uE058";
    // U+E073  Reversed G clef
    Glyphs["gClefReversed"] = "\uE073";
    // U+E074  Turned G clef
    Glyphs["gClefTurned"] = "\uE074";
    // U+E586  Glissando down
    Glyphs["glissandoDown"] = "\uE586";
    // U+E585  Glissando up
    Glyphs["glissandoUp"] = "\uE585";
    // U+E561  Slashed grace note stem down
    Glyphs["graceNoteAcciaccaturaStemDown"] = "\uE561";
    // U+E560  Slashed grace note stem up
    Glyphs["graceNoteAcciaccaturaStemUp"] = "\uE560";
    // U+E563  Grace note stem down
    Glyphs["graceNoteAppoggiaturaStemDown"] = "\uE563";
    // U+E562  Grace note stem up
    Glyphs["graceNoteAppoggiaturaStemUp"] = "\uE562";
    // U+E565  Slash for stem down grace note
    Glyphs["graceNoteSlashStemDown"] = "\uE565";
    // U+E564  Slash for stem up grace note
    Glyphs["graceNoteSlashStemUp"] = "\uE564";
    // U+E848  Full barr
    Glyphs["guitarBarreFull"] = "\uE848";
    // U+E849  Half barr
    Glyphs["guitarBarreHalf"] = "\uE849";
    // U+E83F  Closed wah/volume pedal
    Glyphs["guitarClosePedal"] = "\uE83F";
    // U+E843  Fade in
    Glyphs["guitarFadeIn"] = "\uE843";
    // U+E844  Fade out
    Glyphs["guitarFadeOut"] = "\uE844";
    // U+E842  Golpe (tapping the pick guard)
    Glyphs["guitarGolpe"] = "\uE842";
    // U+E83E  Half-open wah/volume pedal
    Glyphs["guitarHalfOpenPedal"] = "\uE83E";
    // U+E840  Left-hand tapping
    Glyphs["guitarLeftHandTapping"] = "\uE840";
    // U+E83D  Open wah/volume pedal
    Glyphs["guitarOpenPedal"] = "\uE83D";
    // U+E841  Right-hand tapping
    Glyphs["guitarRightHandTapping"] = "\uE841";
    // U+E832  Guitar shake
    Glyphs["guitarShake"] = "\uE832";
    // U+E833  String number 0
    Glyphs["guitarString0"] = "\uE833";
    // U+E834  String number 1
    Glyphs["guitarString1"] = "\uE834";
    // U+E84A  String number 10
    Glyphs["guitarString10"] = "\uE84A";
    // U+E84B  String number 11
    Glyphs["guitarString11"] = "\uE84B";
    // U+E84C  String number 12
    Glyphs["guitarString12"] = "\uE84C";
    // U+E84D  String number 13
    Glyphs["guitarString13"] = "\uE84D";
    // U+E835  String number 2
    Glyphs["guitarString2"] = "\uE835";
    // U+E836  String number 3
    Glyphs["guitarString3"] = "\uE836";
    // U+E837  String number 4
    Glyphs["guitarString4"] = "\uE837";
    // U+E838  String number 5
    Glyphs["guitarString5"] = "\uE838";
    // U+E839  String number 6
    Glyphs["guitarString6"] = "\uE839";
    // U+E83A  String number 7
    Glyphs["guitarString7"] = "\uE83A";
    // U+E83B  String number 8
    Glyphs["guitarString8"] = "\uE83B";
    // U+E83C  String number 9
    Glyphs["guitarString9"] = "\uE83C";
    // U+E847  Strum direction down
    Glyphs["guitarStrumDown"] = "\uE847";
    // U+E846  Strum direction up
    Glyphs["guitarStrumUp"] = "\uE846";
    // U+E831  Guitar vibrato bar dip
    Glyphs["guitarVibratoBarDip"] = "\uE831";
    // U+E830  Guitar vibrato bar scoop
    Glyphs["guitarVibratoBarScoop"] = "\uE830";
    // U+EAB2  Vibrato wiggle segment
    Glyphs["guitarVibratoStroke"] = "\uEAB2";
    // U+E845  Volume swell
    Glyphs["guitarVolumeSwell"] = "\uE845";
    // U+EAB3  Wide vibrato wiggle segment
    Glyphs["guitarWideVibratoStroke"] = "\uEAB3";
    // U+E81F  Belltree
    Glyphs["handbellsBelltree"] = "\uE81F";
    // U+E81E  Damp 3
    Glyphs["handbellsDamp3"] = "\uE81E";
    // U+E81B  Echo
    Glyphs["handbellsEcho1"] = "\uE81B";
    // U+E81C  Echo 2
    Glyphs["handbellsEcho2"] = "\uE81C";
    // U+E81D  Gyro
    Glyphs["handbellsGyro"] = "\uE81D";
    // U+E812  Hand martellato
    Glyphs["handbellsHandMartellato"] = "\uE812";
    // U+E815  Mallet, bell on table
    Glyphs["handbellsMalletBellOnTable"] = "\uE815";
    // U+E814  Mallet, bell suspended
    Glyphs["handbellsMalletBellSuspended"] = "\uE814";
    // U+E816  Mallet lift
    Glyphs["handbellsMalletLft"] = "\uE816";
    // U+E810  Martellato
    Glyphs["handbellsMartellato"] = "\uE810";
    // U+E811  Martellato lift
    Glyphs["handbellsMartellatoLift"] = "\uE811";
    // U+E813  Muted martellato
    Glyphs["handbellsMutedMartellato"] = "\uE813";
    // U+E817  Pluck lift
    Glyphs["handbellsPluckLift"] = "\uE817";
    // U+E81A  Swing
    Glyphs["handbellsSwing"] = "\uE81A";
    // U+E819  Swing down
    Glyphs["handbellsSwingDown"] = "\uE819";
    // U+E818  Swing up
    Glyphs["handbellsSwingUp"] = "\uE818";
    // U+E821  Table pair of handbells
    Glyphs["handbellsTablePairBells"] = "\uE821";
    // U+E820  Table single handbell
    Glyphs["handbellsTableSingleBell"] = "\uE820";
    // U+E68F  Metal rod pictogram
    Glyphs["harpMetalRod"] = "\uE68F";
    // U+E681  Harp pedal centered (natural)
    Glyphs["harpPedalCentered"] = "\uE681";
    // U+E683  Harp pedal divider
    Glyphs["harpPedalDivider"] = "\uE683";
    // U+E682  Harp pedal lowered (sharp)
    Glyphs["harpPedalLowered"] = "\uE682";
    // U+E680  Harp pedal raised (flat)
    Glyphs["harpPedalRaised"] = "\uE680";
    // U+E695  Ascending aeolian chords (Salzedo)
    Glyphs["harpSalzedoAeolianAscending"] = "\uE695";
    // U+E696  Descending aeolian chords (Salzedo)
    Glyphs["harpSalzedoAeolianDescending"] = "\uE696";
    // U+E69A  Damp above (Salzedo)
    Glyphs["harpSalzedoDampAbove"] = "\uE69A";
    // U+E699  Damp below (Salzedo)
    Glyphs["harpSalzedoDampBelow"] = "\uE699";
    // U+E698  Damp with both hands (Salzedo)
    Glyphs["harpSalzedoDampBothHands"] = "\uE698";
    // U+E697  Damp only low strings (Salzedo)
    Glyphs["harpSalzedoDampLowStrings"] = "\uE697";
    // U+E68D  Fluidic sounds, left hand (Salzedo)
    Glyphs["harpSalzedoFluidicSoundsLeft"] = "\uE68D";
    // U+E68E  Fluidic sounds, right hand (Salzedo)
    Glyphs["harpSalzedoFluidicSoundsRight"] = "\uE68E";
    // U+E69C  Isolated sounds (Salzedo)
    Glyphs["harpSalzedoIsolatedSounds"] = "\uE69C";
    // U+E688  Metallic sounds (Salzedo)
    Glyphs["harpSalzedoMetallicSounds"] = "\uE688";
    // U+E69B  Metallic sounds, one string (Salzedo)
    Glyphs["harpSalzedoMetallicSoundsOneString"] = "\uE69B";
    // U+E68C  Muffle totally (Salzedo)
    Glyphs["harpSalzedoMuffleTotally"] = "\uE68C";
    // U+E685  Oboic flux (Salzedo)
    Glyphs["harpSalzedoOboicFlux"] = "\uE685";
    // U+E68A  Play at upper end of strings (Salzedo)
    Glyphs["harpSalzedoPlayUpperEnd"] = "\uE68A";
    // U+E684  Slide with suppleness (Salzedo)
    Glyphs["harpSalzedoSlideWithSuppleness"] = "\uE684";
    // U+E69D  Snare drum effect (Salzedo)
    Glyphs["harpSalzedoSnareDrum"] = "\uE69D";
    // U+E689  Tam-tam sounds (Salzedo)
    Glyphs["harpSalzedoTamTamSounds"] = "\uE689";
    // U+E686  Thunder effect (Salzedo)
    Glyphs["harpSalzedoThunderEffect"] = "\uE686";
    // U+E68B  Timpanic sounds (Salzedo)
    Glyphs["harpSalzedoTimpanicSounds"] = "\uE68B";
    // U+E687  Whistling sounds (Salzedo)
    Glyphs["harpSalzedoWhistlingSounds"] = "\uE687";
    // U+E694  Combining string noise for stem
    Glyphs["harpStringNoiseStem"] = "\uE694";
    // U+E690  Tuning key pictogram
    Glyphs["harpTuningKey"] = "\uE690";
    // U+E693  Retune strings for glissando
    Glyphs["harpTuningKeyGlissando"] = "\uE693";
    // U+E691  Use handle of tuning key pictogram
    Glyphs["harpTuningKeyHandle"] = "\uE691";
    // U+E692  Use shank of tuning key pictogram
    Glyphs["harpTuningKeyShank"] = "\uE692";
    // U+ED70  Indian drum clef
    Glyphs["indianDrumClef"] = "\uED70";
    // U+EDE2  Back-chug
    Glyphs["kahnBackChug"] = "\uEDE2";
    // U+EDD8  Back-flap
    Glyphs["kahnBackFlap"] = "\uEDD8";
    // U+EDE1  Back-riff
    Glyphs["kahnBackRiff"] = "\uEDE1";
    // U+EDDA  Back-rip
    Glyphs["kahnBackRip"] = "\uEDDA";
    // U+EDC6  Ball-change
    Glyphs["kahnBallChange"] = "\uEDC6";
    // U+EDCD  Ball-dig
    Glyphs["kahnBallDig"] = "\uEDCD";
    // U+EDA7  Brush-backward
    Glyphs["kahnBrushBackward"] = "\uEDA7";
    // U+EDA6  Brush-forward
    Glyphs["kahnBrushForward"] = "\uEDA6";
    // U+EDDD  Chug
    Glyphs["kahnChug"] = "\uEDDD";
    // U+EDB8  Clap
    Glyphs["kahnClap"] = "\uEDB8";
    // U+EDBA  Double-snap
    Glyphs["kahnDoubleSnap"] = "\uEDBA";
    // U+EDEB  Double-wing
    Glyphs["kahnDoubleWing"] = "\uEDEB";
    // U+EDB2  Draw-step
    Glyphs["kahnDrawStep"] = "\uEDB2";
    // U+EDB3  Draw-tap
    Glyphs["kahnDrawTap"] = "\uEDB3";
    // U+EDCF  Flam
    Glyphs["kahnFlam"] = "\uEDCF";
    // U+EDD5  Flap
    Glyphs["kahnFlap"] = "\uEDD5";
    // U+EDD7  Flap-step
    Glyphs["kahnFlapStep"] = "\uEDD7";
    // U+EDA9  Flat
    Glyphs["kahnFlat"] = "\uEDA9";
    // U+EDB0  Flea-hop
    Glyphs["kahnFleaHop"] = "\uEDB0";
    // U+EDB1  Flea-tap
    Glyphs["kahnFleaTap"] = "\uEDB1";
    // U+EDA8  Grace-tap
    Glyphs["kahnGraceTap"] = "\uEDA8";
    // U+EDD1  Grace-tap-change
    Glyphs["kahnGraceTapChange"] = "\uEDD1";
    // U+EDD0  Grace-tap-hop
    Glyphs["kahnGraceTapHop"] = "\uEDD0";
    // U+EDD3  Grace-tap-stamp
    Glyphs["kahnGraceTapStamp"] = "\uEDD3";
    // U+EDAA  Heel
    Glyphs["kahnHeel"] = "\uEDAA";
    // U+EDC9  Heel-change
    Glyphs["kahnHeelChange"] = "\uEDC9";
    // U+EDBB  Heel-click
    Glyphs["kahnHeelClick"] = "\uEDBB";
    // U+EDB6  Heel-drop
    Glyphs["kahnHeelDrop"] = "\uEDB6";
    // U+EDC4  Heel-step
    Glyphs["kahnHeelStep"] = "\uEDC4";
    // U+EDCB  Heel-tap
    Glyphs["kahnHeelTap"] = "\uEDCB";
    // U+EDA2  Hop
    Glyphs["kahnHop"] = "\uEDA2";
    // U+EDA5  Jump-apart
    Glyphs["kahnJumpApart"] = "\uEDA5";
    // U+EDA4  Jump-together
    Glyphs["kahnJumpTogether"] = "\uEDA4";
    // U+EDAD  Knee-inward
    Glyphs["kahnKneeInward"] = "\uEDAD";
    // U+EDAC  Knee-outward
    Glyphs["kahnKneeOutward"] = "\uEDAC";
    // U+EDA3  Leap
    Glyphs["kahnLeap"] = "\uEDA3";
    // U+EDD2  Leap-flat-foot
    Glyphs["kahnLeapFlatFoot"] = "\uEDD2";
    // U+EDD4  Leap-heel-click
    Glyphs["kahnLeapHeelClick"] = "\uEDD4";
    // U+EDBF  Left-catch
    Glyphs["kahnLeftCatch"] = "\uEDBF";
    // U+EDBD  Left-cross
    Glyphs["kahnLeftCross"] = "\uEDBD";
    // U+EDEE  Left-foot
    Glyphs["kahnLeftFoot"] = "\uEDEE";
    // U+EDC1  Left-toe-strike
    Glyphs["kahnLeftToeStrike"] = "\uEDC1";
    // U+EDF0  Left-turn
    Glyphs["kahnLeftTurn"] = "\uEDF0";
    // U+EDEC  Over-the-top
    Glyphs["kahnOverTheTop"] = "\uEDEC";
    // U+EDED  Over-the-top-tap
    Glyphs["kahnOverTheTopTap"] = "\uEDED";
    // U+EDE3  Pull
    Glyphs["kahnPull"] = "\uEDE3";
    // U+EDDE  Push
    Glyphs["kahnPush"] = "\uEDDE";
    // U+EDE0  Riff
    Glyphs["kahnRiff"] = "\uEDE0";
    // U+EDE7  Riffle
    Glyphs["kahnRiffle"] = "\uEDE7";
    // U+EDC0  Right-catch
    Glyphs["kahnRightCatch"] = "\uEDC0";
    // U+EDBE  Right-cross
    Glyphs["kahnRightCross"] = "\uEDBE";
    // U+EDEF  Right-foot
    Glyphs["kahnRightFoot"] = "\uEDEF";
    // U+EDC2  Right-toe-strike
    Glyphs["kahnRightToeStrike"] = "\uEDC2";
    // U+EDF1  Right-turn
    Glyphs["kahnRightTurn"] = "\uEDF1";
    // U+EDD6  Rip
    Glyphs["kahnRip"] = "\uEDD6";
    // U+EDE8  Ripple
    Glyphs["kahnRipple"] = "\uEDE8";
    // U+EDAE  Scrape
    Glyphs["kahnScrape"] = "\uEDAE";
    // U+EDDC  Scuff
    Glyphs["kahnScuff"] = "\uEDDC";
    // U+EDE6  Scuffle
    Glyphs["kahnScuffle"] = "\uEDE6";
    // U+EDE5  Shuffle
    Glyphs["kahnShuffle"] = "\uEDE5";
    // U+EDCE  Slam
    Glyphs["kahnSlam"] = "\uEDCE";
    // U+EDD9  Slap
    Glyphs["kahnSlap"] = "\uEDD9";
    // U+EDB4  Slide-step
    Glyphs["kahnSlideStep"] = "\uEDB4";
    // U+EDB5  Slide-tap
    Glyphs["kahnSlideTap"] = "\uEDB5";
    // U+EDB9  Snap
    Glyphs["kahnSnap"] = "\uEDB9";
    // U+EDC3  Stamp
    Glyphs["kahnStamp"] = "\uEDC3";
    // U+EDC8  Stamp-stamp
    Glyphs["kahnStampStamp"] = "\uEDC8";
    // U+EDA0  Step
    Glyphs["kahnStep"] = "\uEDA0";
    // U+EDC7  Step-stamp
    Glyphs["kahnStepStamp"] = "\uEDC7";
    // U+EDCA  Stomp
    Glyphs["kahnStomp"] = "\uEDCA";
    // U+EDDB  Stomp-brush
    Glyphs["kahnStompBrush"] = "\uEDDB";
    // U+EDA1  Tap
    Glyphs["kahnTap"] = "\uEDA1";
    // U+EDAB  Toe
    Glyphs["kahnToe"] = "\uEDAB";
    // U+EDBC  Toe-click
    Glyphs["kahnToeClick"] = "\uEDBC";
    // U+EDB7  Toe-drop
    Glyphs["kahnToeDrop"] = "\uEDB7";
    // U+EDC5  Toe-step
    Glyphs["kahnToeStep"] = "\uEDC5";
    // U+EDCC  Toe-tap
    Glyphs["kahnToeTap"] = "\uEDCC";
    // U+EDAF  Trench
    Glyphs["kahnTrench"] = "\uEDAF";
    // U+EDE9  Wing
    Glyphs["kahnWing"] = "\uEDE9";
    // U+EDEA  Wing-change
    Glyphs["kahnWingChange"] = "\uEDEA";
    // U+EDE4  Zank
    Glyphs["kahnZank"] = "\uEDE4";
    // U+EDDF  Zink
    Glyphs["kahnZink"] = "\uEDDF";
    // U+E668  Clavichord bebung, 2 finger movements (above)
    Glyphs["keyboardBebung2DotsAbove"] = "\uE668";
    // U+E669  Clavichord bebung, 2 finger movements (below)
    Glyphs["keyboardBebung2DotsBelow"] = "\uE669";
    // U+E66A  Clavichord bebung, 3 finger movements (above)
    Glyphs["keyboardBebung3DotsAbove"] = "\uE66A";
    // U+E66B  Clavichord bebung, 3 finger movements (below)
    Glyphs["keyboardBebung3DotsBelow"] = "\uE66B";
    // U+E66C  Clavichord bebung, 4 finger movements (above)
    Glyphs["keyboardBebung4DotsAbove"] = "\uE66C";
    // U+E66D  Clavichord bebung, 4 finger movements (below)
    Glyphs["keyboardBebung4DotsBelow"] = "\uE66D";
    // U+E65E  Left pedal pictogram
    Glyphs["keyboardLeftPedalPictogram"] = "\uE65E";
    // U+E65F  Middle pedal pictogram
    Glyphs["keyboardMiddlePedalPictogram"] = "\uE65F";
    // U+E653  Pedal d
    Glyphs["keyboardPedalD"] = "\uE653";
    // U+E654  Pedal dot
    Glyphs["keyboardPedalDot"] = "\uE654";
    // U+E652  Pedal e
    Glyphs["keyboardPedalE"] = "\uE652";
    // U+E656  Half-pedal mark
    Glyphs["keyboardPedalHalf"] = "\uE656";
    // U+E65B  Half pedal mark 1
    Glyphs["keyboardPedalHalf2"] = "\uE65B";
    // U+E65C  Half pedal mark 2
    Glyphs["keyboardPedalHalf3"] = "\uE65C";
    // U+E661  Pedal heel 1
    Glyphs["keyboardPedalHeel1"] = "\uE661";
    // U+E662  Pedal heel 2
    Glyphs["keyboardPedalHeel2"] = "\uE662";
    // U+E663  Pedal heel 3 (Davis)
    Glyphs["keyboardPedalHeel3"] = "\uE663";
    // U+E674  Pedal heel to toe
    Glyphs["keyboardPedalHeelToToe"] = "\uE674";
    // U+E666  Pedal heel or toe
    Glyphs["keyboardPedalHeelToe"] = "\uE666";
    // U+E673  Pedal hook end
    Glyphs["keyboardPedalHookEnd"] = "\uE673";
    // U+E672  Pedal hook start
    Glyphs["keyboardPedalHookStart"] = "\uE672";
    // U+E658  Pedal hyphen
    Glyphs["keyboardPedalHyphen"] = "\uE658";
    // U+E651  Pedal P
    Glyphs["keyboardPedalP"] = "\uE651";
    // U+E676  Left parenthesis for pedal marking
    Glyphs["keyboardPedalParensLeft"] = "\uE676";
    // U+E677  Right parenthesis for pedal marking
    Glyphs["keyboardPedalParensRight"] = "\uE677";
    // U+E650  Pedal mark
    Glyphs["keyboardPedalPed"] = "\uE650";
    // U+E65A  Pedal S
    Glyphs["keyboardPedalS"] = "\uE65A";
    // U+E659  Sostenuto pedal mark
    Glyphs["keyboardPedalSost"] = "\uE659";
    // U+E664  Pedal toe 1
    Glyphs["keyboardPedalToe1"] = "\uE664";
    // U+E665  Pedal toe 2
    Glyphs["keyboardPedalToe2"] = "\uE665";
    // U+E675  Pedal toe to heel
    Glyphs["keyboardPedalToeToHeel"] = "\uE675";
    // U+E655  Pedal up mark
    Glyphs["keyboardPedalUp"] = "\uE655";
    // U+E657  Pedal up notch
    Glyphs["keyboardPedalUpNotch"] = "\uE657";
    // U+E65D  Pedal up special
    Glyphs["keyboardPedalUpSpecial"] = "\uE65D";
    // U+E670  Play with left hand
    Glyphs["keyboardPlayWithLH"] = "\uE670";
    // U+E671  Play with left hand (end)
    Glyphs["keyboardPlayWithLHEnd"] = "\uE671";
    // U+E66E  Play with right hand
    Glyphs["keyboardPlayWithRH"] = "\uE66E";
    // U+E66F  Play with right hand (end)
    Glyphs["keyboardPlayWithRHEnd"] = "\uE66F";
    // U+E667  Pluck strings inside piano (Maderna)
    Glyphs["keyboardPluckInside"] = "\uE667";
    // U+E660  Right pedal pictogram
    Glyphs["keyboardRightPedalPictogram"] = "\uE660";
    // U+EC3E  Kievan flat
    Glyphs["kievanAccidentalFlat"] = "\uEC3E";
    // U+EC3D  Kievan sharp
    Glyphs["kievanAccidentalSharp"] = "\uEC3D";
    // U+EC3C  Kievan augmentation dot
    Glyphs["kievanAugmentationDot"] = "\uEC3C";
    // U+EC30  Kievan C clef (tse-fa-ut)
    Glyphs["kievanCClef"] = "\uEC30";
    // U+EC31  Kievan ending symbol
    Glyphs["kievanEndingSymbol"] = "\uEC31";
    // U+EC3A  Kievan eighth note, stem down
    Glyphs["kievanNote8thStemDown"] = "\uEC3A";
    // U+EC39  Kievan eighth note, stem up
    Glyphs["kievanNote8thStemUp"] = "\uEC39";
    // U+EC3B  Kievan beam
    Glyphs["kievanNoteBeam"] = "\uEC3B";
    // U+EC35  Kievan half note (on staff line)
    Glyphs["kievanNoteHalfStaffLine"] = "\uEC35";
    // U+EC36  Kievan half note (in staff space)
    Glyphs["kievanNoteHalfStaffSpace"] = "\uEC36";
    // U+EC38  Kievan quarter note, stem down
    Glyphs["kievanNoteQuarterStemDown"] = "\uEC38";
    // U+EC37  Kievan quarter note, stem up
    Glyphs["kievanNoteQuarterStemUp"] = "\uEC37";
    // U+EC32  Kievan reciting note
    Glyphs["kievanNoteReciting"] = "\uEC32";
    // U+EC33  Kievan whole note
    Glyphs["kievanNoteWhole"] = "\uEC33";
    // U+EC34  Kievan final whole note
    Glyphs["kievanNoteWholeFinal"] = "\uEC34";
    // U+EC40  Do hand sign
    Glyphs["kodalyHandDo"] = "\uEC40";
    // U+EC43  Fa hand sign
    Glyphs["kodalyHandFa"] = "\uEC43";
    // U+EC45  La hand sign
    Glyphs["kodalyHandLa"] = "\uEC45";
    // U+EC42  Mi hand sign
    Glyphs["kodalyHandMi"] = "\uEC42";
    // U+EC41  Re hand sign
    Glyphs["kodalyHandRe"] = "\uEC41";
    // U+EC44  So hand sign
    Glyphs["kodalyHandSo"] = "\uEC44";
    // U+EC46  Ti hand sign
    Glyphs["kodalyHandTi"] = "\uEC46";
    // U+E04C  Left repeat sign within bar
    Glyphs["leftRepeatSmall"] = "\uE04C";
    // U+E022  Leger line
    Glyphs["legerLine"] = "\uE022";
    // U+E024  Leger line (narrow)
    Glyphs["legerLineNarrow"] = "\uE024";
    // U+E023  Leger line (wide)
    Glyphs["legerLineWide"] = "\uE023";
    // U+EBA4  Lute tablature end repeat barline
    Glyphs["luteBarlineEndRepeat"] = "\uEBA4";
    // U+EBA5  Lute tablature final barline
    Glyphs["luteBarlineFinal"] = "\uEBA5";
    // U+EBA3  Lute tablature start repeat barline
    Glyphs["luteBarlineStartRepeat"] = "\uEBA3";
    // U+EBAB  16th note (semiquaver) duration sign
    Glyphs["luteDuration16th"] = "\uEBAB";
    // U+EBAC  32nd note (demisemiquaver) duration sign
    Glyphs["luteDuration32nd"] = "\uEBAC";
    // U+EBAA  Eighth note (quaver) duration sign
    Glyphs["luteDuration8th"] = "\uEBAA";
    // U+EBA6  Double whole note (breve) duration sign
    Glyphs["luteDurationDoubleWhole"] = "\uEBA6";
    // U+EBA8  Half note (minim) duration sign
    Glyphs["luteDurationHalf"] = "\uEBA8";
    // U+EBA9  Quarter note (crotchet) duration sign
    Glyphs["luteDurationQuarter"] = "\uEBA9";
    // U+EBA7  Whole note (semibreve) duration sign
    Glyphs["luteDurationWhole"] = "\uEBA7";
    // U+EBAE  Right-hand fingering, first finger
    Glyphs["luteFingeringRHFirst"] = "\uEBAE";
    // U+EBAF  Right-hand fingering, second finger
    Glyphs["luteFingeringRHSecond"] = "\uEBAF";
    // U+EBB0  Right-hand fingering, third finger
    Glyphs["luteFingeringRHThird"] = "\uEBB0";
    // U+EBAD  Right-hand fingering, thumb
    Glyphs["luteFingeringRHThumb"] = "\uEBAD";
    // U+EBD0  10th course (diapason)
    Glyphs["luteFrench10thCourse"] = "\uEBD0";
    // U+EBCD  Seventh course (diapason)
    Glyphs["luteFrench7thCourse"] = "\uEBCD";
    // U+EBCE  Eighth course (diapason)
    Glyphs["luteFrench8thCourse"] = "\uEBCE";
    // U+EBCF  Ninth course (diapason)
    Glyphs["luteFrench9thCourse"] = "\uEBCF";
    // U+EBD5  Appoggiatura from above
    Glyphs["luteFrenchAppoggiaturaAbove"] = "\uEBD5";
    // U+EBD4  Appoggiatura from below
    Glyphs["luteFrenchAppoggiaturaBelow"] = "\uEBD4";
    // U+EBC0  Open string (a)
    Glyphs["luteFrenchFretA"] = "\uEBC0";
    // U+EBC1  First fret (b)
    Glyphs["luteFrenchFretB"] = "\uEBC1";
    // U+EBC2  Second fret (c)
    Glyphs["luteFrenchFretC"] = "\uEBC2";
    // U+EBC3  Third fret (d)
    Glyphs["luteFrenchFretD"] = "\uEBC3";
    // U+EBC4  Fourth fret (e)
    Glyphs["luteFrenchFretE"] = "\uEBC4";
    // U+EBC5  Fifth fret (f)
    Glyphs["luteFrenchFretF"] = "\uEBC5";
    // U+EBC6  Sixth fret (g)
    Glyphs["luteFrenchFretG"] = "\uEBC6";
    // U+EBC7  Seventh fret (h)
    Glyphs["luteFrenchFretH"] = "\uEBC7";
    // U+EBC8  Eighth fret (i)
    Glyphs["luteFrenchFretI"] = "\uEBC8";
    // U+EBC9  Ninth fret (k)
    Glyphs["luteFrenchFretK"] = "\uEBC9";
    // U+EBCA  10th fret (l)
    Glyphs["luteFrenchFretL"] = "\uEBCA";
    // U+EBCB  11th fret (m)
    Glyphs["luteFrenchFretM"] = "\uEBCB";
    // U+EBCC  12th fret (n)
    Glyphs["luteFrenchFretN"] = "\uEBCC";
    // U+EBD3  Inverted mordent
    Glyphs["luteFrenchMordentInverted"] = "\uEBD3";
    // U+EBD2  Mordent with lower auxiliary
    Glyphs["luteFrenchMordentLower"] = "\uEBD2";
    // U+EBD1  Mordent with upper auxiliary
    Glyphs["luteFrenchMordentUpper"] = "\uEBD1";
    // U+EC00  5th course, 1st fret (a)
    Glyphs["luteGermanALower"] = "\uEC00";
    // U+EC17  6th course, 1st fret (A)
    Glyphs["luteGermanAUpper"] = "\uEC17";
    // U+EC01  4th course, 1st fret (b)
    Glyphs["luteGermanBLower"] = "\uEC01";
    // U+EC18  6th course, 2nd fret (B)
    Glyphs["luteGermanBUpper"] = "\uEC18";
    // U+EC02  3rd course, 1st fret (c)
    Glyphs["luteGermanCLower"] = "\uEC02";
    // U+EC19  6th course, 3rd fret (C)
    Glyphs["luteGermanCUpper"] = "\uEC19";
    // U+EC03  2nd course, 1st fret (d)
    Glyphs["luteGermanDLower"] = "\uEC03";
    // U+EC1A  6th course, 4th fret (D)
    Glyphs["luteGermanDUpper"] = "\uEC1A";
    // U+EC04  1st course, 1st fret (e)
    Glyphs["luteGermanELower"] = "\uEC04";
    // U+EC1B  6th course, 5th fret (E)
    Glyphs["luteGermanEUpper"] = "\uEC1B";
    // U+EC05  5th course, 2nd fret (f)
    Glyphs["luteGermanFLower"] = "\uEC05";
    // U+EC1C  6th course, 6th fret (F)
    Glyphs["luteGermanFUpper"] = "\uEC1C";
    // U+EC06  4th course, 2nd fret (g)
    Glyphs["luteGermanGLower"] = "\uEC06";
    // U+EC1D  6th course, 7th fret (G)
    Glyphs["luteGermanGUpper"] = "\uEC1D";
    // U+EC07  3rd course, 2nd fret (h)
    Glyphs["luteGermanHLower"] = "\uEC07";
    // U+EC1E  6th course, 8th fret (H)
    Glyphs["luteGermanHUpper"] = "\uEC1E";
    // U+EC08  2nd course, 2nd fret (i)
    Glyphs["luteGermanILower"] = "\uEC08";
    // U+EC1F  6th course, 9th fret (I)
    Glyphs["luteGermanIUpper"] = "\uEC1F";
    // U+EC09  1st course, 2nd fret (k)
    Glyphs["luteGermanKLower"] = "\uEC09";
    // U+EC20  6th course, 10th fret (K)
    Glyphs["luteGermanKUpper"] = "\uEC20";
    // U+EC0A  5th course, 3rd fret (l)
    Glyphs["luteGermanLLower"] = "\uEC0A";
    // U+EC21  6th course, 11th fret (L)
    Glyphs["luteGermanLUpper"] = "\uEC21";
    // U+EC0B  4th course, 3rd fret (m)
    Glyphs["luteGermanMLower"] = "\uEC0B";
    // U+EC22  6th course, 12th fret (M)
    Glyphs["luteGermanMUpper"] = "\uEC22";
    // U+EC0C  3rd course, 3rd fret (n)
    Glyphs["luteGermanNLower"] = "\uEC0C";
    // U+EC23  6th course, 13th fret (N)
    Glyphs["luteGermanNUpper"] = "\uEC23";
    // U+EC0D  2nd course, 3rd fret (o)
    Glyphs["luteGermanOLower"] = "\uEC0D";
    // U+EC0E  1st course, 3rd fret (p)
    Glyphs["luteGermanPLower"] = "\uEC0E";
    // U+EC0F  5th course, 4th fret (q)
    Glyphs["luteGermanQLower"] = "\uEC0F";
    // U+EC10  4th course, 4th fret (r)
    Glyphs["luteGermanRLower"] = "\uEC10";
    // U+EC11  3rd course, 4th fret (s)
    Glyphs["luteGermanSLower"] = "\uEC11";
    // U+EC12  2nd course, 4th fret (t)
    Glyphs["luteGermanTLower"] = "\uEC12";
    // U+EC13  1st course, 4th fret (v)
    Glyphs["luteGermanVLower"] = "\uEC13";
    // U+EC14  5th course, 5th fret (x)
    Glyphs["luteGermanXLower"] = "\uEC14";
    // U+EC15  4th course, 5th fret (y)
    Glyphs["luteGermanYLower"] = "\uEC15";
    // U+EC16  3rd course, 5th fret (z)
    Glyphs["luteGermanZLower"] = "\uEC16";
    // U+EBF1  C sol fa ut clef
    Glyphs["luteItalianClefCSolFaUt"] = "\uEBF1";
    // U+EBF0  F fa ut clef
    Glyphs["luteItalianClefFFaUt"] = "\uEBF0";
    // U+EBE0  Open string (0)
    Glyphs["luteItalianFret0"] = "\uEBE0";
    // U+EBE1  First fret (1)
    Glyphs["luteItalianFret1"] = "\uEBE1";
    // U+EBE2  Second fret (2)
    Glyphs["luteItalianFret2"] = "\uEBE2";
    // U+EBE3  Third fret (3)
    Glyphs["luteItalianFret3"] = "\uEBE3";
    // U+EBE4  Fourth fret (4)
    Glyphs["luteItalianFret4"] = "\uEBE4";
    // U+EBE5  Fifth fret (5)
    Glyphs["luteItalianFret5"] = "\uEBE5";
    // U+EBE6  Sixth fret (6)
    Glyphs["luteItalianFret6"] = "\uEBE6";
    // U+EBE7  Seventh fret (7)
    Glyphs["luteItalianFret7"] = "\uEBE7";
    // U+EBE8  Eighth fret (8)
    Glyphs["luteItalianFret8"] = "\uEBE8";
    // U+EBE9  Ninth fret (9)
    Glyphs["luteItalianFret9"] = "\uEBE9";
    // U+EBF4  Hold finger in place
    Glyphs["luteItalianHoldFinger"] = "\uEBF4";
    // U+EBF3  Hold note
    Glyphs["luteItalianHoldNote"] = "\uEBF3";
    // U+EBF5  Release finger
    Glyphs["luteItalianReleaseFinger"] = "\uEBF5";
    // U+EBEA  Fast tempo indication (de Mudarra)
    Glyphs["luteItalianTempoFast"] = "\uEBEA";
    // U+EBEC  Neither fast nor slow tempo indication (de Mudarra)
    Glyphs["luteItalianTempoNeitherFastNorSlow"] = "\uEBEC";
    // U+EBED  Slow tempo indication (de Mudarra)
    Glyphs["luteItalianTempoSlow"] = "\uEBED";
    // U+EBEB  Somewhat fast tempo indication (de Narvaez)
    Glyphs["luteItalianTempoSomewhatFast"] = "\uEBEB";
    // U+EBEE  Very slow indication (de Narvaez)
    Glyphs["luteItalianTempoVerySlow"] = "\uEBEE";
    // U+EBEF  Triple time indication
    Glyphs["luteItalianTimeTriple"] = "\uEBEF";
    // U+EBF2  Single-finger tremolo or mordent
    Glyphs["luteItalianTremolo"] = "\uEBF2";
    // U+EBF6  Vibrato (verre cass)
    Glyphs["luteItalianVibrato"] = "\uEBF6";
    // U+EBA0  Lute tablature staff, 6 courses
    Glyphs["luteStaff6Lines"] = "\uEBA0";
    // U+EBA2  Lute tablature staff, 6 courses (narrow)
    Glyphs["luteStaff6LinesNarrow"] = "\uEBA2";
    // U+EBA1  Lute tablature staff, 6 courses (wide)
    Glyphs["luteStaff6LinesWide"] = "\uEBA1";
    // U+E551  Elision
    Glyphs["lyricsElision"] = "\uE551";
    // U+E550  Narrow elision
    Glyphs["lyricsElisionNarrow"] = "\uE550";
    // U+E552  Wide elision
    Glyphs["lyricsElisionWide"] = "\uE552";
    // U+E553  Baseline hyphen
    Glyphs["lyricsHyphenBaseline"] = "\uE553";
    // U+E554  Non-breaking baseline hyphen
    Glyphs["lyricsHyphenBaselineNonBreaking"] = "\uE554";
    // U+E555  Text repeats
    Glyphs["lyricsTextRepeat"] = "\uE555";
    // U+E9E1  Flat, hard b (mi)
    Glyphs["medRenFlatHardB"] = "\uE9E1";
    // U+E9E0  Flat, soft b (fa)
    Glyphs["medRenFlatSoftB"] = "\uE9E0";
    // U+E9E4  Flat with dot
    Glyphs["medRenFlatWithDot"] = "\uE9E4";
    // U+EA24  G clef (Corpus Monodicum)
    Glyphs["medRenGClefCMN"] = "\uEA24";
    // U+EA22  Liquescence
    Glyphs["medRenLiquescenceCMN"] = "\uEA22";
    // U+EA26  Liquescent ascending (Corpus Monodicum)
    Glyphs["medRenLiquescentAscCMN"] = "\uEA26";
    // U+EA27  Liquescent descending (Corpus Monodicum)
    Glyphs["medRenLiquescentDescCMN"] = "\uEA27";
    // U+E9E2  Natural
    Glyphs["medRenNatural"] = "\uE9E2";
    // U+E9E5  Natural with interrupted cross
    Glyphs["medRenNaturalWithCross"] = "\uE9E5";
    // U+EA2A  Oriscus (Corpus Monodicum)
    Glyphs["medRenOriscusCMN"] = "\uEA2A";
    // U+EA23  Plica
    Glyphs["medRenPlicaCMN"] = "\uEA23";
    // U+EA25  Punctum (Corpus Monodicum)
    Glyphs["medRenPunctumCMN"] = "\uEA25";
    // U+EA28  Quilisma (Corpus Monodicum)
    Glyphs["medRenQuilismaCMN"] = "\uEA28";
    // U+E9E3  Croix
    Glyphs["medRenSharpCroix"] = "\uE9E3";
    // U+EA29  Strophicus (Corpus Monodicum)
    Glyphs["medRenStrophicusCMN"] = "\uEA29";
    // U+EA10  Alteration sign
    Glyphs["mensuralAlterationSign"] = "\uEA10";
    // U+E952  Black mensural brevis
    Glyphs["mensuralBlackBrevis"] = "\uE952";
    // U+E956  Black mensural void brevis
    Glyphs["mensuralBlackBrevisVoid"] = "\uE956";
    // U+E95A  Black mensural dragma
    Glyphs["mensuralBlackDragma"] = "\uE95A";
    // U+E951  Black mensural longa
    Glyphs["mensuralBlackLonga"] = "\uE951";
    // U+E950  Black mensural maxima
    Glyphs["mensuralBlackMaxima"] = "\uE950";
    // U+E954  Black mensural minima
    Glyphs["mensuralBlackMinima"] = "\uE954";
    // U+E958  Black mensural void minima
    Glyphs["mensuralBlackMinimaVoid"] = "\uE958";
    // U+E953  Black mensural semibrevis
    Glyphs["mensuralBlackSemibrevis"] = "\uE953";
    // U+E959  Black mensural semibrevis caudata
    Glyphs["mensuralBlackSemibrevisCaudata"] = "\uE959";
    // U+E95B  Black mensural oblique semibrevis
    Glyphs["mensuralBlackSemibrevisOblique"] = "\uE95B";
    // U+E957  Black mensural void semibrevis
    Glyphs["mensuralBlackSemibrevisVoid"] = "\uE957";
    // U+E955  Black mensural semiminima
    Glyphs["mensuralBlackSemiminima"] = "\uE955";
    // U+E905  Mensural C clef
    Glyphs["mensuralCclef"] = "\uE905";
    // U+E90A  Petrucci C clef, high position
    Glyphs["mensuralCclefPetrucciPosHigh"] = "\uE90A";
    // U+E90B  Petrucci C clef, highest position
    Glyphs["mensuralCclefPetrucciPosHighest"] = "\uE90B";
    // U+E908  Petrucci C clef, low position
    Glyphs["mensuralCclefPetrucciPosLow"] = "\uE908";
    // U+E907  Petrucci C clef, lowest position
    Glyphs["mensuralCclefPetrucciPosLowest"] = "\uE907";
    // U+E909  Petrucci C clef, middle position
    Glyphs["mensuralCclefPetrucciPosMiddle"] = "\uE909";
    // U+EA0F  Coloration end, round
    Glyphs["mensuralColorationEndRound"] = "\uEA0F";
    // U+EA0D  Coloration end, square
    Glyphs["mensuralColorationEndSquare"] = "\uEA0D";
    // U+EA0E  Coloration start, round
    Glyphs["mensuralColorationStartRound"] = "\uEA0E";
    // U+EA0C  Coloration start, square
    Glyphs["mensuralColorationStartSquare"] = "\uEA0C";
    // U+E940  Combining stem diagonal
    Glyphs["mensuralCombStemDiagonal"] = "\uE940";
    // U+E93F  Combining stem down
    Glyphs["mensuralCombStemDown"] = "\uE93F";
    // U+E948  Combining stem with extended flag down
    Glyphs["mensuralCombStemDownFlagExtended"] = "\uE948";
    // U+E946  Combining stem with flared flag down
    Glyphs["mensuralCombStemDownFlagFlared"] = "\uE946";
    // U+E94C  Combining stem with fusa flag down
    Glyphs["mensuralCombStemDownFlagFusa"] = "\uE94C";
    // U+E944  Combining stem with flag left down
    Glyphs["mensuralCombStemDownFlagLeft"] = "\uE944";
    // U+E942  Combining stem with flag right down
    Glyphs["mensuralCombStemDownFlagRight"] = "\uE942";
    // U+E94A  Combining stem with semiminima flag down
    Glyphs["mensuralCombStemDownFlagSemiminima"] = "\uE94A";
    // U+E93E  Combining stem up
    Glyphs["mensuralCombStemUp"] = "\uE93E";
    // U+E947  Combining stem with extended flag up
    Glyphs["mensuralCombStemUpFlagExtended"] = "\uE947";
    // U+E945  Combining stem with flared flag up
    Glyphs["mensuralCombStemUpFlagFlared"] = "\uE945";
    // U+E94B  Combining stem with fusa flag up
    Glyphs["mensuralCombStemUpFlagFusa"] = "\uE94B";
    // U+E943  Combining stem with flag left up
    Glyphs["mensuralCombStemUpFlagLeft"] = "\uE943";
    // U+E941  Combining stem with flag right up
    Glyphs["mensuralCombStemUpFlagRight"] = "\uE941";
    // U+E949  Combining stem with semiminima flag up
    Glyphs["mensuralCombStemUpFlagSemiminima"] = "\uE949";
    // U+EA0A  Checkmark custos
    Glyphs["mensuralCustosCheckmark"] = "\uEA0A";
    // U+EA03  Mensural custos down
    Glyphs["mensuralCustosDown"] = "\uEA03";
    // U+EA0B  Turn-like custos
    Glyphs["mensuralCustosTurn"] = "\uEA0B";
    // U+EA02  Mensural custos up
    Glyphs["mensuralCustosUp"] = "\uEA02";
    // U+E903  Mensural F clef
    Glyphs["mensuralFclef"] = "\uE903";
    // U+E904  Petrucci F clef
    Glyphs["mensuralFclefPetrucci"] = "\uE904";
    // U+E900  Mensural G clef
    Glyphs["mensuralGclef"] = "\uE900";
    // U+E901  Petrucci G clef
    Glyphs["mensuralGclefPetrucci"] = "\uE901";
    // U+E92D  Modus imperfectum, vertical
    Glyphs["mensuralModusImperfectumVert"] = "\uE92D";
    // U+E92C  Modus perfectum, vertical
    Glyphs["mensuralModusPerfectumVert"] = "\uE92C";
    // U+E934  Longa/brevis notehead, black
    Glyphs["mensuralNoteheadLongaBlack"] = "\uE934";
    // U+E936  Longa/brevis notehead, black and void
    Glyphs["mensuralNoteheadLongaBlackVoid"] = "\uE936";
    // U+E935  Longa/brevis notehead, void
    Glyphs["mensuralNoteheadLongaVoid"] = "\uE935";
    // U+E937  Longa/brevis notehead, white
    Glyphs["mensuralNoteheadLongaWhite"] = "\uE937";
    // U+E930  Maxima notehead, black
    Glyphs["mensuralNoteheadMaximaBlack"] = "\uE930";
    // U+E932  Maxima notehead, black and void
    Glyphs["mensuralNoteheadMaximaBlackVoid"] = "\uE932";
    // U+E931  Maxima notehead, void
    Glyphs["mensuralNoteheadMaximaVoid"] = "\uE931";
    // U+E933  Maxima notehead, white
    Glyphs["mensuralNoteheadMaximaWhite"] = "\uE933";
    // U+E93C  Minima notehead, white
    Glyphs["mensuralNoteheadMinimaWhite"] = "\uE93C";
    // U+E938  Semibrevis notehead, black
    Glyphs["mensuralNoteheadSemibrevisBlack"] = "\uE938";
    // U+E93A  Semibrevis notehead, black and void
    Glyphs["mensuralNoteheadSemibrevisBlackVoid"] = "\uE93A";
    // U+E93B  Semibrevis notehead, black and void (turned)
    Glyphs["mensuralNoteheadSemibrevisBlackVoidTurned"] = "\uE93B";
    // U+E939  Semibrevis notehead, void
    Glyphs["mensuralNoteheadSemibrevisVoid"] = "\uE939";
    // U+E93D  Semiminima/fusa notehead, white
    Glyphs["mensuralNoteheadSemiminimaWhite"] = "\uE93D";
    // U+E970  Oblique form, ascending 2nd, black
    Glyphs["mensuralObliqueAsc2ndBlack"] = "\uE970";
    // U+E972  Oblique form, ascending 2nd, black and void
    Glyphs["mensuralObliqueAsc2ndBlackVoid"] = "\uE972";
    // U+E971  Oblique form, ascending 2nd, void
    Glyphs["mensuralObliqueAsc2ndVoid"] = "\uE971";
    // U+E973  Oblique form, ascending 2nd, white
    Glyphs["mensuralObliqueAsc2ndWhite"] = "\uE973";
    // U+E974  Oblique form, ascending 3rd, black
    Glyphs["mensuralObliqueAsc3rdBlack"] = "\uE974";
    // U+E976  Oblique form, ascending 3rd, black and void
    Glyphs["mensuralObliqueAsc3rdBlackVoid"] = "\uE976";
    // U+E975  Oblique form, ascending 3rd, void
    Glyphs["mensuralObliqueAsc3rdVoid"] = "\uE975";
    // U+E977  Oblique form, ascending 3rd, white
    Glyphs["mensuralObliqueAsc3rdWhite"] = "\uE977";
    // U+E978  Oblique form, ascending 4th, black
    Glyphs["mensuralObliqueAsc4thBlack"] = "\uE978";
    // U+E97A  Oblique form, ascending 4th, black and void
    Glyphs["mensuralObliqueAsc4thBlackVoid"] = "\uE97A";
    // U+E979  Oblique form, ascending 4th, void
    Glyphs["mensuralObliqueAsc4thVoid"] = "\uE979";
    // U+E97B  Oblique form, ascending 4th, white
    Glyphs["mensuralObliqueAsc4thWhite"] = "\uE97B";
    // U+E97C  Oblique form, ascending 5th, black
    Glyphs["mensuralObliqueAsc5thBlack"] = "\uE97C";
    // U+E97E  Oblique form, ascending 5th, black and void
    Glyphs["mensuralObliqueAsc5thBlackVoid"] = "\uE97E";
    // U+E97D  Oblique form, ascending 5th, void
    Glyphs["mensuralObliqueAsc5thVoid"] = "\uE97D";
    // U+E97F  Oblique form, ascending 5th, white
    Glyphs["mensuralObliqueAsc5thWhite"] = "\uE97F";
    // U+E980  Oblique form, descending 2nd, black
    Glyphs["mensuralObliqueDesc2ndBlack"] = "\uE980";
    // U+E982  Oblique form, descending 2nd, black and void
    Glyphs["mensuralObliqueDesc2ndBlackVoid"] = "\uE982";
    // U+E981  Oblique form, descending 2nd, void
    Glyphs["mensuralObliqueDesc2ndVoid"] = "\uE981";
    // U+E983  Oblique form, descending 2nd, white
    Glyphs["mensuralObliqueDesc2ndWhite"] = "\uE983";
    // U+E984  Oblique form, descending 3rd, black
    Glyphs["mensuralObliqueDesc3rdBlack"] = "\uE984";
    // U+E986  Oblique form, descending 3rd, black and void
    Glyphs["mensuralObliqueDesc3rdBlackVoid"] = "\uE986";
    // U+E985  Oblique form, descending 3rd, void
    Glyphs["mensuralObliqueDesc3rdVoid"] = "\uE985";
    // U+E987  Oblique form, descending 3rd, white
    Glyphs["mensuralObliqueDesc3rdWhite"] = "\uE987";
    // U+E988  Oblique form, descending 4th, black
    Glyphs["mensuralObliqueDesc4thBlack"] = "\uE988";
    // U+E98A  Oblique form, descending 4th, black and void
    Glyphs["mensuralObliqueDesc4thBlackVoid"] = "\uE98A";
    // U+E989  Oblique form, descending 4th, void
    Glyphs["mensuralObliqueDesc4thVoid"] = "\uE989";
    // U+E98B  Oblique form, descending 4th, white
    Glyphs["mensuralObliqueDesc4thWhite"] = "\uE98B";
    // U+E98C  Oblique form, descending 5th, black
    Glyphs["mensuralObliqueDesc5thBlack"] = "\uE98C";
    // U+E98E  Oblique form, descending 5th, black and void
    Glyphs["mensuralObliqueDesc5thBlackVoid"] = "\uE98E";
    // U+E98D  Oblique form, descending 5th, void
    Glyphs["mensuralObliqueDesc5thVoid"] = "\uE98D";
    // U+E98F  Oblique form, descending 5th, white
    Glyphs["mensuralObliqueDesc5thWhite"] = "\uE98F";
    // U+E910  Tempus perfectum cum prolatione perfecta (9/8)
    Glyphs["mensuralProlation1"] = "\uE910";
    // U+E919  Tempus imperfectum cum prolatione imperfecta diminution 4
    Glyphs["mensuralProlation10"] = "\uE919";
    // U+E91A  Tempus imperfectum cum prolatione imperfecta diminution 5
    Glyphs["mensuralProlation11"] = "\uE91A";
    // U+E911  Tempus perfectum cum prolatione imperfecta (3/4)
    Glyphs["mensuralProlation2"] = "\uE911";
    // U+E912  Tempus perfectum cum prolatione imperfecta diminution 1 (3/8)
    Glyphs["mensuralProlation3"] = "\uE912";
    // U+E913  Tempus perfectum cum prolatione perfecta diminution 2 (9/16)
    Glyphs["mensuralProlation4"] = "\uE913";
    // U+E914  Tempus imperfectum cum prolatione perfecta (6/8)
    Glyphs["mensuralProlation5"] = "\uE914";
    // U+E915  Tempus imperfectum cum prolatione imperfecta (2/4)
    Glyphs["mensuralProlation6"] = "\uE915";
    // U+E916  Tempus imperfectum cum prolatione imperfecta diminution 1 (2/2)
    Glyphs["mensuralProlation7"] = "\uE916";
    // U+E917  Tempus imperfectum cum prolatione imperfecta diminution 2 (6/16)
    Glyphs["mensuralProlation8"] = "\uE917";
    // U+E918  Tempus imperfectum cum prolatione imperfecta diminution 3 (2/2)
    Glyphs["mensuralProlation9"] = "\uE918";
    // U+E920  Combining dot
    Glyphs["mensuralProlationCombiningDot"] = "\uE920";
    // U+E924  Combining void dot
    Glyphs["mensuralProlationCombiningDotVoid"] = "\uE924";
    // U+E925  Combining vertical stroke
    Glyphs["mensuralProlationCombiningStroke"] = "\uE925";
    // U+E922  Combining three dots horizontal
    Glyphs["mensuralProlationCombiningThreeDots"] = "\uE922";
    // U+E923  Combining three dots triangular
    Glyphs["mensuralProlationCombiningThreeDotsTri"] = "\uE923";
    // U+E921  Combining two dots
    Glyphs["mensuralProlationCombiningTwoDots"] = "\uE921";
    // U+E926  Mensural proportion 1
    Glyphs["mensuralProportion1"] = "\uE926";
    // U+E927  Mensural proportion 2
    Glyphs["mensuralProportion2"] = "\uE927";
    // U+E928  Mensural proportion 3
    Glyphs["mensuralProportion3"] = "\uE928";
    // U+E929  Mensural proportion 4
    Glyphs["mensuralProportion4"] = "\uE929";
    // U+EE90  Mensural proportion 5
    Glyphs["mensuralProportion5"] = "\uEE90";
    // U+EE91  Mensural proportion 6
    Glyphs["mensuralProportion6"] = "\uEE91";
    // U+EE92  Mensural proportion 7
    Glyphs["mensuralProportion7"] = "\uEE92";
    // U+EE93  Mensural proportion 8
    Glyphs["mensuralProportion8"] = "\uEE93";
    // U+EE94  Mensural proportion 9
    Glyphs["mensuralProportion9"] = "\uEE94";
    // U+E92B  Mensural proportion major
    Glyphs["mensuralProportionMajor"] = "\uE92B";
    // U+E92A  Mensural proportion minor
    Glyphs["mensuralProportionMinor"] = "\uE92A";
    // U+E91C  Proportio dupla 1
    Glyphs["mensuralProportionProportioDupla1"] = "\uE91C";
    // U+E91D  Proportio dupla 2
    Glyphs["mensuralProportionProportioDupla2"] = "\uE91D";
    // U+E91F  Proportio quadrupla
    Glyphs["mensuralProportionProportioQuadrupla"] = "\uE91F";
    // U+E91E  Proportio tripla
    Glyphs["mensuralProportionProportioTripla"] = "\uE91E";
    // U+E91B  Tempus perfectum
    Glyphs["mensuralProportionTempusPerfectum"] = "\uE91B";
    // U+E9F3  Brevis rest
    Glyphs["mensuralRestBrevis"] = "\uE9F3";
    // U+E9F7  Fusa rest
    Glyphs["mensuralRestFusa"] = "\uE9F7";
    // U+E9F2  Longa imperfecta rest
    Glyphs["mensuralRestLongaImperfecta"] = "\uE9F2";
    // U+E9F1  Longa perfecta rest
    Glyphs["mensuralRestLongaPerfecta"] = "\uE9F1";
    // U+E9F0  Maxima rest
    Glyphs["mensuralRestMaxima"] = "\uE9F0";
    // U+E9F5  Minima rest
    Glyphs["mensuralRestMinima"] = "\uE9F5";
    // U+E9F4  Semibrevis rest
    Glyphs["mensuralRestSemibrevis"] = "\uE9F4";
    // U+E9F8  Semifusa rest
    Glyphs["mensuralRestSemifusa"] = "\uE9F8";
    // U+E9F6  Semiminima rest
    Glyphs["mensuralRestSemiminima"] = "\uE9F6";
    // U+EA01  Signum congruentiae down
    Glyphs["mensuralSignumDown"] = "\uEA01";
    // U+EA00  Signum congruentiae up
    Glyphs["mensuralSignumUp"] = "\uEA00";
    // U+E92F  Tempus imperfectum, horizontal
    Glyphs["mensuralTempusImperfectumHoriz"] = "\uE92F";
    // U+E92E  Tempus perfectum, horizontal
    Glyphs["mensuralTempusPerfectumHoriz"] = "\uE92E";
    // U+E95E  White mensural brevis
    Glyphs["mensuralWhiteBrevis"] = "\uE95E";
    // U+E961  White mensural fusa
    Glyphs["mensuralWhiteFusa"] = "\uE961";
    // U+E95D  White mensural longa
    Glyphs["mensuralWhiteLonga"] = "\uE95D";
    // U+E95C  White mensural maxima
    Glyphs["mensuralWhiteMaxima"] = "\uE95C";
    // U+E95F  White mensural minima
    Glyphs["mensuralWhiteMinima"] = "\uE95F";
    // U+E962  White mensural semibrevis
    Glyphs["mensuralWhiteSemibrevis"] = "\uE962";
    // U+E960  White mensural semiminima
    Glyphs["mensuralWhiteSemiminima"] = "\uE960";
    // U+ECB7  Augmentation dot
    Glyphs["metAugmentationDot"] = "\uECB7";
    // U+ECB6  1024th note (semihemidemisemihemidemisemiquaver) stem down
    Glyphs["metNote1024thDown"] = "\uECB6";
    // U+ECB5  1024th note (semihemidemisemihemidemisemiquaver) stem up
    Glyphs["metNote1024thUp"] = "\uECB5";
    // U+ECB0  128th note (semihemidemisemiquaver) stem down
    Glyphs["metNote128thDown"] = "\uECB0";
    // U+ECAF  128th note (semihemidemisemiquaver) stem up
    Glyphs["metNote128thUp"] = "\uECAF";
    // U+ECAA  16th note (semiquaver) stem down
    Glyphs["metNote16thDown"] = "\uECAA";
    // U+ECA9  16th note (semiquaver) stem up
    Glyphs["metNote16thUp"] = "\uECA9";
    // U+ECB2  256th note (demisemihemidemisemiquaver) stem down
    Glyphs["metNote256thDown"] = "\uECB2";
    // U+ECB1  256th note (demisemihemidemisemiquaver) stem up
    Glyphs["metNote256thUp"] = "\uECB1";
    // U+ECAC  32nd note (demisemiquaver) stem down
    Glyphs["metNote32ndDown"] = "\uECAC";
    // U+ECAB  32nd note (demisemiquaver) stem up
    Glyphs["metNote32ndUp"] = "\uECAB";
    // U+ECB4  512th note (hemidemisemihemidemisemiquaver) stem down
    Glyphs["metNote512thDown"] = "\uECB4";
    // U+ECB3  512th note (hemidemisemihemidemisemiquaver) stem up
    Glyphs["metNote512thUp"] = "\uECB3";
    // U+ECAE  64th note (hemidemisemiquaver) stem down
    Glyphs["metNote64thDown"] = "\uECAE";
    // U+ECAD  64th note (hemidemisemiquaver) stem up
    Glyphs["metNote64thUp"] = "\uECAD";
    // U+ECA8  Eighth note (quaver) stem down
    Glyphs["metNote8thDown"] = "\uECA8";
    // U+ECA7  Eighth note (quaver) stem up
    Glyphs["metNote8thUp"] = "\uECA7";
    // U+ECA0  Double whole note (breve)
    Glyphs["metNoteDoubleWhole"] = "\uECA0";
    // U+ECA1  Double whole note (square)
    Glyphs["metNoteDoubleWholeSquare"] = "\uECA1";
    // U+ECA4  Half note (minim) stem down
    Glyphs["metNoteHalfDown"] = "\uECA4";
    // U+ECA3  Half note (minim) stem up
    Glyphs["metNoteHalfUp"] = "\uECA3";
    // U+ECA6  Quarter note (crotchet) stem down
    Glyphs["metNoteQuarterDown"] = "\uECA6";
    // U+ECA5  Quarter note (crotchet) stem up
    Glyphs["metNoteQuarterUp"] = "\uECA5";
    // U+ECA2  Whole note (semibreve)
    Glyphs["metNoteWhole"] = "\uECA2";
    // U+EC63  Left-pointing arrow for metric modulation
    Glyphs["metricModulationArrowLeft"] = "\uEC63";
    // U+EC64  Right-pointing arrow for metric modulation
    Glyphs["metricModulationArrowRight"] = "\uEC64";
    // U+EC61  Do not copy
    Glyphs["miscDoNotCopy"] = "\uEC61";
    // U+EC60  Do not photocopy
    Glyphs["miscDoNotPhotocopy"] = "\uEC60";
    // U+EC62  Eyeglasses
    Glyphs["miscEyeglasses"] = "\uEC62";
    // U+E1E6  1024th note (semihemidemisemihemidemisemiquaver) stem down
    Glyphs["note1024thDown"] = "\uE1E6";
    // U+E1E5  1024th note (semihemidemisemihemidemisemiquaver) stem up
    Glyphs["note1024thUp"] = "\uE1E5";
    // U+E1E0  128th note (semihemidemisemiquaver) stem down
    Glyphs["note128thDown"] = "\uE1E0";
    // U+E1DF  128th note (semihemidemisemiquaver) stem up
    Glyphs["note128thUp"] = "\uE1DF";
    // U+E1DA  16th note (semiquaver) stem down
    Glyphs["note16thDown"] = "\uE1DA";
    // U+E1D9  16th note (semiquaver) stem up
    Glyphs["note16thUp"] = "\uE1D9";
    // U+E1E2  256th note (demisemihemidemisemiquaver) stem down
    Glyphs["note256thDown"] = "\uE1E2";
    // U+E1E1  256th note (demisemihemidemisemiquaver) stem up
    Glyphs["note256thUp"] = "\uE1E1";
    // U+E1DC  32nd note (demisemiquaver) stem down
    Glyphs["note32ndDown"] = "\uE1DC";
    // U+E1DB  32nd note (demisemiquaver) stem up
    Glyphs["note32ndUp"] = "\uE1DB";
    // U+E1E4  512th note (hemidemisemihemidemisemiquaver) stem down
    Glyphs["note512thDown"] = "\uE1E4";
    // U+E1E3  512th note (hemidemisemihemidemisemiquaver) stem up
    Glyphs["note512thUp"] = "\uE1E3";
    // U+E1DE  64th note (hemidemisemiquaver) stem down
    Glyphs["note64thDown"] = "\uE1DE";
    // U+E1DD  64th note (hemidemisemiquaver) stem up
    Glyphs["note64thUp"] = "\uE1DD";
    // U+E1D8  Eighth note (quaver) stem down
    Glyphs["note8thDown"] = "\uE1D8";
    // U+E1D7  Eighth note (quaver) stem up
    Glyphs["note8thUp"] = "\uE1D7";
    // U+E197  A (black note)
    Glyphs["noteABlack"] = "\uE197";
    // U+E196  A flat (black note)
    Glyphs["noteAFlatBlack"] = "\uE196";
    // U+E17F  A flat (half note)
    Glyphs["noteAFlatHalf"] = "\uE17F";
    // U+E168  A flat (whole note)
    Glyphs["noteAFlatWhole"] = "\uE168";
    // U+E180  A (half note)
    Glyphs["noteAHalf"] = "\uE180";
    // U+E198  A sharp (black note)
    Glyphs["noteASharpBlack"] = "\uE198";
    // U+E181  A sharp (half note)
    Glyphs["noteASharpHalf"] = "\uE181";
    // U+E16A  A sharp (whole note)
    Glyphs["noteASharpWhole"] = "\uE16A";
    // U+E169  A (whole note)
    Glyphs["noteAWhole"] = "\uE169";
    // U+E19A  B (black note)
    Glyphs["noteBBlack"] = "\uE19A";
    // U+E199  B flat (black note)
    Glyphs["noteBFlatBlack"] = "\uE199";
    // U+E182  B flat (half note)
    Glyphs["noteBFlatHalf"] = "\uE182";
    // U+E16B  B flat (whole note)
    Glyphs["noteBFlatWhole"] = "\uE16B";
    // U+E183  B (half note)
    Glyphs["noteBHalf"] = "\uE183";
    // U+E19B  B sharp (black note)
    Glyphs["noteBSharpBlack"] = "\uE19B";
    // U+E184  B sharp (half note)
    Glyphs["noteBSharpHalf"] = "\uE184";
    // U+E16D  B sharp (whole note)
    Glyphs["noteBSharpWhole"] = "\uE16D";
    // U+E16C  B (whole note)
    Glyphs["noteBWhole"] = "\uE16C";
    // U+E19D  C (black note)
    Glyphs["noteCBlack"] = "\uE19D";
    // U+E19C  C flat (black note)
    Glyphs["noteCFlatBlack"] = "\uE19C";
    // U+E185  C flat (half note)
    Glyphs["noteCFlatHalf"] = "\uE185";
    // U+E16E  C flat (whole note)
    Glyphs["noteCFlatWhole"] = "\uE16E";
    // U+E186  C (half note)
    Glyphs["noteCHalf"] = "\uE186";
    // U+E19E  C sharp (black note)
    Glyphs["noteCSharpBlack"] = "\uE19E";
    // U+E187  C sharp (half note)
    Glyphs["noteCSharpHalf"] = "\uE187";
    // U+E170  C sharp (whole note)
    Glyphs["noteCSharpWhole"] = "\uE170";
    // U+E16F  C (whole note)
    Glyphs["noteCWhole"] = "\uE16F";
    // U+E1A0  D (black note)
    Glyphs["noteDBlack"] = "\uE1A0";
    // U+E19F  D flat (black note)
    Glyphs["noteDFlatBlack"] = "\uE19F";
    // U+E188  D flat (half note)
    Glyphs["noteDFlatHalf"] = "\uE188";
    // U+E171  D flat (whole note)
    Glyphs["noteDFlatWhole"] = "\uE171";
    // U+E189  D (half note)
    Glyphs["noteDHalf"] = "\uE189";
    // U+E1A1  D sharp (black note)
    Glyphs["noteDSharpBlack"] = "\uE1A1";
    // U+E18A  D sharp (half note)
    Glyphs["noteDSharpHalf"] = "\uE18A";
    // U+E173  D sharp (whole note)
    Glyphs["noteDSharpWhole"] = "\uE173";
    // U+E172  D (whole note)
    Glyphs["noteDWhole"] = "\uE172";
    // U+EEF2  Di (black note)
    Glyphs["noteDiBlack"] = "\uEEF2";
    // U+EEE9  Di (half note)
    Glyphs["noteDiHalf"] = "\uEEE9";
    // U+EEE0  Di (whole note)
    Glyphs["noteDiWhole"] = "\uEEE0";
    // U+E160  Do (black note)
    Glyphs["noteDoBlack"] = "\uE160";
    // U+E158  Do (half note)
    Glyphs["noteDoHalf"] = "\uE158";
    // U+E150  Do (whole note)
    Glyphs["noteDoWhole"] = "\uE150";
    // U+E1D0  Double whole note (breve)
    Glyphs["noteDoubleWhole"] = "\uE1D0";
    // U+E1D1  Double whole note (square)
    Glyphs["noteDoubleWholeSquare"] = "\uE1D1";
    // U+E1A3  E (black note)
    Glyphs["noteEBlack"] = "\uE1A3";
    // U+E1A2  E flat (black note)
    Glyphs["noteEFlatBlack"] = "\uE1A2";
    // U+E18B  E flat (half note)
    Glyphs["noteEFlatHalf"] = "\uE18B";
    // U+E174  E flat (whole note)
    Glyphs["noteEFlatWhole"] = "\uE174";
    // U+E18C  E (half note)
    Glyphs["noteEHalf"] = "\uE18C";
    // U+E1A4  E sharp (black note)
    Glyphs["noteESharpBlack"] = "\uE1A4";
    // U+E18D  E sharp (half note)
    Glyphs["noteESharpHalf"] = "\uE18D";
    // U+E176  E sharp (whole note)
    Glyphs["noteESharpWhole"] = "\uE176";
    // U+E175  E (whole note)
    Glyphs["noteEWhole"] = "\uE175";
    // U+E1AF  Empty black note
    Glyphs["noteEmptyBlack"] = "\uE1AF";
    // U+E1AE  Empty half note
    Glyphs["noteEmptyHalf"] = "\uE1AE";
    // U+E1AD  Empty whole note
    Glyphs["noteEmptyWhole"] = "\uE1AD";
    // U+E1A6  F (black note)
    Glyphs["noteFBlack"] = "\uE1A6";
    // U+E1A5  F flat (black note)
    Glyphs["noteFFlatBlack"] = "\uE1A5";
    // U+E18E  F flat (half note)
    Glyphs["noteFFlatHalf"] = "\uE18E";
    // U+E177  F flat (whole note)
    Glyphs["noteFFlatWhole"] = "\uE177";
    // U+E18F  F (half note)
    Glyphs["noteFHalf"] = "\uE18F";
    // U+E1A7  F sharp (black note)
    Glyphs["noteFSharpBlack"] = "\uE1A7";
    // U+E190  F sharp (half note)
    Glyphs["noteFSharpHalf"] = "\uE190";
    // U+E179  F sharp (whole note)
    Glyphs["noteFSharpWhole"] = "\uE179";
    // U+E178  F (whole note)
    Glyphs["noteFWhole"] = "\uE178";
    // U+E163  Fa (black note)
    Glyphs["noteFaBlack"] = "\uE163";
    // U+E15B  Fa (half note)
    Glyphs["noteFaHalf"] = "\uE15B";
    // U+E153  Fa (whole note)
    Glyphs["noteFaWhole"] = "\uE153";
    // U+EEF6  Fi (black note)
    Glyphs["noteFiBlack"] = "\uEEF6";
    // U+EEED  Fi (half note)
    Glyphs["noteFiHalf"] = "\uEEED";
    // U+EEE4  Fi (whole note)
    Glyphs["noteFiWhole"] = "\uEEE4";
    // U+E1A9  G (black note)
    Glyphs["noteGBlack"] = "\uE1A9";
    // U+E1A8  G flat (black note)
    Glyphs["noteGFlatBlack"] = "\uE1A8";
    // U+E191  G flat (half note)
    Glyphs["noteGFlatHalf"] = "\uE191";
    // U+E17A  G flat (whole note)
    Glyphs["noteGFlatWhole"] = "\uE17A";
    // U+E192  G (half note)
    Glyphs["noteGHalf"] = "\uE192";
    // U+E1AA  G sharp (black note)
    Glyphs["noteGSharpBlack"] = "\uE1AA";
    // U+E193  G sharp (half note)
    Glyphs["noteGSharpHalf"] = "\uE193";
    // U+E17C  G sharp (whole note)
    Glyphs["noteGSharpWhole"] = "\uE17C";
    // U+E17B  G (whole note)
    Glyphs["noteGWhole"] = "\uE17B";
    // U+E1AB  H (black note)
    Glyphs["noteHBlack"] = "\uE1AB";
    // U+E194  H (half note)
    Glyphs["noteHHalf"] = "\uE194";
    // U+E1AC  H sharp (black note)
    Glyphs["noteHSharpBlack"] = "\uE1AC";
    // U+E195  H sharp (half note)
    Glyphs["noteHSharpHalf"] = "\uE195";
    // U+E17E  H sharp (whole note)
    Glyphs["noteHSharpWhole"] = "\uE17E";
    // U+E17D  H (whole note)
    Glyphs["noteHWhole"] = "\uE17D";
    // U+E1D4  Half note (minim) stem down
    Glyphs["noteHalfDown"] = "\uE1D4";
    // U+E1D3  Half note (minim) stem up
    Glyphs["noteHalfUp"] = "\uE1D3";
    // U+E165  La (black note)
    Glyphs["noteLaBlack"] = "\uE165";
    // U+E15D  La (half note)
    Glyphs["noteLaHalf"] = "\uE15D";
    // U+E155  La (whole note)
    Glyphs["noteLaWhole"] = "\uE155";
    // U+EEF9  Le (black note)
    Glyphs["noteLeBlack"] = "\uEEF9";
    // U+EEF0  Le (half note)
    Glyphs["noteLeHalf"] = "\uEEF0";
    // U+EEE7  Le (whole note)
    Glyphs["noteLeWhole"] = "\uEEE7";
    // U+EEF8  Li (black note)
    Glyphs["noteLiBlack"] = "\uEEF8";
    // U+EEEF  Li (half note)
    Glyphs["noteLiHalf"] = "\uEEEF";
    // U+EEE6  Li (whole note)
    Glyphs["noteLiWhole"] = "\uEEE6";
    // U+EEF5  Me (black note)
    Glyphs["noteMeBlack"] = "\uEEF5";
    // U+EEEC  Me (half note)
    Glyphs["noteMeHalf"] = "\uEEEC";
    // U+EEE3  Me (whole note)
    Glyphs["noteMeWhole"] = "\uEEE3";
    // U+E162  Mi (black note)
    Glyphs["noteMiBlack"] = "\uE162";
    // U+E15A  Mi (half note)
    Glyphs["noteMiHalf"] = "\uE15A";
    // U+E152  Mi (whole note)
    Glyphs["noteMiWhole"] = "\uE152";
    // U+E1D6  Quarter note (crotchet) stem down
    Glyphs["noteQuarterDown"] = "\uE1D6";
    // U+E1D5  Quarter note (crotchet) stem up
    Glyphs["noteQuarterUp"] = "\uE1D5";
    // U+EEF4  Ra (black note)
    Glyphs["noteRaBlack"] = "\uEEF4";
    // U+EEEB  Ra (half note)
    Glyphs["noteRaHalf"] = "\uEEEB";
    // U+EEE2  Ra (whole note)
    Glyphs["noteRaWhole"] = "\uEEE2";
    // U+E161  Re (black note)
    Glyphs["noteReBlack"] = "\uE161";
    // U+E159  Re (half note)
    Glyphs["noteReHalf"] = "\uE159";
    // U+E151  Re (whole note)
    Glyphs["noteReWhole"] = "\uE151";
    // U+EEF3  Ri (black note)
    Glyphs["noteRiBlack"] = "\uEEF3";
    // U+EEEA  Ri (half note)
    Glyphs["noteRiHalf"] = "\uEEEA";
    // U+EEE1  Ri (whole note)
    Glyphs["noteRiWhole"] = "\uEEE1";
    // U+EEF7  Se (black note)
    Glyphs["noteSeBlack"] = "\uEEF7";
    // U+EEEE  Se (half note)
    Glyphs["noteSeHalf"] = "\uEEEE";
    // U+EEE5  Se (whole note)
    Glyphs["noteSeWhole"] = "\uEEE5";
    // U+E1C9  Arrowhead left black (Funk 7-shape re)
    Glyphs["noteShapeArrowheadLeftBlack"] = "\uE1C9";
    // U+ECDC  Arrowhead left double whole (Funk 7-shape re)
    Glyphs["noteShapeArrowheadLeftDoubleWhole"] = "\uECDC";
    // U+E1C8  Arrowhead left white (Funk 7-shape re)
    Glyphs["noteShapeArrowheadLeftWhite"] = "\uE1C8";
    // U+E1B9  Diamond black (4-shape mi; 7-shape mi)
    Glyphs["noteShapeDiamondBlack"] = "\uE1B9";
    // U+ECD4  Diamond double whole (4-shape mi; 7-shape mi)
    Glyphs["noteShapeDiamondDoubleWhole"] = "\uECD4";
    // U+E1B8  Diamond white (4-shape mi; 7-shape mi)
    Glyphs["noteShapeDiamondWhite"] = "\uE1B8";
    // U+E1C5  Isosceles triangle black (Walker 7-shape ti)
    Glyphs["noteShapeIsoscelesTriangleBlack"] = "\uE1C5";
    // U+ECDA  Isosceles triangle double whole (Walker 7-shape ti)
    Glyphs["noteShapeIsoscelesTriangleDoubleWhole"] = "\uECDA";
    // U+E1C4  Isosceles triangle white (Walker 7-shape ti)
    Glyphs["noteShapeIsoscelesTriangleWhite"] = "\uE1C4";
    // U+E1C1  Inverted keystone black (Walker 7-shape do)
    Glyphs["noteShapeKeystoneBlack"] = "\uE1C1";
    // U+ECD8  Inverted keystone double whole (Walker 7-shape do)
    Glyphs["noteShapeKeystoneDoubleWhole"] = "\uECD8";
    // U+E1C0  Inverted keystone white (Walker 7-shape do)
    Glyphs["noteShapeKeystoneWhite"] = "\uE1C0";
    // U+E1BD  Moon black (Aikin 7-shape re)
    Glyphs["noteShapeMoonBlack"] = "\uE1BD";
    // U+ECD6  Moon double whole (Aikin 7-shape re)
    Glyphs["noteShapeMoonDoubleWhole"] = "\uECD6";
    // U+E1C7  Moon left black (Funk 7-shape do)
    Glyphs["noteShapeMoonLeftBlack"] = "\uE1C7";
    // U+ECDB  Moon left double whole (Funk 7-shape do)
    Glyphs["noteShapeMoonLeftDoubleWhole"] = "\uECDB";
    // U+E1C6  Moon left white (Funk 7-shape do)
    Glyphs["noteShapeMoonLeftWhite"] = "\uE1C6";
    // U+E1BC  Moon white (Aikin 7-shape re)
    Glyphs["noteShapeMoonWhite"] = "\uE1BC";
    // U+E1C3  Quarter moon black (Walker 7-shape re)
    Glyphs["noteShapeQuarterMoonBlack"] = "\uE1C3";
    // U+ECD9  Quarter moon double whole (Walker 7-shape re)
    Glyphs["noteShapeQuarterMoonDoubleWhole"] = "\uECD9";
    // U+E1C2  Quarter moon white (Walker 7-shape re)
    Glyphs["noteShapeQuarterMoonWhite"] = "\uE1C2";
    // U+E1B1  Round black (4-shape sol; 7-shape so)
    Glyphs["noteShapeRoundBlack"] = "\uE1B1";
    // U+ECD0  Round double whole (4-shape sol; 7-shape so)
    Glyphs["noteShapeRoundDoubleWhole"] = "\uECD0";
    // U+E1B0  Round white (4-shape sol; 7-shape so)
    Glyphs["noteShapeRoundWhite"] = "\uE1B0";
    // U+E1B3  Square black (4-shape la; Aikin 7-shape la)
    Glyphs["noteShapeSquareBlack"] = "\uE1B3";
    // U+ECD1  Square double whole (4-shape la; Aikin 7-shape la)
    Glyphs["noteShapeSquareDoubleWhole"] = "\uECD1";
    // U+E1B2  Square white (4-shape la; Aikin 7-shape la)
    Glyphs["noteShapeSquareWhite"] = "\uE1B2";
    // U+E1B7  Triangle left black (stem up; 4-shape fa; 7-shape fa)
    Glyphs["noteShapeTriangleLeftBlack"] = "\uE1B7";
    // U+ECD3  Triangle left double whole (stem up; 4-shape fa; 7-shape fa)
    Glyphs["noteShapeTriangleLeftDoubleWhole"] = "\uECD3";
    // U+E1B6  Triangle left white (stem up; 4-shape fa; 7-shape fa)
    Glyphs["noteShapeTriangleLeftWhite"] = "\uE1B6";
    // U+E1B5  Triangle right black (stem down; 4-shape fa; 7-shape fa)
    Glyphs["noteShapeTriangleRightBlack"] = "\uE1B5";
    // U+ECD2  Triangle right double whole (stem down; 4-shape fa; 7-shape fa)
    Glyphs["noteShapeTriangleRightDoubleWhole"] = "\uECD2";
    // U+E1B4  Triangle right white (stem down; 4-shape fa; 7-shape fa)
    Glyphs["noteShapeTriangleRightWhite"] = "\uE1B4";
    // U+E1BF  Triangle-round black (Aikin 7-shape ti)
    Glyphs["noteShapeTriangleRoundBlack"] = "\uE1BF";
    // U+ECD7  Triangle-round white (Aikin 7-shape ti)
    Glyphs["noteShapeTriangleRoundDoubleWhole"] = "\uECD7";
    // U+E1CB  Triangle-round left black (Funk 7-shape ti)
    Glyphs["noteShapeTriangleRoundLeftBlack"] = "\uE1CB";
    // U+ECDD  Triangle-round left double whole (Funk 7-shape ti)
    Glyphs["noteShapeTriangleRoundLeftDoubleWhole"] = "\uECDD";
    // U+E1CA  Triangle-round left white (Funk 7-shape ti)
    Glyphs["noteShapeTriangleRoundLeftWhite"] = "\uE1CA";
    // U+E1BE  Triangle-round white (Aikin 7-shape ti)
    Glyphs["noteShapeTriangleRoundWhite"] = "\uE1BE";
    // U+E1BB  Triangle up black (Aikin 7-shape do)
    Glyphs["noteShapeTriangleUpBlack"] = "\uE1BB";
    // U+ECD5  Triangle up double whole (Aikin 7-shape do)
    Glyphs["noteShapeTriangleUpDoubleWhole"] = "\uECD5";
    // U+E1BA  Triangle up white (Aikin 7-shape do)
    Glyphs["noteShapeTriangleUpWhite"] = "\uE1BA";
    // U+E167  Si (black note)
    Glyphs["noteSiBlack"] = "\uE167";
    // U+E15F  Si (half note)
    Glyphs["noteSiHalf"] = "\uE15F";
    // U+E157  Si (whole note)
    Glyphs["noteSiWhole"] = "\uE157";
    // U+E164  So (black note)
    Glyphs["noteSoBlack"] = "\uE164";
    // U+E15C  So (half note)
    Glyphs["noteSoHalf"] = "\uE15C";
    // U+E154  So (whole note)
    Glyphs["noteSoWhole"] = "\uE154";
    // U+EEFA  Te (black note)
    Glyphs["noteTeBlack"] = "\uEEFA";
    // U+EEF1  Te (half note)
    Glyphs["noteTeHalf"] = "\uEEF1";
    // U+EEE8  Te (whole note)
    Glyphs["noteTeWhole"] = "\uEEE8";
    // U+E166  Ti (black note)
    Glyphs["noteTiBlack"] = "\uE166";
    // U+E15E  Ti (half note)
    Glyphs["noteTiHalf"] = "\uE15E";
    // U+E156  Ti (whole note)
    Glyphs["noteTiWhole"] = "\uE156";
    // U+E1D2  Whole note (semibreve)
    Glyphs["noteWhole"] = "\uE1D2";
    // U+E0A4  Black notehead
    Glyphs["noteheadBlack"] = "\uE0A4";
    // U+E0F7  Circle slash notehead
    Glyphs["noteheadCircleSlash"] = "\uE0F7";
    // U+E0B3  Circle X notehead
    Glyphs["noteheadCircleX"] = "\uE0B3";
    // U+E0B0  Circle X double whole
    Glyphs["noteheadCircleXDoubleWhole"] = "\uE0B0";
    // U+E0B2  Circle X half
    Glyphs["noteheadCircleXHalf"] = "\uE0B2";
    // U+E0B1  Circle X whole
    Glyphs["noteheadCircleXWhole"] = "\uE0B1";
    // U+E0E4  Circled black notehead
    Glyphs["noteheadCircledBlack"] = "\uE0E4";
    // U+E0E8  Black notehead in large circle
    Glyphs["noteheadCircledBlackLarge"] = "\uE0E8";
    // U+E0E7  Circled double whole notehead
    Glyphs["noteheadCircledDoubleWhole"] = "\uE0E7";
    // U+E0EB  Double whole notehead in large circle
    Glyphs["noteheadCircledDoubleWholeLarge"] = "\uE0EB";
    // U+E0E5  Circled half notehead
    Glyphs["noteheadCircledHalf"] = "\uE0E5";
    // U+E0E9  Half notehead in large circle
    Glyphs["noteheadCircledHalfLarge"] = "\uE0E9";
    // U+E0E6  Circled whole notehead
    Glyphs["noteheadCircledWhole"] = "\uE0E6";
    // U+E0EA  Whole notehead in large circle
    Glyphs["noteheadCircledWholeLarge"] = "\uE0EA";
    // U+E0EC  Cross notehead in large circle
    Glyphs["noteheadCircledXLarge"] = "\uE0EC";
    // U+E124  Double whole note cluster, 2nd
    Glyphs["noteheadClusterDoubleWhole2nd"] = "\uE124";
    // U+E128  Double whole note cluster, 3rd
    Glyphs["noteheadClusterDoubleWhole3rd"] = "\uE128";
    // U+E12E  Combining double whole note cluster, bottom
    Glyphs["noteheadClusterDoubleWholeBottom"] = "\uE12E";
    // U+E12D  Combining double whole note cluster, middle
    Glyphs["noteheadClusterDoubleWholeMiddle"] = "\uE12D";
    // U+E12C  Combining double whole note cluster, top
    Glyphs["noteheadClusterDoubleWholeTop"] = "\uE12C";
    // U+E126  Half note cluster, 2nd
    Glyphs["noteheadClusterHalf2nd"] = "\uE126";
    // U+E12A  Half note cluster, 3rd
    Glyphs["noteheadClusterHalf3rd"] = "\uE12A";
    // U+E134  Combining half note cluster, bottom
    Glyphs["noteheadClusterHalfBottom"] = "\uE134";
    // U+E133  Combining half note cluster, middle
    Glyphs["noteheadClusterHalfMiddle"] = "\uE133";
    // U+E132  Combining half note cluster, top
    Glyphs["noteheadClusterHalfTop"] = "\uE132";
    // U+E127  Quarter note cluster, 2nd
    Glyphs["noteheadClusterQuarter2nd"] = "\uE127";
    // U+E12B  Quarter note cluster, 3rd
    Glyphs["noteheadClusterQuarter3rd"] = "\uE12B";
    // U+E137  Combining quarter note cluster, bottom
    Glyphs["noteheadClusterQuarterBottom"] = "\uE137";
    // U+E136  Combining quarter note cluster, middle
    Glyphs["noteheadClusterQuarterMiddle"] = "\uE136";
    // U+E135  Combining quarter note cluster, top
    Glyphs["noteheadClusterQuarterTop"] = "\uE135";
    // U+E123  Cluster notehead black (round)
    Glyphs["noteheadClusterRoundBlack"] = "\uE123";
    // U+E122  Cluster notehead white (round)
    Glyphs["noteheadClusterRoundWhite"] = "\uE122";
    // U+E121  Cluster notehead black (square)
    Glyphs["noteheadClusterSquareBlack"] = "\uE121";
    // U+E120  Cluster notehead white (square)
    Glyphs["noteheadClusterSquareWhite"] = "\uE120";
    // U+E125  Whole note cluster, 2nd
    Glyphs["noteheadClusterWhole2nd"] = "\uE125";
    // U+E129  Whole note cluster, 3rd
    Glyphs["noteheadClusterWhole3rd"] = "\uE129";
    // U+E131  Combining whole note cluster, bottom
    Glyphs["noteheadClusterWholeBottom"] = "\uE131";
    // U+E130  Combining whole note cluster, middle
    Glyphs["noteheadClusterWholeMiddle"] = "\uE130";
    // U+E12F  Combining whole note cluster, top
    Glyphs["noteheadClusterWholeTop"] = "\uE12F";
    // U+EEAE  4/11 note (eleventh note series, Cowell)
    Glyphs["noteheadCowellEleventhNoteSeriesHalf"] = "\uEEAE";
    // U+EEAD  8/11 note (eleventh note series, Cowell)
    Glyphs["noteheadCowellEleventhNoteSeriesWhole"] = "\uEEAD";
    // U+EEAF  2/11 note (eleventh note series, Cowell)
    Glyphs["noteheadCowellEleventhSeriesBlack"] = "\uEEAF";
    // U+EEB5  2/15 note (fifteenth note series, Cowell)
    Glyphs["noteheadCowellFifteenthNoteSeriesBlack"] = "\uEEB5";
    // U+EEB4  4/15 note (fifteenth note series, Cowell)
    Glyphs["noteheadCowellFifteenthNoteSeriesHalf"] = "\uEEB4";
    // U+EEB3  8/15 note (fifteenth note series, Cowell)
    Glyphs["noteheadCowellFifteenthNoteSeriesWhole"] = "\uEEB3";
    // U+EEA6  1/5 note (fifth note series, Cowell)
    Glyphs["noteheadCowellFifthNoteSeriesBlack"] = "\uEEA6";
    // U+EEA5  2/5 note (fifth note series, Cowell)
    Glyphs["noteheadCowellFifthNoteSeriesHalf"] = "\uEEA5";
    // U+EEA4  4/5 note (fifth note series, Cowell)
    Glyphs["noteheadCowellFifthNoteSeriesWhole"] = "\uEEA4";
    // U+EEAC  2/9 note (ninth note series, Cowell)
    Glyphs["noteheadCowellNinthNoteSeriesBlack"] = "\uEEAC";
    // U+EEAB  4/9 note (ninth note series, Cowell)
    Glyphs["noteheadCowellNinthNoteSeriesHalf"] = "\uEEAB";
    // U+EEAA  8/9 note (ninth note series, Cowell)
    Glyphs["noteheadCowellNinthNoteSeriesWhole"] = "\uEEAA";
    // U+EEA9  1/7 note (seventh note series, Cowell)
    Glyphs["noteheadCowellSeventhNoteSeriesBlack"] = "\uEEA9";
    // U+EEA8  2/7 note (seventh note series, Cowell)
    Glyphs["noteheadCowellSeventhNoteSeriesHalf"] = "\uEEA8";
    // U+EEA7  4/7 note (seventh note series, Cowell)
    Glyphs["noteheadCowellSeventhNoteSeriesWhole"] = "\uEEA7";
    // U+EEA3  1/6 note (third note series, Cowell)
    Glyphs["noteheadCowellThirdNoteSeriesBlack"] = "\uEEA3";
    // U+EEA2  1/3 note (third note series, Cowell)
    Glyphs["noteheadCowellThirdNoteSeriesHalf"] = "\uEEA2";
    // U+EEA1  2/3 note (third note series, Cowell)
    Glyphs["noteheadCowellThirdNoteSeriesWhole"] = "\uEEA1";
    // U+EEB2  2/13 note (thirteenth note series, Cowell)
    Glyphs["noteheadCowellThirteenthNoteSeriesBlack"] = "\uEEB2";
    // U+EEB1  4/13 note (thirteenth note series, Cowell)
    Glyphs["noteheadCowellThirteenthNoteSeriesHalf"] = "\uEEB1";
    // U+EEB0  8/13 note (thirteenth note series, Cowell)
    Glyphs["noteheadCowellThirteenthNoteSeriesWhole"] = "\uEEB0";
    // U+E0DB  Diamond black notehead
    Glyphs["noteheadDiamondBlack"] = "\uE0DB";
    // U+E0E2  Diamond black notehead (old)
    Glyphs["noteheadDiamondBlackOld"] = "\uE0E2";
    // U+E0DC  Diamond black notehead (wide)
    Glyphs["noteheadDiamondBlackWide"] = "\uE0DC";
    // U+E139  Black diamond cluster, 2nd
    Glyphs["noteheadDiamondClusterBlack2nd"] = "\uE139";
    // U+E13B  Black diamond cluster, 3rd
    Glyphs["noteheadDiamondClusterBlack3rd"] = "\uE13B";
    // U+E141  Combining black diamond cluster, bottom
    Glyphs["noteheadDiamondClusterBlackBottom"] = "\uE141";
    // U+E140  Combining black diamond cluster, middle
    Glyphs["noteheadDiamondClusterBlackMiddle"] = "\uE140";
    // U+E13F  Combining black diamond cluster, top
    Glyphs["noteheadDiamondClusterBlackTop"] = "\uE13F";
    // U+E138  White diamond cluster, 2nd
    Glyphs["noteheadDiamondClusterWhite2nd"] = "\uE138";
    // U+E13A  White diamond cluster, 3rd
    Glyphs["noteheadDiamondClusterWhite3rd"] = "\uE13A";
    // U+E13E  Combining white diamond cluster, bottom
    Glyphs["noteheadDiamondClusterWhiteBottom"] = "\uE13E";
    // U+E13D  Combining white diamond cluster, middle
    Glyphs["noteheadDiamondClusterWhiteMiddle"] = "\uE13D";
    // U+E13C  Combining white diamond cluster, top
    Glyphs["noteheadDiamondClusterWhiteTop"] = "\uE13C";
    // U+E0D7  Diamond double whole notehead
    Glyphs["noteheadDiamondDoubleWhole"] = "\uE0D7";
    // U+E0DF  Diamond double whole notehead (old)
    Glyphs["noteheadDiamondDoubleWholeOld"] = "\uE0DF";
    // U+E0D9  Diamond half notehead
    Glyphs["noteheadDiamondHalf"] = "\uE0D9";
    // U+E0E3  Half-filled diamond notehead
    Glyphs["noteheadDiamondHalfFilled"] = "\uE0E3";
    // U+E0E1  Diamond half notehead (old)
    Glyphs["noteheadDiamondHalfOld"] = "\uE0E1";
    // U+E0DA  Diamond half notehead (wide)
    Glyphs["noteheadDiamondHalfWide"] = "\uE0DA";
    // U+E0FC  Open diamond notehead
    Glyphs["noteheadDiamondOpen"] = "\uE0FC";
    // U+E0DD  Diamond white notehead
    Glyphs["noteheadDiamondWhite"] = "\uE0DD";
    // U+E0DE  Diamond white notehead (wide)
    Glyphs["noteheadDiamondWhiteWide"] = "\uE0DE";
    // U+E0D8  Diamond whole notehead
    Glyphs["noteheadDiamondWhole"] = "\uE0D8";
    // U+E0E0  Diamond whole notehead (old)
    Glyphs["noteheadDiamondWholeOld"] = "\uE0E0";
    // U+E0A0  Double whole (breve) notehead
    Glyphs["noteheadDoubleWhole"] = "\uE0A0";
    // U+E0A1  Double whole (breve) notehead (square)
    Glyphs["noteheadDoubleWholeSquare"] = "\uE0A1";
    // U+E0B4  Double whole notehead with X
    Glyphs["noteheadDoubleWholeWithX"] = "\uE0B4";
    // U+E0A3  Half (minim) notehead
    Glyphs["noteheadHalf"] = "\uE0A3";
    // U+E0FB  Filled half (minim) notehead
    Glyphs["noteheadHalfFilled"] = "\uE0FB";
    // U+E0B6  Half notehead with X
    Glyphs["noteheadHalfWithX"] = "\uE0B6";
    // U+E0F8  Heavy X notehead
    Glyphs["noteheadHeavyX"] = "\uE0F8";
    // U+E0F9  Heavy X with hat notehead
    Glyphs["noteheadHeavyXHat"] = "\uE0F9";
    // U+E0F4  Large arrow down (lowest pitch) black notehead
    Glyphs["noteheadLargeArrowDownBlack"] = "\uE0F4";
    // U+E0F1  Large arrow down (lowest pitch) double whole notehead
    Glyphs["noteheadLargeArrowDownDoubleWhole"] = "\uE0F1";
    // U+E0F3  Large arrow down (lowest pitch) half notehead
    Glyphs["noteheadLargeArrowDownHalf"] = "\uE0F3";
    // U+E0F2  Large arrow down (lowest pitch) whole notehead
    Glyphs["noteheadLargeArrowDownWhole"] = "\uE0F2";
    // U+E0F0  Large arrow up (highest pitch) black notehead
    Glyphs["noteheadLargeArrowUpBlack"] = "\uE0F0";
    // U+E0ED  Large arrow up (highest pitch) double whole notehead
    Glyphs["noteheadLargeArrowUpDoubleWhole"] = "\uE0ED";
    // U+E0EF  Large arrow up (highest pitch) half notehead
    Glyphs["noteheadLargeArrowUpHalf"] = "\uE0EF";
    // U+E0EE  Large arrow up (highest pitch) whole notehead
    Glyphs["noteheadLargeArrowUpWhole"] = "\uE0EE";
    // U+E0CB  Moon notehead black
    Glyphs["noteheadMoonBlack"] = "\uE0CB";
    // U+E0CA  Moon notehead white
    Glyphs["noteheadMoonWhite"] = "\uE0CA";
    // U+EEA0  Sine notehead (Nancarrow)
    Glyphs["noteheadNancarrowSine"] = "\uEEA0";
    // U+E0A5  Null notehead
    Glyphs["noteheadNull"] = "\uE0A5";
    // U+E0CE  Parenthesis notehead
    Glyphs["noteheadParenthesis"] = "\uE0CE";
    // U+E0F5  Opening parenthesis
    Glyphs["noteheadParenthesisLeft"] = "\uE0F5";
    // U+E0F6  Closing parenthesis
    Glyphs["noteheadParenthesisRight"] = "\uE0F6";
    // U+E0AF  Plus notehead black
    Glyphs["noteheadPlusBlack"] = "\uE0AF";
    // U+E0AC  Plus notehead double whole
    Glyphs["noteheadPlusDoubleWhole"] = "\uE0AC";
    // U+E0AE  Plus notehead half
    Glyphs["noteheadPlusHalf"] = "\uE0AE";
    // U+E0AD  Plus notehead whole
    Glyphs["noteheadPlusWhole"] = "\uE0AD";
    // U+E144  Combining black rectangular cluster, bottom
    Glyphs["noteheadRectangularClusterBlackBottom"] = "\uE144";
    // U+E143  Combining black rectangular cluster, middle
    Glyphs["noteheadRectangularClusterBlackMiddle"] = "\uE143";
    // U+E142  Combining black rectangular cluster, top
    Glyphs["noteheadRectangularClusterBlackTop"] = "\uE142";
    // U+E147  Combining white rectangular cluster, bottom
    Glyphs["noteheadRectangularClusterWhiteBottom"] = "\uE147";
    // U+E146  Combining white rectangular cluster, middle
    Glyphs["noteheadRectangularClusterWhiteMiddle"] = "\uE146";
    // U+E145  Combining white rectangular cluster, top
    Glyphs["noteheadRectangularClusterWhiteTop"] = "\uE145";
    // U+E113  Round black notehead
    Glyphs["noteheadRoundBlack"] = "\uE113";
    // U+E11C  Round black notehead, double slashed
    Glyphs["noteheadRoundBlackDoubleSlashed"] = "\uE11C";
    // U+E110  Large round black notehead
    Glyphs["noteheadRoundBlackLarge"] = "\uE110";
    // U+E118  Round black notehead, slashed
    Glyphs["noteheadRoundBlackSlashed"] = "\uE118";
    // U+E116  Large round black notehead, slashed
    Glyphs["noteheadRoundBlackSlashedLarge"] = "\uE116";
    // U+E114  Round white notehead
    Glyphs["noteheadRoundWhite"] = "\uE114";
    // U+E11D  Round white notehead, double slashed
    Glyphs["noteheadRoundWhiteDoubleSlashed"] = "\uE11D";
    // U+E111  Large round white notehead
    Glyphs["noteheadRoundWhiteLarge"] = "\uE111";
    // U+E119  Round white notehead, slashed
    Glyphs["noteheadRoundWhiteSlashed"] = "\uE119";
    // U+E117  Large round white notehead, slashed
    Glyphs["noteheadRoundWhiteSlashedLarge"] = "\uE117";
    // U+E115  Round white notehead with dot
    Glyphs["noteheadRoundWhiteWithDot"] = "\uE115";
    // U+E112  Large round white notehead with dot
    Glyphs["noteheadRoundWhiteWithDotLarge"] = "\uE112";
    // U+E104  Large white diamond
    Glyphs["noteheadSlashDiamondWhite"] = "\uE104";
    // U+E101  Slash with horizontal ends
    Glyphs["noteheadSlashHorizontalEnds"] = "\uE101";
    // U+E108  Muted slash with horizontal ends
    Glyphs["noteheadSlashHorizontalEndsMuted"] = "\uE108";
    // U+E100  Slash with vertical ends
    Glyphs["noteheadSlashVerticalEnds"] = "\uE100";
    // U+E107  Muted slash with vertical ends
    Glyphs["noteheadSlashVerticalEndsMuted"] = "\uE107";
    // U+E105  Small slash with vertical ends
    Glyphs["noteheadSlashVerticalEndsSmall"] = "\uE105";
    // U+E10A  White slash double whole
    Glyphs["noteheadSlashWhiteDoubleWhole"] = "\uE10A";
    // U+E103  White slash half
    Glyphs["noteheadSlashWhiteHalf"] = "\uE103";
    // U+E109  Muted white slash
    Glyphs["noteheadSlashWhiteMuted"] = "\uE109";
    // U+E102  White slash whole
    Glyphs["noteheadSlashWhiteWhole"] = "\uE102";
    // U+E106  Large X notehead
    Glyphs["noteheadSlashX"] = "\uE106";
    // U+E0CF  Slashed black notehead (bottom left to top right)
    Glyphs["noteheadSlashedBlack1"] = "\uE0CF";
    // U+E0D0  Slashed black notehead (top left to bottom right)
    Glyphs["noteheadSlashedBlack2"] = "\uE0D0";
    // U+E0D5  Slashed double whole notehead (bottom left to top right)
    Glyphs["noteheadSlashedDoubleWhole1"] = "\uE0D5";
    // U+E0D6  Slashed double whole notehead (top left to bottom right)
    Glyphs["noteheadSlashedDoubleWhole2"] = "\uE0D6";
    // U+E0D1  Slashed half notehead (bottom left to top right)
    Glyphs["noteheadSlashedHalf1"] = "\uE0D1";
    // U+E0D2  Slashed half notehead (top left to bottom right)
    Glyphs["noteheadSlashedHalf2"] = "\uE0D2";
    // U+E0D3  Slashed whole notehead (bottom left to top right)
    Glyphs["noteheadSlashedWhole1"] = "\uE0D3";
    // U+E0D4  Slashed whole notehead (top left to bottom right)
    Glyphs["noteheadSlashedWhole2"] = "\uE0D4";
    // U+E0B9  Square notehead black
    Glyphs["noteheadSquareBlack"] = "\uE0B9";
    // U+E11A  Large square black notehead
    Glyphs["noteheadSquareBlackLarge"] = "\uE11A";
    // U+E11B  Large square white notehead
    Glyphs["noteheadSquareBlackWhite"] = "\uE11B";
    // U+E0B8  Square notehead white
    Glyphs["noteheadSquareWhite"] = "\uE0B8";
    // U+E0C7  Triangle notehead down black
    Glyphs["noteheadTriangleDownBlack"] = "\uE0C7";
    // U+E0C3  Triangle notehead down double whole
    Glyphs["noteheadTriangleDownDoubleWhole"] = "\uE0C3";
    // U+E0C5  Triangle notehead down half
    Glyphs["noteheadTriangleDownHalf"] = "\uE0C5";
    // U+E0C6  Triangle notehead down white
    Glyphs["noteheadTriangleDownWhite"] = "\uE0C6";
    // U+E0C4  Triangle notehead down whole
    Glyphs["noteheadTriangleDownWhole"] = "\uE0C4";
    // U+E0C0  Triangle notehead left black
    Glyphs["noteheadTriangleLeftBlack"] = "\uE0C0";
    // U+E0BF  Triangle notehead left white
    Glyphs["noteheadTriangleLeftWhite"] = "\uE0BF";
    // U+E0C2  Triangle notehead right black
    Glyphs["noteheadTriangleRightBlack"] = "\uE0C2";
    // U+E0C1  Triangle notehead right white
    Glyphs["noteheadTriangleRightWhite"] = "\uE0C1";
    // U+E0CD  Triangle-round notehead down black
    Glyphs["noteheadTriangleRoundDownBlack"] = "\uE0CD";
    // U+E0CC  Triangle-round notehead down white
    Glyphs["noteheadTriangleRoundDownWhite"] = "\uE0CC";
    // U+E0BE  Triangle notehead up black
    Glyphs["noteheadTriangleUpBlack"] = "\uE0BE";
    // U+E0BA  Triangle notehead up double whole
    Glyphs["noteheadTriangleUpDoubleWhole"] = "\uE0BA";
    // U+E0BC  Triangle notehead up half
    Glyphs["noteheadTriangleUpHalf"] = "\uE0BC";
    // U+E0C9  Triangle notehead up right black
    Glyphs["noteheadTriangleUpRightBlack"] = "\uE0C9";
    // U+E0C8  Triangle notehead up right white
    Glyphs["noteheadTriangleUpRightWhite"] = "\uE0C8";
    // U+E0BD  Triangle notehead up white
    Glyphs["noteheadTriangleUpWhite"] = "\uE0BD";
    // U+E0BB  Triangle notehead up whole
    Glyphs["noteheadTriangleUpWhole"] = "\uE0BB";
    // U+E0B7  Void notehead with X
    Glyphs["noteheadVoidWithX"] = "\uE0B7";
    // U+E0A2  Whole (semibreve) notehead
    Glyphs["noteheadWhole"] = "\uE0A2";
    // U+E0FA  Filled whole (semibreve) notehead
    Glyphs["noteheadWholeFilled"] = "\uE0FA";
    // U+E0B5  Whole notehead with X
    Glyphs["noteheadWholeWithX"] = "\uE0B5";
    // U+E0A9  X notehead black
    Glyphs["noteheadXBlack"] = "\uE0A9";
    // U+E0A6  X notehead double whole
    Glyphs["noteheadXDoubleWhole"] = "\uE0A6";
    // U+E0A8  X notehead half
    Glyphs["noteheadXHalf"] = "\uE0A8";
    // U+E0AA  Ornate X notehead
    Glyphs["noteheadXOrnate"] = "\uE0AA";
    // U+E0AB  Ornate X notehead in ellipse
    Glyphs["noteheadXOrnateEllipse"] = "\uE0AB";
    // U+E0A7  X notehead whole
    Glyphs["noteheadXWhole"] = "\uE0A7";
    // U+EC91  a (baseline)
    Glyphs["octaveBaselineA"] = "\uEC91";
    // U+EC93  b (baseline)
    Glyphs["octaveBaselineB"] = "\uEC93";
    // U+EC95  m (baseline)
    Glyphs["octaveBaselineM"] = "\uEC95";
    // U+EC97  v (baseline)
    Glyphs["octaveBaselineV"] = "\uEC97";
    // U+E51F  Bassa
    Glyphs["octaveBassa"] = "\uE51F";
    // U+EC90  Loco
    Glyphs["octaveLoco"] = "\uEC90";
    // U+E51A  Left parenthesis for octave signs
    Glyphs["octaveParensLeft"] = "\uE51A";
    // U+E51B  Right parenthesis for octave signs
    Glyphs["octaveParensRight"] = "\uE51B";
    // U+EC92  a (superscript)
    Glyphs["octaveSuperscriptA"] = "\uEC92";
    // U+EC94  b (superscript)
    Glyphs["octaveSuperscriptB"] = "\uEC94";
    // U+EC96  m (superscript)
    Glyphs["octaveSuperscriptM"] = "\uEC96";
    // U+EC98  v (superscript)
    Glyphs["octaveSuperscriptV"] = "\uEC98";
    // U+E233  One-handed roll (Stevens)
    Glyphs["oneHandedRollStevens"] = "\uE233";
    // U+EE2E  Two Fusae
    Glyphs["organGerman2Fusae"] = "\uEE2E";
    // U+EE2C  Two Minimae
    Glyphs["organGerman2Minimae"] = "\uEE2C";
    // U+EE19  Combining double octave line above
    Glyphs["organGerman2OctaveUp"] = "\uEE19";
    // U+EE2F  Two Semifusae
    Glyphs["organGerman2Semifusae"] = "\uEE2F";
    // U+EE2D  Two Semiminimae
    Glyphs["organGerman2Semiminimae"] = "\uEE2D";
    // U+EE32  Three Fusae
    Glyphs["organGerman3Fusae"] = "\uEE32";
    // U+EE30  Three Minimae
    Glyphs["organGerman3Minimae"] = "\uEE30";
    // U+EE33  Three Semifusae
    Glyphs["organGerman3Semifusae"] = "\uEE33";
    // U+EE31  Three Semiminimae
    Glyphs["organGerman3Semiminimae"] = "\uEE31";
    // U+EE36  Four Fusae
    Glyphs["organGerman4Fusae"] = "\uEE36";
    // U+EE34  Four Minimae
    Glyphs["organGerman4Minimae"] = "\uEE34";
    // U+EE37  Four Semifusae
    Glyphs["organGerman4Semifusae"] = "\uEE37";
    // U+EE35  Four Semiminimae
    Glyphs["organGerman4Semiminimae"] = "\uEE35";
    // U+EE3A  Five Fusae
    Glyphs["organGerman5Fusae"] = "\uEE3A";
    // U+EE38  Five Minimae
    Glyphs["organGerman5Minimae"] = "\uEE38";
    // U+EE3B  Five Semifusae
    Glyphs["organGerman5Semifusae"] = "\uEE3B";
    // U+EE39  Five Semiminimae
    Glyphs["organGerman5Semiminimae"] = "\uEE39";
    // U+EE3E  Six Fusae
    Glyphs["organGerman6Fusae"] = "\uEE3E";
    // U+EE3C  Six Minimae
    Glyphs["organGerman6Minimae"] = "\uEE3C";
    // U+EE3F  Six Semifusae
    Glyphs["organGerman6Semifusae"] = "\uEE3F";
    // U+EE3D  Six Semiminimae
    Glyphs["organGerman6Semiminimae"] = "\uEE3D";
    // U+EE15  German organ tablature small A
    Glyphs["organGermanALower"] = "\uEE15";
    // U+EE09  German organ tablature great A
    Glyphs["organGermanAUpper"] = "\uEE09";
    // U+EE1C  Rhythm Dot
    Glyphs["organGermanAugmentationDot"] = "\uEE1C";
    // U+EE16  German organ tablature small B
    Glyphs["organGermanBLower"] = "\uEE16";
    // U+EE0A  German organ tablature great B
    Glyphs["organGermanBUpper"] = "\uEE0A";
    // U+EE25  Brevis (Binary) Buxheimer Orgelbuch
    Glyphs["organGermanBuxheimerBrevis2"] = "\uEE25";
    // U+EE24  Brevis (Ternary) Buxheimer Orgelbuch
    Glyphs["organGermanBuxheimerBrevis3"] = "\uEE24";
    // U+EE1E  Minima Rest Buxheimer Orgelbuch
    Glyphs["organGermanBuxheimerMinimaRest"] = "\uEE1E";
    // U+EE26  Semibrevis Buxheimer Orgelbuch
    Glyphs["organGermanBuxheimerSemibrevis"] = "\uEE26";
    // U+EE1D  Semibrevis Rest Buxheimer Orgelbuch
    Glyphs["organGermanBuxheimerSemibrevisRest"] = "\uEE1D";
    // U+EE0C  German organ tablature small C
    Glyphs["organGermanCLower"] = "\uEE0C";
    // U+EE00  German organ tablature great C
    Glyphs["organGermanCUpper"] = "\uEE00";
    // U+EE0D  German organ tablature small Cis
    Glyphs["organGermanCisLower"] = "\uEE0D";
    // U+EE01  German organ tablature great Cis
    Glyphs["organGermanCisUpper"] = "\uEE01";
    // U+EE0E  German organ tablature small D
    Glyphs["organGermanDLower"] = "\uEE0E";
    // U+EE02  German organ tablature great D
    Glyphs["organGermanDUpper"] = "\uEE02";
    // U+EE0F  German organ tablature small Dis
    Glyphs["organGermanDisLower"] = "\uEE0F";
    // U+EE03  German organ tablature great Dis
    Glyphs["organGermanDisUpper"] = "\uEE03";
    // U+EE10  German organ tablature small E
    Glyphs["organGermanELower"] = "\uEE10";
    // U+EE04  German organ tablature great E
    Glyphs["organGermanEUpper"] = "\uEE04";
    // U+EE11  German organ tablature small F
    Glyphs["organGermanFLower"] = "\uEE11";
    // U+EE05  German organ tablature great F
    Glyphs["organGermanFUpper"] = "\uEE05";
    // U+EE12  German organ tablature small Fis
    Glyphs["organGermanFisLower"] = "\uEE12";
    // U+EE06  German organ tablature great Fis
    Glyphs["organGermanFisUpper"] = "\uEE06";
    // U+EE2A  Fusa
    Glyphs["organGermanFusa"] = "\uEE2A";
    // U+EE22  Fusa Rest
    Glyphs["organGermanFusaRest"] = "\uEE22";
    // U+EE13  German organ tablature small G
    Glyphs["organGermanGLower"] = "\uEE13";
    // U+EE07  German organ tablature great G
    Glyphs["organGermanGUpper"] = "\uEE07";
    // U+EE14  German organ tablature small Gis
    Glyphs["organGermanGisLower"] = "\uEE14";
    // U+EE08  German organ tablature great Gis
    Glyphs["organGermanGisUpper"] = "\uEE08";
    // U+EE17  German organ tablature small H
    Glyphs["organGermanHLower"] = "\uEE17";
    // U+EE0B  German organ tablature great H
    Glyphs["organGermanHUpper"] = "\uEE0B";
    // U+EE28  Minima
    Glyphs["organGermanMinima"] = "\uEE28";
    // U+EE20  Minima Rest
    Glyphs["organGermanMinimaRest"] = "\uEE20";
    // U+EE1A  Combining single octave line below
    Glyphs["organGermanOctaveDown"] = "\uEE1A";
    // U+EE18  Combining single octave line above
    Glyphs["organGermanOctaveUp"] = "\uEE18";
    // U+EE27  Semibrevis
    Glyphs["organGermanSemibrevis"] = "\uEE27";
    // U+EE1F  Semibrevis Rest
    Glyphs["organGermanSemibrevisRest"] = "\uEE1F";
    // U+EE2B  Semifusa
    Glyphs["organGermanSemifusa"] = "\uEE2B";
    // U+EE23  Semifusa Rest
    Glyphs["organGermanSemifusaRest"] = "\uEE23";
    // U+EE29  Semiminima
    Glyphs["organGermanSemiminima"] = "\uEE29";
    // U+EE21  Semiminima Rest
    Glyphs["organGermanSemiminimaRest"] = "\uEE21";
    // U+EE1B  Tie
    Glyphs["organGermanTie"] = "\uEE1B";
    // U+E59A  Ornament bottom left concave stroke
    Glyphs["ornamentBottomLeftConcaveStroke"] = "\uE59A";
    // U+E59B  Ornament bottom left concave stroke, large
    Glyphs["ornamentBottomLeftConcaveStrokeLarge"] = "\uE59B";
    // U+E59C  Ornament bottom left convex stroke
    Glyphs["ornamentBottomLeftConvexStroke"] = "\uE59C";
    // U+E5A7  Ornament bottom right concave stroke
    Glyphs["ornamentBottomRightConcaveStroke"] = "\uE5A7";
    // U+E5A8  Ornament bottom right convex stroke
    Glyphs["ornamentBottomRightConvexStroke"] = "\uE5A8";
    // U+E581  Comma
    Glyphs["ornamentComma"] = "\uE581";
    // U+E57E  Double oblique straight lines NW-SE
    Glyphs["ornamentDoubleObliqueLinesAfterNote"] = "\uE57E";
    // U+E57D  Double oblique straight lines SW-NE
    Glyphs["ornamentDoubleObliqueLinesBeforeNote"] = "\uE57D";
    // U+E578  Curve below
    Glyphs["ornamentDownCurve"] = "\uE578";
    // U+E56F  Haydn ornament
    Glyphs["ornamentHaydn"] = "\uE56F";
    // U+E592  Ornament high left concave stroke
    Glyphs["ornamentHighLeftConcaveStroke"] = "\uE592";
    // U+E593  Ornament high left convex stroke
    Glyphs["ornamentHighLeftConvexStroke"] = "\uE593";
    // U+E5A2  Ornament high right concave stroke
    Glyphs["ornamentHighRightConcaveStroke"] = "\uE5A2";
    // U+E5A3  Ornament high right convex stroke
    Glyphs["ornamentHighRightConvexStroke"] = "\uE5A3";
    // U+E576  Hook after note
    Glyphs["ornamentHookAfterNote"] = "\uE576";
    // U+E575  Hook before note
    Glyphs["ornamentHookBeforeNote"] = "\uE575";
    // U+E572  Left-facing half circle
    Glyphs["ornamentLeftFacingHalfCircle"] = "\uE572";
    // U+E574  Left-facing hook
    Glyphs["ornamentLeftFacingHook"] = "\uE574";
    // U+E597  Ornament left +
    Glyphs["ornamentLeftPlus"] = "\uE597";
    // U+E596  Ornament left shake t
    Glyphs["ornamentLeftShakeT"] = "\uE596";
    // U+E594  Ornament left vertical stroke
    Glyphs["ornamentLeftVerticalStroke"] = "\uE594";
    // U+E595  Ornament left vertical stroke with cross (+)
    Glyphs["ornamentLeftVerticalStrokeWithCross"] = "\uE595";
    // U+E598  Ornament low left concave stroke
    Glyphs["ornamentLowLeftConcaveStroke"] = "\uE598";
    // U+E599  Ornament low left convex stroke
    Glyphs["ornamentLowLeftConvexStroke"] = "\uE599";
    // U+E5A5  Ornament low right concave stroke
    Glyphs["ornamentLowRightConcaveStroke"] = "\uE5A5";
    // U+E5A6  Ornament low right convex stroke
    Glyphs["ornamentLowRightConvexStroke"] = "\uE5A6";
    // U+E59F  Ornament middle vertical stroke
    Glyphs["ornamentMiddleVerticalStroke"] = "\uE59F";
    // U+E56D  Mordent
    Glyphs["ornamentMordent"] = "\uE56D";
    // U+E57C  Oblique straight line NW-SE
    Glyphs["ornamentObliqueLineAfterNote"] = "\uE57C";
    // U+E57B  Oblique straight line SW-NE
    Glyphs["ornamentObliqueLineBeforeNote"] = "\uE57B";
    // U+E580  Oblique straight line tilted NW-SE
    Glyphs["ornamentObliqueLineHorizAfterNote"] = "\uE580";
    // U+E57F  Oblique straight line tilted SW-NE
    Glyphs["ornamentObliqueLineHorizBeforeNote"] = "\uE57F";
    // U+EA21  Oriscus
    Glyphs["ornamentOriscus"] = "\uEA21";
    // U+E588  Pinc (Couperin)
    Glyphs["ornamentPinceCouperin"] = "\uE588";
    // U+E570  Port de voix
    Glyphs["ornamentPortDeVoixV"] = "\uE570";
    // U+E5B2  Supported appoggiatura trill
    Glyphs["ornamentPrecompAppoggTrill"] = "\uE5B2";
    // U+E5B3  Supported appoggiatura trill with two-note suffix
    Glyphs["ornamentPrecompAppoggTrillSuffix"] = "\uE5B3";
    // U+E5BE  Cadence
    Glyphs["ornamentPrecompCadence"] = "\uE5BE";
    // U+E5C1  Cadence with upper prefix
    Glyphs["ornamentPrecompCadenceUpperPrefix"] = "\uE5C1";
    // U+E5C2  Cadence with upper prefix and turn
    Glyphs["ornamentPrecompCadenceUpperPrefixTurn"] = "\uE5C2";
    // U+E5BF  Cadence with turn
    Glyphs["ornamentPrecompCadenceWithTurn"] = "\uE5BF";
    // U+E5B1  Descending slide
    Glyphs["ornamentPrecompDescendingSlide"] = "\uE5B1";
    // U+E5C0  Double cadence with lower prefix
    Glyphs["ornamentPrecompDoubleCadenceLowerPrefix"] = "\uE5C0";
    // U+E5C3  Double cadence with upper prefix
    Glyphs["ornamentPrecompDoubleCadenceUpperPrefix"] = "\uE5C3";
    // U+E5C4  Double cadence with upper prefix and turn
    Glyphs["ornamentPrecompDoubleCadenceUpperPrefixTurn"] = "\uE5C4";
    // U+E5C7  Inverted mordent with upper prefix
    Glyphs["ornamentPrecompInvertedMordentUpperPrefix"] = "\uE5C7";
    // U+E5C5  Mordent with release
    Glyphs["ornamentPrecompMordentRelease"] = "\uE5C5";
    // U+E5C6  Mordent with upper prefix
    Glyphs["ornamentPrecompMordentUpperPrefix"] = "\uE5C6";
    // U+E5BC  Pre-beat port de voix followed by multiple mordent (Dandrieu)
    Glyphs["ornamentPrecompPortDeVoixMordent"] = "\uE5BC";
    // U+E5B0  Slide
    Glyphs["ornamentPrecompSlide"] = "\uE5B0";
    // U+E5B8  Slide-trill with two-note suffix (J.S. Bach)
    Glyphs["ornamentPrecompSlideTrillBach"] = "\uE5B8";
    // U+E5B5  Slide-trill (D'Anglebert)
    Glyphs["ornamentPrecompSlideTrillDAnglebert"] = "\uE5B5";
    // U+E5B6  Slide-trill with one-note suffix (Marpurg)
    Glyphs["ornamentPrecompSlideTrillMarpurg"] = "\uE5B6";
    // U+E5B9  Slide-trill (Muffat)
    Glyphs["ornamentPrecompSlideTrillMuffat"] = "\uE5B9";
    // U+E5BA  Slide-trill with two-note suffix (Muffat)
    Glyphs["ornamentPrecompSlideTrillSuffixMuffat"] = "\uE5BA";
    // U+E5C8  Trill with lower suffix
    Glyphs["ornamentPrecompTrillLowerSuffix"] = "\uE5C8";
    // U+E5BB  Trill with two-note suffix (Dandrieu)
    Glyphs["ornamentPrecompTrillSuffixDandrieu"] = "\uE5BB";
    // U+E5BD  Trill with mordent
    Glyphs["ornamentPrecompTrillWithMordent"] = "\uE5BD";
    // U+E5B7  Turn-trill with two-note suffix (J.S. Bach)
    Glyphs["ornamentPrecompTurnTrillBach"] = "\uE5B7";
    // U+E5B4  Turn-trill (D'Anglebert)
    Glyphs["ornamentPrecompTurnTrillDAnglebert"] = "\uE5B4";
    // U+EA20  Quilisma
    Glyphs["ornamentQuilisma"] = "\uEA20";
    // U+E571  Right-facing half circle
    Glyphs["ornamentRightFacingHalfCircle"] = "\uE571";
    // U+E573  Right-facing hook
    Glyphs["ornamentRightFacingHook"] = "\uE573";
    // U+E5A4  Ornament right vertical stroke
    Glyphs["ornamentRightVerticalStroke"] = "\uE5A4";
    // U+E587  Schleifer (long mordent)
    Glyphs["ornamentSchleifer"] = "\uE587";
    // U+E582  Shake
    Glyphs["ornamentShake3"] = "\uE582";
    // U+E584  Shake (Muffat)
    Glyphs["ornamentShakeMuffat1"] = "\uE584";
    // U+E57A  Short oblique straight line NW-SE
    Glyphs["ornamentShortObliqueLineAfterNote"] = "\uE57A";
    // U+E579  Short oblique straight line SW-NE
    Glyphs["ornamentShortObliqueLineBeforeNote"] = "\uE579";
    // U+E56C  Short trill
    Glyphs["ornamentShortTrill"] = "\uE56C";
    // U+E590  Ornament top left concave stroke
    Glyphs["ornamentTopLeftConcaveStroke"] = "\uE590";
    // U+E591  Ornament top left convex stroke
    Glyphs["ornamentTopLeftConvexStroke"] = "\uE591";
    // U+E5A0  Ornament top right concave stroke
    Glyphs["ornamentTopRightConcaveStroke"] = "\uE5A0";
    // U+E5A1  Ornament top right convex stroke
    Glyphs["ornamentTopRightConvexStroke"] = "\uE5A1";
    // U+E56E  Tremblement
    Glyphs["ornamentTremblement"] = "\uE56E";
    // U+E589  Tremblement appuy (Couperin)
    Glyphs["ornamentTremblementCouperin"] = "\uE589";
    // U+E566  Trill
    Glyphs["ornamentTrill"] = "\uE566";
    // U+E567  Turn
    Glyphs["ornamentTurn"] = "\uE567";
    // U+E568  Inverted turn
    Glyphs["ornamentTurnInverted"] = "\uE568";
    // U+E569  Turn with slash
    Glyphs["ornamentTurnSlash"] = "\uE569";
    // U+E56A  Turn up
    Glyphs["ornamentTurnUp"] = "\uE56A";
    // U+E56B  Inverted turn up
    Glyphs["ornamentTurnUpS"] = "\uE56B";
    // U+E577  Curve above
    Glyphs["ornamentUpCurve"] = "\uE577";
    // U+E583  Vertical line
    Glyphs["ornamentVerticalLine"] = "\uE583";
    // U+E59D  Ornament zig-zag line without right-hand end
    Glyphs["ornamentZigZagLineNoRightEnd"] = "\uE59D";
    // U+E59E  Ornament zig-zag line with right-hand end
    Glyphs["ornamentZigZagLineWithRightEnd"] = "\uE59E";
    // U+E510  Ottava
    Glyphs["ottava"] = "\uE510";
    // U+E511  Ottava alta
    Glyphs["ottavaAlta"] = "\uE511";
    // U+E512  Ottava bassa
    Glyphs["ottavaBassa"] = "\uE512";
    // U+E513  Ottava bassa (ba)
    Glyphs["ottavaBassaBa"] = "\uE513";
    // U+E51C  Ottava bassa (8vb)
    Glyphs["ottavaBassaVb"] = "\uE51C";
    // U+E22B  Penderecki unmeasured tremolo
    Glyphs["pendereckiTremolo"] = "\uE22B";
    // U+E717  Agogo
    Glyphs["pictAgogo"] = "\uE717";
    // U+E712  Almglocken
    Glyphs["pictAlmglocken"] = "\uE712";
    // U+E701  Anvil
    Glyphs["pictAnvil"] = "\uE701";
    // U+E6C3  Bamboo tube chimes
    Glyphs["pictBambooChimes"] = "\uE6C3";
    // U+E6FB  Bamboo scraper
    Glyphs["pictBambooScraper"] = "\uE6FB";
    // U+E6D4  Bass drum
    Glyphs["pictBassDrum"] = "\uE6D4";
    // U+E6D5  Bass drum on side
    Glyphs["pictBassDrumOnSide"] = "\uE6D5";
    // U+E7DE  Bow
    Glyphs["pictBeaterBow"] = "\uE7DE";
    // U+E7EB  Box for percussion beater
    Glyphs["pictBeaterBox"] = "\uE7EB";
    // U+E7DA  Brass mallets down
    Glyphs["pictBeaterBrassMalletsDown"] = "\uE7DA";
    // U+E7EE  Brass mallets left
    Glyphs["pictBeaterBrassMalletsLeft"] = "\uE7EE";
    // U+E7ED  Brass mallets right
    Glyphs["pictBeaterBrassMalletsRight"] = "\uE7ED";
    // U+E7D9  Brass mallets up
    Glyphs["pictBeaterBrassMalletsUp"] = "\uE7D9";
    // U+E7EA  Combining dashed circle for round beaters (plated)
    Glyphs["pictBeaterCombiningDashedCircle"] = "\uE7EA";
    // U+E7E9  Combining parentheses for round beaters (padded)
    Glyphs["pictBeaterCombiningParentheses"] = "\uE7E9";
    // U+E7A1  Double bass drum stick down
    Glyphs["pictBeaterDoubleBassDrumDown"] = "\uE7A1";
    // U+E7A0  Double bass drum stick up
    Glyphs["pictBeaterDoubleBassDrumUp"] = "\uE7A0";
    // U+E7E4  Finger
    Glyphs["pictBeaterFinger"] = "\uE7E4";
    // U+E7E6  Fingernails
    Glyphs["pictBeaterFingernails"] = "\uE7E6";
    // U+E7E5  Fist
    Glyphs["pictBeaterFist"] = "\uE7E5";
    // U+E7DD  Guiro scraper
    Glyphs["pictBeaterGuiroScraper"] = "\uE7DD";
    // U+E7E1  Hammer
    Glyphs["pictBeaterHammer"] = "\uE7E1";
    // U+E7D0  Metal hammer, down
    Glyphs["pictBeaterHammerMetalDown"] = "\uE7D0";
    // U+E7CF  Metal hammer, up
    Glyphs["pictBeaterHammerMetalUp"] = "\uE7CF";
    // U+E7CE  Plastic hammer, down
    Glyphs["pictBeaterHammerPlasticDown"] = "\uE7CE";
    // U+E7CD  Plastic hammer, up
    Glyphs["pictBeaterHammerPlasticUp"] = "\uE7CD";
    // U+E7CC  Wooden hammer, down
    Glyphs["pictBeaterHammerWoodDown"] = "\uE7CC";
    // U+E7CB  Wooden hammer, up
    Glyphs["pictBeaterHammerWoodUp"] = "\uE7CB";
    // U+E7E3  Hand
    Glyphs["pictBeaterHand"] = "\uE7E3";
    // U+E79D  Hard bass drum stick down
    Glyphs["pictBeaterHardBassDrumDown"] = "\uE79D";
    // U+E79C  Hard bass drum stick up
    Glyphs["pictBeaterHardBassDrumUp"] = "\uE79C";
    // U+E785  Hard glockenspiel stick down
    Glyphs["pictBeaterHardGlockenspielDown"] = "\uE785";
    // U+E787  Hard glockenspiel stick left
    Glyphs["pictBeaterHardGlockenspielLeft"] = "\uE787";
    // U+E786  Hard glockenspiel stick right
    Glyphs["pictBeaterHardGlockenspielRight"] = "\uE786";
    // U+E784  Hard glockenspiel stick up
    Glyphs["pictBeaterHardGlockenspielUp"] = "\uE784";
    // U+E791  Hard timpani stick down
    Glyphs["pictBeaterHardTimpaniDown"] = "\uE791";
    // U+E793  Hard timpani stick left
    Glyphs["pictBeaterHardTimpaniLeft"] = "\uE793";
    // U+E792  Hard timpani stick right
    Glyphs["pictBeaterHardTimpaniRight"] = "\uE792";
    // U+E790  Hard timpani stick up
    Glyphs["pictBeaterHardTimpaniUp"] = "\uE790";
    // U+E779  Hard xylophone stick down
    Glyphs["pictBeaterHardXylophoneDown"] = "\uE779";
    // U+E77B  Hard xylophone stick left
    Glyphs["pictBeaterHardXylophoneLeft"] = "\uE77B";
    // U+E77A  Hard xylophone stick right
    Glyphs["pictBeaterHardXylophoneRight"] = "\uE77A";
    // U+E778  Hard xylophone stick up
    Glyphs["pictBeaterHardXylophoneUp"] = "\uE778";
    // U+E7AB  Hard yarn beater down
    Glyphs["pictBeaterHardYarnDown"] = "\uE7AB";
    // U+E7AD  Hard yarn beater left
    Glyphs["pictBeaterHardYarnLeft"] = "\uE7AD";
    // U+E7AC  Hard yarn beater right
    Glyphs["pictBeaterHardYarnRight"] = "\uE7AC";
    // U+E7AA  Hard yarn beater up
    Glyphs["pictBeaterHardYarnUp"] = "\uE7AA";
    // U+E7D4  Jazz sticks down
    Glyphs["pictBeaterJazzSticksDown"] = "\uE7D4";
    // U+E7D3  Jazz sticks up
    Glyphs["pictBeaterJazzSticksUp"] = "\uE7D3";
    // U+E7E2  Knitting needle
    Glyphs["pictBeaterKnittingNeedle"] = "\uE7E2";
    // U+E7DF  Chime hammer up
    Glyphs["pictBeaterMallet"] = "\uE7DF";
    // U+E7EC  Chime hammer down
    Glyphs["pictBeaterMalletDown"] = "\uE7EC";
    // U+E79B  Medium bass drum stick down
    Glyphs["pictBeaterMediumBassDrumDown"] = "\uE79B";
    // U+E79A  Medium bass drum stick up
    Glyphs["pictBeaterMediumBassDrumUp"] = "\uE79A";
    // U+E78D  Medium timpani stick down
    Glyphs["pictBeaterMediumTimpaniDown"] = "\uE78D";
    // U+E78F  Medium timpani stick left
    Glyphs["pictBeaterMediumTimpaniLeft"] = "\uE78F";
    // U+E78E  Medium timpani stick right
    Glyphs["pictBeaterMediumTimpaniRight"] = "\uE78E";
    // U+E78C  Medium timpani stick up
    Glyphs["pictBeaterMediumTimpaniUp"] = "\uE78C";
    // U+E775  Medium xylophone stick down
    Glyphs["pictBeaterMediumXylophoneDown"] = "\uE775";
    // U+E777  Medium xylophone stick left
    Glyphs["pictBeaterMediumXylophoneLeft"] = "\uE777";
    // U+E776  Medium xylophone stick right
    Glyphs["pictBeaterMediumXylophoneRight"] = "\uE776";
    // U+E774  Medium xylophone stick up
    Glyphs["pictBeaterMediumXylophoneUp"] = "\uE774";
    // U+E7A7  Medium yarn beater down
    Glyphs["pictBeaterMediumYarnDown"] = "\uE7A7";
    // U+E7A9  Medium yarn beater left
    Glyphs["pictBeaterMediumYarnLeft"] = "\uE7A9";
    // U+E7A8  Medium yarn beater right
    Glyphs["pictBeaterMediumYarnRight"] = "\uE7A8";
    // U+E7A6  Medium yarn beater up
    Glyphs["pictBeaterMediumYarnUp"] = "\uE7A6";
    // U+E79F  Metal bass drum stick down
    Glyphs["pictBeaterMetalBassDrumDown"] = "\uE79F";
    // U+E79E  Metal bass drum stick up
    Glyphs["pictBeaterMetalBassDrumUp"] = "\uE79E";
    // U+E7C8  Metal beater down
    Glyphs["pictBeaterMetalDown"] = "\uE7C8";
    // U+E7E0  Metal hammer
    Glyphs["pictBeaterMetalHammer"] = "\uE7E0";
    // U+E7CA  Metal beater, left
    Glyphs["pictBeaterMetalLeft"] = "\uE7CA";
    // U+E7C9  Metal beater, right
    Glyphs["pictBeaterMetalRight"] = "\uE7C9";
    // U+E7C7  Metal beater, up
    Glyphs["pictBeaterMetalUp"] = "\uE7C7";
    // U+E7D2  Snare sticks down
    Glyphs["pictBeaterSnareSticksDown"] = "\uE7D2";
    // U+E7D1  Snare sticks up
    Glyphs["pictBeaterSnareSticksUp"] = "\uE7D1";
    // U+E799  Soft bass drum stick down
    Glyphs["pictBeaterSoftBassDrumDown"] = "\uE799";
    // U+E798  Soft bass drum stick up
    Glyphs["pictBeaterSoftBassDrumUp"] = "\uE798";
    // U+E781  Soft glockenspiel stick down
    Glyphs["pictBeaterSoftGlockenspielDown"] = "\uE781";
    // U+E783  Soft glockenspiel stick left
    Glyphs["pictBeaterSoftGlockenspielLeft"] = "\uE783";
    // U+E782  Soft glockenspiel stick right
    Glyphs["pictBeaterSoftGlockenspielRight"] = "\uE782";
    // U+E780  Soft glockenspiel stick up
    Glyphs["pictBeaterSoftGlockenspielUp"] = "\uE780";
    // U+E789  Soft timpani stick down
    Glyphs["pictBeaterSoftTimpaniDown"] = "\uE789";
    // U+E78B  Soft timpani stick left
    Glyphs["pictBeaterSoftTimpaniLeft"] = "\uE78B";
    // U+E78A  Soft timpani stick right
    Glyphs["pictBeaterSoftTimpaniRight"] = "\uE78A";
    // U+E788  Soft timpani stick up
    Glyphs["pictBeaterSoftTimpaniUp"] = "\uE788";
    // U+E7DB  Soft xylophone beaters
    Glyphs["pictBeaterSoftXylophone"] = "\uE7DB";
    // U+E771  Soft xylophone stick down
    Glyphs["pictBeaterSoftXylophoneDown"] = "\uE771";
    // U+E773  Soft xylophone stick left
    Glyphs["pictBeaterSoftXylophoneLeft"] = "\uE773";
    // U+E772  Soft xylophone stick right
    Glyphs["pictBeaterSoftXylophoneRight"] = "\uE772";
    // U+E770  Soft xylophone stick up
    Glyphs["pictBeaterSoftXylophoneUp"] = "\uE770";
    // U+E7A3  Soft yarn beater down
    Glyphs["pictBeaterSoftYarnDown"] = "\uE7A3";
    // U+E7A5  Soft yarn beater left
    Glyphs["pictBeaterSoftYarnLeft"] = "\uE7A5";
    // U+E7A4  Soft yarn beater right
    Glyphs["pictBeaterSoftYarnRight"] = "\uE7A4";
    // U+E7A2  Soft yarn beater up
    Glyphs["pictBeaterSoftYarnUp"] = "\uE7A2";
    // U+E7DC  Spoon-shaped wooden mallet
    Glyphs["pictBeaterSpoonWoodenMallet"] = "\uE7DC";
    // U+E7AF  Superball beater down
    Glyphs["pictBeaterSuperballDown"] = "\uE7AF";
    // U+E7B1  Superball beater left
    Glyphs["pictBeaterSuperballLeft"] = "\uE7B1";
    // U+E7B0  Superball beater right
    Glyphs["pictBeaterSuperballRight"] = "\uE7B0";
    // U+E7AE  Superball beater up
    Glyphs["pictBeaterSuperballUp"] = "\uE7AE";
    // U+E7D6  Triangle beater down
    Glyphs["pictBeaterTriangleDown"] = "\uE7D6";
    // U+E7EF  Triangle beater plain
    Glyphs["pictBeaterTrianglePlain"] = "\uE7EF";
    // U+E7D5  Triangle beater up
    Glyphs["pictBeaterTriangleUp"] = "\uE7D5";
    // U+E7D8  Wire brushes down
    Glyphs["pictBeaterWireBrushesDown"] = "\uE7D8";
    // U+E7D7  Wire brushes up
    Glyphs["pictBeaterWireBrushesUp"] = "\uE7D7";
    // U+E795  Wood timpani stick down
    Glyphs["pictBeaterWoodTimpaniDown"] = "\uE795";
    // U+E797  Wood timpani stick left
    Glyphs["pictBeaterWoodTimpaniLeft"] = "\uE797";
    // U+E796  Wood timpani stick right
    Glyphs["pictBeaterWoodTimpaniRight"] = "\uE796";
    // U+E794  Wood timpani stick up
    Glyphs["pictBeaterWoodTimpaniUp"] = "\uE794";
    // U+E77D  Wood xylophone stick down
    Glyphs["pictBeaterWoodXylophoneDown"] = "\uE77D";
    // U+E77F  Wood xylophone stick left
    Glyphs["pictBeaterWoodXylophoneLeft"] = "\uE77F";
    // U+E77E  Wood xylophone stick right
    Glyphs["pictBeaterWoodXylophoneRight"] = "\uE77E";
    // U+E77C  Wood xylophone stick up
    Glyphs["pictBeaterWoodXylophoneUp"] = "\uE77C";
    // U+E714  Bell
    Glyphs["pictBell"] = "\uE714";
    // U+E72A  Bell of cymbal
    Glyphs["pictBellOfCymbal"] = "\uE72A";
    // U+E713  Bell plate
    Glyphs["pictBellPlate"] = "\uE713";
    // U+E71A  Bell tree
    Glyphs["pictBellTree"] = "\uE71A";
    // U+E751  Bird whistle
    Glyphs["pictBirdWhistle"] = "\uE751";
    // U+E6F7  Board clapper
    Glyphs["pictBoardClapper"] = "\uE6F7";
    // U+E6DD  Bongos
    Glyphs["pictBongos"] = "\uE6DD";
    // U+E6E1  Brake drum
    Glyphs["pictBrakeDrum"] = "\uE6E1";
    // U+E743  Cabasa
    Glyphs["pictCabasa"] = "\uE743";
    // U+E761  Cannon
    Glyphs["pictCannon"] = "\uE761";
    // U+E755  Car horn
    Glyphs["pictCarHorn"] = "\uE755";
    // U+E6F8  Castanets
    Glyphs["pictCastanets"] = "\uE6F8";
    // U+E6F9  Castanets with handle
    Glyphs["pictCastanetsWithHandle"] = "\uE6F9";
    // U+E6B0  Celesta
    Glyphs["pictCelesta"] = "\uE6B0";
    // U+E716  Cencerro
    Glyphs["pictCencerro"] = "\uE716";
    // U+E7FE  Center (Weinberg)
    Glyphs["pictCenter1"] = "\uE7FE";
    // U+E7FF  Center (Ghent)
    Glyphs["pictCenter2"] = "\uE7FF";
    // U+E800  Center (Caltabiano)
    Glyphs["pictCenter3"] = "\uE800";
    // U+E748  Chain rattle
    Glyphs["pictChainRattle"] = "\uE748";
    // U+E6C2  Chimes
    Glyphs["pictChimes"] = "\uE6C2";
    // U+E726  Chinese cymbal
    Glyphs["pictChineseCymbal"] = "\uE726";
    // U+E805  Choke (Weinberg)
    Glyphs["pictChokeCymbal"] = "\uE805";
    // U+E6F2  Claves
    Glyphs["pictClaves"] = "\uE6F2";
    // U+E7E7  Coins
    Glyphs["pictCoins"] = "\uE7E7";
    // U+E6DE  Conga
    Glyphs["pictConga"] = "\uE6DE";
    // U+E711  Cow bell
    Glyphs["pictCowBell"] = "\uE711";
    // U+E720  Crash cymbals
    Glyphs["pictCrashCymbals"] = "\uE720";
    // U+E6AE  Crotales
    Glyphs["pictCrotales"] = "\uE6AE";
    // U+E80C  Combining crush for stem
    Glyphs["pictCrushStem"] = "\uE80C";
    // U+E6E4  Cuica
    Glyphs["pictCuica"] = "\uE6E4";
    // U+E728  Cymbal tongs
    Glyphs["pictCymbalTongs"] = "\uE728";
    // U+E7F9  Damp
    Glyphs["pictDamp1"] = "\uE7F9";
    // U+E7FA  Damp 2
    Glyphs["pictDamp2"] = "\uE7FA";
    // U+E7FB  Damp 3
    Glyphs["pictDamp3"] = "\uE7FB";
    // U+E7FC  Damp 4
    Glyphs["pictDamp4"] = "\uE7FC";
    // U+E80D  Combining X for stem (dead note)
    Glyphs["pictDeadNoteStem"] = "\uE80D";
    // U+E7E8  Drum stick
    Glyphs["pictDrumStick"] = "\uE7E8";
    // U+E757  Duck call
    Glyphs["pictDuckCall"] = "\uE757";
    // U+E729  Edge of cymbal
    Glyphs["pictEdgeOfCymbal"] = "\uE729";
    // U+E6A9  Empty trapezoid
    Glyphs["pictEmptyTrap"] = "\uE6A9";
    // U+E727  Finger cymbals
    Glyphs["pictFingerCymbals"] = "\uE727";
    // U+E740  Flexatone
    Glyphs["pictFlexatone"] = "\uE740";
    // U+E6F5  Football rattle
    Glyphs["pictFootballRatchet"] = "\uE6F5";
    // U+E765  Glass harmonica
    Glyphs["pictGlassHarmonica"] = "\uE765";
    // U+E764  Glass harp
    Glyphs["pictGlassHarp"] = "\uE764";
    // U+E6C6  Glass plate chimes
    Glyphs["pictGlassPlateChimes"] = "\uE6C6";
    // U+E6C5  Glass tube chimes
    Glyphs["pictGlassTubeChimes"] = "\uE6C5";
    // U+E6A0  Glockenspiel
    Glyphs["pictGlsp"] = "\uE6A0";
    // U+E6AA  Glockenspiel (Smith Brindle)
    Glyphs["pictGlspSmithBrindle"] = "\uE6AA";
    // U+E6E2  Goblet drum (djembe, dumbek)
    Glyphs["pictGobletDrum"] = "\uE6E2";
    // U+E732  Gong
    Glyphs["pictGong"] = "\uE732";
    // U+E733  Gong with button (nipple)
    Glyphs["pictGongWithButton"] = "\uE733";
    // U+E6F3  Guiro
    Glyphs["pictGuiro"] = "\uE6F3";
    // U+E7C4  Hard gum beater, down
    Glyphs["pictGumHardDown"] = "\uE7C4";
    // U+E7C6  Hard gum beater, left
    Glyphs["pictGumHardLeft"] = "\uE7C6";
    // U+E7C5  Hard gum beater, right
    Glyphs["pictGumHardRight"] = "\uE7C5";
    // U+E7C3  Hard gum beater, up
    Glyphs["pictGumHardUp"] = "\uE7C3";
    // U+E7C0  Medium gum beater, down
    Glyphs["pictGumMediumDown"] = "\uE7C0";
    // U+E7C2  Medium gum beater, left
    Glyphs["pictGumMediumLeft"] = "\uE7C2";
    // U+E7C1  Medium gum beater, right
    Glyphs["pictGumMediumRight"] = "\uE7C1";
    // U+E7BF  Medium gum beater, up
    Glyphs["pictGumMediumUp"] = "\uE7BF";
    // U+E7BC  Soft gum beater, down
    Glyphs["pictGumSoftDown"] = "\uE7BC";
    // U+E7BE  Soft gum beater, left
    Glyphs["pictGumSoftLeft"] = "\uE7BE";
    // U+E7BD  Soft gum beater, right
    Glyphs["pictGumSoftRight"] = "\uE7BD";
    // U+E7BB  Soft gum beater, up
    Glyphs["pictGumSoftUp"] = "\uE7BB";
    // U+E7F6  Half-open
    Glyphs["pictHalfOpen1"] = "\uE7F6";
    // U+E7F7  Half-open 2 (Weinberg)
    Glyphs["pictHalfOpen2"] = "\uE7F7";
    // U+E715  Handbell
    Glyphs["pictHandbell"] = "\uE715";
    // U+E722  Hi-hat
    Glyphs["pictHiHat"] = "\uE722";
    // U+E723  Hi-hat cymbals on stand
    Glyphs["pictHiHatOnStand"] = "\uE723";
    // U+E767  Jaw harp
    Glyphs["pictJawHarp"] = "\uE767";
    // U+E719  Jingle bells
    Glyphs["pictJingleBells"] = "\uE719";
    // U+E756  Klaxon horn
    Glyphs["pictKlaxonHorn"] = "\uE756";
    // U+E807  Right hand (Agostini)
    Glyphs["pictLeftHandCircle"] = "\uE807";
    // U+E763  Lion's roar
    Glyphs["pictLionsRoar"] = "\uE763";
    // U+E6B1  Lithophone
    Glyphs["pictLithophone"] = "\uE6B1";
    // U+E6DF  Log drum
    Glyphs["pictLogDrum"] = "\uE6DF";
    // U+E75A  Lotus flute
    Glyphs["pictLotusFlute"] = "\uE75A";
    // U+E6A6  Marimba
    Glyphs["pictMar"] = "\uE6A6";
    // U+E6AC  Marimba (Smith Brindle)
    Glyphs["pictMarSmithBrindle"] = "\uE6AC";
    // U+E741  Maraca
    Glyphs["pictMaraca"] = "\uE741";
    // U+E742  Maracas
    Glyphs["pictMaracas"] = "\uE742";
    // U+E759  Megaphone
    Glyphs["pictMegaphone"] = "\uE759";
    // U+E6C8  Metal plate chimes
    Glyphs["pictMetalPlateChimes"] = "\uE6C8";
    // U+E6C7  Metal tube chimes
    Glyphs["pictMetalTubeChimes"] = "\uE6C7";
    // U+E766  Musical saw
    Glyphs["pictMusicalSaw"] = "\uE766";
    // U+E804  Normal position (Caltabiano)
    Glyphs["pictNormalPosition"] = "\uE804";
    // U+E7F4  On rim
    Glyphs["pictOnRim"] = "\uE7F4";
    // U+E7F8  Open
    Glyphs["pictOpen"] = "\uE7F8";
    // U+E7F5  Closed / rim shot
    Glyphs["pictOpenRimShot"] = "\uE7F5";
    // U+E760  Pistol shot
    Glyphs["pictPistolShot"] = "\uE760";
    // U+E752  Police whistle
    Glyphs["pictPoliceWhistle"] = "\uE752";
    // U+E6FA  Quijada (jawbone)
    Glyphs["pictQuijada"] = "\uE6FA";
    // U+E747  Rainstick
    Glyphs["pictRainstick"] = "\uE747";
    // U+E6F4  Ratchet
    Glyphs["pictRatchet"] = "\uE6F4";
    // U+E6FC  Reco-reco
    Glyphs["pictRecoReco"] = "\uE6FC";
    // U+E806  Left hand (Agostini)
    Glyphs["pictRightHandSquare"] = "\uE806";
    // U+E801  Rim or edge (Weinberg)
    Glyphs["pictRim1"] = "\uE801";
    // U+E802  Rim (Ghent)
    Glyphs["pictRim2"] = "\uE802";
    // U+E803  Rim (Caltabiano)
    Glyphs["pictRim3"] = "\uE803";
    // U+E7FD  Rim shot for stem
    Glyphs["pictRimShotOnStem"] = "\uE7FD";
    // U+E762  Sandpaper blocks
    Glyphs["pictSandpaperBlocks"] = "\uE762";
    // U+E7F3  Scrape around rim (counter-clockwise)
    Glyphs["pictScrapeAroundRim"] = "\uE7F3";
    // U+E80E  Scrape around rim (clockwise)
    Glyphs["pictScrapeAroundRimClockwise"] = "\uE80E";
    // U+E7F1  Scrape from center to edge
    Glyphs["pictScrapeCenterToEdge"] = "\uE7F1";
    // U+E7F2  Scrape from edge to center
    Glyphs["pictScrapeEdgeToCenter"] = "\uE7F2";
    // U+E718  Shell bells
    Glyphs["pictShellBells"] = "\uE718";
    // U+E6C4  Shell chimes
    Glyphs["pictShellChimes"] = "\uE6C4";
    // U+E753  Siren
    Glyphs["pictSiren"] = "\uE753";
    // U+E746  Sistrum
    Glyphs["pictSistrum"] = "\uE746";
    // U+E724  Sizzle cymbal
    Glyphs["pictSizzleCymbal"] = "\uE724";
    // U+E710  Sleigh bell
    Glyphs["pictSleighBell"] = "\uE710";
    // U+E734  Slide brush on gong
    Glyphs["pictSlideBrushOnGong"] = "\uE734";
    // U+E750  Slide whistle
    Glyphs["pictSlideWhistle"] = "\uE750";
    // U+E6E0  Slit drum
    Glyphs["pictSlitDrum"] = "\uE6E0";
    // U+E6D1  Snare drum
    Glyphs["pictSnareDrum"] = "\uE6D1";
    // U+E6D3  Military snare drum
    Glyphs["pictSnareDrumMilitary"] = "\uE6D3";
    // U+E6D2  Snare drum, snares off
    Glyphs["pictSnareDrumSnaresOff"] = "\uE6D2";
    // U+E6AF  Steel drums
    Glyphs["pictSteelDrums"] = "\uE6AF";
    // U+E7F0  Stick shot
    Glyphs["pictStickShot"] = "\uE7F0";
    // U+E7B2  Superball
    Glyphs["pictSuperball"] = "\uE7B2";
    // U+E721  Suspended cymbal
    Glyphs["pictSuspendedCymbal"] = "\uE721";
    // U+E808  Combining swish for stem
    Glyphs["pictSwishStem"] = "\uE808";
    // U+E6E3  Indian tabla
    Glyphs["pictTabla"] = "\uE6E3";
    // U+E730  Tam-tam
    Glyphs["pictTamTam"] = "\uE730";
    // U+E731  Tam-tam with beater (Smith Brindle)
    Glyphs["pictTamTamWithBeater"] = "\uE731";
    // U+E6DB  Tambourine
    Glyphs["pictTambourine"] = "\uE6DB";
    // U+E6F1  Temple blocks
    Glyphs["pictTempleBlocks"] = "\uE6F1";
    // U+E6D6  Tenor drum
    Glyphs["pictTenorDrum"] = "\uE6D6";
    // U+E744  Thundersheet
    Glyphs["pictThundersheet"] = "\uE744";
    // U+E6DC  Timbales
    Glyphs["pictTimbales"] = "\uE6DC";
    // U+E6D0  Timpani
    Glyphs["pictTimpani"] = "\uE6D0";
    // U+E6D7  Tom-tom
    Glyphs["pictTomTom"] = "\uE6D7";
    // U+E6D8  Chinese tom-tom
    Glyphs["pictTomTomChinese"] = "\uE6D8";
    // U+E6DA  Indo-American tom tom
    Glyphs["pictTomTomIndoAmerican"] = "\uE6DA";
    // U+E6D9  Japanese tom-tom
    Glyphs["pictTomTomJapanese"] = "\uE6D9";
    // U+E700  Triangle
    Glyphs["pictTriangle"] = "\uE700";
    // U+E6B2  Tubaphone
    Glyphs["pictTubaphone"] = "\uE6B2";
    // U+E6C0  Tubular bells
    Glyphs["pictTubularBells"] = "\uE6C0";
    // U+E80A  Combining turn left for stem
    Glyphs["pictTurnLeftStem"] = "\uE80A";
    // U+E80B  Combining turn left or right for stem
    Glyphs["pictTurnRightLeftStem"] = "\uE80B";
    // U+E809  Combining turn right for stem
    Glyphs["pictTurnRightStem"] = "\uE809";
    // U+E6A7  Vibraphone
    Glyphs["pictVib"] = "\uE6A7";
    // U+E6A8  Metallophone (vibraphone motor off)
    Glyphs["pictVibMotorOff"] = "\uE6A8";
    // U+E6AD  Vibraphone (Smith Brindle)
    Glyphs["pictVibSmithBrindle"] = "\uE6AD";
    // U+E745  Vibraslap
    Glyphs["pictVibraslap"] = "\uE745";
    // U+E725  Vietnamese hat cymbal
    Glyphs["pictVietnameseHat"] = "\uE725";
    // U+E6F6  Whip
    Glyphs["pictWhip"] = "\uE6F6";
    // U+E6C1  Wind chimes (glass)
    Glyphs["pictWindChimesGlass"] = "\uE6C1";
    // U+E754  Wind machine
    Glyphs["pictWindMachine"] = "\uE754";
    // U+E758  Wind whistle (or mouth siren)
    Glyphs["pictWindWhistle"] = "\uE758";
    // U+E6F0  Wood block
    Glyphs["pictWoodBlock"] = "\uE6F0";
    // U+E7B4  Wound beater, hard core down
    Glyphs["pictWoundHardDown"] = "\uE7B4";
    // U+E7B6  Wound beater, hard core left
    Glyphs["pictWoundHardLeft"] = "\uE7B6";
    // U+E7B5  Wound beater, hard core right
    Glyphs["pictWoundHardRight"] = "\uE7B5";
    // U+E7B3  Wound beater, hard core up
    Glyphs["pictWoundHardUp"] = "\uE7B3";
    // U+E7B8  Wound beater, soft core down
    Glyphs["pictWoundSoftDown"] = "\uE7B8";
    // U+E7BA  Wound beater, soft core left
    Glyphs["pictWoundSoftLeft"] = "\uE7BA";
    // U+E7B9  Wound beater, soft core right
    Glyphs["pictWoundSoftRight"] = "\uE7B9";
    // U+E7B7  Wound beater, soft core up
    Glyphs["pictWoundSoftUp"] = "\uE7B7";
    // U+E6A1  Xylophone
    Glyphs["pictXyl"] = "\uE6A1";
    // U+E6A3  Bass xylophone
    Glyphs["pictXylBass"] = "\uE6A3";
    // U+E6AB  Xylophone (Smith Brindle)
    Glyphs["pictXylSmithBrindle"] = "\uE6AB";
    // U+E6A2  Tenor xylophone
    Glyphs["pictXylTenor"] = "\uE6A2";
    // U+E6A5  Trough tenor xylophone
    Glyphs["pictXylTenorTrough"] = "\uE6A5";
    // U+E6A4  Trough xylophone
    Glyphs["pictXylTrough"] = "\uE6A4";
    // U+E632  Buzz pizzicato
    Glyphs["pluckedBuzzPizzicato"] = "\uE632";
    // U+E638  Damp
    Glyphs["pluckedDamp"] = "\uE638";
    // U+E639  Damp all
    Glyphs["pluckedDampAll"] = "\uE639";
    // U+E63B  Damp for stem
    Glyphs["pluckedDampOnStem"] = "\uE63B";
    // U+E637  Fingernail flick
    Glyphs["pluckedFingernailFlick"] = "\uE637";
    // U+E633  Left-hand pizzicato
    Glyphs["pluckedLeftHandPizzicato"] = "\uE633";
    // U+E63A  Plectrum
    Glyphs["pluckedPlectrum"] = "\uE63A";
    // U+E631  Snap pizzicato above
    Glyphs["pluckedSnapPizzicatoAbove"] = "\uE631";
    // U+E630  Snap pizzicato below
    Glyphs["pluckedSnapPizzicatoBelow"] = "\uE630";
    // U+E636  With fingernails
    Glyphs["pluckedWithFingernails"] = "\uE636";
    // U+E514  Quindicesima
    Glyphs["quindicesima"] = "\uE514";
    // U+E515  Quindicesima alta
    Glyphs["quindicesimaAlta"] = "\uE515";
    // U+E516  Quindicesima bassa
    Glyphs["quindicesimaBassa"] = "\uE516";
    // U+E51D  Quindicesima bassa (mb)
    Glyphs["quindicesimaBassaMb"] = "\uE51D";
    // U+E500  Repeat last bar
    Glyphs["repeat1Bar"] = "\uE500";
    // U+E501  Repeat last two bars
    Glyphs["repeat2Bars"] = "\uE501";
    // U+E502  Repeat last four bars
    Glyphs["repeat4Bars"] = "\uE502";
    // U+E505  Repeat bar lower dot
    Glyphs["repeatBarLowerDot"] = "\uE505";
    // U+E504  Repeat bar slash
    Glyphs["repeatBarSlash"] = "\uE504";
    // U+E503  Repeat bar upper dot
    Glyphs["repeatBarUpperDot"] = "\uE503";
    // U+E044  Single repeat dot
    Glyphs["repeatDot"] = "\uE044";
    // U+E043  Repeat dots
    Glyphs["repeatDots"] = "\uE043";
    // U+E040  Left (start) repeat sign
    Glyphs["repeatLeft"] = "\uE040";
    // U+E041  Right (end) repeat sign
    Glyphs["repeatRight"] = "\uE041";
    // U+E042  Right and left repeat sign
    Glyphs["repeatRightLeft"] = "\uE042";
    // U+E4ED  1024th rest
    Glyphs["rest1024th"] = "\uE4ED";
    // U+E4EA  128th (semihemidemisemiquaver) rest
    Glyphs["rest128th"] = "\uE4EA";
    // U+E4E7  16th (semiquaver) rest
    Glyphs["rest16th"] = "\uE4E7";
    // U+E4EB  256th rest
    Glyphs["rest256th"] = "\uE4EB";
    // U+E4E8  32nd (demisemiquaver) rest
    Glyphs["rest32nd"] = "\uE4E8";
    // U+E4EC  512th rest
    Glyphs["rest512th"] = "\uE4EC";
    // U+E4E9  64th (hemidemisemiquaver) rest
    Glyphs["rest64th"] = "\uE4E9";
    // U+E4E6  Eighth (quaver) rest
    Glyphs["rest8th"] = "\uE4E6";
    // U+E4E2  Double whole (breve) rest
    Glyphs["restDoubleWhole"] = "\uE4E2";
    // U+E4F3  Double whole rest on leger lines
    Glyphs["restDoubleWholeLegerLine"] = "\uE4F3";
    // U+E4EE  Multiple measure rest
    Glyphs["restHBar"] = "\uE4EE";
    // U+E4EF  H-bar, left half
    Glyphs["restHBarLeft"] = "\uE4EF";
    // U+E4F0  H-bar, middle
    Glyphs["restHBarMiddle"] = "\uE4F0";
    // U+E4F1  H-bar, right half
    Glyphs["restHBarRight"] = "\uE4F1";
    // U+E4E4  Half (minim) rest
    Glyphs["restHalf"] = "\uE4E4";
    // U+E4F5  Half rest on leger line
    Glyphs["restHalfLegerLine"] = "\uE4F5";
    // U+E4E1  Longa rest
    Glyphs["restLonga"] = "\uE4E1";
    // U+E4E0  Maxima rest
    Glyphs["restMaxima"] = "\uE4E0";
    // U+E4E5  Quarter (crotchet) rest
    Glyphs["restQuarter"] = "\uE4E5";
    // U+E4F2  Old-style quarter (crotchet) rest
    Glyphs["restQuarterOld"] = "\uE4F2";
    // U+E4F6  Z-style quarter (crotchet) rest
    Glyphs["restQuarterZ"] = "\uE4F6";
    // U+E4E3  Whole (semibreve) rest
    Glyphs["restWhole"] = "\uE4E3";
    // U+E4F4  Whole rest on leger line
    Glyphs["restWholeLegerLine"] = "\uE4F4";
    // U+E001  Reversed brace
    Glyphs["reversedBrace"] = "\uE001";
    // U+E006  Reversed bracket bottom
    Glyphs["reversedBracketBottom"] = "\uE006";
    // U+E005  Reversed bracket top
    Glyphs["reversedBracketTop"] = "\uE005";
    // U+E04D  Right repeat sign within bar
    Glyphs["rightRepeatSmall"] = "\uE04D";
    // U+EF00  Scale degree 1
    Glyphs["scaleDegree1"] = "\uEF00";
    // U+EF01  Scale degree 2
    Glyphs["scaleDegree2"] = "\uEF01";
    // U+EF02  Scale degree 3
    Glyphs["scaleDegree3"] = "\uEF02";
    // U+EF03  Scale degree 4
    Glyphs["scaleDegree4"] = "\uEF03";
    // U+EF04  Scale degree 5
    Glyphs["scaleDegree5"] = "\uEF04";
    // U+EF05  Scale degree 6
    Glyphs["scaleDegree6"] = "\uEF05";
    // U+EF06  Scale degree 7
    Glyphs["scaleDegree7"] = "\uEF06";
    // U+EF07  Scale degree 8
    Glyphs["scaleDegree8"] = "\uEF07";
    // U+EF08  Scale degree 9
    Glyphs["scaleDegree9"] = "\uEF08";
    // U+E06F  Schffer clef
    Glyphs["schaefferClef"] = "\uE06F";
    // U+E072  Schffer F clef to G clef change
    Glyphs["schaefferFClefToGClef"] = "\uE072";
    // U+E071  Schffer G clef to F clef change
    Glyphs["schaefferGClefToFClef"] = "\uE071";
    // U+E070  Schffer previous clef
    Glyphs["schaefferPreviousClef"] = "\uE070";
    // U+E047  Segno
    Glyphs["segno"] = "\uE047";
    // U+E04A  Segno (serpent)
    Glyphs["segnoSerpent1"] = "\uE04A";
    // U+E04B  Segno (serpent with vertical lines)
    Glyphs["segnoSerpent2"] = "\uE04B";
    // U+E06B  Semi-pitched percussion clef 1
    Glyphs["semipitchedPercussionClef1"] = "\uE06B";
    // U+E06C  Semi-pitched percussion clef 2
    Glyphs["semipitchedPercussionClef2"] = "\uE06C";
    // U+EC52  Flat
    Glyphs["smnFlat"] = "\uEC52";
    // U+EC53  Flat (white)
    Glyphs["smnFlatWhite"] = "\uEC53";
    // U+EC57  Double flat history sign
    Glyphs["smnHistoryDoubleFlat"] = "\uEC57";
    // U+EC55  Double sharp history sign
    Glyphs["smnHistoryDoubleSharp"] = "\uEC55";
    // U+EC56  Flat history sign
    Glyphs["smnHistoryFlat"] = "\uEC56";
    // U+EC54  Sharp history sign
    Glyphs["smnHistorySharp"] = "\uEC54";
    // U+EC58  Natural (N)
    Glyphs["smnNatural"] = "\uEC58";
    // U+EC50  Sharp stem up
    Glyphs["smnSharp"] = "\uEC50";
    // U+EC59  Sharp stem down
    Glyphs["smnSharpDown"] = "\uEC59";
    // U+EC51  Sharp (white) stem up
    Glyphs["smnSharpWhite"] = "\uEC51";
    // U+EC5A  Sharp (white) stem down
    Glyphs["smnSharpWhiteDown"] = "\uEC5A";
    // U+E00A  Split bar divider (bar spans a system break)
    Glyphs["splitBarDivider"] = "\uE00A";
    // U+E010  1-line staff
    Glyphs["staff1Line"] = "\uE010";
    // U+E01C  1-line staff (narrow)
    Glyphs["staff1LineNarrow"] = "\uE01C";
    // U+E016  1-line staff (wide)
    Glyphs["staff1LineWide"] = "\uE016";
    // U+E011  2-line staff
    Glyphs["staff2Lines"] = "\uE011";
    // U+E01D  2-line staff (narrow)
    Glyphs["staff2LinesNarrow"] = "\uE01D";
    // U+E017  2-line staff (wide)
    Glyphs["staff2LinesWide"] = "\uE017";
    // U+E012  3-line staff
    Glyphs["staff3Lines"] = "\uE012";
    // U+E01E  3-line staff (narrow)
    Glyphs["staff3LinesNarrow"] = "\uE01E";
    // U+E018  3-line staff (wide)
    Glyphs["staff3LinesWide"] = "\uE018";
    // U+E013  4-line staff
    Glyphs["staff4Lines"] = "\uE013";
    // U+E01F  4-line staff (narrow)
    Glyphs["staff4LinesNarrow"] = "\uE01F";
    // U+E019  4-line staff (wide)
    Glyphs["staff4LinesWide"] = "\uE019";
    // U+E014  5-line staff
    Glyphs["staff5Lines"] = "\uE014";
    // U+E020  5-line staff (narrow)
    Glyphs["staff5LinesNarrow"] = "\uE020";
    // U+E01A  5-line staff (wide)
    Glyphs["staff5LinesWide"] = "\uE01A";
    // U+E015  6-line staff
    Glyphs["staff6Lines"] = "\uE015";
    // U+E021  6-line staff (narrow)
    Glyphs["staff6LinesNarrow"] = "\uE021";
    // U+E01B  6-line staff (wide)
    Glyphs["staff6LinesWide"] = "\uE01B";
    // U+E00B  Staff divide arrow down
    Glyphs["staffDivideArrowDown"] = "\uE00B";
    // U+E00C  Staff divide arrow up
    Glyphs["staffDivideArrowUp"] = "\uE00C";
    // U+E00D  Staff divide arrows
    Glyphs["staffDivideArrowUpDown"] = "\uE00D";
    // U+EB98  Lower 1 staff position
    Glyphs["staffPosLower1"] = "\uEB98";
    // U+EB99  Lower 2 staff positions
    Glyphs["staffPosLower2"] = "\uEB99";
    // U+EB9A  Lower 3 staff positions
    Glyphs["staffPosLower3"] = "\uEB9A";
    // U+EB9B  Lower 4 staff positions
    Glyphs["staffPosLower4"] = "\uEB9B";
    // U+EB9C  Lower 5 staff positions
    Glyphs["staffPosLower5"] = "\uEB9C";
    // U+EB9D  Lower 6 staff positions
    Glyphs["staffPosLower6"] = "\uEB9D";
    // U+EB9E  Lower 7 staff positions
    Glyphs["staffPosLower7"] = "\uEB9E";
    // U+EB9F  Lower 8 staff positions
    Glyphs["staffPosLower8"] = "\uEB9F";
    // U+EB90  Raise 1 staff position
    Glyphs["staffPosRaise1"] = "\uEB90";
    // U+EB91  Raise 2 staff positions
    Glyphs["staffPosRaise2"] = "\uEB91";
    // U+EB92  Raise 3 staff positions
    Glyphs["staffPosRaise3"] = "\uEB92";
    // U+EB93  Raise 4 staff positions
    Glyphs["staffPosRaise4"] = "\uEB93";
    // U+EB94  Raise 5 staff positions
    Glyphs["staffPosRaise5"] = "\uEB94";
    // U+EB95  Raise 6 staff positions
    Glyphs["staffPosRaise6"] = "\uEB95";
    // U+EB96  Raise 7 staff positions
    Glyphs["staffPosRaise7"] = "\uEB96";
    // U+EB97  Raise 8 staff positions
    Glyphs["staffPosRaise8"] = "\uEB97";
    // U+E210  Combining stem
    Glyphs["stem"] = "\uE210";
    // U+E215  Combining bow on bridge stem
    Glyphs["stemBowOnBridge"] = "\uE215";
    // U+E216  Combining bow on tailpiece stem
    Glyphs["stemBowOnTailpiece"] = "\uE216";
    // U+E217  Combining buzz roll stem
    Glyphs["stemBuzzRoll"] = "\uE217";
    // U+E218  Combining damp stem
    Glyphs["stemDamp"] = "\uE218";
    // U+E21F  Combining harp string noise stem
    Glyphs["stemHarpStringNoise"] = "\uE21F";
    // U+E21A  Combining multiphonics (black) stem
    Glyphs["stemMultiphonicsBlack"] = "\uE21A";
    // U+E21C  Combining multiphonics (black and white) stem
    Glyphs["stemMultiphonicsBlackWhite"] = "\uE21C";
    // U+E21B  Combining multiphonics (white) stem
    Glyphs["stemMultiphonicsWhite"] = "\uE21B";
    // U+E213  Combining Penderecki unmeasured tremolo stem
    Glyphs["stemPendereckiTremolo"] = "\uE213";
    // U+E21E  Combining rim shot stem
    Glyphs["stemRimShot"] = "\uE21E";
    // U+E211  Combining sprechgesang stem
    Glyphs["stemSprechgesang"] = "\uE211";
    // U+E214  Combining sul ponticello (bow behind bridge) stem
    Glyphs["stemSulPonticello"] = "\uE214";
    // U+E21D  Combining sussurando stem
    Glyphs["stemSussurando"] = "\uE21D";
    // U+E212  Combining swished stem
    Glyphs["stemSwished"] = "\uE212";
    // U+E219  Combining vibrato pulse accent (Saunders) stem
    Glyphs["stemVibratoPulse"] = "\uE219";
    // U+E232  Stockhausen irregular tremolo ("Morsen", like Morse code)
    Glyphs["stockhausenTremolo"] = "\uE232";
    // U+E618  Bow behind bridge (sul ponticello)
    Glyphs["stringsBowBehindBridge"] = "\uE618";
    // U+E62A  Bow behind bridge on four strings
    Glyphs["stringsBowBehindBridgeFourStrings"] = "\uE62A";
    // U+E627  Bow behind bridge on one string
    Glyphs["stringsBowBehindBridgeOneString"] = "\uE627";
    // U+E629  Bow behind bridge on three strings
    Glyphs["stringsBowBehindBridgeThreeStrings"] = "\uE629";
    // U+E628  Bow behind bridge on two strings
    Glyphs["stringsBowBehindBridgeTwoStrings"] = "\uE628";
    // U+E619  Bow on top of bridge
    Glyphs["stringsBowOnBridge"] = "\uE619";
    // U+E61A  Bow on tailpiece
    Glyphs["stringsBowOnTailpiece"] = "\uE61A";
    // U+E626  Change bow direction, indeterminate
    Glyphs["stringsChangeBowDirection"] = "\uE626";
    // U+E610  Down bow
    Glyphs["stringsDownBow"] = "\uE610";
    // U+EE82  Down bow, away from body
    Glyphs["stringsDownBowAwayFromBody"] = "\uEE82";
    // U+EE84  Down bow, beyond bridge
    Glyphs["stringsDownBowBeyondBridge"] = "\uEE84";
    // U+EE80  Down bow, towards body
    Glyphs["stringsDownBowTowardsBody"] = "\uEE80";
    // U+E611  Turned down bow
    Glyphs["stringsDownBowTurned"] = "\uE611";
    // U+E622  Fouett
    Glyphs["stringsFouette"] = "\uE622";
    // U+E615  Half-harmonic
    Glyphs["stringsHalfHarmonic"] = "\uE615";
    // U+E614  Harmonic
    Glyphs["stringsHarmonic"] = "\uE614";
    // U+E620  Jet (gettato) above
    Glyphs["stringsJeteAbove"] = "\uE620";
    // U+E621  Jet (gettato) below
    Glyphs["stringsJeteBelow"] = "\uE621";
    // U+E617  Mute off
    Glyphs["stringsMuteOff"] = "\uE617";
    // U+E616  Mute on
    Glyphs["stringsMuteOn"] = "\uE616";
    // U+E61B  Overpressure, down bow
    Glyphs["stringsOverpressureDownBow"] = "\uE61B";
    // U+E61F  Overpressure, no bow direction
    Glyphs["stringsOverpressureNoDirection"] = "\uE61F";
    // U+E61D  Overpressure possibile, down bow
    Glyphs["stringsOverpressurePossibileDownBow"] = "\uE61D";
    // U+E61E  Overpressure possibile, up bow
    Glyphs["stringsOverpressurePossibileUpBow"] = "\uE61E";
    // U+E61C  Overpressure, up bow
    Glyphs["stringsOverpressureUpBow"] = "\uE61C";
    // U+EE88  Scrape, circular clockwise
    Glyphs["stringsScrapeCircularClockwise"] = "\uEE88";
    // U+EE89  Scrape, circular counter-clockwise
    Glyphs["stringsScrapeCircularCounterclockwise"] = "\uEE89";
    // U+EE86  Scrape, parallel inward
    Glyphs["stringsScrapeParallelInward"] = "\uEE86";
    // U+EE87  Scrape, parallel outward
    Glyphs["stringsScrapeParallelOutward"] = "\uEE87";
    // U+E624  Thumb position
    Glyphs["stringsThumbPosition"] = "\uE624";
    // U+E625  Turned thumb position
    Glyphs["stringsThumbPositionTurned"] = "\uE625";
    // U+EE8A  Triple chop, inward
    Glyphs["stringsTripleChopInward"] = "\uEE8A";
    // U+EE8B  Triple chop, outward
    Glyphs["stringsTripleChopOutward"] = "\uEE8B";
    // U+E612  Up bow
    Glyphs["stringsUpBow"] = "\uE612";
    // U+EE83  Up bow, away from body
    Glyphs["stringsUpBowAwayFromBody"] = "\uEE83";
    // U+EE85  Up bow, beyond bridge
    Glyphs["stringsUpBowBeyondBridge"] = "\uEE85";
    // U+EE81  Up bow, towards body
    Glyphs["stringsUpBowTowardsBody"] = "\uEE81";
    // U+E613  Turned up bow
    Glyphs["stringsUpBowTurned"] = "\uE613";
    // U+E623  Vibrato pulse accent (Saunders) for stem
    Glyphs["stringsVibratoPulse"] = "\uE623";
    // U+EE72  Swiss rudiments doubl black notehead
    Glyphs["swissRudimentsNoteheadBlackDouble"] = "\uEE72";
    // U+EE70  Swiss rudiments flam black notehead
    Glyphs["swissRudimentsNoteheadBlackFlam"] = "\uEE70";
    // U+EE73  Swiss rudiments doubl half (minim) notehead
    Glyphs["swissRudimentsNoteheadHalfDouble"] = "\uEE73";
    // U+EE71  Swiss rudiments flam half (minim) notehead
    Glyphs["swissRudimentsNoteheadHalfFlam"] = "\uEE71";
    // U+E007  System divider
    Glyphs["systemDivider"] = "\uE007";
    // U+E009  Extra long system divider
    Glyphs["systemDividerExtraLong"] = "\uE009";
    // U+E008  Long system divider
    Glyphs["systemDividerLong"] = "\uE008";
    // U+E1FC  Augmentation dot
    Glyphs["textAugmentationDot"] = "\uE1FC";
    // U+E1F5  Black note, fractional 16th beam, long stem
    Glyphs["textBlackNoteFrac16thLongStem"] = "\uE1F5";
    // U+E1F4  Black note, fractional 16th beam, short stem
    Glyphs["textBlackNoteFrac16thShortStem"] = "\uE1F4";
    // U+E1F6  Black note, fractional 32nd beam, long stem
    Glyphs["textBlackNoteFrac32ndLongStem"] = "\uE1F6";
    // U+E1F3  Black note, fractional 8th beam, long stem
    Glyphs["textBlackNoteFrac8thLongStem"] = "\uE1F3";
    // U+E1F2  Black note, fractional 8th beam, short stem
    Glyphs["textBlackNoteFrac8thShortStem"] = "\uE1F2";
    // U+E1F1  Black note, long stem
    Glyphs["textBlackNoteLongStem"] = "\uE1F1";
    // U+E1F0  Black note, short stem
    Glyphs["textBlackNoteShortStem"] = "\uE1F0";
    // U+E1FA  Continuing 16th beam for long stem
    Glyphs["textCont16thBeamLongStem"] = "\uE1FA";
    // U+E1F9  Continuing 16th beam for short stem
    Glyphs["textCont16thBeamShortStem"] = "\uE1F9";
    // U+E1FB  Continuing 32nd beam for long stem
    Glyphs["textCont32ndBeamLongStem"] = "\uE1FB";
    // U+E1F8  Continuing 8th beam for long stem
    Glyphs["textCont8thBeamLongStem"] = "\uE1F8";
    // U+E1F7  Continuing 8th beam for short stem
    Glyphs["textCont8thBeamShortStem"] = "\uE1F7";
    // U+E209  Headless black note, fractional 16th beam, long stem
    Glyphs["textHeadlessBlackNoteFrac16thLongStem"] = "\uE209";
    // U+E208  Headless black note, fractional 16th beam, short stem
    Glyphs["textHeadlessBlackNoteFrac16thShortStem"] = "\uE208";
    // U+E20A  Headless black note, fractional 32nd beam, long stem
    Glyphs["textHeadlessBlackNoteFrac32ndLongStem"] = "\uE20A";
    // U+E207  Headless black note, fractional 8th beam, long stem
    Glyphs["textHeadlessBlackNoteFrac8thLongStem"] = "\uE207";
    // U+E206  Headless black note, fractional 8th beam, short stem
    Glyphs["textHeadlessBlackNoteFrac8thShortStem"] = "\uE206";
    // U+E205  Headless black note, long stem
    Glyphs["textHeadlessBlackNoteLongStem"] = "\uE205";
    // U+E204  Headless black note, short stem
    Glyphs["textHeadlessBlackNoteShortStem"] = "\uE204";
    // U+E1FD  Tie
    Glyphs["textTie"] = "\uE1FD";
    // U+E202  Tuplet number 3 for long stem
    Glyphs["textTuplet3LongStem"] = "\uE202";
    // U+E1FF  Tuplet number 3 for short stem
    Glyphs["textTuplet3ShortStem"] = "\uE1FF";
    // U+E203  Tuplet bracket end for long stem
    Glyphs["textTupletBracketEndLongStem"] = "\uE203";
    // U+E200  Tuplet bracket end for short stem
    Glyphs["textTupletBracketEndShortStem"] = "\uE200";
    // U+E201  Tuplet bracket start for long stem
    Glyphs["textTupletBracketStartLongStem"] = "\uE201";
    // U+E1FE  Tuplet bracket start for short stem
    Glyphs["textTupletBracketStartShortStem"] = "\uE1FE";
    // U+E080  Time signature 0
    Glyphs["timeSig0"] = "\uE080";
    // U+ECF0  Reversed time signature 0
    Glyphs["timeSig0Reversed"] = "\uECF0";
    // U+ECE0  Turned time signature 0
    Glyphs["timeSig0Turned"] = "\uECE0";
    // U+E081  Time signature 1
    Glyphs["timeSig1"] = "\uE081";
    // U+ECF1  Reversed time signature 1
    Glyphs["timeSig1Reversed"] = "\uECF1";
    // U+ECE1  Turned time signature 1
    Glyphs["timeSig1Turned"] = "\uECE1";
    // U+E082  Time signature 2
    Glyphs["timeSig2"] = "\uE082";
    // U+ECF2  Reversed time signature 2
    Glyphs["timeSig2Reversed"] = "\uECF2";
    // U+ECE2  Turned time signature 2
    Glyphs["timeSig2Turned"] = "\uECE2";
    // U+E083  Time signature 3
    Glyphs["timeSig3"] = "\uE083";
    // U+ECF3  Reversed time signature 3
    Glyphs["timeSig3Reversed"] = "\uECF3";
    // U+ECE3  Turned time signature 3
    Glyphs["timeSig3Turned"] = "\uECE3";
    // U+E084  Time signature 4
    Glyphs["timeSig4"] = "\uE084";
    // U+ECF4  Reversed time signature 4
    Glyphs["timeSig4Reversed"] = "\uECF4";
    // U+ECE4  Turned time signature 4
    Glyphs["timeSig4Turned"] = "\uECE4";
    // U+E085  Time signature 5
    Glyphs["timeSig5"] = "\uE085";
    // U+ECF5  Reversed time signature 5
    Glyphs["timeSig5Reversed"] = "\uECF5";
    // U+ECE5  Turned time signature 5
    Glyphs["timeSig5Turned"] = "\uECE5";
    // U+E086  Time signature 6
    Glyphs["timeSig6"] = "\uE086";
    // U+ECF6  Reversed time signature 6
    Glyphs["timeSig6Reversed"] = "\uECF6";
    // U+ECE6  Turned time signature 6
    Glyphs["timeSig6Turned"] = "\uECE6";
    // U+E087  Time signature 7
    Glyphs["timeSig7"] = "\uE087";
    // U+ECF7  Reversed time signature 7
    Glyphs["timeSig7Reversed"] = "\uECF7";
    // U+ECE7  Turned time signature 7
    Glyphs["timeSig7Turned"] = "\uECE7";
    // U+E088  Time signature 8
    Glyphs["timeSig8"] = "\uE088";
    // U+ECF8  Reversed time signature 8
    Glyphs["timeSig8Reversed"] = "\uECF8";
    // U+ECE8  Turned time signature 8
    Glyphs["timeSig8Turned"] = "\uECE8";
    // U+E089  Time signature 9
    Glyphs["timeSig9"] = "\uE089";
    // U+ECF9  Reversed time signature 9
    Glyphs["timeSig9Reversed"] = "\uECF9";
    // U+ECE9  Turned time signature 9
    Glyphs["timeSig9Turned"] = "\uECE9";
    // U+EC80  Left bracket for whole time signature
    Glyphs["timeSigBracketLeft"] = "\uEC80";
    // U+EC82  Left bracket for numerator only
    Glyphs["timeSigBracketLeftSmall"] = "\uEC82";
    // U+EC81  Right bracket for whole time signature
    Glyphs["timeSigBracketRight"] = "\uEC81";
    // U+EC83  Right bracket for numerator only
    Glyphs["timeSigBracketRightSmall"] = "\uEC83";
    // U+E09F  Control character for denominator digit
    Glyphs["timeSigCombDenominator"] = "\uE09F";
    // U+E09E  Control character for numerator digit
    Glyphs["timeSigCombNumerator"] = "\uE09E";
    // U+E096  Time signature comma
    Glyphs["timeSigComma"] = "\uE096";
    // U+E08A  Common time
    Glyphs["timeSigCommon"] = "\uE08A";
    // U+ECFA  Reversed common time
    Glyphs["timeSigCommonReversed"] = "\uECFA";
    // U+ECEA  Turned common time
    Glyphs["timeSigCommonTurned"] = "\uECEA";
    // U+EC85  Cut time (Bach)
    Glyphs["timeSigCut2"] = "\uEC85";
    // U+EC86  Cut triple time (9/8)
    Glyphs["timeSigCut3"] = "\uEC86";
    // U+E08B  Cut time
    Glyphs["timeSigCutCommon"] = "\uE08B";
    // U+ECFB  Reversed cut time
    Glyphs["timeSigCutCommonReversed"] = "\uECFB";
    // U+ECEB  Turned cut time
    Glyphs["timeSigCutCommonTurned"] = "\uECEB";
    // U+E08F  Time signature equals
    Glyphs["timeSigEquals"] = "\uE08F";
    // U+E098  Time signature fraction 
    Glyphs["timeSigFractionHalf"] = "\uE098";
    // U+E09A  Time signature fraction 
    Glyphs["timeSigFractionOneThird"] = "\uE09A";
    // U+E097  Time signature fraction 
    Glyphs["timeSigFractionQuarter"] = "\uE097";
    // U+E099  Time signature fraction 
    Glyphs["timeSigFractionThreeQuarters"] = "\uE099";
    // U+E09B  Time signature fraction 
    Glyphs["timeSigFractionTwoThirds"] = "\uE09B";
    // U+E08E  Time signature fraction slash
    Glyphs["timeSigFractionalSlash"] = "\uE08E";
    // U+E090  Time signature minus
    Glyphs["timeSigMinus"] = "\uE090";
    // U+E091  Time signature multiply
    Glyphs["timeSigMultiply"] = "\uE091";
    // U+E09D  Open time signature (Penderecki)
    Glyphs["timeSigOpenPenderecki"] = "\uE09D";
    // U+E094  Left parenthesis for whole time signature
    Glyphs["timeSigParensLeft"] = "\uE094";
    // U+E092  Left parenthesis for numerator only
    Glyphs["timeSigParensLeftSmall"] = "\uE092";
    // U+E095  Right parenthesis for whole time signature
    Glyphs["timeSigParensRight"] = "\uE095";
    // U+E093  Right parenthesis for numerator only
    Glyphs["timeSigParensRightSmall"] = "\uE093";
    // U+E08C  Time signature +
    Glyphs["timeSigPlus"] = "\uE08C";
    // U+E08D  Time signature + (for numerators)
    Glyphs["timeSigPlusSmall"] = "\uE08D";
    // U+EC84  Time signature slash separator
    Glyphs["timeSigSlash"] = "\uEC84";
    // U+E09C  Open time signature
    Glyphs["timeSigX"] = "\uE09C";
    // U+E220  Combining tremolo 1
    Glyphs["tremolo1"] = "\uE220";
    // U+E221  Combining tremolo 2
    Glyphs["tremolo2"] = "\uE221";
    // U+E222  Combining tremolo 3
    Glyphs["tremolo3"] = "\uE222";
    // U+E223  Combining tremolo 4
    Glyphs["tremolo4"] = "\uE223";
    // U+E224  Combining tremolo 5
    Glyphs["tremolo5"] = "\uE224";
    // U+E22E  Divide measured tremolo by 2
    Glyphs["tremoloDivisiDots2"] = "\uE22E";
    // U+E22F  Divide measured tremolo by 3
    Glyphs["tremoloDivisiDots3"] = "\uE22F";
    // U+E230  Divide measured tremolo by 4
    Glyphs["tremoloDivisiDots4"] = "\uE230";
    // U+E231  Divide measured tremolo by 6
    Glyphs["tremoloDivisiDots6"] = "\uE231";
    // U+E225  Fingered tremolo 1
    Glyphs["tremoloFingered1"] = "\uE225";
    // U+E226  Fingered tremolo 2
    Glyphs["tremoloFingered2"] = "\uE226";
    // U+E227  Fingered tremolo 3
    Glyphs["tremoloFingered3"] = "\uE227";
    // U+E228  Fingered tremolo 4
    Glyphs["tremoloFingered4"] = "\uE228";
    // U+E229  Fingered tremolo 5
    Glyphs["tremoloFingered5"] = "\uE229";
    // U+E5F2  Triple-tongue above
    Glyphs["tripleTongueAbove"] = "\uE5F2";
    // U+E5F3  Triple-tongue below
    Glyphs["tripleTongueBelow"] = "\uE5F3";
    // U+E880  Tuplet 0
    Glyphs["tuplet0"] = "\uE880";
    // U+E881  Tuplet 1
    Glyphs["tuplet1"] = "\uE881";
    // U+E882  Tuplet 2
    Glyphs["tuplet2"] = "\uE882";
    // U+E883  Tuplet 3
    Glyphs["tuplet3"] = "\uE883";
    // U+E884  Tuplet 4
    Glyphs["tuplet4"] = "\uE884";
    // U+E885  Tuplet 5
    Glyphs["tuplet5"] = "\uE885";
    // U+E886  Tuplet 6
    Glyphs["tuplet6"] = "\uE886";
    // U+E887  Tuplet 7
    Glyphs["tuplet7"] = "\uE887";
    // U+E888  Tuplet 8
    Glyphs["tuplet8"] = "\uE888";
    // U+E889  Tuplet 9
    Glyphs["tuplet9"] = "\uE889";
    // U+E88A  Tuplet colon
    Glyphs["tupletColon"] = "\uE88A";
    // U+E22C  Wieniawski unmeasured tremolo
    Glyphs["unmeasuredTremolo"] = "\uE22C";
    // U+E22D  Wieniawski unmeasured tremolo (simpler)
    Glyphs["unmeasuredTremoloSimple"] = "\uE22D";
    // U+E069  Unpitched percussion clef 1
    Glyphs["unpitchedPercussionClef1"] = "\uE069";
    // U+E06A  Unpitched percussion clef 2
    Glyphs["unpitchedPercussionClef2"] = "\uE06A";
    // U+E517  Ventiduesima
    Glyphs["ventiduesima"] = "\uE517";
    // U+E518  Ventiduesima alta
    Glyphs["ventiduesimaAlta"] = "\uE518";
    // U+E519  Ventiduesima bassa
    Glyphs["ventiduesimaBassa"] = "\uE519";
    // U+E51E  Ventiduesima bassa (mb)
    Glyphs["ventiduesimaBassaMb"] = "\uE51E";
    // U+E649  Finger click (Stockhausen)
    Glyphs["vocalFingerClickStockhausen"] = "\uE649";
    // U+E64B  Halb gesungen (semi-sprechgesang)
    Glyphs["vocalHalbGesungen"] = "\uE64B";
    // U+E640  Mouth closed
    Glyphs["vocalMouthClosed"] = "\uE640";
    // U+E642  Mouth open
    Glyphs["vocalMouthOpen"] = "\uE642";
    // U+E644  Mouth pursed
    Glyphs["vocalMouthPursed"] = "\uE644";
    // U+E641  Mouth slightly open
    Glyphs["vocalMouthSlightlyOpen"] = "\uE641";
    // U+E643  Mouth wide open
    Glyphs["vocalMouthWideOpen"] = "\uE643";
    // U+E647  Nasal voice
    Glyphs["vocalNasalVoice"] = "\uE647";
    // U+E645  Sprechgesang
    Glyphs["vocalSprechgesang"] = "\uE645";
    // U+E648  Tongue click (Stockhausen)
    Glyphs["vocalTongueClickStockhausen"] = "\uE648";
    // U+E64A  Tongue and finger click (Stockhausen)
    Glyphs["vocalTongueFingerClickStockhausen"] = "\uE64A";
    // U+E646  Combining sussurando for stem
    Glyphs["vocalsSussurando"] = "\uE646";
    // U+EAAA  Arpeggiato wiggle segment, downwards
    Glyphs["wiggleArpeggiatoDown"] = "\uEAAA";
    // U+EAAE  Arpeggiato arrowhead down
    Glyphs["wiggleArpeggiatoDownArrow"] = "\uEAAE";
    // U+EAAC  Arpeggiato downward swash
    Glyphs["wiggleArpeggiatoDownSwash"] = "\uEAAC";
    // U+EAA9  Arpeggiato wiggle segment, upwards
    Glyphs["wiggleArpeggiatoUp"] = "\uEAA9";
    // U+EAAD  Arpeggiato arrowhead up
    Glyphs["wiggleArpeggiatoUpArrow"] = "\uEAAD";
    // U+EAAB  Arpeggiato upward swash
    Glyphs["wiggleArpeggiatoUpSwash"] = "\uEAAB";
    // U+EAC9  Circular motion segment
    Glyphs["wiggleCircular"] = "\uEAC9";
    // U+EAC0  Constant circular motion segment
    Glyphs["wiggleCircularConstant"] = "\uEAC0";
    // U+EAC1  Constant circular motion segment (flipped)
    Glyphs["wiggleCircularConstantFlipped"] = "\uEAC1";
    // U+EAC3  Constant circular motion segment (flipped, large)
    Glyphs["wiggleCircularConstantFlippedLarge"] = "\uEAC3";
    // U+EAC2  Constant circular motion segment (large)
    Glyphs["wiggleCircularConstantLarge"] = "\uEAC2";
    // U+EACB  Circular motion end
    Glyphs["wiggleCircularEnd"] = "\uEACB";
    // U+EAC8  Circular motion segment, large
    Glyphs["wiggleCircularLarge"] = "\uEAC8";
    // U+EAC7  Circular motion segment, larger
    Glyphs["wiggleCircularLarger"] = "\uEAC7";
    // U+EAC6  Circular motion segment, larger still
    Glyphs["wiggleCircularLargerStill"] = "\uEAC6";
    // U+EAC5  Circular motion segment, largest
    Glyphs["wiggleCircularLargest"] = "\uEAC5";
    // U+EACA  Circular motion segment, small
    Glyphs["wiggleCircularSmall"] = "\uEACA";
    // U+EAC4  Circular motion start
    Glyphs["wiggleCircularStart"] = "\uEAC4";
    // U+EAAF  Glissando wiggle segment
    Glyphs["wiggleGlissando"] = "\uEAAF";
    // U+EABD  Group glissando 1
    Glyphs["wiggleGlissandoGroup1"] = "\uEABD";
    // U+EABE  Group glissando 2
    Glyphs["wiggleGlissandoGroup2"] = "\uEABE";
    // U+EABF  Group glissando 3
    Glyphs["wiggleGlissandoGroup3"] = "\uEABF";
    // U+EAF0  Quasi-random squiggle 1
    Glyphs["wiggleRandom1"] = "\uEAF0";
    // U+EAF1  Quasi-random squiggle 2
    Glyphs["wiggleRandom2"] = "\uEAF1";
    // U+EAF2  Quasi-random squiggle 3
    Glyphs["wiggleRandom3"] = "\uEAF2";
    // U+EAF3  Quasi-random squiggle 4
    Glyphs["wiggleRandom4"] = "\uEAF3";
    // U+EABB  Sawtooth line segment
    Glyphs["wiggleSawtooth"] = "\uEABB";
    // U+EABA  Narrow sawtooth line segment
    Glyphs["wiggleSawtoothNarrow"] = "\uEABA";
    // U+EABC  Wide sawtooth line segment
    Glyphs["wiggleSawtoothWide"] = "\uEABC";
    // U+EAB8  Square wave line segment
    Glyphs["wiggleSquareWave"] = "\uEAB8";
    // U+EAB7  Narrow square wave line segment
    Glyphs["wiggleSquareWaveNarrow"] = "\uEAB7";
    // U+EAB9  Wide square wave line segment
    Glyphs["wiggleSquareWaveWide"] = "\uEAB9";
    // U+EAA4  Trill wiggle segment
    Glyphs["wiggleTrill"] = "\uEAA4";
    // U+EAA3  Trill wiggle segment, fast
    Glyphs["wiggleTrillFast"] = "\uEAA3";
    // U+EAA2  Trill wiggle segment, faster
    Glyphs["wiggleTrillFaster"] = "\uEAA2";
    // U+EAA1  Trill wiggle segment, faster still
    Glyphs["wiggleTrillFasterStill"] = "\uEAA1";
    // U+EAA0  Trill wiggle segment, fastest
    Glyphs["wiggleTrillFastest"] = "\uEAA0";
    // U+EAA5  Trill wiggle segment, slow
    Glyphs["wiggleTrillSlow"] = "\uEAA5";
    // U+EAA6  Trill wiggle segment, slower
    Glyphs["wiggleTrillSlower"] = "\uEAA6";
    // U+EAA7  Trill wiggle segment, slower still
    Glyphs["wiggleTrillSlowerStill"] = "\uEAA7";
    // U+EAA8  Trill wiggle segment, slowest
    Glyphs["wiggleTrillSlowest"] = "\uEAA8";
    // U+EAEE  Vibrato largest, slower
    Glyphs["wiggleVIbratoLargestSlower"] = "\uEAEE";
    // U+EAE0  Vibrato medium, slower
    Glyphs["wiggleVIbratoMediumSlower"] = "\uEAE0";
    // U+EAB0  Vibrato / shake wiggle segment
    Glyphs["wiggleVibrato"] = "\uEAB0";
    // U+EAE5  Vibrato large, fast
    Glyphs["wiggleVibratoLargeFast"] = "\uEAE5";
    // U+EAE4  Vibrato large, faster
    Glyphs["wiggleVibratoLargeFaster"] = "\uEAE4";
    // U+EAE3  Vibrato large, faster still
    Glyphs["wiggleVibratoLargeFasterStill"] = "\uEAE3";
    // U+EAE2  Vibrato large, fastest
    Glyphs["wiggleVibratoLargeFastest"] = "\uEAE2";
    // U+EAE6  Vibrato large, slow
    Glyphs["wiggleVibratoLargeSlow"] = "\uEAE6";
    // U+EAE7  Vibrato large, slower
    Glyphs["wiggleVibratoLargeSlower"] = "\uEAE7";
    // U+EAE8  Vibrato large, slowest
    Glyphs["wiggleVibratoLargeSlowest"] = "\uEAE8";
    // U+EAEC  Vibrato largest, fast
    Glyphs["wiggleVibratoLargestFast"] = "\uEAEC";
    // U+EAEB  Vibrato largest, faster
    Glyphs["wiggleVibratoLargestFaster"] = "\uEAEB";
    // U+EAEA  Vibrato largest, faster still
    Glyphs["wiggleVibratoLargestFasterStill"] = "\uEAEA";
    // U+EAE9  Vibrato largest, fastest
    Glyphs["wiggleVibratoLargestFastest"] = "\uEAE9";
    // U+EAED  Vibrato largest, slow
    Glyphs["wiggleVibratoLargestSlow"] = "\uEAED";
    // U+EAEF  Vibrato largest, slowest
    Glyphs["wiggleVibratoLargestSlowest"] = "\uEAEF";
    // U+EADE  Vibrato medium, fast
    Glyphs["wiggleVibratoMediumFast"] = "\uEADE";
    // U+EADD  Vibrato medium, faster
    Glyphs["wiggleVibratoMediumFaster"] = "\uEADD";
    // U+EADC  Vibrato medium, faster still
    Glyphs["wiggleVibratoMediumFasterStill"] = "\uEADC";
    // U+EADB  Vibrato medium, fastest
    Glyphs["wiggleVibratoMediumFastest"] = "\uEADB";
    // U+EADF  Vibrato medium, slow
    Glyphs["wiggleVibratoMediumSlow"] = "\uEADF";
    // U+EAE1  Vibrato medium, slowest
    Glyphs["wiggleVibratoMediumSlowest"] = "\uEAE1";
    // U+EAD7  Vibrato small, fast
    Glyphs["wiggleVibratoSmallFast"] = "\uEAD7";
    // U+EAD6  Vibrato small, faster
    Glyphs["wiggleVibratoSmallFaster"] = "\uEAD6";
    // U+EAD5  Vibrato small, faster still
    Glyphs["wiggleVibratoSmallFasterStill"] = "\uEAD5";
    // U+EAD4  Vibrato small, fastest
    Glyphs["wiggleVibratoSmallFastest"] = "\uEAD4";
    // U+EAD8  Vibrato small, slow
    Glyphs["wiggleVibratoSmallSlow"] = "\uEAD8";
    // U+EAD9  Vibrato small, slower
    Glyphs["wiggleVibratoSmallSlower"] = "\uEAD9";
    // U+EADA  Vibrato small, slowest
    Glyphs["wiggleVibratoSmallSlowest"] = "\uEADA";
    // U+EAD0  Vibrato smallest, fast
    Glyphs["wiggleVibratoSmallestFast"] = "\uEAD0";
    // U+EACF  Vibrato smallest, faster
    Glyphs["wiggleVibratoSmallestFaster"] = "\uEACF";
    // U+EACE  Vibrato smallest, faster still
    Glyphs["wiggleVibratoSmallestFasterStill"] = "\uEACE";
    // U+EACD  Vibrato smallest, fastest
    Glyphs["wiggleVibratoSmallestFastest"] = "\uEACD";
    // U+EAD1  Vibrato smallest, slow
    Glyphs["wiggleVibratoSmallestSlow"] = "\uEAD1";
    // U+EAD2  Vibrato smallest, slower
    Glyphs["wiggleVibratoSmallestSlower"] = "\uEAD2";
    // U+EAD3  Vibrato smallest, slowest
    Glyphs["wiggleVibratoSmallestSlowest"] = "\uEAD3";
    // U+EACC  Vibrato start
    Glyphs["wiggleVibratoStart"] = "\uEACC";
    // U+EAB1  Wide vibrato / shake wiggle segment
    Glyphs["wiggleVibratoWide"] = "\uEAB1";
    // U+EAB5  Wavy line segment
    Glyphs["wiggleWavy"] = "\uEAB5";
    // U+EAB4  Narrow wavy line segment
    Glyphs["wiggleWavyNarrow"] = "\uEAB4";
    // U+EAB6  Wide wavy line segment
    Glyphs["wiggleWavyWide"] = "\uEAB6";
    // U+E5F4  Closed hole
    Glyphs["windClosedHole"] = "\uE5F4";
    // U+E5FB  Flatter embouchure
    Glyphs["windFlatEmbouchure"] = "\uE5FB";
    // U+E5F6  Half-closed hole
    Glyphs["windHalfClosedHole1"] = "\uE5F6";
    // U+E5F7  Half-closed hole 2
    Glyphs["windHalfClosedHole2"] = "\uE5F7";
    // U+E5F8  Half-open hole
    Glyphs["windHalfClosedHole3"] = "\uE5F8";
    // U+E5FE  Somewhat relaxed embouchure
    Glyphs["windLessRelaxedEmbouchure"] = "\uE5FE";
    // U+E600  Somewhat tight embouchure
    Glyphs["windLessTightEmbouchure"] = "\uE600";
    // U+E60A  Mouthpiece or hand pop
    Glyphs["windMouthpiecePop"] = "\uE60A";
    // U+E607  Combining multiphonics (black) for stem
    Glyphs["windMultiphonicsBlackStem"] = "\uE607";
    // U+E609  Combining multiphonics (black and white) for stem
    Glyphs["windMultiphonicsBlackWhiteStem"] = "\uE609";
    // U+E608  Combining multiphonics (white) for stem
    Glyphs["windMultiphonicsWhiteStem"] = "\uE608";
    // U+E5F9  Open hole
    Glyphs["windOpenHole"] = "\uE5F9";
    // U+E606  Much more reed (push inwards)
    Glyphs["windReedPositionIn"] = "\uE606";
    // U+E604  Normal reed position
    Glyphs["windReedPositionNormal"] = "\uE604";
    // U+E605  Very little reed (pull outwards)
    Glyphs["windReedPositionOut"] = "\uE605";
    // U+E5FD  Relaxed embouchure
    Glyphs["windRelaxedEmbouchure"] = "\uE5FD";
    // U+E60B  Rim only
    Glyphs["windRimOnly"] = "\uE60B";
    // U+E5FC  Sharper embouchure
    Glyphs["windSharpEmbouchure"] = "\uE5FC";
    // U+E603  Very tight embouchure / strong air pressure
    Glyphs["windStrongAirPressure"] = "\uE603";
    // U+E5F5  Three-quarters closed hole
    Glyphs["windThreeQuartersClosedHole"] = "\uE5F5";
    // U+E5FF  Tight embouchure
    Glyphs["windTightEmbouchure"] = "\uE5FF";
    // U+E5FA  Trill key
    Glyphs["windTrillKey"] = "\uE5FA";
    // U+E601  Very tight embouchure
    Glyphs["windVeryTightEmbouchure"] = "\uE601";
    // U+E602  Very relaxed embouchure / weak air-pressure
    Glyphs["windWeakAirPressure"] = "\uE602";
})(Glyphs || (Glyphs = {}));


/***/ }),

/***/ "./src/gracenote.ts":
/*!**************************!*\
  !*** ./src/gracenote.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GraceNote: () => (/* binding */ GraceNote)
/* harmony export */ });
/* harmony import */ var _stavenote__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stavenote */ "./src/stavenote.ts");
/* harmony import */ var _stem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stem */ "./src/stem.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors





class GraceNote extends _stavenote__WEBPACK_IMPORTED_MODULE_0__.StaveNote {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_3__.Category.GraceNote;
    }
    static get LEDGER_LINE_OFFSET() {
        return 2;
    }
    constructor(noteStruct) {
        super(Object.assign({ strokePx: GraceNote.LEDGER_LINE_OFFSET }, noteStruct));
        this.slash = noteStruct.slash || false;
        this.slur = true;
        this.buildNoteHeads();
        this.width = 3;
    }
    getStemExtension() {
        if (this.stemExtensionOverride) {
            return this.stemExtensionOverride;
        }
        let ret = super.getStemExtension();
        ret = _stem__WEBPACK_IMPORTED_MODULE_1__.Stem.HEIGHT * this.getFontScale() - _stem__WEBPACK_IMPORTED_MODULE_1__.Stem.HEIGHT + ret;
        return ret;
    }
    draw() {
        super.draw();
        this.setRendered();
        const stem = this.stem;
        if (this.slash && stem) {
            const scale = this.getFontScale();
            let slashBBox = undefined;
            const beam = this.beam;
            if (beam) {
                // FIXME: should render slash after beam?
                if (!beam.postFormatted) {
                    beam.postFormat();
                }
                slashBBox = this.calcBeamedNotesSlashBBox(8 * scale, 8 * scale, {
                    stem: 6 * scale,
                    beam: 5 * scale,
                });
            }
            else {
                const stemDirection = this.getStemDirection();
                const noteHeadBounds = this.getNoteHeadBounds();
                const noteHeadWidth = this.noteHeads[0].getWidth();
                const x = stemDirection === _stem__WEBPACK_IMPORTED_MODULE_1__.Stem.DOWN ? this.getAbsoluteX() : this.getAbsoluteX() + noteHeadWidth;
                const defaultOffsetY = (_tables__WEBPACK_IMPORTED_MODULE_2__.Tables.STEM_HEIGHT * scale) / 2;
                const y = stemDirection === _stem__WEBPACK_IMPORTED_MODULE_1__.Stem.DOWN ? noteHeadBounds.yBottom + defaultOffsetY : noteHeadBounds.yTop - defaultOffsetY;
                if (stemDirection === _stem__WEBPACK_IMPORTED_MODULE_1__.Stem.DOWN) {
                    slashBBox = {
                        x1: x - noteHeadWidth,
                        y1: y - noteHeadWidth,
                        x2: x + noteHeadWidth,
                        y2: y + noteHeadWidth,
                    };
                }
                else {
                    slashBBox = {
                        x1: x - noteHeadWidth,
                        y1: y + noteHeadWidth,
                        x2: x + noteHeadWidth,
                        y2: y - noteHeadWidth,
                    };
                }
            }
            // FIXME: avoid staff lines, ledger lines or others.
            const ctx = this.checkContext();
            ctx.save();
            ctx.setLineWidth(1 * scale); // FIXME: use more appropriate value.
            ctx.beginPath();
            ctx.moveTo(slashBBox.x1, slashBBox.y1);
            ctx.lineTo(slashBBox.x2, slashBBox.y2);
            ctx.closePath();
            ctx.stroke();
            ctx.restore();
        }
    }
    calcBeamedNotesSlashBBox(slashStemOffset, slashBeamOffset, protrusions) {
        const beam = this.beam;
        if (!beam)
            throw new _util__WEBPACK_IMPORTED_MODULE_4__.RuntimeError('NoBeam', "Can't calculate without a beam.");
        const beamSlope = beam.slope;
        const isBeamEndNote = beam.notes[beam.notes.length - 1] === this;
        const scaleX = isBeamEndNote ? -1 : 1;
        const beamAngle = Math.atan(beamSlope * scaleX);
        // slash line intersecting point on beam.
        const iPointOnBeam = {
            dx: Math.cos(beamAngle) * slashBeamOffset,
            dy: Math.sin(beamAngle) * slashBeamOffset,
        };
        slashStemOffset *= this.getStemDirection();
        const slashAngle = Math.atan((iPointOnBeam.dy - slashStemOffset) / iPointOnBeam.dx);
        const protrusionStemDeltaX = Math.cos(slashAngle) * protrusions.stem * scaleX;
        const protrusionStemDeltaY = Math.sin(slashAngle) * protrusions.stem;
        const protrusionBeamDeltaX = Math.cos(slashAngle) * protrusions.beam * scaleX;
        const protrusionBeamDeltaY = Math.sin(slashAngle) * protrusions.beam;
        const stemX = this.getStemX();
        const stem0X = beam.notes[0].getStemX();
        const stemY = beam.getBeamYToDraw() + (stemX - stem0X) * beamSlope;
        const ret = {
            x1: stemX - protrusionStemDeltaX,
            y1: stemY + slashStemOffset - protrusionStemDeltaY,
            x2: stemX + iPointOnBeam.dx * scaleX + protrusionBeamDeltaX,
            y2: stemY + iPointOnBeam.dy + protrusionBeamDeltaY,
        };
        return ret;
    }
}


/***/ }),

/***/ "./src/gracenotegroup.ts":
/*!*******************************!*\
  !*** ./src/gracenotegroup.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GraceNoteGroup: () => (/* binding */ GraceNoteGroup)
/* harmony export */ });
/* harmony import */ var _beam__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./beam */ "./src/beam.ts");
/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatter */ "./src/formatter.ts");
/* harmony import */ var _modifier__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifier */ "./src/modifier.ts");
/* harmony import */ var _stavenote__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stavenote */ "./src/stavenote.ts");
/* harmony import */ var _stavetie__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stavetie */ "./src/stavetie.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _tabtie__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tabtie */ "./src/tabtie.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./util */ "./src/util.ts");
/* harmony import */ var _voice__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./voice */ "./src/voice.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
//
// ## Description
//
// This file implements `GraceNoteGroup` which is used to format and
// render grace notes.










// To enable logging for this class. Set `GraceNoteGroup.DEBUG` to `true`.
// eslint-disable-next-line
function L(...args) {
    if (GraceNoteGroup.DEBUG)
        (0,_util__WEBPACK_IMPORTED_MODULE_8__.log)('Vex.Flow.GraceNoteGroup', args);
}
/** GraceNoteGroup is used to format and render grace notes. */
class GraceNoteGroup extends _modifier__WEBPACK_IMPORTED_MODULE_2__.Modifier {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_7__.Category.GraceNoteGroup;
    }
    /** Arranges groups inside a `ModifierContext`. */
    static format(gracenoteGroups, state) {
        const groupSpacingStave = 4;
        const groupSpacingTab = 0;
        if (!gracenoteGroups || gracenoteGroups.length === 0)
            return false;
        const groupList = [];
        let prevNote = null;
        let shiftL = 0;
        for (let i = 0; i < gracenoteGroups.length; ++i) {
            const gracenoteGroup = gracenoteGroups[i];
            const note = gracenoteGroup.getNote();
            const isStavenote = (0,_typeguard__WEBPACK_IMPORTED_MODULE_7__.isStaveNote)(note);
            const spacing = isStavenote ? groupSpacingStave : groupSpacingTab;
            if (isStavenote && note !== prevNote) {
                // Iterate through all notes to get the displaced pixels
                for (let n = 0; n < note.keys.length; ++n) {
                    shiftL = Math.max(note.getLeftDisplacedHeadPx(), shiftL);
                }
                prevNote = note;
            }
            groupList.push({ shift: shiftL, gracenoteGroup, spacing });
        }
        // If first note left shift in case it is displaced
        let groupShift = groupList[0].shift;
        let formatWidth;
        for (let i = 0; i < groupList.length; ++i) {
            const gracenoteGroup = groupList[i].gracenoteGroup;
            gracenoteGroup.preFormat();
            formatWidth = gracenoteGroup.getWidth() + groupList[i].spacing;
            groupShift = Math.max(formatWidth, groupShift);
        }
        for (let i = 0; i < groupList.length; ++i) {
            const gracenoteGroup = groupList[i].gracenoteGroup;
            formatWidth = gracenoteGroup.getWidth() + groupList[i].spacing;
            gracenoteGroup.setSpacingFromNextModifier(groupShift - Math.min(formatWidth, groupShift) + _stavenote__WEBPACK_IMPORTED_MODULE_3__.StaveNote.minNoteheadPadding);
        }
        state.leftShift += groupShift;
        return true;
    }
    //** `GraceNoteGroup` inherits from `Modifier` and is placed inside a `ModifierContext`. */
    constructor(graceNotes, showSlur) {
        super();
        this.preFormatted = false;
        this.position = _modifier__WEBPACK_IMPORTED_MODULE_2__.Modifier.Position.LEFT;
        this.graceNotes = graceNotes;
        this.width = 0;
        this.showSlur = showSlur;
        this.slur = undefined;
        this.voice = new _voice__WEBPACK_IMPORTED_MODULE_9__.Voice({
            numBeats: 4,
            beatValue: 4,
            resolution: _tables__WEBPACK_IMPORTED_MODULE_5__.Tables.RESOLUTION,
        }).setStrict(false);
        this.renderOptions = {
            slurYShift: 0,
        };
        this.beams = [];
        this.voice.addTickables(this.graceNotes);
        return this;
    }
    preFormat() {
        if (this.preFormatted)
            return;
        if (!this.formatter) {
            this.formatter = new _formatter__WEBPACK_IMPORTED_MODULE_1__.Formatter();
        }
        this.formatter.joinVoices([this.voice]).format([this.voice], 0, {});
        this.setWidth(this.formatter.getMinTotalWidth());
        this.preFormatted = true;
    }
    beamNotes(graceNotes) {
        graceNotes = graceNotes || this.graceNotes;
        if (graceNotes.length > 1) {
            const beam = new _beam__WEBPACK_IMPORTED_MODULE_0__.Beam(graceNotes);
            beam.renderOptions.beamWidth = 3;
            beam.renderOptions.partialBeamLength = 4;
            this.beams.push(beam);
        }
        return this;
    }
    setWidth(width) {
        this.width = width;
        return this;
    }
    getWidth() {
        return this.width + _stavenote__WEBPACK_IMPORTED_MODULE_3__.StaveNote.minNoteheadPadding;
    }
    getGraceNotes() {
        return this.graceNotes;
    }
    draw() {
        const ctx = this.checkContext();
        const note = this.checkAttachedNote();
        this.setRendered();
        L('Drawing grace note group for:', note);
        this.alignSubNotesWithNote(this.getGraceNotes(), note); // Modifier function
        // Draw grace notes.
        this.graceNotes.forEach((graceNote) => graceNote.setContext(ctx).draw());
        // Draw beams.
        this.beams.forEach((beam) => beam.setContext(ctx).draw());
        if (this.showSlur) {
            // Create and draw slur.
            const isStavenote = (0,_typeguard__WEBPACK_IMPORTED_MODULE_7__.isStaveNote)(note);
            const TieClass = isStavenote ? _stavetie__WEBPACK_IMPORTED_MODULE_4__.StaveTie : _tabtie__WEBPACK_IMPORTED_MODULE_6__.TabTie;
            this.slur = new TieClass({
                lastNote: this.graceNotes[0],
                firstNote: note,
                firstIndexes: [0],
                lastIndexes: [0],
            });
            this.slur.renderOptions.cp2 = 12;
            this.slur.renderOptions.yShift = (isStavenote ? 7 : 5) + this.renderOptions.slurYShift;
            this.slur.setContext(ctx).draw();
        }
    }
}
GraceNoteGroup.DEBUG = false;


/***/ }),

/***/ "./src/gracetabnote.ts":
/*!*****************************!*\
  !*** ./src/gracetabnote.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GraceTabNote: () => (/* binding */ GraceTabNote)
/* harmony export */ });
/* harmony import */ var _tabnote__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tabnote */ "./src/tabnote.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// @author Balazs Forian-Szabo
//
// ## Description
//
// A basic implementation of grace notes
// to be rendered on a tab stave.
//
// See `tests/gracetabnote_tests.ts` for usage examples.


class GraceTabNote extends _tabnote__WEBPACK_IMPORTED_MODULE_0__.TabNote {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_1__.Category.GraceTabNote;
    }
    constructor(noteStruct) {
        super(noteStruct, false);
        this.renderOptions = Object.assign(Object.assign({}, this.renderOptions), { 
            // vertical shift from stave line
            yShift: 0.3 });
        this.updateWidth();
    }
}


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Accidental: () => (/* reexport safe */ _accidental__WEBPACK_IMPORTED_MODULE_0__.Accidental),
/* harmony export */   Annotation: () => (/* reexport safe */ _annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation),
/* harmony export */   AnnotationHorizontalJustify: () => (/* reexport safe */ _annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationHorizontalJustify),
/* harmony export */   AnnotationVerticalJustify: () => (/* reexport safe */ _annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify),
/* harmony export */   Articulation: () => (/* reexport safe */ _articulation__WEBPACK_IMPORTED_MODULE_2__.Articulation),
/* harmony export */   BEAM_BOTH: () => (/* reexport safe */ _beam__WEBPACK_IMPORTED_MODULE_4__.BEAM_BOTH),
/* harmony export */   BEAM_LEFT: () => (/* reexport safe */ _beam__WEBPACK_IMPORTED_MODULE_4__.BEAM_LEFT),
/* harmony export */   BEAM_RIGHT: () => (/* reexport safe */ _beam__WEBPACK_IMPORTED_MODULE_4__.BEAM_RIGHT),
/* harmony export */   BarNote: () => (/* reexport safe */ _barnote__WEBPACK_IMPORTED_MODULE_3__.BarNote),
/* harmony export */   Barline: () => (/* reexport safe */ _stavebarline__WEBPACK_IMPORTED_MODULE_46__.Barline),
/* harmony export */   BarlineType: () => (/* reexport safe */ _stavebarline__WEBPACK_IMPORTED_MODULE_46__.BarlineType),
/* harmony export */   Beam: () => (/* reexport safe */ _beam__WEBPACK_IMPORTED_MODULE_4__.Beam),
/* harmony export */   Bend: () => (/* reexport safe */ _bend__WEBPACK_IMPORTED_MODULE_5__.Bend),
/* harmony export */   BoundingBox: () => (/* reexport safe */ _boundingbox__WEBPACK_IMPORTED_MODULE_6__.BoundingBox),
/* harmony export */   Builder: () => (/* reexport safe */ _easyscore__WEBPACK_IMPORTED_MODULE_14__.Builder),
/* harmony export */   CanvasContext: () => (/* reexport safe */ _canvascontext__WEBPACK_IMPORTED_MODULE_7__.CanvasContext),
/* harmony export */   Category: () => (/* reexport safe */ _typeguard__WEBPACK_IMPORTED_MODULE_78__.Category),
/* harmony export */   ChordSymbol: () => (/* reexport safe */ _chordsymbol__WEBPACK_IMPORTED_MODULE_8__.ChordSymbol),
/* harmony export */   ChordSymbolBlock: () => (/* reexport safe */ _chordsymbol__WEBPACK_IMPORTED_MODULE_8__.ChordSymbolBlock),
/* harmony export */   ChordSymbolHorizontalJustify: () => (/* reexport safe */ _chordsymbol__WEBPACK_IMPORTED_MODULE_8__.ChordSymbolHorizontalJustify),
/* harmony export */   ChordSymbolVerticalJustify: () => (/* reexport safe */ _chordsymbol__WEBPACK_IMPORTED_MODULE_8__.ChordSymbolVerticalJustify),
/* harmony export */   Clef: () => (/* reexport safe */ _clef__WEBPACK_IMPORTED_MODULE_9__.Clef),
/* harmony export */   ClefNote: () => (/* reexport safe */ _clefnote__WEBPACK_IMPORTED_MODULE_10__.ClefNote),
/* harmony export */   Crescendo: () => (/* reexport safe */ _crescendo__WEBPACK_IMPORTED_MODULE_11__.Crescendo),
/* harmony export */   Curve: () => (/* reexport safe */ _curve__WEBPACK_IMPORTED_MODULE_12__.Curve),
/* harmony export */   CurvePosition: () => (/* reexport safe */ _curve__WEBPACK_IMPORTED_MODULE_12__.CurvePosition),
/* harmony export */   Dot: () => (/* reexport safe */ _dot__WEBPACK_IMPORTED_MODULE_13__.Dot),
/* harmony export */   EasyScore: () => (/* reexport safe */ _easyscore__WEBPACK_IMPORTED_MODULE_14__.EasyScore),
/* harmony export */   EasyScoreGrammar: () => (/* reexport safe */ _easyscore__WEBPACK_IMPORTED_MODULE_14__.EasyScoreGrammar),
/* harmony export */   Element: () => (/* reexport safe */ _element__WEBPACK_IMPORTED_MODULE_15__.Element),
/* harmony export */   Factory: () => (/* reexport safe */ _factory__WEBPACK_IMPORTED_MODULE_16__.Factory),
/* harmony export */   Flow: () => (/* reexport safe */ _flow__WEBPACK_IMPORTED_MODULE_17__.Flow),
/* harmony export */   Font: () => (/* reexport safe */ _font__WEBPACK_IMPORTED_MODULE_18__.Font),
/* harmony export */   FontStyle: () => (/* reexport safe */ _font__WEBPACK_IMPORTED_MODULE_18__.FontStyle),
/* harmony export */   FontWeight: () => (/* reexport safe */ _font__WEBPACK_IMPORTED_MODULE_18__.FontWeight),
/* harmony export */   Formatter: () => (/* reexport safe */ _formatter__WEBPACK_IMPORTED_MODULE_19__.Formatter),
/* harmony export */   Fraction: () => (/* reexport safe */ _fraction__WEBPACK_IMPORTED_MODULE_20__.Fraction),
/* harmony export */   FretHandFinger: () => (/* reexport safe */ _frethandfinger__WEBPACK_IMPORTED_MODULE_21__.FretHandFinger),
/* harmony export */   GhostNote: () => (/* reexport safe */ _ghostnote__WEBPACK_IMPORTED_MODULE_22__.GhostNote),
/* harmony export */   GlyphNote: () => (/* reexport safe */ _glyphnote__WEBPACK_IMPORTED_MODULE_23__.GlyphNote),
/* harmony export */   GraceNote: () => (/* reexport safe */ _gracenote__WEBPACK_IMPORTED_MODULE_24__.GraceNote),
/* harmony export */   GraceNoteGroup: () => (/* reexport safe */ _gracenotegroup__WEBPACK_IMPORTED_MODULE_25__.GraceNoteGroup),
/* harmony export */   GraceTabNote: () => (/* reexport safe */ _gracetabnote__WEBPACK_IMPORTED_MODULE_26__.GraceTabNote),
/* harmony export */   KeyManager: () => (/* reexport safe */ _keymanager__WEBPACK_IMPORTED_MODULE_27__.KeyManager),
/* harmony export */   KeySigNote: () => (/* reexport safe */ _keysignote__WEBPACK_IMPORTED_MODULE_29__.KeySigNote),
/* harmony export */   KeySignature: () => (/* reexport safe */ _keysignature__WEBPACK_IMPORTED_MODULE_28__.KeySignature),
/* harmony export */   Modifier: () => (/* reexport safe */ _modifier__WEBPACK_IMPORTED_MODULE_30__.Modifier),
/* harmony export */   ModifierContext: () => (/* reexport safe */ _modifiercontext__WEBPACK_IMPORTED_MODULE_31__.ModifierContext),
/* harmony export */   ModifierPosition: () => (/* reexport safe */ _modifier__WEBPACK_IMPORTED_MODULE_30__.ModifierPosition),
/* harmony export */   MultiMeasureRest: () => (/* reexport safe */ _multimeasurerest__WEBPACK_IMPORTED_MODULE_32__.MultiMeasureRest),
/* harmony export */   Music: () => (/* reexport safe */ _music__WEBPACK_IMPORTED_MODULE_33__.Music),
/* harmony export */   Note: () => (/* reexport safe */ _note__WEBPACK_IMPORTED_MODULE_34__.Note),
/* harmony export */   NoteHead: () => (/* reexport safe */ _notehead__WEBPACK_IMPORTED_MODULE_35__.NoteHead),
/* harmony export */   NoteSubGroup: () => (/* reexport safe */ _notesubgroup__WEBPACK_IMPORTED_MODULE_36__.NoteSubGroup),
/* harmony export */   Ornament: () => (/* reexport safe */ _ornament__WEBPACK_IMPORTED_MODULE_37__.Ornament),
/* harmony export */   Parenthesis: () => (/* reexport safe */ _parenthesis__WEBPACK_IMPORTED_MODULE_38__.Parenthesis),
/* harmony export */   Parser: () => (/* reexport safe */ _parser__WEBPACK_IMPORTED_MODULE_39__.Parser),
/* harmony export */   PedalMarking: () => (/* reexport safe */ _pedalmarking__WEBPACK_IMPORTED_MODULE_40__.PedalMarking),
/* harmony export */   Piece: () => (/* reexport safe */ _easyscore__WEBPACK_IMPORTED_MODULE_14__.Piece),
/* harmony export */   Registry: () => (/* reexport safe */ _registry__WEBPACK_IMPORTED_MODULE_41__.Registry),
/* harmony export */   RenderContext: () => (/* reexport safe */ _rendercontext__WEBPACK_IMPORTED_MODULE_42__.RenderContext),
/* harmony export */   Renderer: () => (/* reexport safe */ _renderer__WEBPACK_IMPORTED_MODULE_43__.Renderer),
/* harmony export */   RendererBackends: () => (/* reexport safe */ _renderer__WEBPACK_IMPORTED_MODULE_43__.RendererBackends),
/* harmony export */   RendererLineEndType: () => (/* reexport safe */ _renderer__WEBPACK_IMPORTED_MODULE_43__.RendererLineEndType),
/* harmony export */   RepeatNote: () => (/* reexport safe */ _repeatnote__WEBPACK_IMPORTED_MODULE_44__.RepeatNote),
/* harmony export */   Repetition: () => (/* reexport safe */ _staverepetition__WEBPACK_IMPORTED_MODULE_52__.Repetition),
/* harmony export */   RuntimeError: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_79__.RuntimeError),
/* harmony export */   SVGContext: () => (/* reexport safe */ _svgcontext__WEBPACK_IMPORTED_MODULE_62__.SVGContext),
/* harmony export */   Stave: () => (/* reexport safe */ _stave__WEBPACK_IMPORTED_MODULE_45__.Stave),
/* harmony export */   StaveConnector: () => (/* reexport safe */ _staveconnector__WEBPACK_IMPORTED_MODULE_47__.StaveConnector),
/* harmony export */   StaveHairpin: () => (/* reexport safe */ _stavehairpin__WEBPACK_IMPORTED_MODULE_48__.StaveHairpin),
/* harmony export */   StaveLine: () => (/* reexport safe */ _staveline__WEBPACK_IMPORTED_MODULE_49__.StaveLine),
/* harmony export */   StaveModifier: () => (/* reexport safe */ _stavemodifier__WEBPACK_IMPORTED_MODULE_50__.StaveModifier),
/* harmony export */   StaveModifierPosition: () => (/* reexport safe */ _stavemodifier__WEBPACK_IMPORTED_MODULE_50__.StaveModifierPosition),
/* harmony export */   StaveNote: () => (/* reexport safe */ _stavenote__WEBPACK_IMPORTED_MODULE_51__.StaveNote),
/* harmony export */   StaveSection: () => (/* reexport safe */ _stavesection__WEBPACK_IMPORTED_MODULE_53__.StaveSection),
/* harmony export */   StaveTempo: () => (/* reexport safe */ _stavetempo__WEBPACK_IMPORTED_MODULE_54__.StaveTempo),
/* harmony export */   StaveText: () => (/* reexport safe */ _stavetext__WEBPACK_IMPORTED_MODULE_55__.StaveText),
/* harmony export */   StaveTie: () => (/* reexport safe */ _stavetie__WEBPACK_IMPORTED_MODULE_56__.StaveTie),
/* harmony export */   Stem: () => (/* reexport safe */ _stem__WEBPACK_IMPORTED_MODULE_58__.Stem),
/* harmony export */   StemmableNote: () => (/* reexport safe */ _stemmablenote__WEBPACK_IMPORTED_MODULE_59__.StemmableNote),
/* harmony export */   StringNumber: () => (/* reexport safe */ _stringnumber__WEBPACK_IMPORTED_MODULE_60__.StringNumber),
/* harmony export */   Stroke: () => (/* reexport safe */ _strokes__WEBPACK_IMPORTED_MODULE_61__.Stroke),
/* harmony export */   SymbolModifiers: () => (/* reexport safe */ _chordsymbol__WEBPACK_IMPORTED_MODULE_8__.SymbolModifiers),
/* harmony export */   System: () => (/* reexport safe */ _system__WEBPACK_IMPORTED_MODULE_63__.System),
/* harmony export */   TabNote: () => (/* reexport safe */ _tabnote__WEBPACK_IMPORTED_MODULE_64__.TabNote),
/* harmony export */   TabSlide: () => (/* reexport safe */ _tabslide__WEBPACK_IMPORTED_MODULE_65__.TabSlide),
/* harmony export */   TabStave: () => (/* reexport safe */ _tabstave__WEBPACK_IMPORTED_MODULE_66__.TabStave),
/* harmony export */   TabTie: () => (/* reexport safe */ _tabtie__WEBPACK_IMPORTED_MODULE_67__.TabTie),
/* harmony export */   TextBracket: () => (/* reexport safe */ _textbracket__WEBPACK_IMPORTED_MODULE_68__.TextBracket),
/* harmony export */   TextBracketPosition: () => (/* reexport safe */ _textbracket__WEBPACK_IMPORTED_MODULE_68__.TextBracketPosition),
/* harmony export */   TextDynamics: () => (/* reexport safe */ _textdynamics__WEBPACK_IMPORTED_MODULE_69__.TextDynamics),
/* harmony export */   TextJustification: () => (/* reexport safe */ _textnote__WEBPACK_IMPORTED_MODULE_70__.TextJustification),
/* harmony export */   TextNote: () => (/* reexport safe */ _textnote__WEBPACK_IMPORTED_MODULE_70__.TextNote),
/* harmony export */   TickContext: () => (/* reexport safe */ _tickcontext__WEBPACK_IMPORTED_MODULE_72__.TickContext),
/* harmony export */   Tickable: () => (/* reexport safe */ _tickable__WEBPACK_IMPORTED_MODULE_71__.Tickable),
/* harmony export */   TimeSigNote: () => (/* reexport safe */ _timesignote__WEBPACK_IMPORTED_MODULE_74__.TimeSigNote),
/* harmony export */   TimeSignature: () => (/* reexport safe */ _timesignature__WEBPACK_IMPORTED_MODULE_73__.TimeSignature),
/* harmony export */   Tremolo: () => (/* reexport safe */ _tremolo__WEBPACK_IMPORTED_MODULE_75__.Tremolo),
/* harmony export */   Tuning: () => (/* reexport safe */ _tuning__WEBPACK_IMPORTED_MODULE_76__.Tuning),
/* harmony export */   Tuplet: () => (/* reexport safe */ _tuplet__WEBPACK_IMPORTED_MODULE_77__.Tuplet),
/* harmony export */   TupletLocation: () => (/* reexport safe */ _tuplet__WEBPACK_IMPORTED_MODULE_77__.TupletLocation),
/* harmony export */   Vex: () => (/* reexport safe */ _vex__WEBPACK_IMPORTED_MODULE_80__.Vex),
/* harmony export */   Vibrato: () => (/* reexport safe */ _vibrato__WEBPACK_IMPORTED_MODULE_81__.Vibrato),
/* harmony export */   VibratoBracket: () => (/* reexport safe */ _vibratobracket__WEBPACK_IMPORTED_MODULE_82__.VibratoBracket),
/* harmony export */   Voice: () => (/* reexport safe */ _voice__WEBPACK_IMPORTED_MODULE_83__.Voice),
/* harmony export */   VoiceMode: () => (/* reexport safe */ _voice__WEBPACK_IMPORTED_MODULE_83__.VoiceMode),
/* harmony export */   Volta: () => (/* reexport safe */ _stavevolta__WEBPACK_IMPORTED_MODULE_57__.Volta),
/* harmony export */   VoltaType: () => (/* reexport safe */ _stavevolta__WEBPACK_IMPORTED_MODULE_57__.VoltaType),
/* harmony export */   defined: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_79__.defined),
/* harmony export */   drawDot: () => (/* reexport safe */ _rendercontext__WEBPACK_IMPORTED_MODULE_42__.drawDot),
/* harmony export */   getBottomY: () => (/* reexport safe */ _articulation__WEBPACK_IMPORTED_MODULE_2__.getBottomY),
/* harmony export */   getInitialOffset: () => (/* reexport safe */ _articulation__WEBPACK_IMPORTED_MODULE_2__.getInitialOffset),
/* harmony export */   getTopY: () => (/* reexport safe */ _articulation__WEBPACK_IMPORTED_MODULE_2__.getTopY),
/* harmony export */   globalObject: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_79__.globalObject),
/* harmony export */   isAccidental: () => (/* reexport safe */ _typeguard__WEBPACK_IMPORTED_MODULE_78__.isAccidental),
/* harmony export */   isAnnotation: () => (/* reexport safe */ _typeguard__WEBPACK_IMPORTED_MODULE_78__.isAnnotation),
/* harmony export */   isBarline: () => (/* reexport safe */ _typeguard__WEBPACK_IMPORTED_MODULE_78__.isBarline),
/* harmony export */   isCategory: () => (/* reexport safe */ _typeguard__WEBPACK_IMPORTED_MODULE_78__.isCategory),
/* harmony export */   isDot: () => (/* reexport safe */ _typeguard__WEBPACK_IMPORTED_MODULE_78__.isDot),
/* harmony export */   isGraceNote: () => (/* reexport safe */ _typeguard__WEBPACK_IMPORTED_MODULE_78__.isGraceNote),
/* harmony export */   isGraceNoteGroup: () => (/* reexport safe */ _typeguard__WEBPACK_IMPORTED_MODULE_78__.isGraceNoteGroup),
/* harmony export */   isHTMLCanvas: () => (/* reexport safe */ _web__WEBPACK_IMPORTED_MODULE_84__.isHTMLCanvas),
/* harmony export */   isHTMLDiv: () => (/* reexport safe */ _web__WEBPACK_IMPORTED_MODULE_84__.isHTMLDiv),
/* harmony export */   isNote: () => (/* reexport safe */ _typeguard__WEBPACK_IMPORTED_MODULE_78__.isNote),
/* harmony export */   isRenderContext: () => (/* reexport safe */ _typeguard__WEBPACK_IMPORTED_MODULE_78__.isRenderContext),
/* harmony export */   isStaveNote: () => (/* reexport safe */ _typeguard__WEBPACK_IMPORTED_MODULE_78__.isStaveNote),
/* harmony export */   isStemmableNote: () => (/* reexport safe */ _typeguard__WEBPACK_IMPORTED_MODULE_78__.isStemmableNote),
/* harmony export */   isTabNote: () => (/* reexport safe */ _typeguard__WEBPACK_IMPORTED_MODULE_78__.isTabNote),
/* harmony export */   log: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_79__.log),
/* harmony export */   midLine: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_79__.midLine),
/* harmony export */   normalizeAngle: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_79__.normalizeAngle),
/* harmony export */   prefix: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_79__.prefix),
/* harmony export */   sumArray: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_79__.sumArray),
/* harmony export */   upperFirst: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_79__.upperFirst),
/* harmony export */   warn: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_79__.warn)
/* harmony export */ });
/* harmony import */ var _accidental__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./accidental */ "./src/accidental.ts");
/* harmony import */ var _annotation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./annotation */ "./src/annotation.ts");
/* harmony import */ var _articulation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./articulation */ "./src/articulation.ts");
/* harmony import */ var _barnote__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./barnote */ "./src/barnote.ts");
/* harmony import */ var _beam__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./beam */ "./src/beam.ts");
/* harmony import */ var _bend__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./bend */ "./src/bend.ts");
/* harmony import */ var _boundingbox__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./boundingbox */ "./src/boundingbox.ts");
/* harmony import */ var _canvascontext__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./canvascontext */ "./src/canvascontext.ts");
/* harmony import */ var _chordsymbol__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./chordsymbol */ "./src/chordsymbol.ts");
/* harmony import */ var _clef__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./clef */ "./src/clef.ts");
/* harmony import */ var _clefnote__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./clefnote */ "./src/clefnote.ts");
/* harmony import */ var _crescendo__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./crescendo */ "./src/crescendo.ts");
/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./curve */ "./src/curve.ts");
/* harmony import */ var _dot__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./dot */ "./src/dot.ts");
/* harmony import */ var _easyscore__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./easyscore */ "./src/easyscore.ts");
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _factory__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./factory */ "./src/factory.ts");
/* harmony import */ var _flow__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./flow */ "./src/flow.ts");
/* harmony import */ var _font__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./font */ "./src/font.ts");
/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./formatter */ "./src/formatter.ts");
/* harmony import */ var _fraction__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./fraction */ "./src/fraction.ts");
/* harmony import */ var _frethandfinger__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./frethandfinger */ "./src/frethandfinger.ts");
/* harmony import */ var _ghostnote__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./ghostnote */ "./src/ghostnote.ts");
/* harmony import */ var _glyphnote__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./glyphnote */ "./src/glyphnote.ts");
/* harmony import */ var _gracenote__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./gracenote */ "./src/gracenote.ts");
/* harmony import */ var _gracenotegroup__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./gracenotegroup */ "./src/gracenotegroup.ts");
/* harmony import */ var _gracetabnote__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./gracetabnote */ "./src/gracetabnote.ts");
/* harmony import */ var _keymanager__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./keymanager */ "./src/keymanager.ts");
/* harmony import */ var _keysignature__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./keysignature */ "./src/keysignature.ts");
/* harmony import */ var _keysignote__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./keysignote */ "./src/keysignote.ts");
/* harmony import */ var _modifier__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./modifier */ "./src/modifier.ts");
/* harmony import */ var _modifiercontext__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./modifiercontext */ "./src/modifiercontext.ts");
/* harmony import */ var _multimeasurerest__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./multimeasurerest */ "./src/multimeasurerest.ts");
/* harmony import */ var _music__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./music */ "./src/music.ts");
/* harmony import */ var _note__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./note */ "./src/note.ts");
/* harmony import */ var _notehead__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./notehead */ "./src/notehead.ts");
/* harmony import */ var _notesubgroup__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./notesubgroup */ "./src/notesubgroup.ts");
/* harmony import */ var _ornament__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./ornament */ "./src/ornament.ts");
/* harmony import */ var _parenthesis__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./parenthesis */ "./src/parenthesis.ts");
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./parser */ "./src/parser.ts");
/* harmony import */ var _pedalmarking__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./pedalmarking */ "./src/pedalmarking.ts");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./registry */ "./src/registry.ts");
/* harmony import */ var _rendercontext__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./rendercontext */ "./src/rendercontext.ts");
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./renderer */ "./src/renderer.ts");
/* harmony import */ var _repeatnote__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./repeatnote */ "./src/repeatnote.ts");
/* harmony import */ var _stave__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./stave */ "./src/stave.ts");
/* harmony import */ var _stavebarline__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./stavebarline */ "./src/stavebarline.ts");
/* harmony import */ var _staveconnector__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./staveconnector */ "./src/staveconnector.ts");
/* harmony import */ var _stavehairpin__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./stavehairpin */ "./src/stavehairpin.ts");
/* harmony import */ var _staveline__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./staveline */ "./src/staveline.ts");
/* harmony import */ var _stavemodifier__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./stavemodifier */ "./src/stavemodifier.ts");
/* harmony import */ var _stavenote__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./stavenote */ "./src/stavenote.ts");
/* harmony import */ var _staverepetition__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./staverepetition */ "./src/staverepetition.ts");
/* harmony import */ var _stavesection__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./stavesection */ "./src/stavesection.ts");
/* harmony import */ var _stavetempo__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./stavetempo */ "./src/stavetempo.ts");
/* harmony import */ var _stavetext__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./stavetext */ "./src/stavetext.ts");
/* harmony import */ var _stavetie__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./stavetie */ "./src/stavetie.ts");
/* harmony import */ var _stavevolta__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./stavevolta */ "./src/stavevolta.ts");
/* harmony import */ var _stem__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./stem */ "./src/stem.ts");
/* harmony import */ var _stemmablenote__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./stemmablenote */ "./src/stemmablenote.ts");
/* harmony import */ var _stringnumber__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./stringnumber */ "./src/stringnumber.ts");
/* harmony import */ var _strokes__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./strokes */ "./src/strokes.ts");
/* harmony import */ var _svgcontext__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./svgcontext */ "./src/svgcontext.ts");
/* harmony import */ var _system__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./system */ "./src/system.ts");
/* harmony import */ var _tabnote__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./tabnote */ "./src/tabnote.ts");
/* harmony import */ var _tabslide__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./tabslide */ "./src/tabslide.ts");
/* harmony import */ var _tabstave__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./tabstave */ "./src/tabstave.ts");
/* harmony import */ var _tabtie__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./tabtie */ "./src/tabtie.ts");
/* harmony import */ var _textbracket__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./textbracket */ "./src/textbracket.ts");
/* harmony import */ var _textdynamics__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./textdynamics */ "./src/textdynamics.ts");
/* harmony import */ var _textnote__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./textnote */ "./src/textnote.ts");
/* harmony import */ var _tickable__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./tickable */ "./src/tickable.ts");
/* harmony import */ var _tickcontext__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./tickcontext */ "./src/tickcontext.ts");
/* harmony import */ var _timesignature__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./timesignature */ "./src/timesignature.ts");
/* harmony import */ var _timesignote__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./timesignote */ "./src/timesignote.ts");
/* harmony import */ var _tremolo__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./tremolo */ "./src/tremolo.ts");
/* harmony import */ var _tuning__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./tuning */ "./src/tuning.ts");
/* harmony import */ var _tuplet__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./tuplet */ "./src/tuplet.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./util */ "./src/util.ts");
/* harmony import */ var _vex__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./vex */ "./src/vex.ts");
/* harmony import */ var _vibrato__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./vibrato */ "./src/vibrato.ts");
/* harmony import */ var _vibratobracket__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./vibratobracket */ "./src/vibratobracket.ts");
/* harmony import */ var _voice__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./voice */ "./src/voice.ts");
/* harmony import */ var _web__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./web */ "./src/web.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License



















// Do not export './fonts/*' because they are used by the entry/* files.













































// Do not export './tables' because it is internal. Its public API is accessible via Vex.Flow.*.
















// Do not export './version'. It is accessible via Vex.Flow.BUILD.







/***/ }),

/***/ "./src/keymanager.ts":
/*!***************************!*\
  !*** ./src/keymanager.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeyManager: () => (/* binding */ KeyManager)
/* harmony export */ });
/* harmony import */ var _music__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./music */ "./src/music.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
//
// ## Description
//
// This class implements diatonic key management.


class KeyManager {
    constructor(key) {
        this.music = new _music__WEBPACK_IMPORTED_MODULE_0__.Music();
        this.setKey(key);
    }
    setKey(key) {
        this.key = key;
        this.reset();
        return this;
    }
    getKey() {
        return this.key;
    }
    reset() {
        this.keyParts = this.music.getKeyParts(this.key);
        this.keyString = this.keyParts.root;
        if (this.keyParts.accidental)
            this.keyString += this.keyParts.accidental;
        const isSupportedType = _music__WEBPACK_IMPORTED_MODULE_0__.Music.scaleTypes[this.keyParts.type];
        if (!isSupportedType) {
            throw new _util__WEBPACK_IMPORTED_MODULE_1__.RuntimeError('BadArguments', `Unsupported key type: ${this.key}`);
        }
        this.scale = this.music.getScaleTones(this.music.getNoteValue(this.keyString), _music__WEBPACK_IMPORTED_MODULE_0__.Music.scaleTypes[this.keyParts.type]);
        this.scaleMap = {};
        this.scaleMapByValue = {};
        this.originalScaleMapByValue = {};
        const noteLocation = _music__WEBPACK_IMPORTED_MODULE_0__.Music.rootIndexes[this.keyParts.root];
        for (let i = 0; i < _music__WEBPACK_IMPORTED_MODULE_0__.Music.roots.length; ++i) {
            const index = (noteLocation + i) % _music__WEBPACK_IMPORTED_MODULE_0__.Music.roots.length;
            const rootName = _music__WEBPACK_IMPORTED_MODULE_0__.Music.roots[index];
            const noteName = this.music.getRelativeNoteName(rootName, this.scale[i]);
            this.scaleMap[rootName] = noteName;
            this.scaleMapByValue[this.scale[i]] = noteName;
            this.originalScaleMapByValue[this.scale[i]] = noteName;
        }
        return this;
    }
    getAccidental(key) {
        const root = this.music.getKeyParts(key).root;
        const parts = this.music.getNoteParts(this.scaleMap[root]);
        return {
            note: this.scaleMap[root],
            accidental: parts.accidental,
        };
    }
    selectNote(note) {
        note = note.toLowerCase();
        const parts = this.music.getNoteParts(note);
        // First look for matching note in our altered scale
        const scaleNote = this.scaleMap[parts.root];
        const modparts = this.music.getNoteParts(scaleNote);
        if (scaleNote === note) {
            return {
                note: scaleNote,
                accidental: parts.accidental,
                change: false,
            };
        }
        // Then search for a note of equivalent value in our altered scale
        const valueNote = this.scaleMapByValue[this.music.getNoteValue(note)];
        if (valueNote !== undefined) {
            return {
                note: valueNote,
                accidental: this.music.getNoteParts(valueNote).accidental,
                change: false,
            };
        }
        // Then search for a note of equivalent value in the original scale
        const originalValueNote = this.originalScaleMapByValue[this.music.getNoteValue(note)];
        if (originalValueNote !== undefined) {
            this.scaleMap[modparts.root] = originalValueNote;
            delete this.scaleMapByValue[this.music.getNoteValue(scaleNote)];
            this.scaleMapByValue[this.music.getNoteValue(note)] = originalValueNote;
            return {
                note: originalValueNote,
                accidental: this.music.getNoteParts(originalValueNote).accidental,
                change: true,
            };
        }
        // Then try to unmodify a currently modified note.
        if (modparts.root === note) {
            delete this.scaleMapByValue[this.music.getNoteValue(this.scaleMap[parts.root])];
            this.scaleMapByValue[this.music.getNoteValue(modparts.root)] = modparts.root;
            this.scaleMap[modparts.root] = modparts.root;
            return {
                note: modparts.root,
                accidental: undefined,
                change: true,
            };
        }
        // Last resort -- shitshoot
        delete this.scaleMapByValue[this.music.getNoteValue(this.scaleMap[parts.root])];
        this.scaleMapByValue[this.music.getNoteValue(note)] = note;
        delete this.scaleMap[modparts.root];
        this.scaleMap[modparts.root] = note;
        return {
            note,
            accidental: parts.accidental,
            change: true,
        };
    }
}


/***/ }),

/***/ "./src/keysignature.ts":
/*!*****************************!*\
  !*** ./src/keysignature.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeySignature: () => (/* binding */ KeySignature)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _stavemodifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stavemodifier */ "./src/stavemodifier.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// @author Cyril Silverman
//
// ## Description
//
// This file implements key signatures. A key signature sits on a stave
// and indicates the notes with implicit accidentals.





class KeySignature extends _stavemodifier__WEBPACK_IMPORTED_MODULE_1__.StaveModifier {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_3__.Category.KeySignature;
    }
    // Create a new Key Signature based on a `keySpec`
    constructor(keySpec, cancelKeySpec, alterKeySpec) {
        super();
        this.accList = [];
        this.setKeySig(keySpec, cancelKeySpec, alterKeySpec);
        this.setPosition(_stavemodifier__WEBPACK_IMPORTED_MODULE_1__.StaveModifierPosition.BEGIN);
        this.glyphs = [];
        this.paddingForced = false;
    }
    // Add an accidental glyph to the `KeySignature` instance which represents
    // the provided `acc`. If `nextAcc` is also provided, the appropriate
    // spacing will be included in the glyph's position
    convertToGlyph(acc, nextAcc, stave) {
        const code = _tables__WEBPACK_IMPORTED_MODULE_2__.Tables.accidentalCodes(acc.type);
        const glyph = new _element__WEBPACK_IMPORTED_MODULE_0__.Element(_typeguard__WEBPACK_IMPORTED_MODULE_3__.Category.KeySignature);
        glyph.setText(code);
        // Determine spacing between current accidental and the next accidental
        const extraWidth = 1;
        // Place the glyph on the stave
        glyph.setYShift(stave.getYForLine(acc.line));
        if (this.glyphs.length > 0) {
            const prevGlyph = this.glyphs[this.glyphs.length - 1];
            glyph.setXShift(prevGlyph.getXShift() + prevGlyph.getWidth() + extraWidth);
        }
        this.glyphs.push(glyph);
        // Expand size of key signature
        this.width += glyph.getWidth() + extraWidth;
    }
    // Cancel out a key signature provided in the `spec` parameter. This will
    // place appropriate natural accidentals before the key signature.
    cancelKey(spec) {
        this.formatted = false;
        this.cancelKeySpec = spec;
        return this;
    }
    convertToCancelAccList(spec) {
        // Get the accidental list for the cancelled key signature
        const cancelAccList = _tables__WEBPACK_IMPORTED_MODULE_2__.Tables.keySignature(spec);
        // If the cancelled key has a different accidental type, ie: # vs b
        const differentTypes = this.accList.length > 0 && cancelAccList.length > 0 && cancelAccList[0].type !== this.accList[0].type;
        // Determine how many naturals needed to add
        const naturals = differentTypes ? cancelAccList.length : cancelAccList.length - this.accList.length;
        // Return if no naturals needed
        if (naturals < 1)
            return undefined;
        // Get the line position for each natural
        const cancelled = [];
        for (let i = 0; i < naturals; i++) {
            let index = i;
            if (!differentTypes) {
                index = cancelAccList.length - naturals + i;
            }
            const acc = cancelAccList[index];
            cancelled.push({ type: 'n', line: acc.line });
        }
        // Combine naturals with main accidental list for the key signature
        this.accList = cancelled.concat(this.accList);
        return {
            accList: cancelled,
            type: cancelAccList[0].type,
        };
    }
    addToStave(stave) {
        this.paddingForced = true;
        stave.addModifier(this);
        return this;
    }
    // Apply the accidental staff line placement based on the `clef` and
    // the  accidental `type` for the key signature ('# or 'b').
    convertAccLines(clef, type, accList = this.accList) {
        let offset = 0.0; // if clef === "treble"
        let customLines; // when clef doesn't follow treble key sig shape
        switch (clef) {
            // Treble & Subbass both have offsets of 0, so are not included.
            case 'soprano':
                if (type === '#')
                    customLines = [2.5, 0.5, 2, 0, 1.5, -0.5, 1];
                else
                    offset = -1;
                break;
            case 'mezzo-soprano':
                if (type === 'b')
                    customLines = [0, 2, 0.5, 2.5, 1, 3, 1.5];
                else
                    offset = 1.5;
                break;
            case 'alto':
                offset = 0.5;
                break;
            case 'tenor':
                if (type === '#')
                    customLines = [3, 1, 2.5, 0.5, 2, 0, 1.5];
                else
                    offset = -0.5;
                break;
            case 'baritone-f':
            case 'baritone-c':
                if (type === 'b')
                    customLines = [0.5, 2.5, 1, 3, 1.5, 3.5, 2];
                else
                    offset = 2;
                break;
            case 'bass':
            case 'french':
                offset = 1;
                break;
            default:
                break;
        }
        // If there's a special case, assign those lines/spaces:
        let i;
        if (typeof customLines !== 'undefined') {
            for (i = 0; i < accList.length; ++i) {
                accList[i].line = customLines[i];
            }
        }
        else if (offset !== 0) {
            for (i = 0; i < accList.length; ++i) {
                accList[i].line += offset;
            }
        }
    }
    getPadding(index) {
        if (!this.formatted)
            this.format();
        return this.glyphs.length === 0 || (!this.paddingForced && index < 2) ? 0 : this.padding;
    }
    getWidth() {
        if (!this.formatted)
            this.format();
        return this.width;
    }
    setKeySig(keySpec, cancelKeySpec, alterKeySpec) {
        this.formatted = false;
        this.keySpec = keySpec;
        this.cancelKeySpec = cancelKeySpec;
        this.alterKeySpec = alterKeySpec;
        return this;
    }
    // Alter the accidentals of a key spec one by one.
    // Each alteration is a new accidental that replaces the
    // original accidental (or the canceled one).
    alterKey(alterKeySpec) {
        this.formatted = false;
        this.alterKeySpec = alterKeySpec;
        return this;
    }
    convertToAlterAccList(alterKeySpec) {
        const max = Math.min(alterKeySpec.length, this.accList.length);
        for (let i = 0; i < max; ++i) {
            if (alterKeySpec[i]) {
                this.accList[i].type = alterKeySpec[i];
            }
        }
    }
    format() {
        const stave = this.checkStave();
        this.width = 0;
        this.glyphs = [];
        this.accList = _tables__WEBPACK_IMPORTED_MODULE_2__.Tables.keySignature((0,_util__WEBPACK_IMPORTED_MODULE_4__.defined)(this.keySpec));
        const accList = this.accList;
        const firstAccidentalType = accList.length > 0 ? accList[0].type : undefined;
        let cancelAccList;
        if (this.cancelKeySpec) {
            cancelAccList = this.convertToCancelAccList(this.cancelKeySpec);
        }
        if (this.alterKeySpec) {
            this.convertToAlterAccList(this.alterKeySpec);
        }
        if (this.accList.length > 0) {
            const clef = (this.position === _stavemodifier__WEBPACK_IMPORTED_MODULE_1__.StaveModifierPosition.END ? stave.getEndClef() : stave.getClef()) || stave.getClef();
            if (cancelAccList) {
                this.convertAccLines(clef, cancelAccList.type, cancelAccList.accList);
            }
            this.convertAccLines(clef, firstAccidentalType, accList);
            for (let i = 0; i < this.accList.length; ++i) {
                this.convertToGlyph(this.accList[i], this.accList[i + 1], stave);
            }
        }
        this.formatted = true;
    }
    draw() {
        const stave = this.checkStave();
        const ctx = stave.checkContext();
        if (!this.formatted)
            this.format();
        this.setRendered();
        this.applyStyle(ctx);
        ctx.openGroup('keysignature', this.getAttribute('id'));
        for (let i = 0; i < this.glyphs.length; i++) {
            const glyph = this.glyphs[i];
            glyph.renderText(ctx, this.x, 0);
        }
        ctx.closeGroup();
        this.restoreStyle(ctx);
    }
}


/***/ }),

/***/ "./src/keysignote.ts":
/*!***************************!*\
  !*** ./src/keysignote.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeySigNote: () => (/* binding */ KeySigNote)
/* harmony export */ });
/* harmony import */ var _keysignature__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keysignature */ "./src/keysignature.ts");
/* harmony import */ var _note__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./note */ "./src/note.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// @author: Mark Meeus 2019



class KeySigNote extends _note__WEBPACK_IMPORTED_MODULE_1__.Note {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_2__.Category.KeySigNote;
    }
    constructor(keySpec, cancelKeySpec, alterKeySpec) {
        super({ duration: 'b' });
        this.keySignature = new _keysignature__WEBPACK_IMPORTED_MODULE_0__.KeySignature(keySpec, cancelKeySpec, alterKeySpec);
        // Note properties
        this.ignoreTicks = true;
    }
    /* Overridden to ignore */
    // eslint-disable-next-line
    addToModifierContext(mc) {
        // DO NOTHING.
        return this;
    }
    preFormat() {
        this.preFormatted = true;
        this.keySignature.setStave(this.checkStave());
        this.setWidth(this.keySignature.getWidth());
        return this;
    }
    draw() {
        const ctx = this.checkStave().checkContext();
        this.setRendered();
        this.keySignature.setX(this.getAbsoluteX());
        this.keySignature.setContext(ctx);
        this.keySignature.draw();
    }
}


/***/ }),

/***/ "./src/metrics.ts":
/*!************************!*\
  !*** ./src/metrics.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Metrics: () => (/* binding */ Metrics),
/* harmony export */   MetricsDefaults: () => (/* binding */ MetricsDefaults)
/* harmony export */ });
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
class Metrics {
    /** Use the provided key to look up a FontInfo in CommonMetrics. **/
    static getFontInfo(key) {
        return {
            family: Metrics.get(`${key}.fontFamily`),
            size: Metrics.get(`${key}.fontSize`) * Metrics.get(`${key}.fontScale`),
            weight: Metrics.get(`${key}.fontWeight`),
            style: Metrics.get(`${key}.fontStyle`),
        };
    }
    /**
     * Use the provided key to look up a value in CommonMetrics.
     *
     * @param key is a string separated by periods (e.g., `Stroke.text.fontFamily`).
     * @param defaultValue is returned if the lookup fails.
     * @returns the retrieved value (or `defaultValue` if the lookup fails).
     *
     * For the key `Stroke.text.fontFamily`, check all of the following in order:
     *   1) CommonMetrics.fontFamily
     *   2) CommonMetrics.Stroke.fontFamily
     *   3) CommonMetrics.Stroke.text.fontFamily
     * Retrieve the value from the most specific key (i.e., prefer #3 over #2 over #1 in the above example).
     */
    // eslint-disable-next-line
    static get(key, defaultValue) {
        var _a;
        const keyParts = key.split('.');
        const lastKeyPart = keyParts.pop(); // Use ! because keyParts is not empty, since ''.split('.') still returns [''].
        // Start from root of CommonMetrics and go down as far as possible.
        let curr = MetricsDefaults;
        let retVal = defaultValue;
        while (curr) {
            // Update retVal whenever we find a value assigned to a more specific key.
            retVal = (_a = curr[lastKeyPart]) !== null && _a !== void 0 ? _a : retVal;
            const keyPart = keyParts.shift();
            if (keyPart) {
                curr = curr[keyPart]; // Go down one level.
            }
            else {
                break;
            }
        }
        return retVal;
    }
}
// eslint-disable-next-line
const MetricsDefaults = {
    fontFamily: 'Bravura',
    fontSize: 30,
    fontScale: 1.0,
    fontWeight: 'normal',
    fontStyle: 'normal',
    Accidental: {
        cautionary: {
            fontSize: 20,
        },
        grace: {
            fontSize: 25,
        },
        noteheadAccidentalPadding: 1,
        leftPadding: 2,
        accidentalSpacing: 3,
    },
    Annotation: {
        fontSize: 10,
    },
    Bend: {
        fontSize: 10,
    },
    ChordSymbol: {
        fontSize: 12,
        spacing: 0.05,
        subscriptOffset: 0.2,
        superscriptOffset: -0.4,
        superSubRatio: 0.6,
    },
    FretHandFinger: {
        fontSize: 9,
        fontWeight: 'bold',
    },
    GraceNote: {
        fontScale: 2 / 3,
    },
    GraceTabNote: {
        fontScale: 2 / 3,
    },
    NoteHead: {
        minPadding: 2,
    },
    PedalMarking: {
        text: {
            fontSize: 12,
            fontStyle: 'italic',
        },
    },
    Repetition: {
        text: {
            fontSize: 12,
            fontWeight: 'bold',
            offsetX: 12,
            offsetY: 25,
            spacing: 5,
        },
        coda: {
            offsetY: 25,
        },
        segno: {
            offsetY: 10,
        },
    },
    Stave: {
        fontSize: 8,
        padding: 12,
        endPaddingMax: 10,
        endPaddingMin: 5,
        unalignedNotePadding: 10,
    },
    StaveConnector: {
        text: {
            fontSize: 16,
        },
    },
    StaveLine: {
        fontSize: 10,
    },
    StaveSection: {
        fontSize: 10,
        fontWeight: 'bold',
    },
    StaveTempo: {
        fontSize: 14,
        glyph: {
            fontSize: 25,
        },
        name: {
            fontWeight: 'bold',
        },
    },
    StaveText: {
        fontSize: 16,
    },
    StaveTie: {
        fontSize: 10,
    },
    StringNumber: {
        fontSize: 10,
        fontWeight: 'bold',
        verticalPadding: 8,
        stemPadding: 2,
        leftPadding: 5,
        rightPadding: 6,
    },
    Stroke: {
        text: {
            fontSize: 10,
            fontStyle: 'italic',
            fontWeight: 'bold',
        },
    },
    TabNote: {
        text: {
            fontSize: 9,
        },
    },
    TabSlide: {
        fontSize: 10,
        fontStyle: 'italic',
        fontWeight: 'bold',
    },
    TabTie: {
        fontSize: 10,
    },
    TextBracket: {
        fontSize: 15,
        fontStyle: 'italic',
    },
    TextNote: {
        text: {
            fontSize: 12,
        },
    },
    Tremolo: {
        spacing: 7,
    },
    Volta: {
        fontSize: 9,
        fontWeight: 'bold',
    },
};


/***/ }),

/***/ "./src/modifier.ts":
/*!*************************!*\
  !*** ./src/modifier.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Modifier: () => (/* binding */ Modifier),
/* harmony export */   ModifierPosition: () => (/* binding */ ModifierPosition)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Modifier_spacingFromNextModifier, _Modifier_modifierContext;



var ModifierPosition;
(function (ModifierPosition) {
    ModifierPosition[ModifierPosition["CENTER"] = 0] = "CENTER";
    ModifierPosition[ModifierPosition["LEFT"] = 1] = "LEFT";
    ModifierPosition[ModifierPosition["RIGHT"] = 2] = "RIGHT";
    ModifierPosition[ModifierPosition["ABOVE"] = 3] = "ABOVE";
    ModifierPosition[ModifierPosition["BELOW"] = 4] = "BELOW";
})(ModifierPosition || (ModifierPosition = {}));
// To enable logging for this class. Set `Vex.Flow.Modifier.DEBUG` to `true`.
// function L(...args) { if (Modifier.DEBUG) log('Vex.Flow.Modifier', args); }
/**
 * `Modifier` is an abstract interface for notational elements that modify
 * a `Note`. Examples of modifiers are `Accidental`, `Annotation`, `Stroke`, etc.
 *
 * For a `Modifier` instance to be positioned correctly, it must be part of
 * a `ModifierContext`. All modifiers in the same context are rendered relative to
 * one another.
 *
 * Typically, all modifiers to a note are part of the same `ModifierContext` instance. Also,
 * in multi-voice staves, all modifiers to notes on the same `tick` are part of the same
 * `ModifierContext`. This ensures that multiple voices don't trample all over each other.
 */
class Modifier extends _element__WEBPACK_IMPORTED_MODULE_0__.Element {
    /**
     * Modifiers category string. Every modifier has a different category.
     * The `ModifierContext` uses this to determine the type and order of the modifiers.
     */
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_1__.Category.Modifier;
    }
    /** Modifiers can be positioned almost anywhere, relative to a note. */
    static get Position() {
        return ModifierPosition;
    }
    static get PositionString() {
        return {
            center: ModifierPosition.CENTER,
            above: ModifierPosition.ABOVE,
            below: ModifierPosition.BELOW,
            left: ModifierPosition.LEFT,
            right: ModifierPosition.RIGHT,
        };
    }
    constructor() {
        super();
        _Modifier_spacingFromNextModifier.set(this, void 0);
        _Modifier_modifierContext.set(this, void 0);
        this.width = 0;
        // The `textLine` is reserved space above or below a stave.
        this.textLine = 0;
        this.position = Modifier.Position.LEFT;
        __classPrivateFieldSet(this, _Modifier_spacingFromNextModifier, 0, "f");
    }
    /** Called when position changes. */
    reset() {
        // DO NOTHING.
    }
    /** Get attached note (`StaveNote`, `TabNote`, etc.) */
    getNote() {
        return (0,_util__WEBPACK_IMPORTED_MODULE_2__.defined)(this.note, 'NoNote', 'Modifier has no note.');
    }
    /**
     * Used in draw() to check and get the attached note (`StaveNote`, `TabNote`, etc.).
     * Also verifies that the index is valid.
     */
    checkAttachedNote() {
        const category = this.getCategory();
        (0,_util__WEBPACK_IMPORTED_MODULE_2__.defined)(this.index, 'NoIndex', `Can't draw ${category} without an index.`);
        return (0,_util__WEBPACK_IMPORTED_MODULE_2__.defined)(this.note, 'NoNote', `Can't draw ${category} without a note.`);
    }
    /**
     * Set attached note.
     * @param note (`StaveNote`, `TabNote`, etc.)
     */
    setNote(note) {
        this.note = note;
        return this;
    }
    /** Get note index, which is a specific note in a chord. */
    getIndex() {
        return this.index;
    }
    /** Check and get note index, which is a specific note in a chord. */
    checkIndex() {
        return (0,_util__WEBPACK_IMPORTED_MODULE_2__.defined)(this.index, 'NoIndex', 'Modifier has an invalid index.');
    }
    /** Set note index, which is a specific note in a chord. */
    setIndex(index) {
        this.index = index;
        return this;
    }
    /** Get `ModifierContext`. */
    getModifierContext() {
        return __classPrivateFieldGet(this, _Modifier_modifierContext, "f");
    }
    /** Check and get `ModifierContext`. */
    checkModifierContext() {
        return (0,_util__WEBPACK_IMPORTED_MODULE_2__.defined)(__classPrivateFieldGet(this, _Modifier_modifierContext, "f"), 'NoModifierContext', 'Modifier Context Required');
    }
    /** Every modifier must be part of a `ModifierContext`. */
    setModifierContext(c) {
        __classPrivateFieldSet(this, _Modifier_modifierContext, c, "f");
        return this;
    }
    /** Get position. */
    getPosition() {
        return this.position;
    }
    /**
     * Set position.
     * @param position CENTER | LEFT | RIGHT | ABOVE | BELOW
     */
    setPosition(position) {
        this.position = typeof position === 'string' ? Modifier.PositionString[position] : position;
        this.reset();
        return this;
    }
    /** Set the `textLine` for the modifier. */
    setTextLine(line) {
        this.textLine = line;
        return this;
    }
    /** Shift modifier down `y` pixels. Negative values shift up. */
    setYShift(y) {
        this.yShift = y;
        return this;
    }
    /** Set spacing from next modifier. */
    setSpacingFromNextModifier(x) {
        __classPrivateFieldSet(this, _Modifier_spacingFromNextModifier, x, "f");
    }
    /** Get spacing from next modifier. */
    getSpacingFromNextModifier() {
        return __classPrivateFieldGet(this, _Modifier_spacingFromNextModifier, "f");
    }
    /**
     * Shift modifier `x` pixels in the direction of the modifier. Negative values
     * shift reverse.
     */
    setXShift(x) {
        this.xShift = 0;
        if (this.position === Modifier.Position.LEFT) {
            this.xShift -= x;
        }
        else {
            this.xShift += x;
        }
        return this;
    }
    /** Get shift modifier `x` */
    getXShift() {
        return this.xShift;
    }
    /** Render the modifier onto the canvas. */
    draw() {
        this.checkContext();
        throw new _util__WEBPACK_IMPORTED_MODULE_2__.RuntimeError('NotImplemented', 'draw() not implemented for this modifier.');
    }
    // aligns sub notes of NoteSubGroup (or GraceNoteGroup) to the main note with correct x-offset
    alignSubNotesWithNote(subNotes, note) {
        // Shift over the tick contexts of each note
        const tickContext = note.getTickContext();
        const metrics = tickContext.getMetrics();
        const stave = note.getStave();
        const subNoteXOffset = tickContext.getX() - metrics.modLeftPx - metrics.modRightPx + this.getSpacingFromNextModifier();
        subNotes.forEach((subNote) => {
            const subTickContext = subNote.getTickContext();
            if (stave)
                subNote.setStave(stave);
            subTickContext.setXOffset(subNoteXOffset); // don't touch baseX to avoid shift each render
        });
    }
}
_Modifier_spacingFromNextModifier = new WeakMap(), _Modifier_modifierContext = new WeakMap();


/***/ }),

/***/ "./src/modifiercontext.ts":
/*!********************************!*\
  !*** ./src/modifiercontext.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ModifierContext: () => (/* binding */ ModifierContext)
/* harmony export */ });
/* harmony import */ var _accidental__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./accidental */ "./src/accidental.ts");
/* harmony import */ var _annotation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./annotation */ "./src/annotation.ts");
/* harmony import */ var _articulation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./articulation */ "./src/articulation.ts");
/* harmony import */ var _bend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bend */ "./src/bend.ts");
/* harmony import */ var _chordsymbol__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chordsymbol */ "./src/chordsymbol.ts");
/* harmony import */ var _dot__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dot */ "./src/dot.ts");
/* harmony import */ var _frethandfinger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./frethandfinger */ "./src/frethandfinger.ts");
/* harmony import */ var _gracenotegroup__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./gracenotegroup */ "./src/gracenotegroup.ts");
/* harmony import */ var _notesubgroup__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./notesubgroup */ "./src/notesubgroup.ts");
/* harmony import */ var _ornament__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ornament */ "./src/ornament.ts");
/* harmony import */ var _parenthesis__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./parenthesis */ "./src/parenthesis.ts");
/* harmony import */ var _stavenote__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./stavenote */ "./src/stavenote.ts");
/* harmony import */ var _stringnumber__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./stringnumber */ "./src/stringnumber.ts");
/* harmony import */ var _strokes__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./strokes */ "./src/strokes.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./util */ "./src/util.ts");
/* harmony import */ var _vibrato__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./vibrato */ "./src/vibrato.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
//
// ## Description
//
// This class implements various types of members to notes (e.g. bends,
// fingering positions etc.).  The ModifierContext works with tickables
// that are at the same tick to ensure that they and their modifiers
// all have proper alignment.  (Note that the ModifierContext also
// runs the spacing of the tickable).
//
// see https://github.com/0xfe/vexflow/wiki/How-Formatting-Works

















// To enable logging for this class. Set `Vex.Flow.ModifierContext.DEBUG` to `true`.
// eslint-disable-next-line
function L(...args) {
    if (ModifierContext.DEBUG)
        (0,_util__WEBPACK_IMPORTED_MODULE_15__.log)('Vex.Flow.ModifierContext', args);
}
class ModifierContext {
    constructor() {
        // Formatting data.
        this.state = {
            leftShift: 0,
            rightShift: 0,
            textLine: 0,
            topTextLine: 0,
        };
        // Current members -- a mapping of Category (string) to a list of Tickables, Modifiers,
        // StaveNotes, TabNotes, etc.
        this.members = {};
        this.preFormatted = false;
        this.postFormatted = false;
        this.formatted = false;
        this.width = 0;
        this.spacing = 0;
    }
    addModifier(member) {
        L('addModifier is deprecated, use addMember instead.');
        return this.addMember(member);
    }
    /**
     * this.members maps CATEGORY strings to arrays of Tickable | Modifier | StaveNote | TabNote.
     * Here we add a new member to this.members, and create a new array if needed.
     * @param member
     * @returns this
     */
    addMember(member) {
        const category = member.getCategory();
        if (!this.members[category]) {
            this.members[category] = [];
        }
        this.members[category].push(member);
        member.setModifierContext(this);
        this.preFormatted = false;
        return this;
    }
    /**
     * @deprecated
     */
    getModifiers(category) {
        L('getModifiers is deprecated, use getMembers instead.');
        return this.getMembers(category);
    }
    getMembers(category) {
        var _a;
        return (_a = this.members[category]) !== null && _a !== void 0 ? _a : [];
    }
    /**
     * Get the width of the entire
     */
    getWidth() {
        return this.width;
    }
    getLeftShift() {
        return this.state.leftShift;
    }
    getRightShift() {
        return this.state.rightShift;
    }
    getState() {
        return this.state;
    }
    getMetrics() {
        if (!this.formatted) {
            throw new _util__WEBPACK_IMPORTED_MODULE_15__.RuntimeError('UnformattedMember', 'Unformatted member has no metrics.');
        }
        return {
            width: this.state.leftShift + this.state.rightShift + this.spacing,
            spacing: this.spacing,
        };
    }
    preFormat() {
        if (this.preFormatted)
            return;
        L('Preformatting ModifierContext');
        const state = this.state;
        const members = this.members;
        // The ordering below determines when different members are formatted and rendered.
        _stavenote__WEBPACK_IMPORTED_MODULE_11__.StaveNote.format(members[_typeguard__WEBPACK_IMPORTED_MODULE_14__.Category.StaveNote], state);
        _parenthesis__WEBPACK_IMPORTED_MODULE_10__.Parenthesis.format(members[_typeguard__WEBPACK_IMPORTED_MODULE_14__.Category.Parenthesis], state);
        _dot__WEBPACK_IMPORTED_MODULE_5__.Dot.format(members[_typeguard__WEBPACK_IMPORTED_MODULE_14__.Category.Dot], state);
        _frethandfinger__WEBPACK_IMPORTED_MODULE_6__.FretHandFinger.format(members[_typeguard__WEBPACK_IMPORTED_MODULE_14__.Category.FretHandFinger], state);
        _accidental__WEBPACK_IMPORTED_MODULE_0__.Accidental.format(members[_typeguard__WEBPACK_IMPORTED_MODULE_14__.Category.Accidental], state);
        _strokes__WEBPACK_IMPORTED_MODULE_13__.Stroke.format(members[_typeguard__WEBPACK_IMPORTED_MODULE_14__.Category.Stroke], state);
        _gracenotegroup__WEBPACK_IMPORTED_MODULE_7__.GraceNoteGroup.format(members[_typeguard__WEBPACK_IMPORTED_MODULE_14__.Category.GraceNoteGroup], state);
        _notesubgroup__WEBPACK_IMPORTED_MODULE_8__.NoteSubGroup.format(members[_typeguard__WEBPACK_IMPORTED_MODULE_14__.Category.NoteSubGroup], state);
        _stringnumber__WEBPACK_IMPORTED_MODULE_12__.StringNumber.format(members[_typeguard__WEBPACK_IMPORTED_MODULE_14__.Category.StringNumber], state);
        _articulation__WEBPACK_IMPORTED_MODULE_2__.Articulation.format(members[_typeguard__WEBPACK_IMPORTED_MODULE_14__.Category.Articulation], state);
        _ornament__WEBPACK_IMPORTED_MODULE_9__.Ornament.format(members[_typeguard__WEBPACK_IMPORTED_MODULE_14__.Category.Ornament], state);
        _annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation.format(members[_typeguard__WEBPACK_IMPORTED_MODULE_14__.Category.Annotation], state);
        _chordsymbol__WEBPACK_IMPORTED_MODULE_4__.ChordSymbol.format(members[_typeguard__WEBPACK_IMPORTED_MODULE_14__.Category.ChordSymbol], state);
        _bend__WEBPACK_IMPORTED_MODULE_3__.Bend.format(members[_typeguard__WEBPACK_IMPORTED_MODULE_14__.Category.Bend], state);
        _vibrato__WEBPACK_IMPORTED_MODULE_16__.Vibrato.format(members[_typeguard__WEBPACK_IMPORTED_MODULE_14__.Category.Vibrato], state, this);
        // Update width of this member context
        this.width = state.leftShift + state.rightShift;
        this.preFormatted = true;
    }
    postFormat() {
        if (this.postFormatted)
            return;
        L('Postformatting ModifierContext');
        // If post-formatting is required for an element, add more lines below.
        _stavenote__WEBPACK_IMPORTED_MODULE_11__.StaveNote.postFormat(this.getMembers(_typeguard__WEBPACK_IMPORTED_MODULE_14__.Category.StaveNote));
    }
}
ModifierContext.DEBUG = false;


/***/ }),

/***/ "./src/multimeasurerest.ts":
/*!*********************************!*\
  !*** ./src/multimeasurerest.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MultiMeasureRest: () => (/* binding */ MultiMeasureRest)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./metrics */ "./src/metrics.ts");
/* harmony import */ var _stavemodifier__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stavemodifier */ "./src/stavemodifier.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
//
// This class implements multiple measure rests.
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _MultiMeasureRest_hasPaddingLeft, _MultiMeasureRest_hasPaddingRight, _MultiMeasureRest_hasLineThickness, _MultiMeasureRest_hasSymbolSpacing;






class MultiMeasureRest extends _element__WEBPACK_IMPORTED_MODULE_0__.Element {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_4__.Category.MultiMeasureRest;
    }
    /**
     *
     * @param numberOfMeasures Number of measures.
     * @param options The options object.
     */
    constructor(numberOfMeasures, options) {
        var _a;
        super();
        this.xs = { left: NaN, right: NaN };
        _MultiMeasureRest_hasPaddingLeft.set(this, false);
        _MultiMeasureRest_hasPaddingRight.set(this, false);
        _MultiMeasureRest_hasLineThickness.set(this, false);
        _MultiMeasureRest_hasSymbolSpacing.set(this, false);
        const fontSize = (_a = options.numberGlyphPoint) !== null && _a !== void 0 ? _a : _metrics__WEBPACK_IMPORTED_MODULE_1__.Metrics.get('MultiMeasureRest.fontSize'); // same as TimeSignature.
        this.fontInfo.size = fontSize;
        this.numberOfMeasures = numberOfMeasures;
        this.text = '';
        const t = `${this.numberOfMeasures}`;
        for (const digit of t) {
            // 0xe080 is timeSig0. We calculate the code point for timeSigN to assemble the digits via SMuFL glyphs.
            this.text += String.fromCodePoint(0xe080 + Number(digit));
        }
        // Keep track of whether these four options were provided.
        __classPrivateFieldSet(this, _MultiMeasureRest_hasPaddingLeft, typeof options.paddingLeft === 'number', "f");
        __classPrivateFieldSet(this, _MultiMeasureRest_hasPaddingRight, typeof options.paddingRight === 'number', "f");
        __classPrivateFieldSet(this, _MultiMeasureRest_hasLineThickness, typeof options.lineThickness === 'number', "f");
        __classPrivateFieldSet(this, _MultiMeasureRest_hasSymbolSpacing, typeof options.symbolSpacing === 'number', "f");
        this.renderOptions = Object.assign({ useSymbols: false, showNumber: true, numberLine: -0.5, numberGlyphPoint: fontSize, line: 2, spacingBetweenLinesPx: _tables__WEBPACK_IMPORTED_MODULE_3__.Tables.STAVE_LINE_DISTANCE, serifThickness: 2, semibreveRestGlyphScale: _metrics__WEBPACK_IMPORTED_MODULE_1__.Metrics.get('fontSize'), paddingLeft: 0, paddingRight: 0, lineThickness: 5, symbolSpacing: 0 }, options);
    }
    getXs() {
        return this.xs;
    }
    setStave(stave) {
        this.stave = stave;
        return this;
    }
    getStave() {
        return this.stave;
    }
    checkStave() {
        return (0,_util__WEBPACK_IMPORTED_MODULE_5__.defined)(this.stave, 'NoStave', 'No stave attached to instance.');
    }
    drawLine(stave, ctx, left, right) {
        const options = this.renderOptions;
        const y = stave.getYForLine(options.line);
        const padding = (right - left) * 0.1;
        left += padding;
        right -= padding;
        let txt = '\ue4ef'; /*restHBarLeft*/
        const el = new _element__WEBPACK_IMPORTED_MODULE_0__.Element();
        el.setText(txt);
        // Add middle bars until the right padding is reached
        for (let i = 1; (i + 2) * el.getWidth() + left <= right; i++) {
            txt += '\ue4f0'; /*restHBarMiddle*/
        }
        txt += '\ue4f1'; /*restHBarRight*/
        el.setText(txt);
        el.renderText(ctx, left + (right - left) * 0.5 - el.getWidth() * 0.5, y);
    }
    drawSymbols(stave, ctx, left, right) {
        const n4 = Math.floor(this.numberOfMeasures / 4);
        const n = this.numberOfMeasures % 4;
        const n2 = Math.floor(n / 2);
        const n1 = n % 2;
        const options = this.renderOptions;
        const elMiddle = new _element__WEBPACK_IMPORTED_MODULE_0__.Element();
        let txt = '';
        for (let i = 0; i < n4; ++i) {
            txt += '\ue4e1' /*restLonga*/ + ' ';
        }
        for (let i = 0; i < n2; ++i) {
            txt += '\ue4e2' /*restDoubleWhole*/ + ' ';
        }
        elMiddle.setText(txt);
        const elTop = new _element__WEBPACK_IMPORTED_MODULE_0__.Element();
        txt = '';
        for (let i = 0; i < n1; ++i) {
            txt += '\ue4e3' /*restWhole*/ + ' ';
        }
        elTop.setText(txt);
        const width = elMiddle.getWidth() + elTop.getWidth();
        let x = left + (right - left) * 0.5 - width * 0.5;
        const line = options.line;
        const yTop = stave.getYForLine(line - 1);
        const yMiddle = stave.getYForLine(line);
        elMiddle.renderText(ctx, x, yMiddle);
        x += elMiddle.getWidth();
        elTop.renderText(ctx, x, yTop);
        x += elTop.getWidth();
    }
    draw() {
        const ctx = this.checkContext();
        this.setRendered();
        const stave = this.checkStave();
        let left = stave.getNoteStartX();
        let right = stave.getNoteEndX();
        // FIXME: getNoteStartX() returns x + 5(barline width)
        //        getNoteEndX() returns x + width(no barline width)
        // See Stave constructor. How do we fix this?
        // Here, we subtract the barline width.
        const begModifiers = stave.getModifiers(_stavemodifier__WEBPACK_IMPORTED_MODULE_2__.StaveModifierPosition.BEGIN);
        if (begModifiers.length === 1 && (0,_typeguard__WEBPACK_IMPORTED_MODULE_4__.isBarline)(begModifiers[0])) {
            left -= begModifiers[0].getWidth();
        }
        const options = this.renderOptions;
        if (__classPrivateFieldGet(this, _MultiMeasureRest_hasPaddingLeft, "f")) {
            left = stave.getX() + options.paddingLeft;
        }
        if (__classPrivateFieldGet(this, _MultiMeasureRest_hasPaddingRight, "f")) {
            right = stave.getX() + stave.getWidth() - options.paddingRight;
        }
        this.xs.left = left;
        this.xs.right = right;
        if (options.useSymbols) {
            this.drawSymbols(stave, ctx, left, right);
        }
        else {
            this.drawLine(stave, ctx, left, right);
        }
        if (options.showNumber) {
            this.renderText(ctx, left + (right - left) * 0.5 - this.width * 0.5, stave.getYForLine(options.numberLine) - this.height * 0.5);
        }
    }
}
_MultiMeasureRest_hasPaddingLeft = new WeakMap(), _MultiMeasureRest_hasPaddingRight = new WeakMap(), _MultiMeasureRest_hasLineThickness = new WeakMap(), _MultiMeasureRest_hasSymbolSpacing = new WeakMap();


/***/ }),

/***/ "./src/music.ts":
/*!**********************!*\
  !*** ./src/music.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Music: () => (/* binding */ Music)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License

/** Music implements some standard music theory routines. */
class Music {
    /** Number of an canonical notes (12). */
    static get NUM_TONES() {
        return this.canonicalNotes.length;
    }
    /** Names of root notes ('c', 'd',...) */
    static get roots() {
        return ['c', 'd', 'e', 'f', 'g', 'a', 'b'];
    }
    /** Values of the root notes.*/
    static get rootValues() {
        return [0, 2, 4, 5, 7, 9, 11];
    }
    /** Indexes of the root notes.*/
    static get rootIndexes() {
        return {
            c: 0,
            d: 1,
            e: 2,
            f: 3,
            g: 4,
            a: 5,
            b: 6,
        };
    }
    /** Names of canonical notes ('c', 'c#', 'd',...). */
    static get canonicalNotes() {
        return ['c', 'c#', 'd', 'd#', 'e', 'f', 'f#', 'g', 'g#', 'a', 'a#', 'b'];
    }
    /** Names of diatonic intervals ('unison', 'm2', 'M2',...). */
    static get diatonicIntervals() {
        return ['unison', 'm2', 'M2', 'm3', 'M3', 'p4', 'dim5', 'p5', 'm6', 'M6', 'b7', 'M7', 'octave'];
    }
    /** NoteAccidental associated to diatonic intervals. */
    static get diatonicAccidentals() {
        return {
            unison: { note: 0, accidental: 0 },
            m2: { note: 1, accidental: -1 },
            M2: { note: 1, accidental: 0 },
            m3: { note: 2, accidental: -1 },
            M3: { note: 2, accidental: 0 },
            p4: { note: 3, accidental: 0 },
            dim5: { note: 4, accidental: -1 },
            p5: { note: 4, accidental: 0 },
            m6: { note: 5, accidental: -1 },
            M6: { note: 5, accidental: 0 },
            b7: { note: 6, accidental: -1 },
            M7: { note: 6, accidental: 0 },
            octave: { note: 7, accidental: 0 },
        };
    }
    /** Semitones shift associated to intervals .*/
    static get intervals() {
        return {
            u: 0,
            unison: 0,
            m2: 1,
            b2: 1,
            min2: 1,
            S: 1,
            H: 1,
            2: 2,
            M2: 2,
            maj2: 2,
            T: 2,
            W: 2,
            m3: 3,
            b3: 3,
            min3: 3,
            M3: 4,
            3: 4,
            maj3: 4,
            4: 5,
            p4: 5,
            '#4': 6,
            b5: 6,
            aug4: 6,
            dim5: 6,
            5: 7,
            p5: 7,
            '#5': 8,
            b6: 8,
            aug5: 8,
            6: 9,
            M6: 9,
            maj6: 9,
            b7: 10,
            m7: 10,
            min7: 10,
            dom7: 10,
            M7: 11,
            maj7: 11,
            8: 12,
            octave: 12,
        };
    }
    /** Semitones shifts associated with scales. */
    static get scales() {
        return {
            major: [2, 2, 1, 2, 2, 2, 1],
            minor: [2, 1, 2, 2, 1, 2, 2],
            ionian: [2, 2, 1, 2, 2, 2, 1],
            dorian: [2, 1, 2, 2, 2, 1, 2],
            phyrgian: [1, 2, 2, 2, 1, 2, 2],
            lydian: [2, 2, 2, 1, 2, 2, 1],
            mixolydian: [2, 2, 1, 2, 2, 1, 2],
            aeolian: [2, 1, 2, 2, 1, 2, 2],
            locrian: [1, 2, 2, 1, 2, 2, 2],
        };
    }
    /** Scales associated with m (minor) and M (major). */
    static get scaleTypes() {
        return {
            M: Music.scales.major,
            m: Music.scales.minor,
        };
    }
    /** Accidentals abbreviations. */
    static get accidentals() {
        return ['bb', 'b', 'n', '#', '##'];
    }
    /** Note values. */
    static get noteValues() {
        return {
            c: { rootIndex: 0, intVal: 0 },
            cn: { rootIndex: 0, intVal: 0 },
            'c#': { rootIndex: 0, intVal: 1 },
            'c##': { rootIndex: 0, intVal: 2 },
            cb: { rootIndex: 0, intVal: 11 },
            cbb: { rootIndex: 0, intVal: 10 },
            d: { rootIndex: 1, intVal: 2 },
            dn: { rootIndex: 1, intVal: 2 },
            'd#': { rootIndex: 1, intVal: 3 },
            'd##': { rootIndex: 1, intVal: 4 },
            db: { rootIndex: 1, intVal: 1 },
            dbb: { rootIndex: 1, intVal: 0 },
            e: { rootIndex: 2, intVal: 4 },
            en: { rootIndex: 2, intVal: 4 },
            'e#': { rootIndex: 2, intVal: 5 },
            'e##': { rootIndex: 2, intVal: 6 },
            eb: { rootIndex: 2, intVal: 3 },
            ebb: { rootIndex: 2, intVal: 2 },
            f: { rootIndex: 3, intVal: 5 },
            fn: { rootIndex: 3, intVal: 5 },
            'f#': { rootIndex: 3, intVal: 6 },
            'f##': { rootIndex: 3, intVal: 7 },
            fb: { rootIndex: 3, intVal: 4 },
            fbb: { rootIndex: 3, intVal: 3 },
            g: { rootIndex: 4, intVal: 7 },
            gn: { rootIndex: 4, intVal: 7 },
            'g#': { rootIndex: 4, intVal: 8 },
            'g##': { rootIndex: 4, intVal: 9 },
            gb: { rootIndex: 4, intVal: 6 },
            gbb: { rootIndex: 4, intVal: 5 },
            a: { rootIndex: 5, intVal: 9 },
            an: { rootIndex: 5, intVal: 9 },
            'a#': { rootIndex: 5, intVal: 10 },
            'a##': { rootIndex: 5, intVal: 11 },
            ab: { rootIndex: 5, intVal: 8 },
            abb: { rootIndex: 5, intVal: 7 },
            b: { rootIndex: 6, intVal: 11 },
            bn: { rootIndex: 6, intVal: 11 },
            'b#': { rootIndex: 6, intVal: 0 },
            'b##': { rootIndex: 6, intVal: 1 },
            bb: { rootIndex: 6, intVal: 10 },
            bbb: { rootIndex: 6, intVal: 9 },
        };
    }
    isValidNoteValue(note) {
        return note >= 0 && note < Music.canonicalNotes.length;
    }
    isValidIntervalValue(interval) {
        return interval >= 0 && interval < Music.diatonicIntervals.length;
    }
    /** Return root and accidental associated to a note. */
    getNoteParts(noteString) {
        if (!noteString || noteString.length < 1) {
            throw new _util__WEBPACK_IMPORTED_MODULE_0__.RuntimeError('BadArguments', 'Invalid note name: ' + noteString);
        }
        if (noteString.length > 3) {
            throw new _util__WEBPACK_IMPORTED_MODULE_0__.RuntimeError('BadArguments', 'Invalid note name: ' + noteString);
        }
        const note = noteString.toLowerCase();
        const regex = /^([cdefgab])(b|bb|n|#|##)?$/;
        const match = regex.exec(note);
        if (match !== null) {
            const root = match[1];
            const accidental = match[2];
            return {
                root,
                accidental,
            };
        }
        else {
            throw new _util__WEBPACK_IMPORTED_MODULE_0__.RuntimeError('BadArguments', 'Invalid note name: ' + noteString);
        }
    }
    /** Return root, accidental and type associated to a key. */
    getKeyParts(keyString) {
        if (!keyString || keyString.length < 1) {
            throw new _util__WEBPACK_IMPORTED_MODULE_0__.RuntimeError('BadArguments', 'Invalid key: ' + keyString);
        }
        const key = keyString.toLowerCase();
        // Support Major, Minor, Melodic Minor, and Harmonic Minor key types.
        const regex = /^([cdefgab])(b|#)?(mel|harm|m|M)?$/;
        const match = regex.exec(key);
        if (match !== null) {
            const root = match[1];
            const accidental = match[2];
            let type = match[3];
            // Unspecified type implies major
            if (!type)
                type = 'M';
            return {
                root,
                accidental,
                type,
            };
        }
        else {
            throw new _util__WEBPACK_IMPORTED_MODULE_0__.RuntimeError('BadArguments', `Invalid key: ${keyString}`);
        }
    }
    /** Note value associated to a note name. */
    getNoteValue(noteString) {
        const value = Music.noteValues[noteString];
        if (value === undefined) {
            throw new _util__WEBPACK_IMPORTED_MODULE_0__.RuntimeError('BadArguments', `Invalid note name: ${noteString}`);
        }
        return value.intVal;
    }
    /** Interval value associated to an interval name. */
    getIntervalValue(intervalString) {
        const value = Music.intervals[intervalString];
        if (value === undefined) {
            throw new _util__WEBPACK_IMPORTED_MODULE_0__.RuntimeError('BadArguments', `Invalid interval name: ${intervalString}`);
        }
        return value;
    }
    /** Canonical note name associated to a value. */
    getCanonicalNoteName(noteValue) {
        if (!this.isValidNoteValue(noteValue)) {
            throw new _util__WEBPACK_IMPORTED_MODULE_0__.RuntimeError('BadArguments', `Invalid note value: ${noteValue}`);
        }
        return Music.canonicalNotes[noteValue];
    }
    /** Interval name associated to a value. */
    getCanonicalIntervalName(intervalValue) {
        if (!this.isValidIntervalValue(intervalValue)) {
            throw new _util__WEBPACK_IMPORTED_MODULE_0__.RuntimeError('BadArguments', `Invalid interval value: ${intervalValue}`);
        }
        return Music.diatonicIntervals[intervalValue];
    }
    /**
     * Given a note, interval, and interval direction, produce the relative note.
     */
    getRelativeNoteValue(noteValue, intervalValue, direction = 1) {
        if (direction !== 1 && direction !== -1) {
            throw new _util__WEBPACK_IMPORTED_MODULE_0__.RuntimeError('BadArguments', `Invalid direction: ${direction}`);
        }
        let sum = (noteValue + direction * intervalValue) % Music.NUM_TONES;
        if (sum < 0)
            sum += Music.NUM_TONES;
        return sum;
    }
    /**
     * Given a root and note value, produce the relative note name.
     */
    getRelativeNoteName(root, noteValue) {
        const parts = this.getNoteParts(root);
        const rootValue = this.getNoteValue(parts.root);
        let interval = noteValue - rootValue;
        if (Math.abs(interval) > Music.NUM_TONES - 3) {
            let multiplier = 1;
            if (interval > 0)
                multiplier = -1;
            // Possibly wrap around. (Add +1 for modulo operator)
            const reverseInterval = ((noteValue + 1 + (rootValue + 1)) % Music.NUM_TONES) * multiplier;
            if (Math.abs(reverseInterval) > 2) {
                throw new _util__WEBPACK_IMPORTED_MODULE_0__.RuntimeError('BadArguments', `Notes not related: ${root}, ${noteValue})`);
            }
            else {
                interval = reverseInterval;
            }
        }
        if (Math.abs(interval) > 2) {
            throw new _util__WEBPACK_IMPORTED_MODULE_0__.RuntimeError('BadArguments', `Notes not related: ${root}, ${noteValue})`);
        }
        let relativeNoteName = parts.root;
        if (interval > 0) {
            for (let i = 1; i <= interval; ++i) {
                relativeNoteName += '#';
            }
        }
        else if (interval < 0) {
            for (let i = -1; i >= interval; --i) {
                relativeNoteName += 'b';
            }
        }
        return relativeNoteName;
    }
    /**
     * Return scale tones, given intervals. Each successive interval is
     * relative to the previous one, e.g., Major Scale:
     *
     *   TTSTTTS = [2,2,1,2,2,2,1]
     *
     * When used with key = 0, returns C scale (which is isomorphic to
     * interval list).
     */
    getScaleTones(key, intervals) {
        const tones = [key];
        let nextNote = key;
        for (let i = 0; i < intervals.length; i++) {
            nextNote = this.getRelativeNoteValue(nextNote, intervals[i]);
            if (nextNote !== key)
                tones.push(nextNote);
        }
        return tones;
    }
    /**
     * Return the interval of a note, given a diatonic scale.
     * e.g., given the scale C, and the note E, returns M3.
     */
    getIntervalBetween(note1, note2, direction = 1) {
        if (direction !== 1 && direction !== -1) {
            throw new _util__WEBPACK_IMPORTED_MODULE_0__.RuntimeError('BadArguments', `Invalid direction: ${direction}`);
        }
        if (!this.isValidNoteValue(note1) || !this.isValidNoteValue(note2)) {
            throw new _util__WEBPACK_IMPORTED_MODULE_0__.RuntimeError('BadArguments', `Invalid notes: ${note1}, ${note2}`);
        }
        let difference = direction === 1 ? note2 - note1 : note1 - note2;
        if (difference < 0)
            difference += Music.NUM_TONES;
        return difference;
    }
    /**
     * Create a scale map that represents the pitch state for a
     * `keySignature`. For example, passing a `G` to `keySignature` would
     * return a scale map with every note naturalized except for `F` which
     * has an `F#` state.
     */
    createScaleMap(keySignature) {
        const keySigParts = this.getKeyParts(keySignature);
        if (!keySigParts.type)
            throw new _util__WEBPACK_IMPORTED_MODULE_0__.RuntimeError('BadArguments', 'Unsupported key type: undefined');
        const scaleName = Music.scaleTypes[keySigParts.type];
        let keySigString = keySigParts.root;
        if (keySigParts.accidental)
            keySigString += keySigParts.accidental;
        if (!scaleName)
            throw new _util__WEBPACK_IMPORTED_MODULE_0__.RuntimeError('BadArguments', 'Unsupported key type: ' + keySignature);
        const scale = this.getScaleTones(this.getNoteValue(keySigString), scaleName);
        const noteLocation = Music.rootIndexes[keySigParts.root];
        const scaleMap = {};
        for (let i = 0; i < Music.roots.length; ++i) {
            const index = (noteLocation + i) % Music.roots.length;
            const rootName = Music.roots[index];
            let noteName = this.getRelativeNoteName(rootName, scale[i]);
            if (noteName.length === 1) {
                noteName += 'n';
            }
            scaleMap[rootName] = noteName;
        }
        return scaleMap;
    }
}


/***/ }),

/***/ "./src/note.ts":
/*!*********************!*\
  !*** ./src/note.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Note: () => (/* binding */ Note)
/* harmony export */ });
/* harmony import */ var _glyphs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glyphs */ "./src/glyphs.ts");
/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./metrics */ "./src/metrics.ts");
/* harmony import */ var _rendercontext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rendercontext */ "./src/rendercontext.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _tickable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tickable */ "./src/tickable.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License







/**
 * Note implements an abstract interface for notes and chords that
 * are rendered on a stave. Notes have some common properties: All of them
 * have a value (e.g., pitch, fret, etc.) and a duration (quarter, half, etc.)
 *
 * Some notes have stems, heads, dots, etc. Most notational elements that
 * surround a note are called *modifiers*, and every note has an associated
 * array of them. All notes also have a rendering context and belong to a stave.
 */
class Note extends _tickable__WEBPACK_IMPORTED_MODULE_4__.Tickable {
    //////////////////////////////////////////////////////////////////////////////////////////////////
    // STATIC MEMBERS
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_5__.Category.Note;
    }
    // Return a glyph given duration and type. The type can be a custom glyph code from customNoteHeads.
    // The default type is a regular note ('n').
    static getGlyphProps(duration, type = 'n') {
        duration = _tables__WEBPACK_IMPORTED_MODULE_3__.Tables.sanitizeDuration(duration);
        // Lookup duration for default glyph head code
        let code = _tables__WEBPACK_IMPORTED_MODULE_3__.Tables.durationCodes[duration];
        if (code === undefined) {
            code = _tables__WEBPACK_IMPORTED_MODULE_3__.Tables.durationCodes['4'];
        }
        // Try and get the note head
        const codeNoteHead = _tables__WEBPACK_IMPORTED_MODULE_3__.Tables.codeNoteHead(type.toUpperCase(), duration);
        // Merge duration props for 'duration' with the note head properties.
        if (codeNoteHead !== _glyphs__WEBPACK_IMPORTED_MODULE_0__.Glyphs.null) {
            code = Object.assign(Object.assign({}, code), { codeHead: codeNoteHead });
        }
        return code;
    }
    /** Debug helper. Displays various note metrics for the given note. */
    static plotMetrics(ctx, note, yPos) {
        var _a;
        const metrics = note.getMetrics();
        const xStart = note.getAbsoluteX() - metrics.modLeftPx - metrics.leftDisplacedHeadPx;
        const xPre1 = note.getAbsoluteX() - metrics.leftDisplacedHeadPx;
        const xAbs = note.getAbsoluteX();
        const xPost1 = note.getAbsoluteX() + metrics.notePx;
        const xPost2 = note.getAbsoluteX() + metrics.notePx + metrics.rightDisplacedHeadPx;
        const xEnd = note.getAbsoluteX() + metrics.notePx + metrics.rightDisplacedHeadPx + metrics.modRightPx;
        const xFreedomRight = xEnd + ((_a = note.getFormatterMetrics().freedom.right) !== null && _a !== void 0 ? _a : 0);
        const xWidth = xEnd - xStart;
        ctx.save();
        ctx.setFont(_metrics__WEBPACK_IMPORTED_MODULE_1__.Metrics.get('fontFamily'), 8);
        ctx.fillText(Math.round(xWidth) + 'px', xStart + note.getXShift(), yPos);
        const y = yPos + 7;
        function stroke(x1, x2, color, yy = y) {
            ctx.beginPath();
            ctx.setStrokeStyle(color);
            ctx.setFillStyle(color);
            ctx.setLineWidth(3);
            ctx.moveTo(x1 + note.getXShift(), yy);
            ctx.lineTo(x2 + note.getXShift(), yy);
            ctx.stroke();
        }
        stroke(xStart, xPre1, 'red');
        stroke(xPre1, xAbs, '#999');
        stroke(xAbs, xPost1, 'green');
        stroke(xPost1, xPost2, '#999');
        stroke(xPost2, xEnd, 'red');
        stroke(xEnd, xFreedomRight, '#DD0');
        stroke(xStart - note.getXShift(), xStart, '#BBB'); // Shift
        (0,_rendercontext__WEBPACK_IMPORTED_MODULE_2__.drawDot)(ctx, xAbs + note.getXShift(), y, 'blue');
        const formatterMetrics = note.getFormatterMetrics();
        if (formatterMetrics.iterations > 0) {
            const spaceDeviation = formatterMetrics.space.deviation;
            const prefix = spaceDeviation >= 0 ? '+' : '';
            ctx.setFillStyle('red');
            ctx.fillText(prefix + Math.round(spaceDeviation), xAbs + note.getXShift(), yPos - 10);
        }
        ctx.restore();
    }
    static parseDuration(durationString) {
        if (!durationString) {
            return undefined;
        }
        const regexp = /(\d*\/?\d+|[a-z])(d*)([nrhms]|$)/;
        const result = regexp.exec(durationString);
        if (!result) {
            return undefined;
        }
        const duration = result[1];
        const dots = result[2].length;
        const type = result[3] || 'n';
        return { duration, dots, type };
    }
    static parseNoteStruct(noteStruct) {
        // Preserve backwards-compatibility
        const durationProps = Note.parseDuration(noteStruct.duration);
        if (!durationProps) {
            return undefined;
        }
        // If specified type is invalid, return undefined.
        let type = noteStruct.type;
        if (type && !_tables__WEBPACK_IMPORTED_MODULE_3__.Tables.validTypes[type]) {
            return undefined;
        }
        // If no type specified, check duration or custom types
        const customTypes = [];
        if (!type) {
            type = durationProps.type || 'n';
            // If we have keys, try and check if we've got a custom glyph
            if (noteStruct.keys !== undefined) {
                noteStruct.keys.forEach((k, i) => {
                    const result = k.split('/');
                    // We have a custom glyph specified after the note eg. /X2
                    customTypes[i] = (result && result.length === 3 ? result[2] : type);
                });
            }
        }
        // Calculate the tick duration of the note
        let ticks = _tables__WEBPACK_IMPORTED_MODULE_3__.Tables.durationToTicks(durationProps.duration);
        if (!ticks) {
            return undefined;
        }
        // Are there any dots?
        const dots = noteStruct.dots ? noteStruct.dots : durationProps.dots;
        if (typeof dots !== 'number') {
            return undefined;
        }
        // Add ticks as necessary depending on the numbr of dots
        let currentTicks = ticks;
        for (let i = 0; i < dots; i++) {
            if (currentTicks <= 1)
                return undefined;
            currentTicks = currentTicks / 2;
            ticks += currentTicks;
        }
        return {
            duration: durationProps.duration,
            type,
            customTypes,
            dots,
            ticks,
        };
    }
    /**
     * Every note is a tickable, i.e., it can be mutated by the `Formatter` class for
     * positioning and layout.
     *
     * @param noteStruct To create a new note you need to provide a `noteStruct`.
     */
    constructor(noteStruct) {
        super();
        if (!noteStruct) {
            throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('BadArguments', 'Note must have valid initialization data to identify duration and type.');
        }
        /** Parses `noteStruct` and get note properties. */
        const parsedNoteStruct = Note.parseNoteStruct(noteStruct);
        if (!parsedNoteStruct) {
            throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('BadArguments', `Invalid note initialization object: ${JSON.stringify(noteStruct)}`);
        }
        // Set note properties from parameters.
        this.keys = noteStruct.keys || [];
        // per-pitch properties
        this.keyProps = [];
        this.duration = parsedNoteStruct.duration;
        this.noteType = parsedNoteStruct.type;
        this.customTypes = parsedNoteStruct.customTypes;
        if (noteStruct.durationOverride) {
            // Custom duration
            this.setDuration(noteStruct.durationOverride);
        }
        else {
            // Default duration
            this.setIntrinsicTicks(parsedNoteStruct.ticks);
        }
        this.modifiers = [];
        // Get the glyph code for this note from the font.
        this.glyphProps = Note.getGlyphProps(this.duration, this.noteType);
        this.customGlyphs = this.customTypes.map((t) => Note.getGlyphProps(this.duration, t));
        // Note to play for audio players.
        this.playNote = undefined;
        // Positioning contexts used by the Formatter.
        this.ignoreTicks = false;
        // Positioning variables
        this.width = 0; // Width in pixels calculated after preFormat
        this.leftDisplacedHeadPx = 0; // Extra room on left for displaced note head
        this.rightDisplacedHeadPx = 0; // Extra room on right for displaced note head
        this.xShift = 0; // X shift from tick context X
        this.ys = []; // list of y coordinates for each note
        // we need to hold on to these for ties and beams.
        if (noteStruct.alignCenter) {
            this.setCenterAlignment(noteStruct.alignCenter);
        }
        // The render surface.
        this.renderOptions = {
            annotationSpacing: 5,
            strokePx: 1,
            yShift: 0,
        };
    }
    /**
     * Get the play note, which is arbitrary data that can be used by an
     * audio player.
     */
    getPlayNote() {
        return this.playNote;
    }
    /**
     * Set the play note, which is arbitrary data that can be used by an
     * audio player.
     */
    setPlayNote(note) {
        this.playNote = note;
        return this;
    }
    /**
     * @returns true if this note is a type of rest.
     *
     * Rests don't have pitches, but take up space in the score.
     * Subclasses should override this default implementation.
     */
    isRest() {
        return false;
    }
    /** Add stroke. */
    addStroke(index, stroke) {
        stroke.setNote(this);
        stroke.setIndex(index);
        this.modifiers.push(stroke);
        this.preFormatted = false;
        return this;
    }
    /** Get the target stave. */
    getStave() {
        return this.stave;
    }
    /** Check and get the target stave. */
    checkStave() {
        return (0,_util__WEBPACK_IMPORTED_MODULE_6__.defined)(this.stave, 'NoStave', 'No stave attached to instance.');
    }
    /** Set the target stave. */
    setStave(stave) {
        this.stave = stave;
        this.setYs([stave.getYForLine(0)]); // Update Y values if the stave is changed.
        this.setContext(this.stave.getContext());
        return this;
    }
    /** Get spacing to the left of the notes. */
    getLeftDisplacedHeadPx() {
        return this.leftDisplacedHeadPx;
    }
    /** Get spacing to the right of the notes. */
    getRightDisplacedHeadPx() {
        return this.rightDisplacedHeadPx;
    }
    /** Set spacing to the left of the notes. */
    setLeftDisplacedHeadPx(x) {
        this.leftDisplacedHeadPx = x;
        return this;
    }
    /** Set spacing to the right of the notes. */
    setRightDisplacedHeadPx(x) {
        this.rightDisplacedHeadPx = x;
        return this;
    }
    /** True if this note has no duration (e.g., bar notes, spacers, etc.). */
    shouldIgnoreTicks() {
        return this.ignoreTicks;
    }
    /** Get the stave line number for the note. */
    // eslint-disable-next-line
    getLineNumber(isTopNote) {
        return 0;
    }
    /** Get the stave line number for rest. */
    getLineForRest() {
        return 0;
    }
    /** Get the glyph associated with this note. */
    getGlyphProps() {
        return this.glyphProps;
    }
    /** Get the glyph width. */
    getGlyphWidth() {
        return 0;
    }
    /**
     * Set Y positions for this note. Each Y value is associated with
     * an individual pitch/key within the note/chord.
     */
    setYs(ys) {
        this.ys = ys;
        return this;
    }
    /**
     * Get Y positions for this note. Each Y value is associated with
     * an individual pitch/key within the note/chord.
     */
    getYs() {
        if (this.ys.length === 0) {
            throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('NoYValues', 'No Y-values calculated for this note.');
        }
        return this.ys;
    }
    /**
     * Get the Y position of the space above the stave onto which text can
     * be rendered.
     */
    getYForTopText(textLine) {
        return this.checkStave().getYForTopText(textLine);
    }
    /** Return the voice that this note belongs in. */
    getVoice() {
        if (!this.voice)
            throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('NoVoice', 'Note has no voice.');
        return this.voice;
    }
    /** Attach this note to `voice`. */
    setVoice(voice) {
        this.voice = voice;
        this.preFormatted = false;
        return this;
    }
    /** Get the `TickContext` for this note. */
    getTickContext() {
        return this.checkTickContext();
    }
    /** Set the `TickContext` for this note. */
    setTickContext(tc) {
        this.tickContext = tc;
        this.preFormatted = false;
        return this;
    }
    /** Accessor to duration. */
    getDuration() {
        return this.duration;
    }
    /** Accessor to isDotted. */
    isDotted() {
        return this.getModifiersByType(_typeguard__WEBPACK_IMPORTED_MODULE_5__.Category.Dot).length > 0;
    }
    /** Accessor to hasStem. */
    hasStem() {
        return false;
    }
    /** Accessor to note type. */
    getNoteType() {
        return this.noteType;
    }
    /** Get the beam. */
    getBeam() {
        return this.beam;
    }
    /** Check and get the beam. */
    checkBeam() {
        return (0,_util__WEBPACK_IMPORTED_MODULE_6__.defined)(this.beam, 'NoBeam', 'No beam attached to instance');
    }
    /** Check it has a beam. */
    hasBeam() {
        return this.beam !== undefined;
    }
    /** Set the beam. */
    setBeam(beam) {
        this.beam = beam;
        return this;
    }
    /**
     * Attach a modifier to this note.
     * @param modifier the Modifier to add.
     * @param index of the key to modify.
     * @returns this
     */
    addModifier(modifier, index = 0) {
        const signature = 'Note.addModifier(modifier: Modifier, index: number=0)';
        // Backwards compatibility with 3.0.9.
        if (typeof index === 'string') {
            index = parseInt(index);
            // eslint-disable-next-line
            console.warn(signature + ' expected a number for `index`, but received a string.');
        }
        // Some versions of VexFlow had the two parameters reversed.
        // Check here and throw an error if the argument types are not correct.
        if (typeof modifier !== 'object' || typeof index !== 'number') {
            throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('WrongParams', 'Incorrect call signature. Use ' + signature + ' instead.');
        }
        modifier.setNote(this);
        modifier.setIndex(index);
        super.addModifier(modifier);
        return this;
    }
    /** Get all modifiers of a specific type in `this.modifiers`. */
    getModifiersByType(type) {
        return this.modifiers.filter((modifier) => modifier.getCategory() === type);
    }
    /** Get the coordinates for where modifiers begin. */
    // eslint-disable-next-line
    getModifierStartXY(position, index, options) {
        if (!this.preFormatted) {
            throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('UnformattedNote', "Can't call GetModifierStartXY on an unformatted note");
        }
        return {
            x: this.getAbsoluteX(),
            y: this.ys[0],
        };
    }
    getRightParenthesisPx(index) {
        const props = this.getKeyProps()[index];
        return props.displaced ? this.getRightDisplacedHeadPx() : 0;
    }
    getLeftParenthesisPx(index) {
        const props = this.getKeyProps()[index];
        return props.displaced ? this.getLeftDisplacedHeadPx() - this.xShift : -this.xShift;
    }
    getFirstDotPx() {
        let px = this.getRightDisplacedHeadPx();
        const parentheses = this.checkModifierContext().getMembers('Parenthesis');
        // consider parentheses on noteheads, dots should be to the right of them
        if (parentheses.length !== 0) {
            px += parentheses[0].getWidth() + 1;
        }
        return px;
    }
    /** Get the metrics for this note. */
    getMetrics() {
        if (!this.preFormatted) {
            throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('UnformattedNote', "Can't call getMetrics on an unformatted note.");
        }
        const modLeftPx = this.modifierContext ? this.modifierContext.getState().leftShift : 0;
        const modRightPx = this.modifierContext ? this.modifierContext.getState().rightShift : 0;
        const width = this.getWidth();
        const glyphWidth = this.getGlyphWidth();
        const notePx = width -
            modLeftPx - // subtract left modifiers
            modRightPx - // subtract right modifiers
            this.leftDisplacedHeadPx - // subtract left displaced head
            this.rightDisplacedHeadPx; // subtract right displaced head
        // NOTE: If you change this, remember to update MockTickable.getMetrics() in the tests/ directory.
        return {
            width,
            glyphWidth,
            notePx,
            // Modifier spacing.
            modLeftPx,
            modRightPx,
            // Displaced note head on left or right.
            leftDisplacedHeadPx: this.leftDisplacedHeadPx,
            rightDisplacedHeadPx: this.rightDisplacedHeadPx,
            glyphPx: 0,
        };
    }
    /**
     * Get the absolute `X` position of this note's tick context. This
     * excludes xShift, so you'll need to factor it in if you're
     * looking for the post-formatted x-position.
     */
    getAbsoluteX() {
        const tickContext = this.checkTickContext(`Can't getAbsoluteX() without a TickContext.`);
        // Position note to left edge of tick context.
        let x = tickContext.getX();
        if (this.stave) {
            x += this.stave.getNoteStartX() + _metrics__WEBPACK_IMPORTED_MODULE_1__.Metrics.get('Stave.padding', 0);
        }
        if (this.isCenterAligned()) {
            x += this.getCenterXShift();
        }
        return x;
    }
    /** Get the direction of the stem. */
    getStemDirection() {
        throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('NoStem', 'No stem attached to this note.');
    }
    /** Get the top and bottom `y` values of the stem. */
    getStemExtents() {
        throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('NoStem', 'No stem attached to this note.');
    }
    /** Get the `x` coordinate to the right of the note. */
    getTieRightX() {
        let tieStartX = this.getAbsoluteX();
        const noteGlyphWidth = this.getGlyphWidth();
        tieStartX += noteGlyphWidth / 2;
        tieStartX += -this.width / 2 + this.width + 2;
        return tieStartX;
    }
    /** Get the `x` coordinate to the left of the note. */
    getTieLeftX() {
        let tieEndX = this.getAbsoluteX();
        const noteGlyphWidth = this.getGlyphWidth();
        tieEndX += noteGlyphWidth / 2;
        tieEndX -= this.width / 2 + 2;
        return tieEndX;
    }
    // Get the pitches in the note
    getKeys() {
        return this.keys;
    }
    // Get the properties for all the keys in the note
    getKeyProps() {
        return this.keyProps;
    }
}


/***/ }),

/***/ "./src/notehead.ts":
/*!*************************!*\
  !*** ./src/notehead.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NoteHead: () => (/* binding */ NoteHead)
/* harmony export */ });
/* harmony import */ var _boundingbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boundingbox */ "./src/boundingbox.ts");
/* harmony import */ var _note__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./note */ "./src/note.ts");
/* harmony import */ var _stem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stem */ "./src/stem.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License





// eslint-disable-next-line
function L(...args) {
    if (NoteHead.DEBUG)
        (0,_util__WEBPACK_IMPORTED_MODULE_4__.log)('Vex.Flow.NoteHead', args);
}
/**
 * `NoteHeads` are typically not manipulated
 * directly, but used internally in `StaveNote`.
 *
 * See `tests/notehead_tests.ts` for usage examples.
 */
class NoteHead extends _note__WEBPACK_IMPORTED_MODULE_1__.Note {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_3__.Category.NoteHead;
    }
    constructor(noteStruct) {
        super(noteStruct);
        this.customGlyph = false;
        // map notehead SMuFL codes to the corresponding SMuFL code with ledger line
        this.ledger = {
            '\ue4e3' /*restWhole*/: '\ue4f4' /*restWholeLegerLine*/,
            '\ue4e4' /*restHalf*/: '\ue4f5' /*restHalfLegerLine*/,
        };
        this.index = noteStruct.index;
        this.x = noteStruct.x || 0;
        this.y = noteStruct.y || 0;
        if (noteStruct.noteType)
            this.noteType = noteStruct.noteType;
        this.displaced = noteStruct.displaced || false;
        this.stemDirection = noteStruct.stemDirection || _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.UP;
        this.line = noteStruct.line || 0;
        // Get glyph code based on duration and note type. This could be
        // regular notes, rests, or other custom codes.
        this.glyphProps = _note__WEBPACK_IMPORTED_MODULE_1__.Note.getGlyphProps(this.duration, this.noteType);
        (0,_util__WEBPACK_IMPORTED_MODULE_4__.defined)(this.glyphProps, 'BadArguments', `No glyph found for duration '${this.duration}' and type '${this.noteType}'`);
        // Swap out the glyph with ledger lines
        if ((this.line > 5 || this.line < 0) && this.ledger[this.glyphProps.codeHead]) {
            this.glyphProps.codeHead = this.ledger[this.glyphProps.codeHead];
        }
        this.text = this.glyphProps.codeHead;
        if (noteStruct.customGlyphCode) {
            this.customGlyph = true;
            this.text = noteStruct.customGlyphCode;
        }
        this.setStyle(noteStruct.style);
        this.slashed = noteStruct.slashed || false;
        this.renderOptions = Object.assign({}, this.renderOptions);
    }
    /** Get the width of the notehead. */
    getWidth() {
        return this.width;
    }
    /** Determine if the notehead is displaced. */
    isDisplaced() {
        return this.displaced === true;
    }
    /** Get the stave line the notehead is placed on. */
    getLine() {
        return this.line;
    }
    /** Set the stave line the notehead is placed on. */
    setLine(line) {
        this.line = line;
        return this;
    }
    /** Get the canvas `x` coordinate position of the notehead. */
    getAbsoluteX() {
        // If the note has not been preformatted, then get the static x value
        // Otherwise, it's been formatted and we should use it's x value relative
        // to its tick context
        const x = !this.preFormatted ? this.x : super.getAbsoluteX();
        // For a more natural displaced notehead, we adjust the displacement amount
        // by half the stem width in order to maintain a slight overlap with the stem
        const displacementStemAdjustment = _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.WIDTH / 2;
        return x + (this.displaced ? (this.width - displacementStemAdjustment) * this.stemDirection : 0);
    }
    /** Get the `BoundingBox` for the `NoteHead`. */
    getBoundingBox() {
        return new _boundingbox__WEBPACK_IMPORTED_MODULE_0__.BoundingBox(this.getAbsoluteX() - this.textMetrics.actualBoundingBoxLeft, this.y - this.textMetrics.actualBoundingBoxAscent, this.width, this.height);
    }
    /** Set notehead to a provided `stave`. */
    setStave(stave) {
        const line = this.getLine();
        this.stave = stave;
        if (this.stave) {
            this.setY(this.stave.getYForNote(line));
            this.setContext(this.stave.getContext());
        }
        return this;
    }
    /** Pre-render formatting. */
    preFormat() {
        if (this.preFormatted)
            return this;
        this.preFormatted = true;
        return this;
    }
    /** Draw the notehead. */
    draw() {
        const ctx = this.checkContext();
        this.setRendered();
        L("Drawing note head '", this.noteType, this.duration, "' at", this.x, this.y);
        this.renderText(ctx, this.getAbsoluteX() - this.x, 0);
    }
}
/** To enable logging for this class. Set `Vex.Flow.NoteHead.DEBUG` to `true`. */
NoteHead.DEBUG = false;


/***/ }),

/***/ "./src/notesubgroup.ts":
/*!*****************************!*\
  !*** ./src/notesubgroup.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NoteSubGroup: () => (/* binding */ NoteSubGroup)
/* harmony export */ });
/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatter */ "./src/formatter.ts");
/* harmony import */ var _modifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifier */ "./src/modifier.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _voice__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./voice */ "./src/voice.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// @author: Taehoon Moon 2016
//
// ## Description
//
// This file implements `NoteSubGroup` which is used to format and
// render notes as a `Modifier`
// ex) ClefNote, TimeSigNote and BarNote.





class NoteSubGroup extends _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_3__.Category.NoteSubGroup;
    }
    // Arrange groups inside a `ModifierContext`
    static format(groups, state) {
        if (!groups || groups.length === 0)
            return false;
        let width = 0;
        for (let i = 0; i < groups.length; ++i) {
            const group = groups[i];
            group.preFormat();
            width += group.getWidth();
        }
        state.leftShift += width;
        return true;
    }
    constructor(subNotes) {
        super();
        this.preFormatted = false;
        this.position = _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.LEFT;
        this.subNotes = subNotes;
        this.subNotes.forEach((subNote) => {
            subNote.setIgnoreTicks(false);
        });
        this.width = 0;
        this.formatter = new _formatter__WEBPACK_IMPORTED_MODULE_0__.Formatter();
        this.voice = new _voice__WEBPACK_IMPORTED_MODULE_4__.Voice({
            numBeats: 4,
            beatValue: 4,
            resolution: _tables__WEBPACK_IMPORTED_MODULE_2__.Tables.RESOLUTION,
        }).setStrict(false);
        this.voice.addTickables(this.subNotes);
    }
    preFormat() {
        if (this.preFormatted)
            return;
        this.formatter.joinVoices([this.voice]).format([this.voice], 0);
        this.setWidth(this.formatter.getMinTotalWidth());
        this.preFormatted = true;
    }
    setWidth(width) {
        this.width = width;
        return this;
    }
    getWidth() {
        return this.width;
    }
    draw() {
        const ctx = this.checkContext();
        const note = this.checkAttachedNote();
        this.setRendered();
        this.alignSubNotesWithNote(this.subNotes, note); // Modifier function
        this.subNotes.forEach((subNote) => subNote.setContext(ctx).drawWithStyle());
    }
}


/***/ }),

/***/ "./src/ornament.ts":
/*!*************************!*\
  !*** ./src/ornament.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ornament: () => (/* binding */ Ornament)
/* harmony export */ });
/* harmony import */ var _articulation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./articulation */ "./src/articulation.ts");
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./metrics */ "./src/metrics.ts");
/* harmony import */ var _modifier__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifier */ "./src/modifier.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _tickcontext__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tickcontext */ "./src/tickcontext.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// @author Cyril Silverman
// MIT License








// eslint-disable-next-line
function L(...args) {
    if (Ornament.DEBUG)
        (0,_util__WEBPACK_IMPORTED_MODULE_7__.log)('Vex.Flow.Ornament', args);
}
/**
 * Ornament implements ornaments as modifiers that can be
 * attached to notes. The complete list of ornaments is available in
 * `tables.ts` under `Vex.Flow.ornamentCodes`.
 *
 * See `tests/ornament_tests.ts` for usage examples.
 */
class Ornament extends _modifier__WEBPACK_IMPORTED_MODULE_3__.Modifier {
    /** Ornaments category string. */
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_6__.Category.Ornament;
    }
    static get minPadding() {
        return _metrics__WEBPACK_IMPORTED_MODULE_2__.Metrics.get('NoteHead.minPadding');
    }
    /** Arrange ornaments inside `ModifierContext` */
    static format(ornaments, state) {
        if (!ornaments || ornaments.length === 0)
            return false;
        let width = 0; // width is used by ornaments, which are always centered on the note head
        let rightShift = state.rightShift; // jazz ornaments calculate r/l shift separately
        let leftShift = state.leftShift;
        for (let i = 0; i < ornaments.length; ++i) {
            const ornament = ornaments[i];
            const increment = 2;
            if (ornament.position === _modifier__WEBPACK_IMPORTED_MODULE_3__.ModifierPosition.RIGHT) {
                ornament.xShift += rightShift + 2;
                rightShift += ornament.width + Ornament.minPadding;
            }
            else if (ornament.position === _modifier__WEBPACK_IMPORTED_MODULE_3__.ModifierPosition.LEFT) {
                ornament.xShift -= leftShift + ornament.width + 2;
                leftShift += ornament.width + Ornament.minPadding;
            }
            else if (ornament.position === _modifier__WEBPACK_IMPORTED_MODULE_3__.ModifierPosition.ABOVE) {
                width = Math.max(ornament.getWidth(), width);
                ornament.setTextLine(state.topTextLine);
                state.topTextLine += increment;
            }
            else {
                width = Math.max(ornament.getWidth(), width);
                ornament.setTextLine(state.textLine);
                state.textLine += increment;
            }
        }
        // Note: 'legit' ornaments don't consider other modifiers when calculating their
        // X position, but jazz ornaments sometimes need to.
        state.leftShift = leftShift + width / 2;
        state.rightShift = rightShift + width / 2;
        return true;
    }
    /**
     * ornamentNoteTransition means the jazz ornament represents an effect from one note to another,
     * these are generally on the top of the staff.
     */
    static get ornamentNoteTransition() {
        return ['flip', 'jazzTurn', 'smear'];
    }
    /**
     * ornamentAttack indicates something that happens in the attach, placed before the note and
     * any accidentals
     */
    static get ornamentAttack() {
        return ['scoop'];
    }
    /**
     * The ornament is aligned based on the note head, but without regard to whether the
     * stem goes up or down.
     */
    static get ornamentAlignWithNoteHead() {
        return ['doit', 'fall', 'fallLong', 'doitLong', 'scoop'];
    }
    /**
     * An ornament that happens on the release of the note, generally placed after the
     * note and overlapping the next beat/measure..
     */
    static get ornamentRelease() {
        return ['doit', 'fall', 'fallLong', 'doitLong', 'jazzTurn', 'smear', 'flip'];
    }
    static get ornamentLeft() {
        return ['scoop'];
    }
    static get ornamentRight() {
        return ['doit', 'fall', 'fallLong', 'doitLong'];
    }
    static get ornamentYShift() {
        return ['fallLong'];
    }
    /** ornamentArticulation goes above/below the note based on space availablity */
    static get ornamentArticulation() {
        return ['bend', 'plungerClosed', 'plungerOpen'];
    }
    /**
     * Create a new ornament of type `type`, which is an entry in
     * `Vex.Flow.ornamentCodes` in `tables.ts`.
     */
    constructor(type) {
        super();
        // Default position ABOVE
        this.position = _modifier__WEBPACK_IMPORTED_MODULE_3__.ModifierPosition.ABOVE;
        if (Ornament.ornamentRight.indexOf(type) >= 0) {
            this.position = _modifier__WEBPACK_IMPORTED_MODULE_3__.ModifierPosition.RIGHT;
        }
        if (Ornament.ornamentLeft.indexOf(type) >= 0) {
            this.position = _modifier__WEBPACK_IMPORTED_MODULE_3__.ModifierPosition.LEFT;
        }
        this.type = type;
        this.delayed = false;
        this.renderOptions = {
            accidentalLowerPadding: 3,
            accidentalUpperPadding: 3,
        };
        // some jazz ornaments are above or below depending on stem direction.
        this.adjustForStemDirection = false;
        this.ornamentAlignWithNoteHead = Ornament.ornamentAlignWithNoteHead.indexOf(this.type) >= 0;
        // Is this a jazz ornament that goes between this note and the next note.
        if (Ornament.ornamentNoteTransition.indexOf(this.type) >= 0) {
            this.delayed = true;
        }
        this.text = _tables__WEBPACK_IMPORTED_MODULE_4__.Tables.ornamentCodes(this.type);
    }
    /** Set note attached to ornament. */
    setNote(note) {
        super.setNote(note);
        // articulations above/below the line can be stacked.
        if (Ornament.ornamentArticulation.indexOf(this.type) >= 0) {
            // Unfortunately we don't know the stem direction.  So we base it
            // on the line number, but also allow it to be overridden.
            if (note.getLineNumber() >= 3) {
                this.position = _modifier__WEBPACK_IMPORTED_MODULE_3__.Modifier.Position.ABOVE;
            }
            else {
                this.position = _modifier__WEBPACK_IMPORTED_MODULE_3__.Modifier.Position.BELOW;
            }
        }
        return this;
    }
    /** Set whether the ornament is to be delayed. */
    setDelayed(delayed) {
        this.delayed = delayed;
        return this;
    }
    /** Set the upper accidental for the ornament. */
    setUpperAccidental(accid) {
        this.accidentalUpper = new _element__WEBPACK_IMPORTED_MODULE_1__.Element();
        this.accidentalUpper.setText(_tables__WEBPACK_IMPORTED_MODULE_4__.Tables.accidentalCodes(accid));
        return this;
    }
    /** Set the lower accidental for the ornament. */
    setLowerAccidental(accid) {
        this.accidentalLower = new _element__WEBPACK_IMPORTED_MODULE_1__.Element();
        this.accidentalLower.setText(_tables__WEBPACK_IMPORTED_MODULE_4__.Tables.accidentalCodes(accid));
        return this;
    }
    /** Render ornament in position next to note. */
    draw() {
        const ctx = this.checkContext();
        const note = this.checkAttachedNote();
        this.setRendered();
        const stave = note.checkStave();
        this.applyStyle();
        ctx.openGroup('ornament', this.getAttribute('id'));
        // Get initial coordinates for the modifier position
        const start = note.getModifierStartXY(this.position, this.index);
        let glyphX = start.x;
        const staffSpace = stave.getSpacingBetweenLines();
        const initialOffset = (0,_articulation__WEBPACK_IMPORTED_MODULE_0__.getInitialOffset)(note, this.position);
        // If the ornament is aligned with the note head, don't consider the stave y
        // but use the 'natural' modifier y
        let glyphY = this.ornamentAlignWithNoteHead ? start.y : 0;
        if (this.position === _modifier__WEBPACK_IMPORTED_MODULE_3__.ModifierPosition.ABOVE) {
            glyphY = (0,_articulation__WEBPACK_IMPORTED_MODULE_0__.getTopY)(note, this.textLine) - (this.textLine + initialOffset) * staffSpace;
        }
        if (this.position === _modifier__WEBPACK_IMPORTED_MODULE_3__.ModifierPosition.BELOW) {
            glyphY = (0,_articulation__WEBPACK_IMPORTED_MODULE_0__.getBottomY)(note, this.textLine) + (this.textLine + initialOffset + 1.5) * staffSpace;
        }
        // Ajdust x position if ornament is delayed
        if (this.delayed) {
            let delayXShift = 0;
            const startX = note.getTickContext().getX();
            if (this.delayXShift !== undefined) {
                delayXShift = this.delayXShift;
            }
            else {
                const nextContext = _tickcontext__WEBPACK_IMPORTED_MODULE_5__.TickContext.getNextContext(note.getTickContext());
                if (nextContext) {
                    delayXShift += (nextContext.getX() - startX) * 0.5;
                }
                else {
                    delayXShift += (stave.getX() + stave.getWidth() - startX) * 0.5;
                }
                this.delayXShift = delayXShift;
            }
            glyphX += delayXShift;
        }
        L('Rendering ornament: ', this.text.charCodeAt(0), glyphX, glyphY);
        if (this.accidentalLower) {
            this.accidentalLower.renderText(ctx, glyphX + this.xShift - this.accidentalLower.getWidth() * 0.5, glyphY + this.yShift - this.accidentalLower.getTextMetrics().actualBoundingBoxDescent);
            glyphY -= this.accidentalLower.getHeight() + this.renderOptions.accidentalLowerPadding;
        }
        // ornament requires yShift
        if (Ornament.ornamentYShift.indexOf(this.type) >= 0) {
            this.yShift += this.getHeight();
        }
        this.renderText(ctx, glyphX -
            (this.position === _modifier__WEBPACK_IMPORTED_MODULE_3__.ModifierPosition.ABOVE || this.position === _modifier__WEBPACK_IMPORTED_MODULE_3__.ModifierPosition.BELOW ? this.width * 0.5 : 0), glyphY);
        if (this.accidentalUpper) {
            glyphY -= this.getHeight() + this.renderOptions.accidentalUpperPadding;
            this.accidentalUpper.renderText(ctx, glyphX + this.xShift - this.accidentalUpper.getWidth() * 0.5, glyphY + this.yShift - this.accidentalUpper.getTextMetrics().actualBoundingBoxDescent);
        }
        ctx.closeGroup();
        this.restoreStyle();
    }
}
/** To enable logging for this class. Set `Vex.Flow.Ornament.DEBUG` to `true`. */
Ornament.DEBUG = false;


/***/ }),

/***/ "./src/parenthesis.ts":
/*!****************************!*\
  !*** ./src/parenthesis.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Parenthesis: () => (/* binding */ Parenthesis)
/* harmony export */ });
/* harmony import */ var _modifier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modifier */ "./src/modifier.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// @author Rodrigo Vilar
// MIT License


/** Parenthesis implements parenthesis modifiers for notes. */
class Parenthesis extends _modifier__WEBPACK_IMPORTED_MODULE_0__.Modifier {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_1__.Category.Parenthesis;
    }
    /** Add parentheses to the notes. */
    static buildAndAttach(notes) {
        for (const note of notes) {
            for (let i = 0; i < note.keys.length; i++) {
                note.addModifier(new Parenthesis(_modifier__WEBPACK_IMPORTED_MODULE_0__.ModifierPosition.LEFT), i);
                note.addModifier(new Parenthesis(_modifier__WEBPACK_IMPORTED_MODULE_0__.ModifierPosition.RIGHT), i);
            }
        }
    }
    /** Arrange parentheses inside a ModifierContext. */
    static format(parentheses, state) {
        if (!parentheses || parentheses.length === 0)
            return false;
        let xWidthL = 0;
        let xWidthR = 0;
        for (let i = 0; i < parentheses.length; ++i) {
            const parenthesis = parentheses[i];
            const note = parenthesis.getNote();
            const pos = parenthesis.getPosition();
            const index = parenthesis.checkIndex();
            let shift = 0;
            if (pos === _modifier__WEBPACK_IMPORTED_MODULE_0__.ModifierPosition.RIGHT) {
                shift = note.getRightParenthesisPx(index);
                xWidthR = xWidthR > shift + parenthesis.width ? xWidthR : shift + parenthesis.width;
            }
            if (pos === _modifier__WEBPACK_IMPORTED_MODULE_0__.ModifierPosition.LEFT) {
                shift = note.getLeftParenthesisPx(index) + parenthesis.width;
                xWidthL = xWidthL > shift + parenthesis.width ? xWidthL : shift + parenthesis.width;
            }
            parenthesis.setXShift(shift);
        }
        state.leftShift += xWidthL;
        state.rightShift += xWidthR;
        return true;
    }
    /**
     * Constructor
     *
     * @param position Modifier.Position.LEFT (default) or Modifier.Position.RIGHT
     */
    constructor(position) {
        super();
        this.position = position !== null && position !== void 0 ? position : _modifier__WEBPACK_IMPORTED_MODULE_0__.Modifier.Position.LEFT;
        if (this.position === _modifier__WEBPACK_IMPORTED_MODULE_0__.Modifier.Position.RIGHT) {
            this.text = '\uE0F6'; /*noteheadParenthesisRight*/
        }
        else if (this.position === _modifier__WEBPACK_IMPORTED_MODULE_0__.Modifier.Position.LEFT) {
            this.text = '\uE0F5'; /*noteheadParenthesisLeft*/
        }
    }
    /** Set the associated note. */
    setNote(note) {
        this.note = note;
        this.setFont(note.getFont());
        return this;
    }
    /** Render the parenthesis. */
    draw() {
        const ctx = this.checkContext();
        const note = this.checkAttachedNote();
        this.setRendered();
        const start = note.getModifierStartXY(this.position, this.index, { forceFlagRight: true });
        this.renderText(ctx, start.x, start.y);
    }
}


/***/ }),

/***/ "./src/parser.ts":
/*!***********************!*\
  !*** ./src/parser.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Parser: () => (/* binding */ Parser)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
//
// A generic text parsing class for VexFlow.

// To enable logging for this class. Set `Vex.Flow.Parser.DEBUG` to `true`.
// eslint-disable-next-line
function L(...args) {
    if (Parser.DEBUG)
        (0,_util__WEBPACK_IMPORTED_MODULE_0__.log)('Vex.Flow.Parser', args);
}
const NO_ERROR_POS = -1;
// Converts parser results into an easy to reference list that can be
// used in triggers. This function returns:
// - nested array in which the leaf elements are string or null
// - string (including empty strings)
// - null
function flattenMatches(r) {
    if ('matchedString' in r)
        return r.matchedString; // string
    if ('results' in r)
        return flattenMatches(r.results);
    const results = r;
    if (results.length === 1)
        return flattenMatches(results[0]);
    if (results.length === 0)
        return null;
    return results.map(flattenMatches); // nested array
}
// This is the base parser class. Given an arbitrary context-free grammar, it
// can parse any line and execute code when specific rules are met (e.g.,
// when a string is terminated.)
class Parser {
    // For an example of a simple grammar, take a look at tests/parser_tests.ts or
    // the EasyScore grammar in easyscore.ts.
    constructor(grammar) {
        this.grammar = grammar;
        this.line = '';
        this.pos = 0;
        this.errorPos = NO_ERROR_POS;
    }
    // Parse `line` using current grammar. Returns `{success: true}` if the
    // line parsed correctly, otherwise returns `{success: false, errorPos: N}`
    // where `errorPos` is the location of the error in the string.
    parse(line) {
        this.line = line;
        this.pos = 0;
        this.errorPos = NO_ERROR_POS;
        const result = this.expect(this.grammar.begin());
        result.errorPos = this.errorPos;
        return result;
    }
    matchFail(returnPos) {
        if (this.errorPos === NO_ERROR_POS)
            this.errorPos = this.pos;
        this.pos = returnPos;
    }
    matchSuccess() {
        this.errorPos = NO_ERROR_POS;
    }
    // Look for `token` in this.line[this.pos], and return success
    // if one is found. `token` is specified as a regular expression.
    matchToken(token, noSpace = false) {
        const regexp = noSpace ? new RegExp('^((' + token + '))') : new RegExp('^((' + token + ')\\s*)');
        const workingLine = this.line.slice(this.pos);
        const result = workingLine.match(regexp);
        if (result !== null) {
            return {
                success: true,
                matchedString: result[2],
                incrementPos: result[1].length,
                pos: this.pos,
            };
        }
        else {
            return { success: false, pos: this.pos };
        }
    }
    // Execute rule to match a sequence of tokens (or rules). If `maybe` is
    // set, then return success even if the token is not found, but reset
    // the position before exiting.
    // TODO: expectOne(...) is never called with the `maybe` parameter.
    expectOne(rule, maybe = false) {
        const results = [];
        const pos = this.pos;
        let allMatches = true;
        let oneMatch = false;
        maybe = maybe === true || rule.maybe === true;
        // Execute all sub rules in sequence.
        if (rule.expect) {
            for (const next of rule.expect) {
                const localPos = this.pos;
                const result = this.expect(next);
                // If `rule.or` is set, then return success if any one
                // of the subrules match, else all subrules must match.
                if (result.success) {
                    results.push(result);
                    oneMatch = true;
                    if (rule.or)
                        break;
                }
                else {
                    allMatches = false;
                    if (!rule.or) {
                        this.pos = localPos;
                        break;
                    }
                }
            }
        }
        const gotOne = (rule.or && oneMatch) || allMatches;
        const success = gotOne || maybe === true;
        const numMatches = gotOne ? 1 : 0;
        if (maybe && !gotOne)
            this.pos = pos;
        if (success) {
            this.matchSuccess();
        }
        else {
            this.matchFail(pos);
        }
        return { success, results, numMatches };
    }
    // Try to match multiple (one or more) instances of the rule. If `maybe` is set,
    // then a failed match is also a success (but the position is reset).
    expectOneOrMore(rule, maybe = false) {
        const results = [];
        const pos = this.pos;
        let numMatches = 0;
        let more = true;
        do {
            const result = this.expectOne(rule);
            if (result.success && result.results) {
                numMatches++;
                results.push(result.results);
            }
            else {
                more = false;
            }
        } while (more);
        const success = numMatches > 0 || maybe === true;
        if (maybe && !(numMatches > 0))
            this.pos = pos;
        if (success) {
            this.matchSuccess();
        }
        else {
            this.matchFail(pos);
        }
        return { success, results, numMatches };
    }
    // Match zero or more instances of `rule`. Offloads to `expectOneOrMore`.
    expectZeroOrMore(rule) {
        return this.expectOneOrMore(rule, true);
    }
    // Execute the rule produced by the provided `rules` function. This
    // offloads to one of the above matchers and consolidates the results. It is also
    // responsible for executing any code triggered by the rule (in `rule.run`.)
    expect(ruleFunc) {
        L('Evaluating rule function:', ruleFunc);
        if (!ruleFunc) {
            throw new _util__WEBPACK_IMPORTED_MODULE_0__.RuntimeError('Invalid rule function');
        }
        let result;
        // Get rule from Grammar class.
        // expect(...) handles both lexing & parsing:
        // - lexer rules produce tokens.
        // - parser rules produce expressions which may trigger code via the
        //   { run: () => ... } trigger functions in easyscore.ts.
        //   These functions build the VexFlow objects that are displayed on screen.
        const rule = ruleFunc.bind(this.grammar)();
        if (rule.token) {
            // A lexer rule has a `token` property.
            // Base case: parse the regex and throw an error if the
            // line doesn't match.
            result = this.matchToken(rule.token, rule.noSpace === true);
            if (result.success) {
                // Token match! Update position and throw away parsed portion
                // of string.
                this.pos += result.incrementPos;
            }
        }
        else if (rule.expect) {
            // A parser rule has an `expect` property.
            if (rule.oneOrMore) {
                result = this.expectOneOrMore(rule);
            }
            else if (rule.zeroOrMore) {
                result = this.expectZeroOrMore(rule);
            }
            else {
                result = this.expectOne(rule);
            }
        }
        else {
            L(rule);
            throw new _util__WEBPACK_IMPORTED_MODULE_0__.RuntimeError('Bad grammar! No `token` or `expect` property ' + rule);
        }
        // If there's a trigger attached to this rule, then run it.
        // Make the matches accessible through `state.matches` in the
        // `run: (state) => ...` trigger.
        const matches = [];
        result.matches = matches;
        if (result.results) {
            result.results.forEach((r) => matches.push(flattenMatches(r)));
        }
        if (rule.run && result.success) {
            rule.run({ matches });
        }
        return result;
    }
}
Parser.DEBUG = false;


/***/ }),

/***/ "./src/pedalmarking.ts":
/*!*****************************!*\
  !*** ./src/pedalmarking.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PedalMarking: () => (/* binding */ PedalMarking)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./metrics */ "./src/metrics.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License





// eslint-disable-next-line
function L(...args) {
    if (PedalMarking.DEBUG)
        (0,_util__WEBPACK_IMPORTED_MODULE_4__.log)('Vex.Flow.PedalMarking', args);
}
/**
 * Draws a pedal glyph with the provided `name` on a rendering `context`
 * at the coordinates `x` and `y. Takes into account the glyph data
 * coordinate shifts.
 */
function drawPedalGlyph(name, ctx, x, y) {
    var _a;
    const glyph = new _element__WEBPACK_IMPORTED_MODULE_0__.Element(PedalMarking.CATEGORY);
    glyph.setText((_a = PedalMarking.GLYPHS[name]) !== null && _a !== void 0 ? _a : name);
    glyph.renderText(ctx, x - (glyph.getWidth() - _tables__WEBPACK_IMPORTED_MODULE_2__.Tables.STAVE_LINE_DISTANCE) / 2, y);
}
/**
 * PedalMarking implements different types of pedal markings. These notation
 * elements indicate to the performer when to depress and release the a pedal.
 *
 * In order to create "Sostenuto", and "una corda" markings, you must set
 * custom text for the release/depress pedal markings.
 */
class PedalMarking extends _element__WEBPACK_IMPORTED_MODULE_0__.Element {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_3__.Category.PedalMarking;
    }
    /**
     * Create a sustain pedal marking. Returns the defaults PedalMarking.
     * Which uses the traditional "Ped" and "*"" markings.
     */
    static createSustain(notes) {
        const pedal = new PedalMarking(notes);
        return pedal;
    }
    /** Create a sostenuto pedal marking */
    static createSostenuto(notes) {
        const pedal = new PedalMarking(notes);
        pedal.setType(PedalMarking.type.MIXED);
        pedal.setCustomText('Sost. Ped.');
        return pedal;
    }
    /** Create an una corda pedal marking */
    static createUnaCorda(notes) {
        const pedal = new PedalMarking(notes);
        pedal.setType(PedalMarking.type.TEXT);
        pedal.setCustomText('una corda', 'tre corda');
        return pedal;
    }
    constructor(notes) {
        super();
        this.notes = notes;
        this.type = PedalMarking.type.TEXT;
        this.line = 0;
        // Custom text for the release/depress markings
        this.customDepressText = '';
        this.customReleaseText = '';
        this.renderOptions = {
            bracketHeight: 10,
            textMarginRight: 6,
            bracketLineWidth: 1,
            color: 'black',
        };
    }
    /** Set pedal type. */
    setType(type) {
        type = typeof type === 'string' ? PedalMarking.typeString[type] : type;
        if (type >= PedalMarking.type.TEXT && type <= PedalMarking.type.MIXED) {
            this.type = type;
        }
        return this;
    }
    /**
     * Set custom text for the `depress`/`release` pedal markings. No text is
     * set if the parameter is falsy.
     */
    setCustomText(depress, release) {
        this.customDepressText = depress || '';
        this.customReleaseText = release || '';
        return this;
    }
    /** Set the staff line to render the markings on. */
    setLine(line) {
        this.line = line;
        return this;
    }
    /** Draw the bracket based pedal markings. */
    drawBracketed() {
        const ctx = this.checkContext();
        let isPedalDepressed = false;
        let prevX;
        let prevY;
        // Iterate through each note
        this.notes.forEach((note, index, notes) => {
            // Each note triggers the opposite pedal action
            isPedalDepressed = !isPedalDepressed;
            // Get the initial coordinates for the note
            const x = note.getAbsoluteX();
            const y = note.checkStave().getYForBottomText(this.line + 3);
            // Throw if current note is positioned before the previous note
            if (x < prevX) {
                throw new _util__WEBPACK_IMPORTED_MODULE_4__.RuntimeError('InvalidConfiguration', 'The notes provided must be in order of ascending x positions');
            }
            // Determine if the previous or next note are the same
            // as the current note. We need to keep track of this for
            // when adjustments are made for the release+depress action
            const nextNoteIsSame = notes[index + 1] === note;
            const prevNoteIsSame = notes[index - 1] === note;
            let xShift = 0;
            if (isPedalDepressed) {
                // Adjustment for release+depress
                xShift = prevNoteIsSame ? 5 : 0;
                if (this.type === PedalMarking.type.MIXED && !prevNoteIsSame) {
                    // For MIXED style, start with text instead of bracket
                    if (this.customDepressText) {
                        // If we have custom text, use instead of the default "Ped" glyph
                        const textWidth = ctx.measureText(this.customDepressText).width;
                        ctx.fillText(this.customDepressText, x - textWidth / 2, y);
                        xShift = textWidth / 2 + this.renderOptions.textMarginRight;
                    }
                    else {
                        // Render the Ped glyph in position
                        drawPedalGlyph('pedalDepress', ctx, x, y);
                        xShift = 20 + this.renderOptions.textMarginRight;
                    }
                }
                else {
                    // Draw start bracket
                    ctx.beginPath();
                    ctx.moveTo(x, y - this.renderOptions.bracketHeight);
                    ctx.lineTo(x + xShift, y);
                    ctx.stroke();
                    ctx.closePath();
                }
            }
            else {
                // Adjustment for release+depress
                xShift = nextNoteIsSame ? -5 : 0;
                // Draw end bracket
                ctx.beginPath();
                ctx.moveTo(prevX, prevY);
                ctx.lineTo(x + xShift, y);
                ctx.lineTo(x, y - this.renderOptions.bracketHeight);
                ctx.stroke();
                ctx.closePath();
            }
            // Store previous coordinates
            prevX = x + xShift;
            prevY = y;
        });
    }
    /**
     * Draw the text based pedal markings. This defaults to the traditional
     * "Ped" and "*"" symbols if no custom text has been provided.
     */
    drawText() {
        const ctx = this.checkContext();
        let isPedalDepressed = false;
        // Iterate through each note, placing glyphs or custom text accordingly
        this.notes.forEach((note) => {
            isPedalDepressed = !isPedalDepressed;
            const stave = note.checkStave();
            const x = note.getAbsoluteX();
            const y = stave.getYForBottomText(this.line + 3);
            let textWidth = 0;
            if (isPedalDepressed) {
                if (this.customDepressText) {
                    textWidth = ctx.measureText(this.customDepressText).width;
                    ctx.fillText(this.customDepressText, x - textWidth / 2, y);
                }
                else {
                    drawPedalGlyph('pedalDepress', ctx, x, y);
                }
            }
            else {
                if (this.customReleaseText) {
                    textWidth = ctx.measureText(this.customReleaseText).width;
                    ctx.fillText(this.customReleaseText, x - textWidth / 2, y);
                }
                else {
                    drawPedalGlyph('pedalRelease', ctx, x, y);
                }
            }
        });
    }
    /** Render the pedal marking in position on the rendering context. */
    draw() {
        const ctx = this.checkContext();
        this.setRendered();
        ctx.save();
        ctx.setStrokeStyle(this.renderOptions.color);
        ctx.setFillStyle(this.renderOptions.color);
        ctx.setFont(_metrics__WEBPACK_IMPORTED_MODULE_1__.Metrics.getFontInfo('PedalMarking.text'));
        L('Rendering Pedal Marking');
        if (this.type === PedalMarking.type.BRACKET || this.type === PedalMarking.type.MIXED) {
            ctx.setLineWidth(this.renderOptions.bracketLineWidth);
            this.drawBracketed();
        }
        else if (this.type === PedalMarking.type.TEXT) {
            this.drawText();
        }
        ctx.restore();
    }
}
/** To enable logging for this class. Set `Vex.Flow.PedalMarking.DEBUG` to `true`. */
PedalMarking.DEBUG = false;
/** Glyph data */
PedalMarking.GLYPHS = {
    pedalDepress: '\uE650' /*keyboardPedalPed*/,
    pedalRelease: '\uE655' /*keyboardPedalUp*/,
};
/** Pedal type as number. */
PedalMarking.type = {
    TEXT: 1,
    BRACKET: 2,
    MIXED: 3,
};
/** Pedal type as string. */
PedalMarking.typeString = {
    text: PedalMarking.type.TEXT,
    bracket: PedalMarking.type.BRACKET,
    mixed: PedalMarking.type.MIXED,
};


/***/ }),

/***/ "./src/registry.ts":
/*!*************************!*\
  !*** ./src/registry.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Registry: () => (/* binding */ Registry)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
// @author Mohit Cheppudira
//
// ## Description
//
// This file implements a registry for VexFlow elements. It allows users
// to track, query, and manage some subset of generated elements, and
// dynamically get and set attributes.
//
// There are two ways to register with a registry:
//
// 1) Explicitly call `registry.register(elem:Element, id?:string)`, or,
// 2) Call `Registry.enableDefaultRegistry(registry)` when ready, and all future
//    elements will automatically register with it.
//
// Once an element is registered, selected attributes are tracked and indexed by
// the registry. This allows fast look up of elements by attributes like id, type,
// and class.
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _a, _Registry_defaultRegistry;

// Indexes are represented as maps of maps of maps. This allows
// for both multi-labeling (e.g., an element can have multiple classes)
// and efficient lookup.
class Index {
    constructor() {
        this.id = {};
        this.type = {};
        this.class = {};
    }
}
class Registry {
    static getDefaultRegistry() {
        return __classPrivateFieldGet(Registry, _a, "f", _Registry_defaultRegistry);
    }
    // If you call `enableDefaultRegistry`, any new elements will auto-register with
    // the provided registry as soon as they're constructed.
    static enableDefaultRegistry(registry) {
        __classPrivateFieldSet(Registry, _a, registry, "f", _Registry_defaultRegistry);
    }
    static disableDefaultRegistry() {
        __classPrivateFieldSet(Registry, _a, undefined, "f", _Registry_defaultRegistry);
    }
    constructor() {
        this.index = new Index();
    }
    clear() {
        this.index = new Index();
        return this;
    }
    setIndexValue(name, value, id, elem) {
        const index = this.index;
        if (!index[name][value]) {
            index[name][value] = {};
        }
        index[name][value][id] = elem;
    }
    // Updates the indexes for element 'id'. If an element's attribute changes
    // from A -> B, make sure to remove the element from A.
    updateIndex({ id, name, value, oldValue }) {
        const elem = this.getElementById(id);
        if (oldValue !== undefined && this.index[name][oldValue]) {
            delete this.index[name][oldValue][id];
        }
        if (value && elem) {
            this.setIndexValue(name, value, elem.getAttribute('id'), elem);
        }
    }
    /**
     * Register element `elem` with this registry.
     * This adds the element to its index and watches it for attribute changes.
     * @param elem
     * @param id
     * @returns this
     */
    register(elem, id) {
        id = id || elem.getAttribute('id');
        if (!id) {
            throw new _util__WEBPACK_IMPORTED_MODULE_0__.RuntimeError("Can't add element without `id` attribute to registry");
        }
        // Manually add id to index, then update other indexes.
        elem.setAttribute('id', id);
        this.setIndexValue('id', id, id, elem);
        this.updateIndex({ id, name: 'type', value: elem.getAttribute('type'), oldValue: undefined });
        elem.onRegister(this);
        return this;
    }
    getElementById(id) {
        var _b, _c;
        return (_c = (_b = this.index.id) === null || _b === void 0 ? void 0 : _b[id]) === null || _c === void 0 ? void 0 : _c[id]; // return undefined if the id is not found.
    }
    getElementsByAttribute(attribute, value) {
        const indexAttr = this.index[attribute];
        if (indexAttr) {
            const indexAttrVal = indexAttr[value];
            if (indexAttrVal) {
                const keys = Object.keys(indexAttrVal);
                return keys.map((k) => indexAttrVal[k]);
            }
        }
        return [];
    }
    getElementsByType(type) {
        return this.getElementsByAttribute('type', type);
    }
    getElementsByClass(className) {
        return this.getElementsByAttribute('class', className);
    }
    // This is called by the element when an attribute value changes. If an indexed
    // attribute changes, then update the local index.
    onUpdate(info) {
        const allowedNames = ['id', 'type', 'class'];
        if (allowedNames.includes(info.name)) {
            this.updateIndex(info);
        }
        return this;
    }
}
_a = Registry;
_Registry_defaultRegistry = { value: void 0 };


/***/ }),

/***/ "./src/rendercontext.ts":
/*!******************************!*\
  !*** ./src/rendercontext.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RenderContext: () => (/* binding */ RenderContext),
/* harmony export */   drawDot: () => (/* binding */ drawDot)
/* harmony export */ });
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License

class RenderContext {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_0__.Category.RenderContext;
    }
    set font(f) {
        this.setFont(f);
    }
    get font() {
        return this.getFont();
    }
}
/**
 * Draw a tiny dot marker on the specified context. A great debugging aid.
 * @param ctx context
 * @param x dot x coordinate
 * @param y dot y coordinate
 * @param color
 */
function drawDot(ctx, x, y, color = '#F55') {
    ctx.save();
    ctx.setFillStyle(color);
    // draw a circle
    ctx.beginPath();
    ctx.arc(x, y, 3, 0, Math.PI * 2, false);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
}


/***/ }),

/***/ "./src/renderer.ts":
/*!*************************!*\
  !*** ./src/renderer.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Renderer: () => (/* binding */ Renderer),
/* harmony export */   RendererBackends: () => (/* binding */ RendererBackends),
/* harmony export */   RendererLineEndType: () => (/* binding */ RendererLineEndType)
/* harmony export */ });
/* harmony import */ var _canvascontext__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./canvascontext */ "./src/canvascontext.ts");
/* harmony import */ var _svgcontext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./svgcontext */ "./src/svgcontext.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ "./src/util.ts");
/* harmony import */ var _web__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./web */ "./src/web.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License





var RendererBackends;
(function (RendererBackends) {
    RendererBackends[RendererBackends["CANVAS"] = 1] = "CANVAS";
    RendererBackends[RendererBackends["SVG"] = 2] = "SVG";
})(RendererBackends || (RendererBackends = {}));
// End of line types
var RendererLineEndType;
(function (RendererLineEndType) {
    RendererLineEndType[RendererLineEndType["NONE"] = 1] = "NONE";
    RendererLineEndType[RendererLineEndType["UP"] = 2] = "UP";
    RendererLineEndType[RendererLineEndType["DOWN"] = 3] = "DOWN";
})(RendererLineEndType || (RendererLineEndType = {}));
/**
 * Support Canvas & SVG rendering contexts.
 */
class Renderer {
    static buildContext(elementId, backend, width, height, background = '#FFF') {
        const renderer = new Renderer(elementId, backend);
        if (width && height) {
            renderer.resize(width, height);
        }
        const ctx = renderer.getContext();
        ctx.setBackgroundFillStyle(background);
        Renderer.lastContext = ctx;
        return ctx;
    }
    static getCanvasContext(elementId, width, height, background) {
        return Renderer.buildContext(elementId, Renderer.Backends.CANVAS, width, height, background);
    }
    static getSVGContext(elementId, width, height, background) {
        return Renderer.buildContext(elementId, Renderer.Backends.SVG, width, height, background);
    }
    // Draw a dashed line (horizontal, vertical or diagonal
    // dashPattern = [3,3] draws a 3 pixel dash followed by a three pixel space.
    // setting the second number to 0 draws a solid line.
    static drawDashedLine(context, fromX, fromY, toX, toY, dashPattern) {
        context.beginPath();
        const dx = toX - fromX;
        const dy = toY - fromY;
        const angle = Math.atan2(dy, dx);
        let x = fromX;
        let y = fromY;
        context.moveTo(fromX, fromY);
        let idx = 0;
        let draw = true;
        while (!((dx < 0 ? x <= toX : x >= toX) && (dy < 0 ? y <= toY : y >= toY))) {
            const dashLength = dashPattern[idx++ % dashPattern.length];
            const nx = x + Math.cos(angle) * dashLength;
            x = dx < 0 ? Math.max(toX, nx) : Math.min(toX, nx);
            const ny = y + Math.sin(angle) * dashLength;
            y = dy < 0 ? Math.max(toY, ny) : Math.min(toY, ny);
            if (draw) {
                context.lineTo(x, y);
            }
            else {
                context.moveTo(x, y);
            }
            draw = !draw;
        }
        context.closePath();
        context.stroke();
    }
    constructor(arg0, arg1) {
        if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_2__.isRenderContext)(arg0)) {
            // The user has provided what looks like a RenderContext, let's just use it.
            this.ctx = arg0;
        }
        else {
            if (arg1 === undefined) {
                // The backend must be specified if the render context isn't directly provided.
                throw new _util__WEBPACK_IMPORTED_MODULE_3__.RuntimeError('InvalidArgument', 'Missing backend argument');
            }
            const backend = arg1;
            let element;
            if (typeof arg0 === 'string') {
                const maybeElement = document.getElementById(arg0);
                if (!maybeElement) {
                    throw new _util__WEBPACK_IMPORTED_MODULE_3__.RuntimeError('BadElementId', `Can't find element with ID "${maybeElement}"`);
                }
                element = maybeElement;
            }
            else {
                element = arg0;
            }
            // Verify backend and create context
            if (backend === Renderer.Backends.CANVAS) {
                if (!(0,_web__WEBPACK_IMPORTED_MODULE_4__.isHTMLCanvas)(element)) {
                    throw new _util__WEBPACK_IMPORTED_MODULE_3__.RuntimeError('BadElement', 'CANVAS context requires an HTMLCanvasElement.');
                }
                const context = element.getContext('2d', { willReadFrequently: true });
                if (!context) {
                    throw new _util__WEBPACK_IMPORTED_MODULE_3__.RuntimeError('BadElement', "Can't get canvas context");
                }
                this.ctx = new _canvascontext__WEBPACK_IMPORTED_MODULE_0__.CanvasContext(context);
            }
            else if (backend === Renderer.Backends.SVG) {
                if (!(0,_web__WEBPACK_IMPORTED_MODULE_4__.isHTMLDiv)(element)) {
                    throw new _util__WEBPACK_IMPORTED_MODULE_3__.RuntimeError('BadElement', 'SVG context requires an HTMLDivElement.');
                }
                this.ctx = new _svgcontext__WEBPACK_IMPORTED_MODULE_1__.SVGContext(element);
            }
            else {
                throw new _util__WEBPACK_IMPORTED_MODULE_3__.RuntimeError('InvalidBackend', `No support for backend: ${backend}`);
            }
        }
    }
    resize(width, height) {
        this.ctx.resize(width, height);
        return this;
    }
    getContext() {
        return this.ctx;
    }
}
Renderer.Backends = RendererBackends;
Renderer.LineEndType = RendererLineEndType;
// Used by vexflow_test_helpers.ts
// Should this be private?
// Can we do this in a cleaner way?
Renderer.lastContext = undefined;


/***/ }),

/***/ "./src/repeatnote.ts":
/*!***************************!*\
  !*** ./src/repeatnote.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RepeatNote: () => (/* binding */ RepeatNote)
/* harmony export */ });
/* harmony import */ var _glyphnote__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glyphnote */ "./src/glyphnote.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors


// Map `type` to SMuFL glyph code.
const CODES = {
    '1': '\uE500' /*repeat1Bar*/,
    '2': '\uE501' /*repeat2Bars*/,
    '4': '\uE502' /*repeat4Bars*/,
    slash: '\uE504' /*repeatBarSlash*/,
};
class RepeatNote extends _glyphnote__WEBPACK_IMPORTED_MODULE_0__.GlyphNote {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_1__.Category.RepeatNote;
    }
    constructor(type, noteStruct, options) {
        const glyphCode = CODES[type] || '\uE500'; /*repeat1Bar*/
        super(glyphCode, Object.assign({ duration: 'q', alignCenter: type !== 'slash' }, noteStruct), options);
    }
}


/***/ }),

/***/ "./src/stave.ts":
/*!**********************!*\
  !*** ./src/stave.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Stave: () => (/* binding */ Stave)
/* harmony export */ });
/* harmony import */ var _boundingbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boundingbox */ "./src/boundingbox.ts");
/* harmony import */ var _clef__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./clef */ "./src/clef.ts");
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _keysignature__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./keysignature */ "./src/keysignature.ts");
/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./metrics */ "./src/metrics.ts");
/* harmony import */ var _stavebarline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./stavebarline */ "./src/stavebarline.ts");
/* harmony import */ var _stavemodifier__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./stavemodifier */ "./src/stavemodifier.ts");
/* harmony import */ var _staverepetition__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./staverepetition */ "./src/staverepetition.ts");
/* harmony import */ var _stavesection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./stavesection */ "./src/stavesection.ts");
/* harmony import */ var _stavetempo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./stavetempo */ "./src/stavetempo.ts");
/* harmony import */ var _stavetext__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./stavetext */ "./src/stavetext.ts");
/* harmony import */ var _stavevolta__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./stavevolta */ "./src/stavevolta.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _timesignature__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./timesignature */ "./src/timesignature.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
















// Used by Stave.format() to sort the modifiers at the beginning and end of a stave.
// The keys (computed property names) match the CATEGORY property in the
// Barline, Clef, KeySignature, TimeSignature classes.
const SORT_ORDER_BEG_MODIFIERS = {
    [_stavebarline__WEBPACK_IMPORTED_MODULE_5__.Barline.CATEGORY]: 0,
    [_clef__WEBPACK_IMPORTED_MODULE_1__.Clef.CATEGORY]: 1,
    [_keysignature__WEBPACK_IMPORTED_MODULE_3__.KeySignature.CATEGORY]: 2,
    [_timesignature__WEBPACK_IMPORTED_MODULE_13__.TimeSignature.CATEGORY]: 3,
};
const SORT_ORDER_END_MODIFIERS = {
    [_timesignature__WEBPACK_IMPORTED_MODULE_13__.TimeSignature.CATEGORY]: 0,
    [_keysignature__WEBPACK_IMPORTED_MODULE_3__.KeySignature.CATEGORY]: 1,
    [_stavebarline__WEBPACK_IMPORTED_MODULE_5__.Barline.CATEGORY]: 2,
    [_clef__WEBPACK_IMPORTED_MODULE_1__.Clef.CATEGORY]: 3,
};
class Stave extends _element__WEBPACK_IMPORTED_MODULE_2__.Element {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_14__.Category.Stave;
    }
    // This is the sum of the padding that normally goes on left + right of a stave during
    // drawing. Used to size staves correctly with content width.
    static get defaultPadding() {
        return _metrics__WEBPACK_IMPORTED_MODULE_4__.Metrics.get('Stave.padding') + _metrics__WEBPACK_IMPORTED_MODULE_4__.Metrics.get('Stave.endPaddingMax');
    }
    // Right padding, used by system if startX is already determined.
    static get rightPadding() {
        return _metrics__WEBPACK_IMPORTED_MODULE_4__.Metrics.get('Stave.endPaddingMax');
    }
    constructor(x, y, width, options) {
        super();
        this.x = x;
        this.y = y;
        this.width = width;
        this.formatted = false;
        this.startX = x + 5;
        this.endX = x + width;
        this.modifiers = []; // stave modifiers (clef, key, time, barlines, coda, segno, etc.)
        this.measure = 0;
        this.clef = 'treble';
        this.endClef = undefined;
        this.options = Object.assign({ verticalBarWidth: 10, numLines: 5, fillStyle: '#999999', leftBar: true, rightBar: true, spacingBetweenLinesPx: _tables__WEBPACK_IMPORTED_MODULE_12__.Tables.STAVE_LINE_DISTANCE, spaceAboveStaffLn: 4, spaceBelowStaffLn: 4, topTextPosition: 1, bottomTextPosition: 4, lineConfig: [] }, options);
        this.bounds = { x: this.x, y: this.y, w: this.width, h: 0 };
        this.defaultLedgerLineStyle = { strokeStyle: '#444', lineWidth: 1.4 };
        this.resetLines();
        // beg bar
        this.addModifier(new _stavebarline__WEBPACK_IMPORTED_MODULE_5__.Barline(this.options.leftBar ? _stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.SINGLE : _stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.NONE));
        // end bar
        this.addEndModifier(new _stavebarline__WEBPACK_IMPORTED_MODULE_5__.Barline(this.options.rightBar ? _stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.SINGLE : _stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.NONE));
    }
    /** Set default style for ledger lines. */
    setDefaultLedgerLineStyle(style) {
        this.defaultLedgerLineStyle = style;
    }
    /** Get default style for ledger lines. */
    getDefaultLedgerLineStyle() {
        return Object.assign(Object.assign({}, this.getStyle()), this.defaultLedgerLineStyle);
    }
    space(spacing) {
        return this.options.spacingBetweenLinesPx * spacing;
    }
    resetLines() {
        this.options.lineConfig = [];
        for (let i = 0; i < this.options.numLines; i++) {
            this.options.lineConfig.push({ visible: true });
        }
        this.height = (this.options.numLines + this.options.spaceAboveStaffLn) * this.options.spacingBetweenLinesPx;
        this.options.bottomTextPosition = this.options.numLines;
    }
    setNoteStartX(x) {
        if (!this.formatted)
            this.format();
        this.startX = x;
        return this;
    }
    getNoteStartX() {
        if (!this.formatted)
            this.format();
        return this.startX;
    }
    getNoteEndX() {
        if (!this.formatted)
            this.format();
        return this.endX;
    }
    getTieStartX() {
        return this.startX;
    }
    getTieEndX() {
        return this.endX;
    }
    getNumLines() {
        return this.options.numLines;
    }
    setNumLines(n) {
        this.options.numLines = n;
        this.resetLines();
        return this;
    }
    getTopLineTopY() {
        return this.getYForLine(0) - _tables__WEBPACK_IMPORTED_MODULE_12__.Tables.STAVE_LINE_THICKNESS / 2;
    }
    getBottomLineBottomY() {
        return this.getYForLine(this.getNumLines() - 1) + _tables__WEBPACK_IMPORTED_MODULE_12__.Tables.STAVE_LINE_THICKNESS / 2;
    }
    setX(x) {
        const shift = x - this.x;
        this.formatted = false;
        this.x = x;
        this.startX += shift;
        this.endX += shift;
        for (let i = 0; i < this.modifiers.length; i++) {
            const mod = this.modifiers[i];
            mod.setX(mod.getX() + shift);
        }
        return this;
    }
    setWidth(width) {
        this.formatted = false;
        this.width = width;
        this.endX = this.x + width;
        // reset the x position of the end barline (TODO(0xfe): This makes no sense)
        // this.modifiers[1].setX(this.endX);
        return this;
    }
    getStyle() {
        return Object.assign({ fillStyle: this.options.fillStyle, strokeStyle: this.options.fillStyle, lineWidth: _tables__WEBPACK_IMPORTED_MODULE_12__.Tables.STAVE_LINE_THICKNESS }, super.getStyle());
    }
    /**
     * Set the measure number of this Stave.
     */
    setMeasure(measure) {
        this.measure = measure;
        return this;
    }
    /**
     * Return the measure number of this Stave.
     */
    getMeasure() {
        return this.measure;
    }
    /**
     * Gets the pixels to shift from the beginning of the stave
     * following the modifier at the provided index
     * @param  {Number} index The index from which to determine the shift
     * @return {Number}       The amount of pixels shifted
     */
    getModifierXShift(index = 0) {
        if (typeof index !== 'number') {
            throw new _util__WEBPACK_IMPORTED_MODULE_15__.RuntimeError('InvalidIndex', 'Must be of number type');
        }
        if (!this.formatted)
            this.format();
        if (this.getModifiers(_stavemodifier__WEBPACK_IMPORTED_MODULE_6__.StaveModifierPosition.BEGIN).length === 1) {
            return 0;
        }
        // for right position modifiers zero shift seems correct, see 'Volta + Modifier Measure Test'
        if (this.modifiers[index].getPosition() === _stavemodifier__WEBPACK_IMPORTED_MODULE_6__.StaveModifierPosition.RIGHT) {
            return 0;
        }
        let startX = this.startX - this.x;
        const begBarline = this.modifiers[0];
        if (begBarline.getType() === _stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.REPEAT_BEGIN && startX > begBarline.getWidth()) {
            startX -= begBarline.getWidth();
        }
        return startX;
    }
    /** Coda & Segno Symbol functions */
    setRepetitionType(type, yShift = 0) {
        this.modifiers.push(new _staverepetition__WEBPACK_IMPORTED_MODULE_7__.Repetition(type, this.x, yShift));
        return this;
    }
    // Volta functions
    setVoltaType(type, label, y) {
        this.modifiers.push(new _stavevolta__WEBPACK_IMPORTED_MODULE_11__.Volta(type, label, this.x, y));
        return this;
    }
    // Section functions
    setSection(section, y, xOffset = 0, fontSize, drawRect = true) {
        const staveSection = new _stavesection__WEBPACK_IMPORTED_MODULE_8__.StaveSection(section, this.x + xOffset, y, drawRect);
        if (fontSize) {
            staveSection.setFontSize(fontSize);
        }
        this.modifiers.push(staveSection);
        return this;
    }
    // Tempo functions
    setTempo(tempo, y) {
        this.modifiers.push(new _stavetempo__WEBPACK_IMPORTED_MODULE_9__.StaveTempo(tempo, this.x, y));
        return this;
    }
    // Text functions
    setStaveText(text, position, options = {}) {
        this.modifiers.push(new _stavetext__WEBPACK_IMPORTED_MODULE_10__.StaveText(text, position, options));
        return this;
    }
    getSpacingBetweenLines() {
        return this.options.spacingBetweenLinesPx;
    }
    getBoundingBox() {
        return new _boundingbox__WEBPACK_IMPORTED_MODULE_0__.BoundingBox(this.x, this.y, this.width, this.getBottomY() - this.y);
    }
    getBottomY() {
        const options = this.options;
        const spacing = options.spacingBetweenLinesPx;
        const scoreBottom = this.getYForLine(options.numLines) + options.spaceBelowStaffLn * spacing;
        return scoreBottom;
    }
    getBottomLineY() {
        return this.getYForLine(this.options.numLines);
    }
    // This returns
    /** @returns the y for the *center* of a staff line */
    getYForLine(line) {
        const options = this.options;
        const spacing = options.spacingBetweenLinesPx;
        const headroom = options.spaceAboveStaffLn;
        const y = this.y + line * spacing + headroom * spacing;
        return y;
    }
    getLineForY(y) {
        // Does the reverse of getYForLine - somewhat dumb and just calls
        // getYForLine until the right value is reaches
        const options = this.options;
        const spacing = options.spacingBetweenLinesPx;
        const headroom = options.spaceAboveStaffLn;
        return (y - this.y) / spacing - headroom;
    }
    getYForTopText(line = 0) {
        return this.getYForLine(-line - this.options.topTextPosition);
    }
    getYForBottomText(line = 0) {
        return this.getYForLine(this.options.bottomTextPosition + line);
    }
    getYForNote(line) {
        const options = this.options;
        const spacing = options.spacingBetweenLinesPx;
        const headroom = options.spaceAboveStaffLn;
        return this.y + headroom * spacing + 5 * spacing - line * spacing;
    }
    getYForGlyphs() {
        return this.getYForLine(3);
    }
    // This method adds a stave modifier to the stave. Note that the first two
    // modifiers (BarLines) are automatically added upon construction.
    addModifier(modifier, position) {
        if (position !== undefined) {
            modifier.setPosition(position);
        }
        modifier.setStave(this);
        this.formatted = false;
        this.modifiers.push(modifier);
        return this;
    }
    addEndModifier(modifier) {
        this.addModifier(modifier, _stavemodifier__WEBPACK_IMPORTED_MODULE_6__.StaveModifierPosition.END);
        return this;
    }
    // Bar Line functions
    setBegBarType(type) {
        // Only valid bar types at beginning of stave is none, single or begin repeat
        const { SINGLE, REPEAT_BEGIN, NONE } = _stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType;
        if (type === SINGLE || type === REPEAT_BEGIN || type === NONE) {
            this.modifiers[0].setType(type);
            this.formatted = false;
        }
        return this;
    }
    setEndBarType(type) {
        // Repeat end not valid at end of stave
        if (type !== _stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.REPEAT_BEGIN) {
            this.modifiers[1].setType(type);
            this.formatted = false;
        }
        return this;
    }
    setClef(clefSpec, size, annotation, position) {
        if (position === undefined) {
            position = _stavemodifier__WEBPACK_IMPORTED_MODULE_6__.StaveModifierPosition.BEGIN;
        }
        if (position === _stavemodifier__WEBPACK_IMPORTED_MODULE_6__.StaveModifierPosition.END) {
            this.endClef = clefSpec;
        }
        else {
            this.clef = clefSpec;
        }
        const clefs = this.getModifiers(position, _clef__WEBPACK_IMPORTED_MODULE_1__.Clef.CATEGORY);
        if (clefs.length === 0) {
            this.addClef(clefSpec, size, annotation, position);
        }
        else {
            clefs[0].setType(clefSpec, size, annotation);
        }
        return this;
    }
    getClef() {
        return this.clef;
    }
    setEndClef(clefSpec, size, annotation) {
        this.setClef(clefSpec, size, annotation, _stavemodifier__WEBPACK_IMPORTED_MODULE_6__.StaveModifierPosition.END);
        return this;
    }
    getEndClef() {
        return this.endClef;
    }
    setKeySignature(keySpec, cancelKeySpec, position) {
        if (position === undefined) {
            position = _stavemodifier__WEBPACK_IMPORTED_MODULE_6__.StaveModifierPosition.BEGIN;
        }
        const keySignatures = this.getModifiers(position, _keysignature__WEBPACK_IMPORTED_MODULE_3__.KeySignature.CATEGORY);
        if (keySignatures.length === 0) {
            this.addKeySignature(keySpec, cancelKeySpec, position);
        }
        else {
            keySignatures[0].setKeySig(keySpec, cancelKeySpec);
        }
        return this;
    }
    setEndKeySignature(keySpec, cancelKeySpec) {
        this.setKeySignature(keySpec, cancelKeySpec, _stavemodifier__WEBPACK_IMPORTED_MODULE_6__.StaveModifierPosition.END);
        return this;
    }
    setTimeSignature(timeSpec, customPadding, position) {
        if (position === undefined) {
            position = _stavemodifier__WEBPACK_IMPORTED_MODULE_6__.StaveModifierPosition.BEGIN;
        }
        const timeSignatures = this.getModifiers(position, _timesignature__WEBPACK_IMPORTED_MODULE_13__.TimeSignature.CATEGORY);
        if (timeSignatures.length === 0) {
            this.addTimeSignature(timeSpec, customPadding, position);
        }
        else {
            timeSignatures[0].setTimeSig(timeSpec);
        }
        return this;
    }
    setEndTimeSignature(timeSpec, customPadding) {
        this.setTimeSignature(timeSpec, customPadding, _stavemodifier__WEBPACK_IMPORTED_MODULE_6__.StaveModifierPosition.END);
        return this;
    }
    /**
     * Add a key signature to the stave.
     *
     * Example:
     * `stave.addKeySignature('Db');`
     * @param keySpec new key specification `[A-G][b|#]?`
     * @param cancelKeySpec
     * @param position
     * @returns
     */
    addKeySignature(keySpec, cancelKeySpec, position) {
        if (position === undefined) {
            position = _stavemodifier__WEBPACK_IMPORTED_MODULE_6__.StaveModifierPosition.BEGIN;
        }
        this.addModifier(new _keysignature__WEBPACK_IMPORTED_MODULE_3__.KeySignature(keySpec, cancelKeySpec).setPosition(position), position);
        return this;
    }
    /**
     * Add a clef to the stave.
     *
     * Example:
     *
     * stave.addClef('treble')
     * @param clef clef (treble|bass|...) see {@link Clef.types}
     * @param size
     * @param annotation
     * @param position
     * @returns
     */
    addClef(clef, size, annotation, position) {
        if (position === undefined || position === _stavemodifier__WEBPACK_IMPORTED_MODULE_6__.StaveModifierPosition.BEGIN) {
            this.clef = clef;
        }
        else if (position === _stavemodifier__WEBPACK_IMPORTED_MODULE_6__.StaveModifierPosition.END) {
            this.endClef = clef;
        }
        this.addModifier(new _clef__WEBPACK_IMPORTED_MODULE_1__.Clef(clef, size, annotation), position);
        return this;
    }
    addEndClef(clef, size, annotation) {
        this.addClef(clef, size, annotation, _stavemodifier__WEBPACK_IMPORTED_MODULE_6__.StaveModifierPosition.END);
        return this;
    }
    /**
     * Add a time signature to the stave
     *
     * Example:
     *
     * `stave.addTimeSignature('4/4');`
     * @param timeSpec time signature specification `(C\||C|\d\/\d)`
     * @param customPadding
     * @param position
     * @returns
     */
    addTimeSignature(timeSpec, customPadding, position) {
        this.addModifier(new _timesignature__WEBPACK_IMPORTED_MODULE_13__.TimeSignature(timeSpec, customPadding), position);
        return this;
    }
    addEndTimeSignature(timeSpec, customPadding) {
        this.addTimeSignature(timeSpec, customPadding, _stavemodifier__WEBPACK_IMPORTED_MODULE_6__.StaveModifierPosition.END);
        return this;
    }
    // Deprecated
    addTrebleGlyph() {
        this.addClef('treble');
        return this;
    }
    /**
     * @param position
     * @param category
     * @returns array of StaveModifiers that match the provided position and category.
     */
    getModifiers(position, category) {
        const noPosition = position === undefined;
        const noCategory = category === undefined;
        if (noPosition && noCategory) {
            return this.modifiers;
        }
        else if (noPosition) {
            // A category was provided.
            return this.modifiers.filter((m) => category === m.getCategory());
        }
        else if (noCategory) {
            // A position was provided.
            return this.modifiers.filter((m) => position === m.getPosition());
        }
        else {
            // Both position and category were provided!
            return this.modifiers.filter((m) => position === m.getPosition() && category === m.getCategory());
        }
    }
    /**
     * Use the modifier's `getCategory()` as a key for the `order` array.
     * The retrieved value is used to sort modifiers from left to right (0 to to 3).
     */
    sortByCategory(items, order) {
        for (let i = items.length - 1; i >= 0; i--) {
            for (let j = 0; j < i; j++) {
                if (order[items[j].getCategory()] > order[items[j + 1].getCategory()]) {
                    const temp = items[j];
                    items[j] = items[j + 1];
                    items[j + 1] = temp;
                }
            }
        }
    }
    format() {
        var _a, _b, _c, _d;
        const begBarline = this.modifiers[0];
        const endBarline = this.modifiers[1];
        const begModifiers = this.getModifiers(_stavemodifier__WEBPACK_IMPORTED_MODULE_6__.StaveModifierPosition.BEGIN);
        const endModifiers = this.getModifiers(_stavemodifier__WEBPACK_IMPORTED_MODULE_6__.StaveModifierPosition.END);
        this.sortByCategory(begModifiers, SORT_ORDER_BEG_MODIFIERS);
        this.sortByCategory(endModifiers, SORT_ORDER_END_MODIFIERS);
        if (begModifiers.length > 1 && begBarline.getType() === _stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.REPEAT_BEGIN) {
            begModifiers.push(begModifiers.splice(0, 1)[0]);
            begModifiers.splice(0, 0, new _stavebarline__WEBPACK_IMPORTED_MODULE_5__.Barline(_stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.SINGLE));
        }
        if (endModifiers.indexOf(endBarline) > 0) {
            endModifiers.splice(0, 0, new _stavebarline__WEBPACK_IMPORTED_MODULE_5__.Barline(_stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.NONE));
        }
        let width;
        let padding;
        let modifier;
        let offset = 0;
        let x = this.x;
        for (let i = 0; i < begModifiers.length; i++) {
            modifier = begModifiers[i];
            padding = modifier.getPadding(i + offset);
            width = modifier.getWidth();
            x += padding;
            modifier.setX(x);
            x += width;
            if (padding + width === 0)
                offset--;
        }
        this.startX = x;
        x = this.x + this.width;
        const widths = {
            left: 0,
            right: 0,
            paddingRight: 0,
            paddingLeft: 0,
        };
        let lastBarlineIdx = 0;
        for (let i = 0; i < endModifiers.length; i++) {
            modifier = endModifiers[i];
            lastBarlineIdx = (0,_typeguard__WEBPACK_IMPORTED_MODULE_14__.isBarline)(modifier) ? i : lastBarlineIdx;
            widths.right = 0;
            widths.left = 0;
            widths.paddingRight = 0;
            widths.paddingLeft = 0;
            const layoutMetrics = modifier.getLayoutMetrics();
            if (layoutMetrics) {
                if (i !== 0) {
                    widths.right = (_a = layoutMetrics.xMax) !== null && _a !== void 0 ? _a : 0;
                    widths.paddingRight = (_b = layoutMetrics.paddingRight) !== null && _b !== void 0 ? _b : 0;
                }
                widths.left = (_c = -layoutMetrics.xMin) !== null && _c !== void 0 ? _c : 0;
                widths.paddingLeft = (_d = layoutMetrics.paddingLeft) !== null && _d !== void 0 ? _d : 0;
                if (i === endModifiers.length - 1) {
                    widths.paddingLeft = 0;
                }
            }
            else {
                widths.paddingRight = modifier.getPadding(i - lastBarlineIdx);
                if (i !== 0) {
                    widths.right = modifier.getWidth();
                }
                if (i === 0) {
                    widths.left = modifier.getWidth();
                }
            }
            x -= widths.paddingRight;
            x -= widths.right;
            modifier.setX(x);
            x -= widths.left;
            x -= widths.paddingLeft;
        }
        this.endX = endModifiers.length === 1 ? this.x + this.width : x;
        this.formatted = true;
    }
    /**
     * All drawing functions below need the context to be set.
     */
    draw() {
        const ctx = this.checkContext();
        this.setRendered();
        this.applyStyle();
        ctx.openGroup('stave', this.getAttribute('id'));
        if (!this.formatted)
            this.format();
        const numLines = this.options.numLines;
        const width = this.width;
        const x = this.x;
        let y;
        // Render lines
        for (let line = 0; line < numLines; line++) {
            y = this.getYForLine(line);
            if (this.options.lineConfig[line].visible) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + width, y);
                ctx.stroke();
            }
        }
        ctx.closeGroup();
        this.restoreStyle();
        // Draw the modifiers (bar lines, coda, segno, repeat brackets, etc.)
        for (let i = 0; i < this.modifiers.length; i++) {
            const modifier = this.modifiers[i];
            // Only draw modifier if it has a draw function
            if (typeof modifier.draw === 'function') {
                modifier.applyStyle(ctx);
                modifier.draw(this, this.getModifierXShift(i));
                modifier.restoreStyle(ctx);
            }
        }
        // Render measure numbers
        if (this.measure > 0) {
            ctx.save();
            ctx.setFont(this.fontInfo);
            const textWidth = ctx.measureText('' + this.measure).width;
            y = this.getYForTopText(0) + 3;
            ctx.fillText('' + this.measure, this.x - textWidth / 2, y);
            ctx.restore();
        }
        return this;
    }
    getVerticalBarWidth() {
        return this.options.verticalBarWidth;
    }
    /**
     * Get the current configuration for the Stave.
     * @return {Array} An array of configuration objects.
     */
    getConfigForLines() {
        return this.options.lineConfig;
    }
    /**
     * Configure properties of the lines in the Stave
     * @param lineNumber The index of the line to configure.
     * @param lineConfig An configuration object for the specified line.
     * @throws RuntimeError "StaveConfigError" When the specified line number is out of
     *   range of the number of lines specified in the constructor.
     */
    setConfigForLine(lineNumber, lineConfig) {
        if (lineNumber >= this.options.numLines || lineNumber < 0) {
            throw new _util__WEBPACK_IMPORTED_MODULE_15__.RuntimeError('StaveConfigError', 'The line number must be within the range of the number of lines in the Stave.');
        }
        if (lineConfig.visible === undefined) {
            throw new _util__WEBPACK_IMPORTED_MODULE_15__.RuntimeError('StaveConfigError', "The line configuration object is missing the 'visible' property.");
        }
        if (typeof lineConfig.visible !== 'boolean') {
            throw new _util__WEBPACK_IMPORTED_MODULE_15__.RuntimeError('StaveConfigError', "The line configuration objects 'visible' property must be true or false.");
        }
        this.options.lineConfig[lineNumber] = lineConfig;
        return this;
    }
    /**
     * Set the staff line configuration array for all of the lines at once.
     * @param linesConfiguration An array of line configuration objects.  These objects
     *   are of the same format as the single one passed in to setLineConfiguration().
     *   The caller can set null for any line config entry if it is desired that the default be used
     * @throws RuntimeError "StaveConfigError" When the lines_configuration array does not have
     *   exactly the same number of elements as the numLines configuration object set in
     *   the constructor.
     */
    setConfigForLines(linesConfiguration) {
        if (linesConfiguration.length !== this.options.numLines) {
            throw new _util__WEBPACK_IMPORTED_MODULE_15__.RuntimeError('StaveConfigError', 'The length of the lines configuration array must match the number of lines in the Stave');
        }
        // Make sure the defaults are present in case an incomplete set of
        //  configuration options were supplied.
        // eslint-disable-next-line
        for (const lineConfig in linesConfiguration) {
            // Allow '{}' to be used if the caller just wants the default for a particular node.
            if (linesConfiguration[lineConfig].visible === undefined) {
                linesConfiguration[lineConfig] = this.options.lineConfig[lineConfig];
            }
            this.options.lineConfig[lineConfig] = Object.assign(Object.assign({}, this.options.lineConfig[lineConfig]), linesConfiguration[lineConfig]);
        }
        this.options.lineConfig = linesConfiguration;
        return this;
    }
    static formatBegModifiers(staves) {
        const adjustCategoryStartX = (category) => {
            let minStartX = 0;
            // Calculate min start X for the category
            staves.forEach((stave) => {
                const modifiers = stave.getModifiers(_stavemodifier__WEBPACK_IMPORTED_MODULE_6__.StaveModifierPosition.BEGIN, category);
                // Consider only the first instance
                if (modifiers.length > 0 && modifiers[0].getX() > minStartX)
                    minStartX = modifiers[0].getX();
            });
            let adjustX = 0;
            staves.forEach((stave) => {
                adjustX = 0;
                const modifiers = stave.getModifiers(_stavemodifier__WEBPACK_IMPORTED_MODULE_6__.StaveModifierPosition.BEGIN, category);
                // Calculate adjustement required for the stave
                modifiers.forEach((modifier) => {
                    if (minStartX - modifier.getX() > adjustX)
                        adjustX = minStartX - modifier.getX();
                });
                const allModifiers = stave.getModifiers(_stavemodifier__WEBPACK_IMPORTED_MODULE_6__.StaveModifierPosition.BEGIN);
                let bAdjust = false;
                // Apply adjustment to all the modifiers in and beyond the category
                allModifiers.forEach((modifier) => {
                    if (modifier.getCategory() === category)
                        bAdjust = true;
                    if (bAdjust && adjustX > 0)
                        modifier.setX(modifier.getX() + adjustX);
                });
                // Apply adjustment also to note start.
                stave.setNoteStartX(stave.getNoteStartX() + adjustX);
            });
        };
        // Make sure that staves are formatted
        staves.forEach((stave) => {
            if (!stave.formatted)
                stave.format();
        });
        // Align Clefs
        adjustCategoryStartX(_typeguard__WEBPACK_IMPORTED_MODULE_14__.Category.Clef);
        // Align key signatures
        adjustCategoryStartX(_typeguard__WEBPACK_IMPORTED_MODULE_14__.Category.KeySignature);
        // Align time signatures
        adjustCategoryStartX(_typeguard__WEBPACK_IMPORTED_MODULE_14__.Category.TimeSignature);
        let maxX = 0;
        // align note start
        staves.forEach((stave) => {
            if (stave.getNoteStartX() > maxX)
                maxX = stave.getNoteStartX();
        });
        staves.forEach((stave) => {
            stave.setNoteStartX(maxX);
        });
        maxX = 0;
        // align REPEAT_BEGIN
        staves.forEach((stave) => {
            const modifiers = stave.getModifiers(_stavemodifier__WEBPACK_IMPORTED_MODULE_6__.StaveModifierPosition.BEGIN, _typeguard__WEBPACK_IMPORTED_MODULE_14__.Category.Barline);
            modifiers.forEach((modifier) => {
                if (modifier.getType() === _stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.REPEAT_BEGIN)
                    if (modifier.getX() > maxX)
                        maxX = modifier.getX();
            });
        });
        staves.forEach((stave) => {
            const modifiers = stave.getModifiers(_stavemodifier__WEBPACK_IMPORTED_MODULE_6__.StaveModifierPosition.BEGIN, _typeguard__WEBPACK_IMPORTED_MODULE_14__.Category.Barline);
            modifiers.forEach((modifier) => {
                if (modifier.getType() === _stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.REPEAT_BEGIN)
                    modifier.setX(maxX);
            });
        });
    }
}


/***/ }),

/***/ "./src/stavebarline.ts":
/*!*****************************!*\
  !*** ./src/stavebarline.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Barline: () => (/* binding */ Barline),
/* harmony export */   BarlineType: () => (/* binding */ BarlineType)
/* harmony export */ });
/* harmony import */ var _stavemodifier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stavemodifier */ "./src/stavemodifier.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
//
// @author: Larry Kuhns 2011



var BarlineType;
(function (BarlineType) {
    BarlineType[BarlineType["SINGLE"] = 1] = "SINGLE";
    BarlineType[BarlineType["DOUBLE"] = 2] = "DOUBLE";
    BarlineType[BarlineType["END"] = 3] = "END";
    BarlineType[BarlineType["REPEAT_BEGIN"] = 4] = "REPEAT_BEGIN";
    BarlineType[BarlineType["REPEAT_END"] = 5] = "REPEAT_END";
    BarlineType[BarlineType["REPEAT_BOTH"] = 6] = "REPEAT_BOTH";
    BarlineType[BarlineType["NONE"] = 7] = "NONE";
})(BarlineType || (BarlineType = {}));
class Barline extends _stavemodifier__WEBPACK_IMPORTED_MODULE_0__.StaveModifier {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_2__.Category.Barline;
    }
    static get type() {
        return BarlineType;
    }
    static get typeString() {
        return {
            single: BarlineType.SINGLE,
            double: BarlineType.DOUBLE,
            end: BarlineType.END,
            repeatBegin: BarlineType.REPEAT_BEGIN,
            repeatEnd: BarlineType.REPEAT_END,
            repeatBoth: BarlineType.REPEAT_BOTH,
            none: BarlineType.NONE,
        };
    }
    constructor(type) {
        super();
        this.thickness = _tables__WEBPACK_IMPORTED_MODULE_1__.Tables.STAVE_LINE_THICKNESS;
        const TYPE = BarlineType;
        this.widths = {};
        this.widths[TYPE.SINGLE] = 5;
        this.widths[TYPE.DOUBLE] = 5;
        this.widths[TYPE.END] = 5;
        this.widths[TYPE.REPEAT_BEGIN] = 5;
        this.widths[TYPE.REPEAT_END] = 5;
        this.widths[TYPE.REPEAT_BOTH] = 5;
        this.widths[TYPE.NONE] = 5;
        this.paddings = {};
        this.paddings[TYPE.SINGLE] = 0;
        this.paddings[TYPE.DOUBLE] = 0;
        this.paddings[TYPE.END] = 0;
        this.paddings[TYPE.REPEAT_BEGIN] = 15;
        this.paddings[TYPE.REPEAT_END] = 15;
        this.paddings[TYPE.REPEAT_BOTH] = 15;
        this.paddings[TYPE.NONE] = 0;
        this.layoutMetricsMap = {};
        this.layoutMetricsMap[TYPE.SINGLE] = {
            xMin: 0,
            xMax: 1,
            paddingLeft: 5,
            paddingRight: 5,
        };
        this.layoutMetricsMap[TYPE.DOUBLE] = {
            xMin: -3,
            xMax: 1,
            paddingLeft: 5,
            paddingRight: 5,
        };
        this.layoutMetricsMap[TYPE.END] = {
            xMin: -5,
            xMax: 1,
            paddingLeft: 5,
            paddingRight: 5,
        };
        this.layoutMetricsMap[TYPE.REPEAT_END] = {
            xMin: -10,
            xMax: 1,
            paddingLeft: 5,
            paddingRight: 5,
        };
        this.layoutMetricsMap[TYPE.REPEAT_BEGIN] = {
            xMin: -2,
            xMax: 10,
            paddingLeft: 5,
            paddingRight: 5,
        };
        this.layoutMetricsMap[TYPE.REPEAT_BOTH] = {
            xMin: -10,
            xMax: 10,
            paddingLeft: 5,
            paddingRight: 5,
        };
        this.layoutMetricsMap[TYPE.NONE] = {
            xMin: 0,
            xMax: 0,
            paddingLeft: 5,
            paddingRight: 5,
        };
        this.setPosition(_stavemodifier__WEBPACK_IMPORTED_MODULE_0__.StaveModifierPosition.BEGIN);
        this.setType(type);
    }
    getType() {
        return this.type;
    }
    setType(type) {
        this.type = typeof type === 'string' ? Barline.typeString[type] : type;
        this.setWidth(this.widths[this.type]);
        this.setPadding(this.paddings[this.type]);
        this.setLayoutMetrics(this.layoutMetricsMap[this.type]);
        return this;
    }
    // Draw barlines
    draw(stave) {
        const ctx = stave.checkContext();
        this.setRendered();
        this.applyStyle(ctx);
        ctx.openGroup('stavebarline', this.getAttribute('id'));
        switch (this.type) {
            case BarlineType.SINGLE:
                this.drawVerticalBar(stave, this.x, false);
                break;
            case BarlineType.DOUBLE:
                this.drawVerticalBar(stave, this.x, true);
                break;
            case BarlineType.END:
                this.drawVerticalEndBar(stave, this.x);
                break;
            case BarlineType.REPEAT_BEGIN:
                // If the barline is shifted over (in front of clef/time/key)
                // Draw vertical bar at the beginning.
                this.drawRepeatBar(stave, this.x, true);
                if (stave.getX() !== this.x) {
                    this.drawVerticalBar(stave, stave.getX());
                }
                break;
            case BarlineType.REPEAT_END:
                this.drawRepeatBar(stave, this.x, false);
                break;
            case BarlineType.REPEAT_BOTH:
                this.drawRepeatBar(stave, this.x, false);
                this.drawRepeatBar(stave, this.x, true);
                break;
            default:
                // Default is NONE, so nothing to draw
                break;
        }
        ctx.closeGroup();
        this.restoreStyle(ctx);
    }
    drawVerticalBar(stave, x, doubleBar) {
        const staveCtx = stave.checkContext();
        const topY = stave.getTopLineTopY();
        const botY = stave.getBottomLineBottomY();
        if (doubleBar) {
            staveCtx.fillRect(x - 3, topY, 1, botY - topY);
        }
        staveCtx.fillRect(x, topY, 1, botY - topY);
    }
    drawVerticalEndBar(stave, x) {
        const staveCtx = stave.checkContext();
        const topY = stave.getTopLineTopY();
        const botY = stave.getBottomLineBottomY();
        staveCtx.fillRect(x - 5, topY, 1, botY - topY);
        staveCtx.fillRect(x - 2, topY, 3, botY - topY);
    }
    drawRepeatBar(stave, x, begin) {
        const staveCtx = stave.checkContext();
        const topY = stave.getTopLineTopY();
        const botY = stave.getBottomLineBottomY();
        let xShift = 3;
        if (!begin) {
            xShift = -5;
        }
        staveCtx.fillRect(x + xShift, topY, 1, botY - topY);
        staveCtx.fillRect(x - 2, topY, 3, botY - topY);
        const dotRadius = 2;
        // Shift dots left or right
        if (begin) {
            xShift += 4;
        }
        else {
            xShift -= 4;
        }
        const dotX = x + xShift + dotRadius / 2;
        // calculate the y offset based on number of stave lines
        let yOffset = (stave.getNumLines() - 1) * stave.getSpacingBetweenLines();
        yOffset = yOffset / 2 - stave.getSpacingBetweenLines() / 2;
        let dotY = topY + yOffset + dotRadius / 2;
        // draw the top repeat dot
        staveCtx.beginPath();
        staveCtx.arc(dotX, dotY, dotRadius, 0, Math.PI * 2, false);
        staveCtx.fill();
        // draw the bottom repeat dot
        dotY += stave.getSpacingBetweenLines();
        staveCtx.beginPath();
        staveCtx.arc(dotX, dotY, dotRadius, 0, Math.PI * 2, false);
        staveCtx.fill();
    }
}


/***/ }),

/***/ "./src/staveconnector.ts":
/*!*******************************!*\
  !*** ./src/staveconnector.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StaveConnector: () => (/* binding */ StaveConnector)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License




function drawBoldDoubleLine(ctx, type, topX, topY, botY) {
    if (type !== StaveConnector.type.BOLD_DOUBLE_LEFT && type !== StaveConnector.type.BOLD_DOUBLE_RIGHT) {
        throw new _util__WEBPACK_IMPORTED_MODULE_3__.RuntimeError('InvalidConnector', 'A REPEAT_BEGIN or REPEAT_END type must be provided.');
    }
    let xShift = 3;
    let variableWidth = 3.5; // Width for avoiding anti-aliasing width issues
    const thickLineOffset = 2; // For aesthetics
    if (type === StaveConnector.type.BOLD_DOUBLE_RIGHT) {
        xShift = -5; // Flips the side of the thin line
        variableWidth = 3;
    }
    // Thin line
    ctx.fillRect(topX + xShift, topY, 1, botY - topY);
    // Thick line
    ctx.fillRect(topX - thickLineOffset, topY, variableWidth, botY - topY);
}
/** StaveConnector implements the connector lines between staves of a system. */
class StaveConnector extends _element__WEBPACK_IMPORTED_MODULE_0__.Element {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_2__.Category.StaveConnector;
    }
    constructor(topStave, bottomStave) {
        super();
        this.thickness = _tables__WEBPACK_IMPORTED_MODULE_1__.Tables.STAVE_LINE_THICKNESS;
        this.topStave = topStave;
        this.bottomStave = bottomStave;
        this.type = StaveConnector.type.DOUBLE;
        // 1. Offset Bold Double Left to align with offset Repeat Begin bars
        // 2. Offset BRACE type not to overlap with another StaveConnector
        this.xShift = 0;
        this.texts = [];
    }
    /**
     * Set type.
     * @param type see {@link StaveConnector.type} & {@link StaveConnector.typeString}
     */
    setType(type) {
        const newType = typeof type === 'string' ? StaveConnector.typeString[type] : type;
        // Be certain that the type is a valid type:
        if (Object.values(StaveConnector.type).includes(newType)) {
            this.type = newType;
        }
        return this;
    }
    /**
     * Get type.
     * @returns number {@link StaveConnector.type}
     */
    getType() {
        return this.type;
    }
    /** Set optional associated Text. */
    setText(text, options = {}) {
        var _a, _b;
        const textElement = new _element__WEBPACK_IMPORTED_MODULE_0__.Element('StaveConnector.text');
        textElement.setText(text);
        textElement.setXShift((_a = options.shiftX) !== null && _a !== void 0 ? _a : 0);
        textElement.setYShift((_b = options.shiftY) !== null && _b !== void 0 ? _b : 0);
        this.texts.push(textElement);
        return this;
    }
    /** Render connector and associated text. */
    draw() {
        const ctx = this.checkContext();
        this.setRendered();
        let topY = this.topStave.getYForLine(0);
        let botY = this.bottomStave.getYForLine(this.bottomStave.getNumLines() - 1) + this.thickness;
        let width = 3;
        let topX = this.topStave.getX();
        const isRightSidedConnector = this.type === StaveConnector.type.SINGLE_RIGHT ||
            this.type === StaveConnector.type.BOLD_DOUBLE_RIGHT ||
            this.type === StaveConnector.type.THIN_DOUBLE;
        if (isRightSidedConnector) {
            topX = this.topStave.getX() + this.topStave.getWidth();
        }
        let attachmentHeight = botY - topY;
        const element = new _element__WEBPACK_IMPORTED_MODULE_0__.Element();
        switch (this.type) {
            case StaveConnector.type.SINGLE:
                width = 1;
                break;
            case StaveConnector.type.SINGLE_LEFT:
                width = 1;
                break;
            case StaveConnector.type.SINGLE_RIGHT:
                width = 1;
                break;
            case StaveConnector.type.DOUBLE:
                topX -= 5;
                topY -= this.thickness;
                attachmentHeight += 0.5;
                break;
            case StaveConnector.type.BRACE: {
                width = 12;
                // May need additional code to draw brace
                const x1 = this.topStave.getX() - 2 + this.xShift;
                const y1 = topY;
                const x3 = x1;
                const y3 = botY;
                const x2 = x1 - width;
                const y2 = y1 + attachmentHeight / 2.0;
                const cpx1 = x2 - 0.9 * width;
                const cpy1 = y1 + 0.2 * attachmentHeight;
                const cpx2 = x1 + 1.1 * width;
                const cpy2 = y2 - 0.135 * attachmentHeight;
                const cpx3 = cpx2;
                const cpy3 = y2 + 0.135 * attachmentHeight;
                const cpx4 = cpx1;
                const cpy4 = y3 - 0.2 * attachmentHeight;
                const cpx5 = x2 - width;
                const cpy5 = cpy4;
                const cpx6 = x1 + 0.4 * width;
                const cpy6 = y2 + 0.135 * attachmentHeight;
                const cpx7 = cpx6;
                const cpy7 = y2 - 0.135 * attachmentHeight;
                const cpx8 = cpx5;
                const cpy8 = cpy1;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
                ctx.bezierCurveTo(cpx3, cpy3, cpx4, cpy4, x3, y3);
                ctx.bezierCurveTo(cpx5, cpy5, cpx6, cpy6, x2, y2);
                ctx.bezierCurveTo(cpx7, cpy7, cpx8, cpy8, x1, y1);
                ctx.fill();
                ctx.stroke();
                break;
            }
            case StaveConnector.type.BRACKET:
                topY -= 6;
                botY += 6;
                attachmentHeight = botY - topY;
                element.setText('\ue003' /* bracketTop */);
                element.renderText(ctx, topX - 5, topY);
                element.setText('\ue004' /* bracketBottom */);
                element.renderText(ctx, topX - 5, botY);
                topX -= 5;
                break;
            case StaveConnector.type.BOLD_DOUBLE_LEFT:
                drawBoldDoubleLine(ctx, this.type, topX + this.xShift, topY, botY - this.thickness);
                break;
            case StaveConnector.type.BOLD_DOUBLE_RIGHT:
                drawBoldDoubleLine(ctx, this.type, topX, topY, botY - this.thickness);
                break;
            case StaveConnector.type.THIN_DOUBLE:
                width = 1;
                attachmentHeight -= this.thickness;
                break;
            case StaveConnector.type.NONE:
                break;
            default:
                throw new _util__WEBPACK_IMPORTED_MODULE_3__.RuntimeError('InvalidType', `The provided StaveConnector.type (${this.type}) is invalid.`);
        }
        if (this.type !== StaveConnector.type.BRACE &&
            this.type !== StaveConnector.type.BOLD_DOUBLE_LEFT &&
            this.type !== StaveConnector.type.BOLD_DOUBLE_RIGHT &&
            this.type !== StaveConnector.type.NONE) {
            ctx.fillRect(topX, topY, width, attachmentHeight);
        }
        // If the connector is a thin double barline, draw the paralell line
        if (this.type === StaveConnector.type.THIN_DOUBLE) {
            ctx.fillRect(topX - 3, topY, width, attachmentHeight);
        }
        // Add stave connector text
        for (let i = 0; i < this.texts.length; i++) {
            const textElement = this.texts[i];
            const x = this.topStave.getX() - textElement.getWidth() - 24;
            const y = (this.topStave.getYForLine(0) + this.bottomStave.getBottomLineY()) / 2;
            textElement.renderText(ctx, x, y + 4);
        }
    }
}
/**
 * SINGLE_LEFT and SINGLE are the same value for compatibility
 * with older versions of vexflow which didn't have right sided
 * stave connectors.
 */
StaveConnector.type = {
    SINGLE_RIGHT: 0,
    SINGLE_LEFT: 1,
    SINGLE: 1,
    DOUBLE: 2,
    BRACE: 3,
    BRACKET: 4,
    BOLD_DOUBLE_LEFT: 5,
    BOLD_DOUBLE_RIGHT: 6,
    THIN_DOUBLE: 7,
    NONE: 8,
};
/**
 * Connector type:
 * * "singleRight"
 * * "singleLeft"
 * * "single"
 * * "double"
 * * "brace"
 * * "bracket"
 * * "boldDoubleLeft"
 * * "boldDoubleRight"
 * * "thinDouble"
 * * "none"
 */
StaveConnector.typeString = {
    singleRight: StaveConnector.type.SINGLE_RIGHT,
    singleLeft: StaveConnector.type.SINGLE_LEFT,
    single: StaveConnector.type.SINGLE,
    double: StaveConnector.type.DOUBLE,
    brace: StaveConnector.type.BRACE,
    bracket: StaveConnector.type.BRACKET,
    boldDoubleLeft: StaveConnector.type.BOLD_DOUBLE_LEFT,
    boldDoubleRight: StaveConnector.type.BOLD_DOUBLE_RIGHT,
    thinDouble: StaveConnector.type.THIN_DOUBLE,
    none: StaveConnector.type.NONE,
};


/***/ }),

/***/ "./src/stavehairpin.ts":
/*!*****************************!*\
  !*** ./src/stavehairpin.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StaveHairpin: () => (/* binding */ StaveHairpin)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _modifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifier */ "./src/modifier.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
//
// ## Description
// @author Raffaele Viglianti, 2012 http://itisnotsound.wordpress.com/
//
// This class implements hairpins between notes.
// Hairpins can be either crescendo or decrescendo.




class StaveHairpin extends _element__WEBPACK_IMPORTED_MODULE_0__.Element {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_2__.Category.StaveHairpin;
    }
    /* Helper function to convert ticks into pixels.
     * Requires a Formatter with voices joined and formatted (to
     * get pixels per tick)
     *
     * options is struct that has:
     *
     *  {
     *   height: px,
     *   yShift: px,         // vertical offset
     *   leftShiftTicks: 0, // left horizontal offset expressed in ticks
     *   rightShiftTicks: 0 // right horizontal offset expressed in ticks
     *  }
     *
     **/
    static FormatByTicksAndDraw(ctx, formatter, notes, type, position, options) {
        var _a, _b;
        const ppt = formatter.pixelsPerTick;
        if (ppt === null) {
            throw new _util__WEBPACK_IMPORTED_MODULE_3__.RuntimeError('BadArguments', 'A valid Formatter must be provide to draw offsets by ticks.');
        }
        const leftShiftPx = ppt * ((_a = options.leftShiftTicks) !== null && _a !== void 0 ? _a : 0);
        const rightShiftPx = ppt * ((_b = options.rightShiftTicks) !== null && _b !== void 0 ? _b : 0);
        const hairpinOptions = {
            height: options.height,
            yShift: options.yShift,
            leftShiftPx,
            rightShiftPx,
            rightShiftTicks: 0,
            leftShiftTicks: 0,
        };
        new StaveHairpin({
            firstNote: notes.firstNote,
            lastNote: notes.lastNote,
        }, type)
            .setContext(ctx)
            .setRenderOptions(hairpinOptions)
            .setPosition(position)
            .draw();
    }
    /**
     * Create a new hairpin from the specified notes.
     *
     * @param {!Object} notes The notes to tie up.
     * Notes is a struct that has:
     *
     *  {
     *    firstNote: Note,
     *    lastNote: Note,
     *  }
     * @param {!Object} type The type of hairpin
     */
    constructor(notes, type) {
        super();
        this.setNotes(notes);
        this.hairpin = type;
        this.position = _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.BELOW;
        this.renderOptions = {
            height: 10,
            yShift: 0,
            leftShiftPx: 0,
            rightShiftPx: 0,
            rightShiftTicks: 0,
            leftShiftTicks: 0,
        };
    }
    setPosition(position) {
        if (position === _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.ABOVE || position === _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.BELOW) {
            this.position = position;
        }
        return this;
    }
    setRenderOptions(options) {
        this.renderOptions = options;
        return this;
    }
    /**
     * Set the notes to attach this hairpin to.
     *
     * @param {!Object} notes The start and end notes.
     */
    setNotes(notes) {
        if (!notes.firstNote && !notes.lastNote) {
            throw new _util__WEBPACK_IMPORTED_MODULE_3__.RuntimeError('BadArguments', 'Hairpin needs to have either firstNote or lastNote set.');
        }
        this.notes = notes;
        this.firstNote = notes.firstNote;
        this.lastNote = notes.lastNote;
        return this;
    }
    renderHairpin(params) {
        const ctx = this.checkContext();
        let dis = this.renderOptions.yShift + 20;
        let yShift = params.firstY;
        if (this.position === _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.ABOVE) {
            dis = -dis + 30;
            yShift = params.firstY - params.staffHeight;
        }
        const leftShiftPx = this.renderOptions.leftShiftPx;
        const rightShiftPx = this.renderOptions.rightShiftPx;
        ctx.beginPath();
        switch (this.hairpin) {
            case StaveHairpin.type.CRESC:
                ctx.moveTo(params.lastX + rightShiftPx, yShift + dis);
                ctx.lineTo(params.firstX + leftShiftPx, yShift + this.renderOptions.height / 2 + dis);
                ctx.lineTo(params.lastX + rightShiftPx, yShift + this.renderOptions.height + dis);
                break;
            case StaveHairpin.type.DECRESC:
                ctx.moveTo(params.firstX + leftShiftPx, yShift + dis);
                ctx.lineTo(params.lastX + rightShiftPx, yShift + this.renderOptions.height / 2 + dis);
                ctx.lineTo(params.firstX + leftShiftPx, yShift + this.renderOptions.height + dis);
                break;
            default:
                // Default is NONE, so nothing to draw
                break;
        }
        ctx.stroke();
        ctx.closePath();
    }
    draw() {
        this.checkContext();
        this.setRendered();
        const firstNote = this.firstNote;
        const lastNote = this.lastNote;
        if (!firstNote || !lastNote)
            throw new _util__WEBPACK_IMPORTED_MODULE_3__.RuntimeError('NoNote', 'Notes required to draw');
        const start = firstNote.getModifierStartXY(this.position, 0);
        const end = lastNote.getModifierStartXY(this.position, 0);
        this.renderHairpin({
            firstX: start.x,
            lastX: end.x,
            firstY: firstNote.checkStave().getY() + firstNote.checkStave().getHeight(),
            lastY: lastNote.checkStave().getY() + lastNote.checkStave().getHeight(),
            staffHeight: firstNote.checkStave().getHeight(),
        });
    }
}
StaveHairpin.type = {
    CRESC: 1,
    DECRESC: 2,
};


/***/ }),

/***/ "./src/staveline.ts":
/*!**************************!*\
  !*** ./src/staveline.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StaveLine: () => (/* binding */ StaveLine)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _textnote__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./textnote */ "./src/textnote.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
//
// ## Description
//
// This file implements `StaveLine` which are simply lines that connect
// two notes. This object is highly configurable, see the `renderOptions`.
// A simple line is often used for notating glissando articulations, but you
// can format a `StaveLine` with arrows or colors for more pedagogical
// purposes, such as diagrams.





// Attribution: Arrow rendering implementations based off of
// Patrick Horgan's article, "Drawing lines and arcs with
// arrow heads on  HTML5 Canvas"
//
// Draw an arrow head that connects between 3 coordinates.
function drawArrowHead(ctx, x0, y0, x1, y1, x2, y2) {
    // all cases do this.
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.lineTo(x0, y0);
    ctx.closePath();
    ctx.fill();
}
class StaveLine extends _element__WEBPACK_IMPORTED_MODULE_0__.Element {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_3__.Category.StaveLine;
    }
    // Initialize the StaveLine with the given `notes`.
    //
    // `notes` is a struct that has:
    //
    //  ```
    //  {
    //    firstNote: Note,
    //    lastNote: Note,
    //    firstIndexes: [n1, n2, n3],
    //    lastIndexes: [n1, n2, n3]
    //  }
    //  ```
    constructor(notes) {
        super();
        this.setNotes(notes);
        this.text = '';
        this.renderOptions = {
            // Space to add to the left or the right
            paddingLeft: 4,
            paddingRight: 3,
            // The width of the line in pixels
            lineWidth: 1,
            // An array of line/space lengths. (TODO/QUESTION: Is this supported in SVG?).
            lineDash: undefined,
            // Can draw rounded line end, instead of a square. (TODO/QUESTION: Is this supported in SVG?).
            roundedEnd: true,
            // The color of the line and arrowheads
            color: undefined,
            // Flags to draw arrows on each end of the line
            drawStartArrow: false,
            drawEndArrow: false,
            // The length of the arrowhead sides
            arrowheadLength: 10,
            // The angle of the arrowhead
            arrowheadAngle: Math.PI / 8,
            // The position of the text
            textPositionVertical: StaveLine.TextVerticalPosition.TOP,
            textJustification: StaveLine.TextJustification.CENTER,
        };
    }
    // The the annotation for the `StaveLine`
    setText(text) {
        this.text = text;
        return this;
    }
    // Set the notes for the `StaveLine`
    setNotes(notes) {
        if (!notes.firstNote && !notes.lastNote) {
            throw new _util__WEBPACK_IMPORTED_MODULE_4__.RuntimeError('BadArguments', 'Notes needs to have either firstNote or lastNote set.');
        }
        if (!notes.firstIndexes)
            notes.firstIndexes = [0];
        if (!notes.lastIndexes)
            notes.lastIndexes = [0];
        if (notes.firstIndexes.length !== notes.lastIndexes.length) {
            throw new _util__WEBPACK_IMPORTED_MODULE_4__.RuntimeError('BadArguments', 'Connected notes must have same number of indexes.');
        }
        this.notes = notes;
        this.firstNote = notes.firstNote;
        this.firstIndexes = notes.firstIndexes;
        this.lastNote = notes.lastNote;
        this.lastIndexes = notes.lastIndexes;
        return this;
    }
    // Apply the style of the `StaveLine` to the context
    applyLineStyle() {
        const ctx = this.checkContext();
        const renderOptions = this.renderOptions;
        if (renderOptions.lineDash) {
            ctx.setLineDash(renderOptions.lineDash);
        }
        if (renderOptions.lineWidth) {
            ctx.setLineWidth(renderOptions.lineWidth);
        }
        if (renderOptions.roundedEnd) {
            ctx.setLineCap('round');
        }
        else {
            ctx.setLineCap('square');
        }
    }
    // Apply the text styling to the context
    applyFontStyle() {
        const ctx = this.checkContext();
        ctx.setFont(this.fontInfo);
        const renderOptions = this.renderOptions;
        const color = renderOptions.color;
        if (color) {
            ctx.setStrokeStyle(color);
            ctx.setFillStyle(color);
        }
    }
    // Helper function to draw a line with arrow heads
    drawArrowLine(ctx, pt1, pt2) {
        const bothArrows = this.renderOptions.drawStartArrow && this.renderOptions.drawEndArrow;
        const x1 = pt1.x;
        const y1 = pt1.y;
        const x2 = pt2.x;
        const y2 = pt2.y;
        // For ends with arrow we actually want to stop before we get to the arrow
        // so that wide lines won't put a flat end on the arrow.
        const distance = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        const ratio = (distance - this.renderOptions.arrowheadLength / 3) / distance;
        let endX;
        let endY;
        let startX;
        let startY;
        if (this.renderOptions.drawEndArrow || bothArrows) {
            endX = Math.round(x1 + (x2 - x1) * ratio);
            endY = Math.round(y1 + (y2 - y1) * ratio);
        }
        else {
            endX = x2;
            endY = y2;
        }
        if (this.renderOptions.drawStartArrow || bothArrows) {
            startX = x1 + (x2 - x1) * (1 - ratio);
            startY = y1 + (y2 - y1) * (1 - ratio);
        }
        else {
            startX = x1;
            startY = y1;
        }
        if (this.renderOptions.color) {
            ctx.setStrokeStyle(this.renderOptions.color);
            ctx.setFillStyle(this.renderOptions.color);
        }
        // Draw the shaft of the arrow
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
        ctx.closePath();
        // calculate the angle of the line
        const lineAngle = Math.atan2(y2 - y1, x2 - x1);
        // h is the line length of a side of the arrow head
        const h = Math.abs(this.renderOptions.arrowheadLength / Math.cos(this.renderOptions.arrowheadAngle));
        let angle1;
        let angle2;
        let topX;
        let topY;
        let bottomX;
        let bottomY;
        if (this.renderOptions.drawEndArrow || bothArrows) {
            angle1 = lineAngle + Math.PI + this.renderOptions.arrowheadAngle;
            topX = x2 + Math.cos(angle1) * h;
            topY = y2 + Math.sin(angle1) * h;
            angle2 = lineAngle + Math.PI - this.renderOptions.arrowheadAngle;
            bottomX = x2 + Math.cos(angle2) * h;
            bottomY = y2 + Math.sin(angle2) * h;
            drawArrowHead(ctx, topX, topY, x2, y2, bottomX, bottomY);
        }
        if (this.renderOptions.drawStartArrow || bothArrows) {
            angle1 = lineAngle + this.renderOptions.arrowheadAngle;
            topX = x1 + Math.cos(angle1) * h;
            topY = y1 + Math.sin(angle1) * h;
            angle2 = lineAngle - this.renderOptions.arrowheadAngle;
            bottomX = x1 + Math.cos(angle2) * h;
            bottomY = y1 + Math.sin(angle2) * h;
            drawArrowHead(ctx, topX, topY, x1, y1, bottomX, bottomY);
        }
    }
    // Renders the `StaveLine` on the context
    draw() {
        const ctx = this.checkContext();
        this.setRendered();
        const firstNote = this.firstNote;
        const lastNote = this.lastNote;
        const renderOptions = this.renderOptions;
        ctx.save();
        this.applyLineStyle();
        // Cycle through each set of indexes and draw lines
        let startPosition = { x: 0, y: 0 };
        let endPosition = { x: 0, y: 0 };
        this.firstIndexes.forEach((firstIndex, i) => {
            const lastIndex = this.lastIndexes[i];
            // Get initial coordinates for the start/end of the line
            startPosition = firstNote.getModifierStartXY(2, firstIndex);
            endPosition = lastNote.getModifierStartXY(1, lastIndex);
            const upwardsSlope = startPosition.y > endPosition.y;
            // Adjust `x` coordinates for modifiers
            startPosition.x += firstNote.getMetrics().modRightPx + renderOptions.paddingLeft;
            endPosition.x -= lastNote.getMetrics().modLeftPx + renderOptions.paddingRight;
            // Adjust first `x` coordinates for displacements
            const noteheadWidth = firstNote.getGlyphWidth();
            const firstDisplaced = firstNote.getKeyProps()[firstIndex].displaced;
            if (firstDisplaced && firstNote.getStemDirection() === 1) {
                startPosition.x += noteheadWidth + renderOptions.paddingLeft;
            }
            // Adjust last `x` coordinates for displacements
            const lastDisplaced = lastNote.getKeyProps()[lastIndex].displaced;
            if (lastDisplaced && lastNote.getStemDirection() === -1) {
                endPosition.x -= noteheadWidth + renderOptions.paddingRight;
            }
            // Adjust y position better if it's not coming from the center of the note
            startPosition.y += upwardsSlope ? -3 : 1;
            endPosition.y += upwardsSlope ? 2 : 0;
            this.drawArrowLine(ctx, startPosition, endPosition);
        });
        ctx.restore();
        // Determine the x coordinate where to start the text
        const textWidth = ctx.measureText(this.text).width;
        const justification = renderOptions.textJustification;
        let x = 0;
        if (justification === StaveLine.TextJustification.LEFT) {
            x = startPosition.x;
        }
        else if (justification === StaveLine.TextJustification.CENTER) {
            const deltaX = endPosition.x - startPosition.x;
            const centerX = deltaX / 2 + startPosition.x;
            x = centerX - textWidth / 2;
        }
        else if (justification === StaveLine.TextJustification.RIGHT) {
            x = endPosition.x - textWidth;
        }
        // Determine the y value to start the text
        let y = 0;
        const verticalPosition = renderOptions.textPositionVertical;
        if (verticalPosition === StaveLine.TextVerticalPosition.TOP) {
            y = firstNote.checkStave().getYForTopText();
        }
        else if (verticalPosition === StaveLine.TextVerticalPosition.BOTTOM) {
            y = firstNote.checkStave().getYForBottomText(_tables__WEBPACK_IMPORTED_MODULE_1__.Tables.TEXT_HEIGHT_OFFSET_HACK);
        }
        // Draw the text
        ctx.save();
        this.applyFontStyle();
        ctx.fillText(this.text, x, y);
        ctx.restore();
        return this;
    }
}
// Text Positioning
StaveLine.TextVerticalPosition = {
    TOP: 1,
    BOTTOM: 2,
};
StaveLine.TextJustification = _textnote__WEBPACK_IMPORTED_MODULE_2__.TextJustification;


/***/ }),

/***/ "./src/stavemodifier.ts":
/*!******************************!*\
  !*** ./src/stavemodifier.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StaveModifier: () => (/* binding */ StaveModifier),
/* harmony export */   StaveModifierPosition: () => (/* binding */ StaveModifierPosition)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
//
// ## Description
// A base class for stave modifiers (e.g. clefs, key signatures)



var StaveModifierPosition;
(function (StaveModifierPosition) {
    StaveModifierPosition[StaveModifierPosition["CENTER"] = 0] = "CENTER";
    StaveModifierPosition[StaveModifierPosition["LEFT"] = 1] = "LEFT";
    StaveModifierPosition[StaveModifierPosition["RIGHT"] = 2] = "RIGHT";
    StaveModifierPosition[StaveModifierPosition["ABOVE"] = 3] = "ABOVE";
    StaveModifierPosition[StaveModifierPosition["BELOW"] = 4] = "BELOW";
    StaveModifierPosition[StaveModifierPosition["BEGIN"] = 5] = "BEGIN";
    StaveModifierPosition[StaveModifierPosition["END"] = 6] = "END";
})(StaveModifierPosition || (StaveModifierPosition = {}));
class StaveModifier extends _element__WEBPACK_IMPORTED_MODULE_0__.Element {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_1__.Category.StaveModifier;
    }
    static get Position() {
        return StaveModifierPosition;
    }
    constructor() {
        super();
        this.padding = 10;
        this.position = StaveModifierPosition.ABOVE;
    }
    getPosition() {
        return this.position;
    }
    setPosition(position) {
        this.position = position;
        return this;
    }
    getStave() {
        return this.stave;
    }
    checkStave() {
        return (0,_util__WEBPACK_IMPORTED_MODULE_2__.defined)(this.stave, 'NoStave', 'No stave attached to instance.');
    }
    setStave(stave) {
        this.stave = stave;
        return this;
    }
    getPadding(index) {
        return index !== undefined && index < 2 ? 0 : this.padding;
    }
    setPadding(padding) {
        this.padding = padding;
        return this;
    }
    setLayoutMetrics(layoutMetrics) {
        this.layoutMetrics = layoutMetrics;
        return this;
    }
    getLayoutMetrics() {
        return this.layoutMetrics;
    }
    // eslint-disable-next-line
    draw(...args) {
        // DO NOTHING.
    }
}


/***/ }),

/***/ "./src/stavenote.ts":
/*!**************************!*\
  !*** ./src/stavenote.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StaveNote: () => (/* binding */ StaveNote)
/* harmony export */ });
/* harmony import */ var _boundingbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boundingbox */ "./src/boundingbox.ts");
/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./metrics */ "./src/metrics.ts");
/* harmony import */ var _modifier__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifier */ "./src/modifier.ts");
/* harmony import */ var _note__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./note */ "./src/note.ts");
/* harmony import */ var _notehead__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./notehead */ "./src/notehead.ts");
/* harmony import */ var _stem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./stem */ "./src/stem.ts");
/* harmony import */ var _stemmablenote__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./stemmablenote */ "./src/stemmablenote.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
//
// This file implements notes for standard notation. This consists of one or
// more `NoteHeads`, an optional stem, and an optional flag.
//
// Throughout these comments, a "note" refers to the entire `StaveNote`,
// and a "key" refers to a specific pitch/notehead within a note.
//
// See `tests/stavenote_tests.ts` for usage examples.
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _StaveNote_noteHeads, _StaveNote_sortedKeyProps;










// To enable logging for this class. Set `Vex.Flow.StaveNote.DEBUG` to `true`.
// eslint-disable-next-line
function L(...args) {
    if (StaveNote.DEBUG)
        (0,_util__WEBPACK_IMPORTED_MODULE_9__.log)('Vex.Flow.StaveNote', args);
}
const isInnerNoteIndex = (note, index) => index === (note.getStemDirection() === _stem__WEBPACK_IMPORTED_MODULE_5__.Stem.UP ? note.keyProps.length - 1 : 0);
// Helper methods for rest positioning in ModifierContext.
function shiftRestVertical(rest, note, dir) {
    const delta = dir;
    rest.line += delta;
    rest.maxLine += delta;
    rest.minLine += delta;
    rest.note.setKeyLine(0, rest.note.getKeyLine(0) + delta);
}
// Called from formatNotes :: center a rest between two notes
function centerRest(rest, noteU, noteL) {
    const delta = rest.line - (0,_util__WEBPACK_IMPORTED_MODULE_9__.midLine)(noteU.minLine, noteL.maxLine);
    rest.note.setKeyLine(0, rest.note.getKeyLine(0) - delta);
    rest.line -= delta;
    rest.maxLine -= delta;
    rest.minLine -= delta;
}
class StaveNote extends _stemmablenote__WEBPACK_IMPORTED_MODULE_6__.StemmableNote {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_8__.Category.StaveNote;
    }
    static get LEDGER_LINE_OFFSET() {
        return 3;
    }
    static get minNoteheadPadding() {
        return _metrics__WEBPACK_IMPORTED_MODULE_1__.Metrics.get('NoteHead.minPadding');
    }
    /** Format notes inside a ModifierContext. */
    static format(notes, state) {
        if (!notes || notes.length < 2)
            return false;
        const notesList = [];
        for (let i = 0; i < notes.length; i++) {
            // Formatting uses sortedKeyProps to calculate line and minL.
            const props = __classPrivateFieldGet(notes[i], _StaveNote_sortedKeyProps, "f");
            const line = props[0].keyProps.line;
            let minL = props[props.length - 1].keyProps.line;
            const stemDirection = notes[i].getStemDirection();
            const stemMax = notes[i].getStemLength() / 10;
            const stemMin = notes[i].getStemMinimumLength() / 10;
            let maxL;
            if (notes[i].isRest()) {
                maxL =
                    line +
                        Math.ceil(__classPrivateFieldGet(notes[i], _StaveNote_noteHeads, "f")[0].getTextMetrics().actualBoundingBoxAscent / _tables__WEBPACK_IMPORTED_MODULE_7__.Tables.STAVE_LINE_DISTANCE);
                minL =
                    line -
                        Math.ceil(__classPrivateFieldGet(notes[i], _StaveNote_noteHeads, "f")[0].getTextMetrics().actualBoundingBoxDescent / _tables__WEBPACK_IMPORTED_MODULE_7__.Tables.STAVE_LINE_DISTANCE);
            }
            else {
                maxL =
                    stemDirection === 1 ? props[props.length - 1].keyProps.line + stemMax : props[props.length - 1].keyProps.line;
                minL = stemDirection === 1 ? props[0].keyProps.line : props[0].keyProps.line - stemMax;
            }
            notesList.push({
                line: props[0].keyProps.line,
                maxLine: maxL,
                minLine: minL,
                isrest: notes[i].isRest(),
                stemDirection,
                stemMax,
                stemMin,
                voiceShift: notes[i].getVoiceShiftWidth(),
                isDisplaced: notes[i].isDisplaced(),
                note: notes[i],
            });
        }
        let voices = 0;
        let noteU = undefined;
        let noteM = undefined;
        let noteL = undefined;
        const draw = [false, false, false];
        for (let i = 0; i < notesList.length; i++) {
            // If .draw is true or undefined, we set draw[i] = true
            draw[i] = notesList[i].note.renderOptions.draw !== false;
        }
        if (draw[0] && draw[1] && draw[2]) {
            // Three visible notes
            voices = 3;
            noteU = notesList[0];
            noteM = notesList[1];
            noteL = notesList[2];
        }
        else if (draw[0] && draw[1]) {
            // Two visible notes, 0 & 1
            voices = 2;
            noteU = notesList[0];
            noteL = notesList[1];
        }
        else if (draw[0] && draw[2]) {
            // Two visible notes, 0 & 2
            voices = 2;
            noteU = notesList[0];
            noteL = notesList[2];
        }
        else if (draw[1] && draw[2]) {
            // Two visible notes, 1 & 2
            voices = 2;
            noteU = notesList[1];
            noteL = notesList[2];
        }
        else {
            // No shift required for less than 2 visible notes
            return true;
        }
        // for two voice backward compatibility, ensure upper voice is stems up
        // for three voices, the voices must be in order (upper, middle, lower)
        if (voices === 2 && noteU.stemDirection === -1 && noteL.stemDirection === 1) {
            noteU = notesList[1];
            noteL = notesList[0];
        }
        const voiceXShift = Math.max(noteU.voiceShift, noteL.voiceShift);
        let xShift = 0;
        // Test for two voice note intersection
        if (voices === 2) {
            const lineSpacing = noteU.note.hasStem() && noteL.note.hasStem() && noteU.stemDirection === noteL.stemDirection ? 0.0 : 0.5;
            if (noteL.isrest && noteU.isrest && noteU.note.duration === noteL.note.duration) {
                noteL.note.renderOptions.draw = false;
            }
            else if (noteU.minLine <= noteL.maxLine + lineSpacing) {
                if (noteU.isrest) {
                    // shift rest up
                    shiftRestVertical(noteU, noteL, 1);
                }
                else if (noteL.isrest) {
                    // shift rest down
                    shiftRestVertical(noteL, noteU, -1);
                }
                else {
                    //Instead of shifting notes, remove the appropriate flag
                    //If we are sharing a line, switch one notes stem direction.
                    //If we are sharing a line and in the same voice, only then offset one note
                    const lineDiff = Math.abs(noteU.line - noteL.line);
                    if (noteU.note.hasStem() && noteL.note.hasStem()) {
                        const noteUHead = __classPrivateFieldGet(noteU.note, _StaveNote_sortedKeyProps, "f")[0].keyProps.code;
                        const noteLHead = __classPrivateFieldGet(noteL.note, _StaveNote_sortedKeyProps, "f")[__classPrivateFieldGet(noteL.note, _StaveNote_sortedKeyProps, "f").length - 1].keyProps.code;
                        if (
                        // If unison is not configured, shift
                        !_tables__WEBPACK_IMPORTED_MODULE_7__.Tables.UNISON ||
                            // If we have different noteheads, shift
                            noteUHead !== noteLHead ||
                            // If we have different dot values, shift
                            noteU.note.getModifiers().filter((item) => item.getCategory() === _typeguard__WEBPACK_IMPORTED_MODULE_8__.Category.Dot && item.getIndex() === 0)
                                .length !==
                                noteL.note.getModifiers().filter((item) => item.getCategory() === _typeguard__WEBPACK_IMPORTED_MODULE_8__.Category.Dot && item.getIndex() === 0)
                                    .length ||
                            // If the notes are quite close but not on the same line, shift
                            (lineDiff < 1 && lineDiff > 0) ||
                            // If styles are different, shift
                            JSON.stringify(noteU.note.getStyle()) !== JSON.stringify(noteL.note.getStyle())) {
                            xShift = voiceXShift + 2;
                            if (noteU.stemDirection === noteL.stemDirection) {
                                // upper voice is middle voice, so shift it right
                                noteU.note.setXShift(xShift);
                            }
                            else {
                                // shift lower voice right
                                noteL.note.setXShift(xShift);
                            }
                        }
                        else if (noteU.note.voice !== noteL.note.voice) {
                            //If we are not in the same voice
                            if (noteU.stemDirection === noteL.stemDirection) {
                                if (noteU.line !== noteL.line) {
                                    xShift = voiceXShift + 2;
                                    noteU.note.setXShift(xShift);
                                }
                                else {
                                    //same line, swap stem direction for one note
                                    if (noteL.stemDirection === 1) {
                                        noteL.stemDirection = -1;
                                        noteL.note.setStemDirection(-1);
                                    }
                                }
                            }
                        } //Very close whole notes
                    }
                    else if (lineDiff < 1) {
                        xShift = voiceXShift + 2;
                        if (noteU.note.duration < noteL.note.duration) {
                            // upper voice is shorter, so shift it right
                            noteU.note.setXShift(xShift);
                        }
                        else {
                            // shift lower voice right
                            noteL.note.setXShift(xShift);
                        }
                    }
                    else if (noteU.note.hasStem()) {
                        noteU.stemDirection = -noteU.note.getStemDirection();
                        noteU.note.setStemDirection(noteU.stemDirection);
                    }
                    else if (noteL.note.hasStem()) {
                        noteL.stemDirection = -noteL.note.getStemDirection();
                        noteL.note.setStemDirection(noteL.stemDirection);
                    }
                }
            }
            // format complete
            state.rightShift += xShift;
            return true;
        }
        if (!noteM)
            throw new _util__WEBPACK_IMPORTED_MODULE_9__.RuntimeError('InvalidState', 'noteM not defined.');
        // For three voices, test if rests can be repositioned
        //
        // Special case 1 :: middle voice rest between two notes
        //
        if (noteM.isrest && !noteU.isrest && !noteL.isrest) {
            if (noteU.minLine <= noteM.maxLine || noteM.minLine <= noteL.maxLine) {
                const restHeight = noteM.maxLine - noteM.minLine;
                const space = noteU.minLine - noteL.maxLine;
                if (restHeight < space) {
                    // center middle voice rest between the upper and lower voices
                    centerRest(noteM, noteU, noteL);
                }
                else {
                    xShift = voiceXShift + 2; // shift middle rest right
                    noteM.note.setXShift(xShift);
                    if (noteL.note.hasBeam() === false) {
                        noteL.stemDirection = -1;
                        noteL.note.setStemDirection(-1);
                    }
                    if (noteU.minLine <= noteL.maxLine && noteU.note.hasBeam() === false) {
                        noteU.stemDirection = 1;
                        noteU.note.setStemDirection(1);
                    }
                }
                // format complete
                state.rightShift += xShift;
                return true;
            }
        }
        // Special case 2 :: all voices are rests
        if (noteU.isrest && noteM.isrest && noteL.isrest) {
            // Hide upper voice rest
            noteU.note.renderOptions.draw = false;
            // Hide lower voice rest
            noteL.note.renderOptions.draw = false;
            // format complete
            state.rightShift += xShift;
            return true;
        }
        // Test if any other rests can be repositioned
        if (noteM.isrest && noteU.isrest && noteM.minLine <= noteL.maxLine) {
            // Hide middle voice rest
            noteM.note.renderOptions.draw = false;
        }
        if (noteM.isrest && noteL.isrest && noteU.minLine <= noteM.maxLine) {
            // Hide middle voice rest
            noteM.note.renderOptions.draw = false;
        }
        if (noteU.isrest && noteU.minLine <= noteM.maxLine) {
            // shift upper voice rest up;
            shiftRestVertical(noteU, noteM, 1);
        }
        if (noteL.isrest && noteM.minLine <= noteL.maxLine) {
            // shift lower voice rest down
            shiftRestVertical(noteL, noteM, -1);
        }
        // If middle voice intersects upper or lower voice
        if (noteU.minLine <= noteM.maxLine + 0.5 || noteM.minLine <= noteL.maxLine) {
            // shift middle note right
            xShift = voiceXShift + 2;
            noteM.note.setXShift(xShift);
            if (noteL.note.hasBeam() === false) {
                noteL.stemDirection = -1;
                noteL.note.setStemDirection(-1);
            }
            if (noteU.minLine <= noteL.maxLine && noteU.note.hasBeam() === false) {
                noteU.stemDirection = 1;
                noteU.note.setStemDirection(1);
            }
        }
        state.rightShift += xShift;
        return true;
    }
    static postFormat(notes) {
        if (!notes)
            return false;
        notes.forEach((note) => note.postFormat());
        return true;
    }
    constructor(noteStruct) {
        var _a, _b, _c;
        super(noteStruct);
        //////////////////////////////////////////////////////////////////////////////////////////////////
        // INSTANCE MEMBERS
        this.minLine = 0;
        this.maxLine = 0;
        _StaveNote_noteHeads.set(this, void 0);
        // Sorted variant of keyProps used internally.
        _StaveNote_sortedKeyProps.set(this, []);
        this.ledgerLineStyle = {};
        this.clef = (_a = noteStruct.clef) !== null && _a !== void 0 ? _a : 'treble';
        this.octaveShift = (_b = noteStruct.octaveShift) !== null && _b !== void 0 ? _b : 0;
        // Pull note rendering properties.
        this.glyphProps = _note__WEBPACK_IMPORTED_MODULE_3__.Note.getGlyphProps(this.duration, this.noteType);
        (0,_util__WEBPACK_IMPORTED_MODULE_9__.defined)(this.glyphProps, 'BadArguments', `No glyph found for duration '${this.duration}' and type '${this.noteType}'`);
        // if true, displace note to right
        this.displaced = false;
        this.dotShiftY = 0;
        // for displaced ledger lines
        this.useDefaultHeadX = false;
        // Drawing
        __classPrivateFieldSet(this, _StaveNote_noteHeads, [], "f");
        this.modifiers = [];
        this.renderOptions = Object.assign(Object.assign({}, this.renderOptions), { 
            // number of stroke px to the left and right of head
            strokePx: noteStruct.strokePx || StaveNote.LEDGER_LINE_OFFSET });
        this.calculateKeyProps();
        this.buildStem();
        // Set the stem direction
        if (noteStruct.autoStem) {
            this.autoStem();
        }
        else {
            this.setStemDirection((_c = noteStruct.stemDirection) !== null && _c !== void 0 ? _c : _stem__WEBPACK_IMPORTED_MODULE_5__.Stem.UP);
        }
        this.reset();
        this.buildFlag();
    }
    reset() {
        super.reset();
        // Save prior noteHead styles & reapply them after making new noteheads.
        const noteHeadStyles = __classPrivateFieldGet(this, _StaveNote_noteHeads, "f").map((noteHead) => noteHead.getStyle());
        this.buildNoteHeads();
        __classPrivateFieldGet(this, _StaveNote_noteHeads, "f").forEach((noteHead, index) => {
            const noteHeadStyle = noteHeadStyles[index];
            if (noteHeadStyle)
                noteHead.setStyle(noteHeadStyle);
        });
        const stave = this.stave;
        if (stave) {
            this.setStave(stave);
        }
        this.calcNoteDisplacements();
        return this;
    }
    setBeam(beam) {
        this.beam = beam;
        this.calcNoteDisplacements();
        // Update stem extension if a beam is assigned.
        if (this.stem) {
            this.stem.setExtension(this.getStemExtension());
        }
        return this;
    }
    // Builds a `Stem` for the note
    buildStem() {
        this.setStem(new _stem__WEBPACK_IMPORTED_MODULE_5__.Stem({ hide: !!this.isRest() }));
        return this;
    }
    // Builds a `NoteHead` for each key in the note
    buildNoteHeads() {
        __classPrivateFieldSet(this, _StaveNote_noteHeads, [], "f");
        const stemDirection = this.getStemDirection();
        const keys = this.getKeys();
        let lastLine = undefined;
        let lineDiff = undefined;
        let displaced = false;
        // Draw notes from bottom to top.
        // For down-stem notes, we draw from top to bottom.
        let start;
        let end;
        let step;
        if (stemDirection === _stem__WEBPACK_IMPORTED_MODULE_5__.Stem.UP) {
            start = 0;
            end = keys.length;
            step = 1;
        }
        else {
            start = keys.length - 1;
            end = -1;
            step = -1;
        }
        for (let i = start; i !== end; i += step) {
            // Building noteheads rely on sortedKeNotes in order to calculate the displacements
            const noteProps = __classPrivateFieldGet(this, _StaveNote_sortedKeyProps, "f")[i].keyProps;
            const line = noteProps.line;
            // Keep track of last line with a note head, so that consecutive heads
            // are correctly displaced.
            if (lastLine === undefined) {
                lastLine = line;
            }
            else {
                lineDiff = Math.abs(lastLine - line);
                if (lineDiff === 0 || lineDiff === 0.5) {
                    displaced = !displaced;
                }
                else {
                    displaced = false;
                    this.useDefaultHeadX = true;
                }
            }
            lastLine = line;
            const notehead = new _notehead__WEBPACK_IMPORTED_MODULE_4__.NoteHead({
                duration: this.duration,
                noteType: this.noteType,
                displaced,
                stemDirection,
                customGlyphCode: noteProps.code,
                line: noteProps.line,
            });
            notehead.fontInfo = this.fontInfo;
            this.addChildElement(notehead);
            __classPrivateFieldGet(this, _StaveNote_noteHeads, "f")[__classPrivateFieldGet(this, _StaveNote_sortedKeyProps, "f")[i].index] = notehead;
        }
        return __classPrivateFieldGet(this, _StaveNote_noteHeads, "f");
    }
    // Automatically sets the stem direction based on the keys in the note
    autoStem() {
        this.setStemDirection(this.calculateOptimalStemDirection());
    }
    calculateOptimalStemDirection() {
        // Figure out optimal stem direction based on given notes
        // minLine & maxLine rely on sortedKeyProps
        this.minLine = __classPrivateFieldGet(this, _StaveNote_sortedKeyProps, "f")[0].keyProps.line;
        this.maxLine = __classPrivateFieldGet(this, _StaveNote_sortedKeyProps, "f")[this.keyProps.length - 1].keyProps.line;
        const MIDDLE_LINE = 3;
        const decider = (this.minLine + this.maxLine) / 2;
        const stemDirection = decider < MIDDLE_LINE ? _stem__WEBPACK_IMPORTED_MODULE_5__.Stem.UP : _stem__WEBPACK_IMPORTED_MODULE_5__.Stem.DOWN;
        return stemDirection;
    }
    // Calculates and stores the properties for each key in the note
    calculateKeyProps() {
        var _a;
        let lastLine;
        for (let i = 0; i < this.keys.length; ++i) {
            const key = this.keys[i];
            const options = { octaveShift: (_a = this.octaveShift) !== null && _a !== void 0 ? _a : 0, duration: this.duration };
            const props = _tables__WEBPACK_IMPORTED_MODULE_7__.Tables.keyProperties(key, this.clef, this.noteType, options);
            if (!props) {
                throw new _util__WEBPACK_IMPORTED_MODULE_9__.RuntimeError('BadArguments', `Invalid key for note properties: ${key}`);
            }
            // Override line placement for default rests
            if (props.key === 'R') {
                if (this.duration === '1' || this.duration === 'w') {
                    props.line = 4;
                }
                else {
                    props.line = 3;
                }
            }
            // Calculate displacement of this note
            const line = props.line;
            if (lastLine === undefined) {
                lastLine = line;
            }
            else {
                if (Math.abs(lastLine - line) === 0.5) {
                    this.displaced = true;
                    props.displaced = true;
                    // Have to mark the previous note as
                    // displaced as well, for modifier placement
                    if (this.keyProps.length > 0) {
                        this.keyProps[i - 1].displaced = true;
                    }
                }
            }
            lastLine = line;
            this.keyProps.push(props);
        }
        // Sort the notes from lowest line to highest line in sortedKeyProps
        // Warn no longer required as keyProps remains unsorted
        this.keyProps.forEach((keyProps, index) => {
            __classPrivateFieldGet(this, _StaveNote_sortedKeyProps, "f").push({ keyProps, index });
        });
        __classPrivateFieldGet(this, _StaveNote_sortedKeyProps, "f").sort((a, b) => a.keyProps.line - b.keyProps.line);
    }
    // Get the `BoundingBox` for the entire note
    getBoundingBox() {
        const boundingBox = new _boundingbox__WEBPACK_IMPORTED_MODULE_0__.BoundingBox(this.getAbsoluteX(), this.ys[0], 0, 0);
        __classPrivateFieldGet(this, _StaveNote_noteHeads, "f").forEach((notehead) => {
            boundingBox.mergeWith(notehead.getBoundingBox());
        });
        const { yTop, yBottom } = this.getNoteHeadBounds();
        // eslint-disable-next-line
        const noteStemHeight = this.stem.getHeight();
        const flagX = this.getStemX() - _tables__WEBPACK_IMPORTED_MODULE_7__.Tables.STEM_WIDTH / 2;
        const flagY = this.getStemDirection() === _stem__WEBPACK_IMPORTED_MODULE_5__.Stem.DOWN
            ? yTop - noteStemHeight - this.flag.getTextMetrics().actualBoundingBoxDescent
            : yBottom - noteStemHeight + this.flag.getTextMetrics().actualBoundingBoxAscent;
        if (!this.isRest() && this.hasStem()) {
            boundingBox.mergeWith(new _boundingbox__WEBPACK_IMPORTED_MODULE_0__.BoundingBox(this.getAbsoluteX(), flagY, 0, 0));
        }
        if (this.hasFlag()) {
            const bbFlag = this.flag.getBoundingBox();
            boundingBox.mergeWith(bbFlag.move(flagX, flagY));
        }
        return boundingBox;
    }
    // Gets the line number of the bottom note in the chord.
    // If `isTopNote` is `true` then get the top note's line number instead
    getLineNumber(isTopNote) {
        if (!this.keyProps.length) {
            throw new _util__WEBPACK_IMPORTED_MODULE_9__.RuntimeError('NoKeyProps', "Can't get bottom note line, because note is not initialized properly.");
        }
        let resultLine = this.keyProps[0].line;
        // No precondition assumed for sortedness of keyProps array
        for (let i = 0; i < this.keyProps.length; i++) {
            const thisLine = this.keyProps[i].line;
            if (isTopNote) {
                if (thisLine > resultLine)
                    resultLine = thisLine;
            }
            else {
                if (thisLine < resultLine)
                    resultLine = thisLine;
            }
        }
        return resultLine;
    }
    /**
     * @returns true if this note is a type of rest. Rests don't have pitches, but take up space in the score.
     */
    isRest() {
        const val = this.glyphProps.codeHead;
        return val >= '\ue4e0' && val <= '\ue4ff';
    }
    // Determine if the current note is a chord
    isChord() {
        return !this.isRest() && this.keys.length > 1;
    }
    // Determine if the `StaveNote` has a stem
    hasStem() {
        return this.glyphProps.stem;
    }
    hasFlag() {
        return super.hasFlag() && !this.isRest();
    }
    getStemX() {
        if (this.noteType === 'r') {
            return this.getCenterGlyphX();
        }
        else {
            // We adjust the origin of the stem because we want the stem left-aligned
            // with the notehead if stemmed-down, and right-aligned if stemmed-up
            return super.getStemX() + (this.stemDirection ? _stem__WEBPACK_IMPORTED_MODULE_5__.Stem.WIDTH / (2 * -this.stemDirection) : 0);
        }
    }
    // Get the `y` coordinate for text placed on the top/bottom of a
    // note at a desired `textLine`
    getYForTopText(textLine) {
        const extents = this.getStemExtents();
        return Math.min(this.checkStave().getYForTopText(textLine), extents.topY - this.renderOptions.annotationSpacing * (textLine + 1));
    }
    getYForBottomText(textLine) {
        const extents = this.getStemExtents();
        return Math.max(this.checkStave().getYForTopText(textLine), extents.baseY + this.renderOptions.annotationSpacing * textLine);
    }
    // Sets the current note to the provided `stave`. This applies
    // `y` values to the `NoteHeads`.
    setStave(stave) {
        super.setStave(stave);
        const ys = __classPrivateFieldGet(this, _StaveNote_noteHeads, "f").map((notehead) => {
            notehead.setStave(stave);
            return notehead.getY();
        });
        this.setYs(ys);
        if (this.stem) {
            const { yTop, yBottom } = this.getNoteHeadBounds();
            this.stem.setYBounds(yTop, yBottom);
        }
        return this;
    }
    // Check if note is shifted to the right
    isDisplaced() {
        return this.displaced;
    }
    // Sets whether shift note to the right. `displaced` is a `boolean`
    setNoteDisplaced(displaced) {
        this.displaced = displaced;
        return this;
    }
    // Get the starting `x` coordinate for a `StaveTie`
    getTieRightX() {
        let tieStartX = this.getAbsoluteX();
        tieStartX += this.getGlyphWidth() + this.xShift + this.rightDisplacedHeadPx;
        if (this.modifierContext)
            tieStartX += this.modifierContext.getRightShift();
        return tieStartX;
    }
    // Get the ending `x` coordinate for a `StaveTie`
    getTieLeftX() {
        let tieEndX = this.getAbsoluteX();
        tieEndX += this.xShift - this.leftDisplacedHeadPx;
        return tieEndX;
    }
    // Get the stave line on which to place a rest
    getLineForRest() {
        let restLine = this.keyProps[0].line;
        if (this.keyProps.length > 1) {
            const lastLine = this.keyProps[this.keyProps.length - 1].line;
            const top = Math.max(restLine, lastLine);
            const bot = Math.min(restLine, lastLine);
            restLine = (0,_util__WEBPACK_IMPORTED_MODULE_9__.midLine)(top, bot);
        }
        return restLine;
    }
    // Get the default `x` and `y` coordinates for the provided `position`
    // and key `index`
    getModifierStartXY(position, index, options = {}) {
        if (!this.preFormatted) {
            throw new _util__WEBPACK_IMPORTED_MODULE_9__.RuntimeError('UnformattedNote', "Can't call GetModifierStartXY on an unformatted note");
        }
        if (this.ys.length === 0) {
            throw new _util__WEBPACK_IMPORTED_MODULE_9__.RuntimeError('NoYValues', 'No Y-Values calculated for this note.');
        }
        const { ABOVE, BELOW, LEFT, RIGHT } = _modifier__WEBPACK_IMPORTED_MODULE_2__.Modifier.Position;
        let x = 0;
        if (position === LEFT) {
            // FIXME: Left modifier padding, move to font file
            x = -1 * 2;
        }
        else if (position === RIGHT) {
            // FIXME: Right modifier padding, move to font file
            x = this.getGlyphWidth() + this.xShift + 2;
            if (this.stemDirection === _stem__WEBPACK_IMPORTED_MODULE_5__.Stem.UP &&
                this.hasFlag() &&
                (options.forceFlagRight || isInnerNoteIndex(this, index))) {
                x += this.flag.getWidth();
            }
        }
        else if (position === BELOW || position === ABOVE) {
            x = this.getGlyphWidth() / 2;
        }
        // addtional y shifts for rests
        let restShift = 0;
        switch (__classPrivateFieldGet(this, _StaveNote_noteHeads, "f")[index].getText()) {
            case '\ue4e2' /*restDoubleWhole*/:
            case '\ue4e3' /*restWhole*/:
                restShift += 0.5;
                break;
            case '\ue4e4' /*restHalf*/:
            case '\ue4e5' /*restQuarter*/:
            case '\ue4e6' /*rest8th*/:
            case '\ue4e7' /*rest16th*/:
                restShift -= 0.5;
                break;
            case '\ue4e8' /*rest32nd*/:
            case '\ue4e9' /*rest64th*/:
                restShift -= 1.5;
                break;
            case '\ue4ea' /*rest128th*/:
                restShift -= 2.5;
                break;
        }
        return {
            x: this.getAbsoluteX() + x,
            y: this.ys[index] + restShift * this.checkStave().getSpacingBetweenLines(),
        };
    }
    // Sets the style of the complete StaveNote, including all keys
    // and the stem.
    setStyle(style) {
        return super.setGroupStyle(style);
    }
    setStemStyle(style) {
        const stem = this.getStem();
        if (stem)
            stem.setStyle(style);
        return this;
    }
    getStemStyle() {
        var _a;
        return (_a = this.stem) === null || _a === void 0 ? void 0 : _a.getStyle();
    }
    setLedgerLineStyle(style) {
        this.ledgerLineStyle = style;
    }
    getLedgerLineStyle() {
        return this.ledgerLineStyle;
    }
    setFlagStyle(style) {
        this.flagStyle = style;
    }
    getFlagStyle() {
        return this.flagStyle;
    }
    /** Get the glyph width. */
    getGlyphWidth() {
        return this.noteHeads[0].getWidth();
    }
    // Sets the notehead at `index` to the provided coloring `style`.
    //
    // `style` is an `object` with the following properties: `shadowColor`,
    // `shadowBlur`, `fillStyle`, `strokeStyle`
    setKeyStyle(index, style) {
        __classPrivateFieldGet(this, _StaveNote_noteHeads, "f")[index].setStyle(style);
        return this;
    }
    setKeyLine(index, line) {
        this.keyProps[index].line = line;
        this.reset();
        return this;
    }
    getKeyLine(index) {
        return this.keyProps[index].line;
    }
    // Get the width of the note if it is displaced. Used for `Voice`
    // formatting
    getVoiceShiftWidth() {
        // TODO: may need to accommodate for dot here.
        return this.getGlyphWidth() * (this.displaced ? 2 : 1);
    }
    // Calculates and sets the extra pixels to the left or right
    // if the note is displaced.
    calcNoteDisplacements() {
        this.setLeftDisplacedHeadPx(this.displaced && this.stemDirection === _stem__WEBPACK_IMPORTED_MODULE_5__.Stem.DOWN ? this.getGlyphWidth() : 0);
        // For upstems with flags, the extra space is unnecessary, since it's taken
        // up by the flag.
        this.setRightDisplacedHeadPx(!this.hasFlag() && this.displaced && this.stemDirection === _stem__WEBPACK_IMPORTED_MODULE_5__.Stem.UP ? this.getGlyphWidth() : 0);
    }
    // Pre-render formatting
    preFormat() {
        if (this.preFormatted)
            return;
        let noteHeadPadding = 0;
        if (this.modifierContext) {
            this.modifierContext.preFormat();
            // If there are no modifiers on this note, make sure there is adequate padding
            // between the notes.
            if (this.modifierContext.getWidth() === 0) {
                noteHeadPadding = StaveNote.minNoteheadPadding;
            }
        }
        let width = this.getGlyphWidth() + this.leftDisplacedHeadPx + this.rightDisplacedHeadPx + noteHeadPadding;
        // For upward flagged notes, the width of the flag needs to be added
        if (this.shouldDrawFlag() && this.stemDirection === _stem__WEBPACK_IMPORTED_MODULE_5__.Stem.UP) {
            width += this.getGlyphWidth();
            // TODO: Add flag width as a separate metric
        }
        this.setWidth(width);
        this.preFormatted = true;
    }
    /**
     * @typedef {Object} noteHeadBounds
     * @property {number} yTop the highest notehead bound
     * @property {number} yBottom the lowest notehead bound
     * @property {number|Null} displacedX the starting x for displaced noteheads
     * @property {number|Null} nonDisplacedX the starting x for non-displaced noteheads
     * @property {number} highestLine the highest notehead line in traditional music line
     *  numbering (bottom line = 1, top line = 5)
     * @property {number} lowestLine the lowest notehead line
     * @property {number|false} highestDisplacedLine the highest staff line number
     *   for a displaced notehead
     * @property {number|false} lowestDisplacedLine
     * @property {number} highestNonDisplacedLine
     * @property {number} lowestNonDisplacedLine
     */
    /**
     * Get the staff line and y value for the highest & lowest noteheads
     * @returns {noteHeadBounds}
     */
    getNoteHeadBounds() {
        // Top and bottom Y values for stem.
        let yTop = +Infinity;
        let yBottom = -Infinity;
        let nonDisplacedX;
        let displacedX;
        let highestLine = this.checkStave().getNumLines();
        let lowestLine = 1;
        let highestDisplacedLine;
        let lowestDisplacedLine;
        let highestNonDisplacedLine = highestLine;
        let lowestNonDisplacedLine = lowestLine;
        __classPrivateFieldGet(this, _StaveNote_noteHeads, "f").forEach((notehead) => {
            const line = notehead.getLine();
            const y = notehead.getY();
            yTop = Math.min(y, yTop);
            yBottom = Math.max(y, yBottom);
            if (displacedX === undefined && notehead.isDisplaced()) {
                displacedX = notehead.getAbsoluteX();
            }
            if (nonDisplacedX === undefined && !notehead.isDisplaced()) {
                nonDisplacedX = notehead.getAbsoluteX();
            }
            highestLine = Math.max(line, highestLine);
            lowestLine = Math.min(line, lowestLine);
            if (notehead.isDisplaced()) {
                highestDisplacedLine = highestDisplacedLine === undefined ? line : Math.max(line, highestDisplacedLine);
                lowestDisplacedLine = lowestDisplacedLine === undefined ? line : Math.min(line, lowestDisplacedLine);
            }
            else {
                highestNonDisplacedLine = Math.max(line, highestNonDisplacedLine);
                lowestNonDisplacedLine = Math.min(line, lowestNonDisplacedLine);
            }
        }, this);
        return {
            yTop,
            yBottom,
            displacedX,
            nonDisplacedX,
            highestLine,
            lowestLine,
            highestDisplacedLine,
            lowestDisplacedLine,
            highestNonDisplacedLine,
            lowestNonDisplacedLine,
        };
    }
    // Get the starting `x` coordinate for the noteheads
    getNoteHeadBeginX() {
        return this.getAbsoluteX() + this.xShift;
    }
    // Get the ending `x` coordinate for the noteheads
    getNoteHeadEndX() {
        const xBegin = this.getNoteHeadBeginX();
        return xBegin + this.getGlyphWidth();
    }
    get noteHeads() {
        return __classPrivateFieldGet(this, _StaveNote_noteHeads, "f").slice();
    }
    // Draw the ledger lines between the stave and the highest/lowest keys
    drawLedgerLines() {
        const stave = this.checkStave();
        const { renderOptions: { strokePx }, } = this;
        const ctx = this.checkContext();
        const width = this.getGlyphWidth() + strokePx * 2;
        const doubleWidth = 2 * (this.getGlyphWidth() + strokePx) - _stem__WEBPACK_IMPORTED_MODULE_5__.Stem.WIDTH / 2;
        if (this.isRest())
            return;
        if (!ctx) {
            throw new _util__WEBPACK_IMPORTED_MODULE_9__.RuntimeError('NoCanvasContext', "Can't draw without a canvas context.");
        }
        const { highestLine, lowestLine, highestDisplacedLine, highestNonDisplacedLine, lowestDisplacedLine, lowestNonDisplacedLine, displacedX, nonDisplacedX, } = this.getNoteHeadBounds();
        // Early out if there are no ledger lines to draw.
        if (highestLine < 6 && lowestLine > 0)
            return;
        const minX = Math.min(displacedX !== null && displacedX !== void 0 ? displacedX : 0, nonDisplacedX !== null && nonDisplacedX !== void 0 ? nonDisplacedX : 0);
        const drawLedgerLine = (y, normal, displaced) => {
            let x;
            if (displaced && normal)
                x = minX - strokePx;
            else if (normal)
                x = (nonDisplacedX !== null && nonDisplacedX !== void 0 ? nonDisplacedX : 0) - strokePx;
            else
                x = (displacedX !== null && displacedX !== void 0 ? displacedX : 0) - strokePx;
            const ledgerWidth = normal && displaced ? doubleWidth : width;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + ledgerWidth, y);
            ctx.stroke();
        };
        const style = Object.assign(Object.assign({}, stave.getDefaultLedgerLineStyle()), this.getLedgerLineStyle());
        this.applyStyle(ctx, style);
        // Draw ledger lines below the staff:
        for (let line = 6; line <= highestLine; ++line) {
            const normal = nonDisplacedX !== undefined && line <= highestNonDisplacedLine;
            const displaced = highestDisplacedLine !== undefined && line <= highestDisplacedLine;
            drawLedgerLine(stave.getYForNote(line), normal, displaced);
        }
        // Draw ledger lines above the staff:
        for (let line = 0; line >= lowestLine; --line) {
            const normal = nonDisplacedX !== undefined && line >= lowestNonDisplacedLine;
            const displaced = lowestDisplacedLine !== undefined && line >= lowestDisplacedLine;
            drawLedgerLine(stave.getYForNote(line), normal, displaced);
        }
        this.restoreStyle(ctx, style);
    }
    // Draw all key modifiers
    drawModifiers(noteheadParam) {
        const ctx = this.checkContext();
        for (let i = 0; i < this.modifiers.length; i++) {
            const modifier = this.modifiers[i];
            const index = modifier.checkIndex();
            const notehead = __classPrivateFieldGet(this, _StaveNote_noteHeads, "f")[index];
            if (notehead === noteheadParam) {
                const noteheadStyle = notehead.getStyle();
                notehead.applyStyle(ctx, noteheadStyle);
                modifier.setContext(ctx);
                modifier.drawWithStyle();
                notehead.restoreStyle(ctx, noteheadStyle);
            }
        }
    }
    shouldDrawFlag() {
        const hasStem = this.stem !== undefined;
        const hasFlag = this.glyphProps.codeFlagUp !== undefined;
        const hasNoBeam = this.beam === undefined;
        return hasStem && hasFlag && hasNoBeam && !this.isRest();
    }
    // Draw the flag for the note
    drawFlag() {
        const ctx = this.checkContext();
        if (!ctx) {
            throw new _util__WEBPACK_IMPORTED_MODULE_9__.RuntimeError('NoCanvasContext', "Can't draw without a canvas context.");
        }
        if (this.shouldDrawFlag()) {
            const { yTop, yBottom } = this.getNoteHeadBounds();
            // eslint-disable-next-line
            const noteStemHeight = this.stem.getHeight();
            const flagX = this.getStemX() - _tables__WEBPACK_IMPORTED_MODULE_7__.Tables.STEM_WIDTH / 2;
            const flagY = this.getStemDirection() === _stem__WEBPACK_IMPORTED_MODULE_5__.Stem.DOWN
                ? // Down stems are below the note head and have flags on the right.
                    yTop - noteStemHeight - this.flag.getTextMetrics().actualBoundingBoxDescent
                : // Up stems are above the note head and have flags on the right.
                    yBottom - noteStemHeight + this.flag.getTextMetrics().actualBoundingBoxAscent;
            // Draw the Flag
            this.applyStyle(ctx, this.flagStyle);
            this.flag.renderText(ctx, flagX, flagY);
            this.restoreStyle(ctx, this.flagStyle);
        }
    }
    // Draw the NoteHeads
    drawNoteHeads() {
        const ctx = this.checkContext();
        __classPrivateFieldGet(this, _StaveNote_noteHeads, "f").forEach((notehead) => {
            notehead.applyStyle(ctx);
            ctx.openGroup('notehead', notehead.getAttribute('id'), { pointerBBox: true });
            notehead.setContext(ctx).draw();
            this.drawModifiers(notehead);
            ctx.closeGroup();
            notehead.restoreStyle(ctx);
        });
    }
    drawStem(stemOptions) {
        // GCR TODO: I can't find any context in which this is called with the stemStruct
        // argument in the codebase or tests. Nor can I find a case where super.drawStem
        // is called at all. Perhaps these should be removed?
        const ctx = this.checkContext();
        if (stemOptions) {
            this.setStem(new _stem__WEBPACK_IMPORTED_MODULE_5__.Stem(stemOptions));
        }
        // If we will render a flag, we shorten the stem so that the tip
        // does not poke through the flag.
        if (this.shouldDrawFlag() && this.stem) {
            this.stem.adjustHeightForFlag();
        }
        if (this.stem) {
            this.stem.setContext(ctx).draw();
        }
    }
    /**
     * Override stemmablenote stem extension to adjust for distance from middle line.
     */
    getStemExtension() {
        const superStemExtension = super.getStemExtension();
        if (!this.glyphProps.stem) {
            return superStemExtension;
        }
        const stemDirection = this.getStemDirection();
        if (stemDirection !== this.calculateOptimalStemDirection()) {
            return superStemExtension; // no adjustment for manually set stem direction.
        }
        let midLineDistance;
        const MIDDLE_LINE = 3;
        if (stemDirection === _stem__WEBPACK_IMPORTED_MODULE_5__.Stem.UP) {
            // Note that the use of maxLine here instead of minLine might
            // seem counterintuitive, but in the case of (say) treble clef
            // chord(F2, E4) stem up, we do not want to extend the stem because
            // of F2, when a normal octave-length stem above E4 is fine.
            //
            // maxLine and minLine are set in calculateOptimalStemDirection() so
            // will be known.
            midLineDistance = MIDDLE_LINE - this.maxLine;
        }
        else {
            midLineDistance = this.minLine - MIDDLE_LINE;
        }
        // how many lines more than an octave is the relevant notehead?
        const linesOverOctaveFromMidLine = midLineDistance - 3.5;
        if (linesOverOctaveFromMidLine <= 0) {
            return superStemExtension;
        }
        const stave = this.getStave();
        let spacingBetweenLines = 10;
        if (stave !== undefined) {
            spacingBetweenLines = stave.getSpacingBetweenLines();
        }
        return superStemExtension + linesOverOctaveFromMidLine * spacingBetweenLines;
    }
    // Draws all the `StaveNote` parts. This is the main drawing method.
    draw() {
        if (this.renderOptions.draw === false)
            return;
        if (this.ys.length === 0) {
            throw new _util__WEBPACK_IMPORTED_MODULE_9__.RuntimeError('NoYValues', "Can't draw note without Y values.");
        }
        const ctx = this.checkContext();
        const xBegin = this.getNoteHeadBeginX();
        const shouldRenderStem = this.hasStem() && !this.beam;
        // Format note head x positions
        __classPrivateFieldGet(this, _StaveNote_noteHeads, "f").forEach((notehead) => notehead.setX(xBegin));
        if (this.stem) {
            // Format stem x positions
            const stemX = this.getStemX();
            this.stem.setNoteHeadXBounds(stemX, stemX);
        }
        L('Rendering ', this.isChord() ? 'chord :' : 'note :', this.keys);
        // Apply the overall style -- may be contradicted by local settings:
        this.applyStyle();
        ctx.openGroup('stavenote', this.getAttribute('id'));
        this.drawLedgerLines();
        if (shouldRenderStem)
            this.drawStem();
        this.drawNoteHeads();
        this.drawFlag();
        ctx.closeGroup();
        this.restoreStyle();
        this.setRendered();
    }
}
_StaveNote_noteHeads = new WeakMap(), _StaveNote_sortedKeyProps = new WeakMap();
StaveNote.DEBUG = false;


/***/ }),

/***/ "./src/staverepetition.ts":
/*!********************************!*\
  !*** ./src/staverepetition.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Repetition: () => (/* binding */ Repetition)
/* harmony export */ });
/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./metrics */ "./src/metrics.ts");
/* harmony import */ var _stavemodifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stavemodifier */ "./src/stavemodifier.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// @author: Larry Kuhns 2011



class Repetition extends _stavemodifier__WEBPACK_IMPORTED_MODULE_1__.StaveModifier {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_2__.Category.Repetition;
    }
    constructor(type, x, yShift) {
        super();
        this.symbolType = type;
        this.x = x;
        this.xShift = 0;
        this.yShift = yShift;
    }
    setShiftX(x) {
        this.xShift = x;
        return this;
    }
    setShiftY(y) {
        this.yShift = y;
        return this;
    }
    draw(stave, x) {
        this.setRendered();
        switch (this.symbolType) {
            case Repetition.type.CODA_RIGHT:
                this.drawCodaFixed(stave, x + stave.getWidth());
                break;
            case Repetition.type.CODA_LEFT:
                this.drawSymbolText(stave, x, 'Coda', true);
                break;
            case Repetition.type.SEGNO_LEFT:
                this.drawSegnoFixed(stave, x);
                break;
            case Repetition.type.SEGNO_RIGHT:
                this.drawSegnoFixed(stave, x + stave.getWidth());
                break;
            case Repetition.type.DC:
                this.drawSymbolText(stave, x, 'D.C.', false);
                break;
            case Repetition.type.DC_AL_CODA:
                this.drawSymbolText(stave, x, 'D.C. al', true);
                break;
            case Repetition.type.DC_AL_FINE:
                this.drawSymbolText(stave, x, 'D.C. al Fine', false);
                break;
            case Repetition.type.DS:
                this.drawSymbolText(stave, x, 'D.S.', false);
                break;
            case Repetition.type.DS_AL_CODA:
                this.drawSymbolText(stave, x, 'D.S. al', true);
                break;
            case Repetition.type.DS_AL_FINE:
                this.drawSymbolText(stave, x, 'D.S. al Fine', false);
                break;
            case Repetition.type.FINE:
                this.drawSymbolText(stave, x, 'Fine', false);
                break;
            case Repetition.type.TO_CODA:
                this.drawSymbolText(stave, x, 'To', true);
                break;
            default:
                break;
        }
        return this;
    }
    drawCodaFixed(stave, x) {
        const y = stave.getYForTopText(stave.getNumLines());
        this.text = '\ue048' /*coda*/;
        this.renderText(stave.checkContext(), x, y + _metrics__WEBPACK_IMPORTED_MODULE_0__.Metrics.get('Repetition.coda.offsetY'));
        return this;
    }
    drawSegnoFixed(stave, x) {
        const y = stave.getYForTopText(stave.getNumLines());
        this.text = '\ue047' /*segno*/;
        this.renderText(stave.checkContext(), x, y + _metrics__WEBPACK_IMPORTED_MODULE_0__.Metrics.get('Repetition.segno.offsetY'));
        return this;
    }
    drawSymbolText(stave, x, text, drawCoda) {
        const ctx = stave.checkContext();
        let textX = 0;
        this.text = text;
        if (drawCoda) {
            this.text += ' \ue048' /*coda*/;
        }
        this.setFont(_metrics__WEBPACK_IMPORTED_MODULE_0__.Metrics.getFontInfo('Repetition.text'));
        switch (this.symbolType) {
            // To the left
            case Repetition.type.CODA_LEFT:
                // Offset Coda text to right of stave beginning
                textX = stave.getVerticalBarWidth();
                break;
            // To the right
            case Repetition.type.DC:
            case Repetition.type.DC_AL_FINE:
            case Repetition.type.DS:
            case Repetition.type.DS_AL_FINE:
            case Repetition.type.FINE:
            default:
                textX =
                    x -
                        (stave.getNoteStartX() - this.x) +
                        stave.getWidth() -
                        this.width -
                        _metrics__WEBPACK_IMPORTED_MODULE_0__.Metrics.get('Repetition.text.offsetX');
        }
        const y = stave.getYForTopText(stave.getNumLines()) + _metrics__WEBPACK_IMPORTED_MODULE_0__.Metrics.get('Repetition.text.offsetY');
        this.renderText(ctx, textX, y);
        return this;
    }
}
Repetition.type = {
    NONE: 1,
    CODA_LEFT: 2,
    CODA_RIGHT: 3,
    SEGNO_LEFT: 4,
    SEGNO_RIGHT: 5,
    DC: 6,
    DC_AL_CODA: 7,
    DC_AL_FINE: 8,
    DS: 9,
    DS_AL_CODA: 10,
    DS_AL_FINE: 11,
    FINE: 12,
    TO_CODA: 13, // To Coda at end of stave
};


/***/ }),

/***/ "./src/stavesection.ts":
/*!*****************************!*\
  !*** ./src/stavesection.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StaveSection: () => (/* binding */ StaveSection)
/* harmony export */ });
/* harmony import */ var _stavemodifier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stavemodifier */ "./src/stavemodifier.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// @author: Larry Kuhns 2011


class StaveSection extends _stavemodifier__WEBPACK_IMPORTED_MODULE_0__.StaveModifier {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_1__.Category.StaveSection;
    }
    constructor(section, x, yShift, drawRect = true) {
        super();
        this.setStaveSection(section);
        this.x = x;
        this.yShift = yShift;
        this.drawRect = drawRect;
    }
    setStaveSection(section) {
        this.text = section;
        return this;
    }
    draw(stave, xShift) {
        const borderWidth = 2;
        const padding = 2;
        const ctx = stave.checkContext();
        this.setRendered();
        ctx.save();
        ctx.setLineWidth(borderWidth);
        const headroom = -1 * this.textMetrics.actualBoundingBoxDescent;
        const width = this.width + 2 * padding; // add left & right padding
        const height = this.height + 2 * padding; // add top & bottom padding
        //  Seems to be a good default y
        const y = stave.getYForTopText(1.5) + this.yShift;
        const x = this.x + xShift;
        if (this.drawRect) {
            ctx.beginPath();
            ctx.rect(x, y - height + headroom, width, height);
            ctx.stroke();
        }
        this.renderText(ctx, xShift + padding, y - padding);
        ctx.restore();
        return this;
    }
}


/***/ }),

/***/ "./src/stavetempo.ts":
/*!***************************!*\
  !*** ./src/stavetempo.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StaveTempo: () => (/* binding */ StaveTempo)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./metrics */ "./src/metrics.ts");
/* harmony import */ var _stavemodifier__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stavemodifier */ "./src/stavemodifier.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// @author: Radosaw Eichler 2012
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _StaveTempo_durationToCode;





class StaveTempo extends _stavemodifier__WEBPACK_IMPORTED_MODULE_2__.StaveModifier {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_4__.Category.StaveTempo;
    }
    constructor(tempo, x, shiftY) {
        super();
        _StaveTempo_durationToCode.set(this, {
            '1/2': '\ue1d0' /*metNoteDoubleWhole*/,
            1: '\ueca2' /*metNoteWhole*/,
            2: '\ueca3' /*metNoteHalfUp*/,
            4: '\ueca5' /*metNoteQuarterUp*/,
            8: '\ueca7' /*metNote8thUp*/,
            16: '\ueca9' /*metNote16thUp*/,
            32: '\uecab' /*metNote32ndUp*/,
            64: '\uecad' /*metNote64thUp*/,
            128: '\uecaf' /*metNote128thUp*/,
            256: '\uecb1' /*metNote256thUp*/,
            512: '\uecb3' /*metNote512thUp*/,
            1024: '\uecb5' /*metNote1024thUp*/,
        });
        this.tempo = tempo;
        this.position = _stavemodifier__WEBPACK_IMPORTED_MODULE_2__.StaveModifierPosition.ABOVE;
        this.x = x;
        this.setXShift(10);
        this.setYShift(shiftY);
    }
    setTempo(tempo) {
        this.tempo = tempo;
        return this;
    }
    draw(stave, shiftX) {
        var _a;
        const ctx = stave.checkContext();
        this.setRendered();
        const name = this.tempo.name;
        const duration = this.tempo.duration;
        const dots = (_a = this.tempo.dots) !== null && _a !== void 0 ? _a : 0;
        const bpm = this.tempo.bpm;
        let x = this.x + shiftX;
        const y = stave.getYForTopText(1);
        ctx.save();
        if (name) {
            this.text = name;
            this.fontInfo = _metrics__WEBPACK_IMPORTED_MODULE_1__.Metrics.getFontInfo('StaveTempo.name');
            this.renderText(ctx, shiftX, y);
            x += this.getWidth();
        }
        if (duration && bpm) {
            if (name) {
                x += 2;
                ctx.setFont(_metrics__WEBPACK_IMPORTED_MODULE_1__.Metrics.getFontInfo('StaveTempo'));
                ctx.fillText('(', x + this.xShift, y + this.yShift);
                x += 5;
            }
            x += 3;
            const el = new _element__WEBPACK_IMPORTED_MODULE_0__.Element('StaveTempo.glyph');
            el.setText(__classPrivateFieldGet(this, _StaveTempo_durationToCode, "f")[_tables__WEBPACK_IMPORTED_MODULE_3__.Tables.sanitizeDuration(duration)]);
            el.renderText(ctx, x + this.xShift, y + this.yShift);
            x += el.getWidth();
            // Draw dot
            ctx.setFont(_metrics__WEBPACK_IMPORTED_MODULE_1__.Metrics.getFontInfo('StaveTempo.glyph'));
            for (let i = 0; i < dots; i++) {
                x += 6;
                ctx.fillText('\uecb7' /*metAugmentationDot*/, x + this.xShift, y + 2 + this.yShift);
            }
            ctx.setFont(_metrics__WEBPACK_IMPORTED_MODULE_1__.Metrics.getFontInfo('StaveTempo'));
            ctx.fillText(' = ' + bpm + (name ? ')' : ''), x + 3 + this.xShift, y + this.yShift);
        }
        ctx.restore();
        return this;
    }
}
_StaveTempo_durationToCode = new WeakMap();


/***/ }),

/***/ "./src/stavetext.ts":
/*!**************************!*\
  !*** ./src/stavetext.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StaveText: () => (/* binding */ StaveText)
/* harmony export */ });
/* harmony import */ var _stavemodifier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stavemodifier */ "./src/stavemodifier.ts");
/* harmony import */ var _textnote__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./textnote */ "./src/textnote.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// @author: Taehoon Moon 2014




class StaveText extends _stavemodifier__WEBPACK_IMPORTED_MODULE_0__.StaveModifier {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_2__.Category.StaveText;
    }
    constructor(text, position, options = {}) {
        var _a, _b, _c;
        super();
        this.setText(text);
        this.setXShift((_a = options.shiftX) !== null && _a !== void 0 ? _a : 0);
        this.setYShift((_b = options.shiftY) !== null && _b !== void 0 ? _b : 0);
        this.position = position;
        this.justification = (_c = options.justification) !== null && _c !== void 0 ? _c : _textnote__WEBPACK_IMPORTED_MODULE_1__.TextNote.Justification.CENTER;
    }
    draw(stave) {
        const ctx = stave.checkContext();
        this.setRendered();
        let x;
        let y;
        switch (this.position) {
            case _stavemodifier__WEBPACK_IMPORTED_MODULE_0__.StaveModifierPosition.LEFT:
            case _stavemodifier__WEBPACK_IMPORTED_MODULE_0__.StaveModifierPosition.RIGHT:
                y = (stave.getYForLine(0) + stave.getBottomLineY()) / 2;
                if (this.position === _stavemodifier__WEBPACK_IMPORTED_MODULE_0__.StaveModifierPosition.LEFT) {
                    x = stave.getX() - this.width - 24;
                }
                else {
                    x = stave.getX() + stave.getWidth() + 24;
                }
                break;
            case _stavemodifier__WEBPACK_IMPORTED_MODULE_0__.StaveModifierPosition.ABOVE:
            case _stavemodifier__WEBPACK_IMPORTED_MODULE_0__.StaveModifierPosition.BELOW:
                x = stave.getX();
                if (this.justification === _textnote__WEBPACK_IMPORTED_MODULE_1__.TextJustification.CENTER) {
                    x += stave.getWidth() / 2 - this.width / 2;
                }
                else if (this.justification === _textnote__WEBPACK_IMPORTED_MODULE_1__.TextJustification.RIGHT) {
                    x += stave.getWidth() - this.width;
                }
                if (this.position === _stavemodifier__WEBPACK_IMPORTED_MODULE_0__.StaveModifierPosition.ABOVE) {
                    y = stave.getYForTopText(2);
                }
                else {
                    y = stave.getYForBottomText(2);
                }
                break;
            default:
                throw new _util__WEBPACK_IMPORTED_MODULE_3__.RuntimeError('InvalidPosition', 'Value Must be in Modifier.Position.');
        }
        this.renderText(ctx, x, y + 4);
        return this;
    }
}


/***/ }),

/***/ "./src/stavetie.ts":
/*!*************************!*\
  !*** ./src/stavetie.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StaveTie: () => (/* binding */ StaveTie)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
//
// This class implements varies types of ties between contiguous notes. The
// ties include: regular ties, hammer ons, pull offs, and slides.



class StaveTie extends _element__WEBPACK_IMPORTED_MODULE_0__.Element {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_1__.Category.StaveTie;
    }
    /**
     * @param notes is a struct that has:
     *
     *  {
     *    firstNote: Note,
     *    lastNote: Note,
     *    firstIndexes: [n1, n2, n3],
     *    lastIndexes: [n1, n2, n3]
     *  }
     *
     * @param text
     */
    constructor(notes, text = '') {
        super();
        this.setNotes(notes);
        this.text = text;
        this.renderOptions = {
            cp1: 8,
            cp2: 12,
            textShiftX: 0,
            firstXShift: 0,
            lastXShift: 0,
            yShift: 7,
            tieSpacing: 0,
        };
    }
    setDirection(direction) {
        this.direction = direction;
        return this;
    }
    /**
     * Set the notes to attach this tie to.
     *
     * @param {!Object} notes The notes to tie up.
     */
    setNotes(notes) {
        if (!notes.firstNote && !notes.lastNote) {
            throw new _util__WEBPACK_IMPORTED_MODULE_2__.RuntimeError('BadArguments', 'Tie needs to have either firstNote or lastNote set.');
        }
        if (!notes.firstIndexes) {
            notes.firstIndexes = [0];
        }
        if (!notes.lastIndexes) {
            notes.lastIndexes = [0];
        }
        if (notes.firstIndexes.length !== notes.lastIndexes.length) {
            throw new _util__WEBPACK_IMPORTED_MODULE_2__.RuntimeError('BadArguments', 'Tied notes must have same number of indexes.');
        }
        this.notes = notes;
        return this;
    }
    /**
     * @return {boolean} Returns true if this is a partial bar.
     */
    isPartial() {
        return !this.notes.firstNote || !this.notes.lastNote;
    }
    /**
     * @param params.firstX is specified in pixels.
     * @param params.lastX is specified in pixels.
     */
    renderTie(params) {
        if (params.firstYs.length === 0 || params.lastYs.length === 0) {
            throw new _util__WEBPACK_IMPORTED_MODULE_2__.RuntimeError('BadArguments', 'No Y-values to render');
        }
        const ctx = this.checkContext();
        let cp1 = this.renderOptions.cp1;
        let cp2 = this.renderOptions.cp2;
        if (Math.abs(params.lastX - params.firstX) < 10) {
            cp1 = 2;
            cp2 = 8;
        }
        const firstXShift = this.renderOptions.firstXShift;
        const lastXShift = this.renderOptions.lastXShift;
        const yShift = this.renderOptions.yShift * params.direction;
        // setNotes(...) verified that firstIndexes and lastIndexes are not undefined.
        // As a result, we use the ! non-null assertion operator here.
        // eslint-disable-next-line
        const firstIndexes = this.notes.firstIndexes;
        // eslint-disable-next-line
        const lastIndexes = this.notes.lastIndexes;
        this.applyStyle();
        ctx.openGroup('stavetie', this.getAttribute('id'));
        for (let i = 0; i < firstIndexes.length; ++i) {
            const cpX = (params.lastX + lastXShift + (params.firstX + firstXShift)) / 2;
            // firstY and lastY are specified in pixels.
            const firstY = params.firstYs[firstIndexes[i]] + yShift;
            const lastY = params.lastYs[lastIndexes[i]] + yShift;
            if (isNaN(firstY) || isNaN(lastY)) {
                throw new _util__WEBPACK_IMPORTED_MODULE_2__.RuntimeError('BadArguments', 'Bad indexes for tie rendering.');
            }
            const topControlPointY = (firstY + lastY) / 2 + cp1 * params.direction;
            const bottomControlPointY = (firstY + lastY) / 2 + cp2 * params.direction;
            ctx.beginPath();
            ctx.moveTo(params.firstX + firstXShift, firstY);
            ctx.quadraticCurveTo(cpX, topControlPointY, params.lastX + lastXShift, lastY);
            ctx.quadraticCurveTo(cpX, bottomControlPointY, params.firstX + firstXShift, firstY);
            ctx.closePath();
            ctx.fill();
        }
        ctx.closeGroup();
        this.restoreStyle();
    }
    /**
     * @param firstX specified in pixels
     * @param lastX specified in pixels
     */
    renderTieText(firstX, lastX) {
        var _a, _b, _c;
        const ctx = this.checkContext();
        let centerX = (firstX + lastX) / 2;
        centerX -= ctx.measureText(this.text).width / 2;
        const stave = (_b = (_a = this.notes.firstNote) === null || _a === void 0 ? void 0 : _a.checkStave()) !== null && _b !== void 0 ? _b : (_c = this.notes.lastNote) === null || _c === void 0 ? void 0 : _c.checkStave();
        if (stave) {
            ctx.save();
            ctx.setFont(this.fontInfo);
            ctx.fillText(this.text, centerX + this.renderOptions.textShiftX, stave.getYForTopText() - 1);
            ctx.restore();
        }
    }
    /**
     * Returns the TieNotes structure of the first and last note this tie connects.
     */
    getNotes() {
        return this.notes;
    }
    draw() {
        this.checkContext();
        this.setRendered();
        const firstNote = this.notes.firstNote;
        const lastNote = this.notes.lastNote;
        // Provide some default values so the compiler doesn't complain.
        // firstX and lastX are in pixels.
        let firstX = 0;
        let lastX = 0;
        let firstYs = [0];
        let lastYs = [0];
        let stemDirection = 0;
        if (firstNote) {
            firstX = firstNote.getTieRightX() + this.renderOptions.tieSpacing;
            stemDirection = firstNote.getStemDirection();
            firstYs = firstNote.getYs();
        }
        else if (lastNote) {
            const stave = lastNote.checkStave();
            firstX = stave.getTieStartX();
            firstYs = lastNote.getYs();
            this.notes.firstIndexes = this.notes.lastIndexes;
        }
        if (lastNote) {
            lastX = lastNote.getTieLeftX() + this.renderOptions.tieSpacing;
            stemDirection = lastNote.getStemDirection();
            lastYs = lastNote.getYs();
        }
        else if (firstNote) {
            const stave = firstNote.checkStave();
            lastX = stave.getTieEndX();
            lastYs = firstNote.getYs();
            this.notes.lastIndexes = this.notes.firstIndexes;
        }
        if (this.direction) {
            stemDirection = this.direction;
        }
        this.renderTie({
            firstX,
            lastX,
            firstYs,
            lastYs,
            direction: stemDirection,
        });
        this.renderTieText(firstX, lastX);
        return true;
    }
}


/***/ }),

/***/ "./src/stavevolta.ts":
/*!***************************!*\
  !*** ./src/stavevolta.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Volta: () => (/* binding */ Volta),
/* harmony export */   VoltaType: () => (/* binding */ VoltaType)
/* harmony export */ });
/* harmony import */ var _stavemodifier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stavemodifier */ "./src/stavemodifier.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// @author: Larry Kuhns 2011


var VoltaType;
(function (VoltaType) {
    VoltaType[VoltaType["NONE"] = 1] = "NONE";
    VoltaType[VoltaType["BEGIN"] = 2] = "BEGIN";
    VoltaType[VoltaType["MID"] = 3] = "MID";
    VoltaType[VoltaType["END"] = 4] = "END";
    VoltaType[VoltaType["BEGIN_END"] = 5] = "BEGIN_END";
})(VoltaType || (VoltaType = {}));
class Volta extends _stavemodifier__WEBPACK_IMPORTED_MODULE_0__.StaveModifier {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_1__.Category.Volta;
    }
    static get type() {
        return VoltaType;
    }
    constructor(type, label, x, yShift) {
        super();
        this.type = type;
        this.x = x;
        this.yShift = yShift;
        this.text = label;
    }
    draw(stave, x) {
        const ctx = stave.checkContext();
        this.setRendered();
        let width = stave.getWidth() - x; // don't include x (offset) for width
        const topY = stave.getYForTopText(stave.getNumLines()) + this.yShift;
        const vertHeight = 1.5 * stave.getSpacingBetweenLines();
        switch (this.type) {
            case VoltaType.BEGIN:
                ctx.fillRect(this.x + x, topY, 1, vertHeight);
                break;
            case VoltaType.END:
                width -= 5;
                ctx.fillRect(this.x + x + width, topY, 1, vertHeight);
                break;
            case VoltaType.BEGIN_END:
                width -= 3;
                ctx.fillRect(this.x + x, topY, 1, vertHeight);
                ctx.fillRect(this.x + x + width, topY, 1, vertHeight);
                break;
            default:
                break;
        }
        // If the beginning of a volta, draw measure number
        if (this.type === VoltaType.BEGIN || this.type === VoltaType.BEGIN_END) {
            this.renderText(ctx, x + 5, topY - this.yShift + 15);
        }
        ctx.fillRect(this.x + x, topY, width, 1);
        return this;
    }
}


/***/ }),

/***/ "./src/stem.ts":
/*!*********************!*\
  !*** ./src/stem.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Stem: () => (/* binding */ Stem)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./metrics */ "./src/metrics.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
//
// ## Description
// This file implements the `Stem` object. Generally this object is handled
// by its parent `StemmableNote`.





// eslint-disable-next-line
function L(...args) {
    if (Stem.DEBUG)
        (0,_util__WEBPACK_IMPORTED_MODULE_4__.log)('Vex.Flow.Stem', args);
}
class Stem extends _element__WEBPACK_IMPORTED_MODULE_0__.Element {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_3__.Category.Stem;
    }
    // Stem directions
    static get UP() {
        return 1;
    }
    static get DOWN() {
        return -1;
    }
    // Theme
    static get WIDTH() {
        return _tables__WEBPACK_IMPORTED_MODULE_2__.Tables.STEM_WIDTH;
    }
    static get HEIGHT() {
        return _tables__WEBPACK_IMPORTED_MODULE_2__.Tables.STEM_HEIGHT;
    }
    constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g;
        super();
        this.stemUpYOffset = 0;
        this.stemDownYOffset = 0;
        this.stemUpYBaseOffset = 0;
        this.stemDownYBaseOffset = 0;
        // Default notehead x bounds
        this.xBegin = (_a = options === null || options === void 0 ? void 0 : options.xBegin) !== null && _a !== void 0 ? _a : 0;
        this.xEnd = (_b = options === null || options === void 0 ? void 0 : options.xEnd) !== null && _b !== void 0 ? _b : 0;
        // Y bounds for top/bottom most notehead
        this.yTop = (_c = options === null || options === void 0 ? void 0 : options.yTop) !== null && _c !== void 0 ? _c : 0;
        this.yBottom = (_d = options === null || options === void 0 ? void 0 : options.yBottom) !== null && _d !== void 0 ? _d : 0;
        // Stem top extension
        this.stemExtension = (_e = options === null || options === void 0 ? void 0 : options.stemExtension) !== null && _e !== void 0 ? _e : 0;
        // Direction of the stem
        this.stemDirection = (_f = options === null || options === void 0 ? void 0 : options.stemDirection) !== null && _f !== void 0 ? _f : 0;
        // Flag to override all draw calls
        this.hide = (options === null || options === void 0 ? void 0 : options.hide) || false;
        this.isStemlet = (options === null || options === void 0 ? void 0 : options.isStemlet) || false;
        this.stemletHeight = (_g = options === null || options === void 0 ? void 0 : options.stemletHeight) !== null && _g !== void 0 ? _g : 0;
        // Use to adjust the rendered height without affecting
        // the results of `.getExtents()`
        this.renderHeightAdjustment = 0;
        this.setOptions(options);
    }
    setOptions(options) {
        var _a, _b, _c, _d;
        // Changing where the stem meets the head
        this.stemUpYOffset = (_a = options === null || options === void 0 ? void 0 : options.stemUpYOffset) !== null && _a !== void 0 ? _a : 0;
        this.stemDownYOffset = (_b = options === null || options === void 0 ? void 0 : options.stemDownYOffset) !== null && _b !== void 0 ? _b : 0;
        this.stemUpYBaseOffset = (_c = options === null || options === void 0 ? void 0 : options.stemUpYBaseOffset) !== null && _c !== void 0 ? _c : 0;
        this.stemDownYBaseOffset = (_d = options === null || options === void 0 ? void 0 : options.stemDownYBaseOffset) !== null && _d !== void 0 ? _d : 0;
    }
    // Set the x bounds for the default notehead
    setNoteHeadXBounds(xBegin, xEnd) {
        this.xBegin = xBegin;
        this.xEnd = xEnd;
        return this;
    }
    // Set the direction of the stem in relation to the noteheads
    setDirection(direction) {
        this.stemDirection = direction;
    }
    // Set the extension for the stem, generally for flags or beams
    setExtension(ext) {
        this.stemExtension = ext;
    }
    getExtension() {
        return this.stemExtension;
    }
    // The the y bounds for the top and bottom noteheads
    setYBounds(yTop, yBottom) {
        this.yTop = yTop;
        this.yBottom = yBottom;
    }
    // Gets the entire height for the stem
    getHeight() {
        const yOffset = this.stemDirection === Stem.UP ? this.stemUpYOffset : this.stemDownYOffset;
        const unsignedHeight = this.yBottom - this.yTop + (Stem.HEIGHT - yOffset + this.stemExtension); // parentheses just for grouping.
        return unsignedHeight * this.stemDirection;
    }
    getBoundingBox() {
        throw new _util__WEBPACK_IMPORTED_MODULE_4__.RuntimeError('NotImplemented', 'getBoundingBox() not implemented.');
    }
    // Get the y coordinates for the very base of the stem to the top of
    // the extension
    getExtents() {
        const isStemUp = this.stemDirection === Stem.UP;
        const ys = [this.yTop, this.yBottom];
        const stemHeight = Stem.HEIGHT + this.stemExtension;
        const innerMostNoteheadY = (isStemUp ? Math.min : Math.max)(...ys);
        const outerMostNoteheadY = (isStemUp ? Math.max : Math.min)(...ys);
        const stemTipY = innerMostNoteheadY + stemHeight * -this.stemDirection;
        return { topY: stemTipY, baseY: outerMostNoteheadY };
    }
    setVisibility(isVisible) {
        this.hide = !isVisible;
        return this;
    }
    setStemlet(isStemlet, stemletHeight) {
        this.isStemlet = isStemlet;
        this.stemletHeight = stemletHeight;
        return this;
    }
    adjustHeightForFlag() {
        this.renderHeightAdjustment = _metrics__WEBPACK_IMPORTED_MODULE_1__.Metrics.get('Stem.heightAdjustmentForFlag', -3);
    }
    adjustHeightForBeam() {
        this.renderHeightAdjustment = -Stem.WIDTH / 2;
    }
    // Render the stem onto the canvas
    draw() {
        this.setRendered();
        if (this.hide)
            return;
        const ctx = this.checkContext();
        let stemX;
        let stemY;
        const stemDirection = this.stemDirection;
        let yBaseOffset = 0;
        if (stemDirection === Stem.DOWN) {
            // Down stems are rendered to the left of the head.
            stemX = this.xBegin;
            stemY = this.yTop + this.stemDownYOffset;
            yBaseOffset = this.stemDownYBaseOffset;
        }
        else {
            // Up stems are rendered to the right of the head.
            stemX = this.xEnd;
            stemY = this.yBottom - this.stemUpYOffset;
            yBaseOffset = this.stemUpYBaseOffset;
        }
        const stemHeight = this.getHeight();
        L('Rendering stem - ', 'Top Y: ', this.yTop, 'Bottom Y: ', this.yBottom);
        // The offset from the stem's base which is required fo satisfy the stemlet height
        const stemletYOffset = this.isStemlet ? stemHeight - this.stemletHeight * this.stemDirection : 0;
        // Draw the stem
        ctx.save();
        this.applyStyle();
        ctx.openGroup('stem', this.getAttribute('id'), { pointerBBox: true });
        ctx.beginPath();
        ctx.setLineWidth(Stem.WIDTH);
        ctx.moveTo(stemX, stemY - stemletYOffset + yBaseOffset);
        ctx.lineTo(stemX, stemY - stemHeight - this.renderHeightAdjustment * stemDirection);
        ctx.stroke();
        ctx.closeGroup();
        this.restoreStyle();
        ctx.restore();
    }
}
/** To enable logging for this class. Set `Vex.Flow.Stem.DEBUG` to `true`. */
Stem.DEBUG = false;


/***/ }),

/***/ "./src/stemmablenote.ts":
/*!******************************!*\
  !*** ./src/stemmablenote.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StemmableNote: () => (/* binding */ StemmableNote)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _glyphs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./glyphs */ "./src/glyphs.ts");
/* harmony import */ var _note__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./note */ "./src/note.ts");
/* harmony import */ var _stem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stem */ "./src/stem.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
//
// ## Description
// `StemmableNote` is an abstract interface for notes with optional stems.
// Examples of stemmable notes are `StaveNote` and `TabNote`







class StemmableNote extends _note__WEBPACK_IMPORTED_MODULE_2__.Note {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_5__.Category.StemmableNote;
    }
    constructor(noteStruct) {
        super(noteStruct);
        this.flag = new _element__WEBPACK_IMPORTED_MODULE_0__.Element();
        this.flagStyle = {};
    }
    // Get and set the note's `Stem`
    getStem() {
        return this.stem;
    }
    checkStem() {
        if (!this.stem) {
            throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('NoStem', 'No stem attached to instance');
        }
        return this.stem;
    }
    setStem(stem) {
        this.stem = stem;
        this.addChildElement(stem);
        return this;
    }
    // Builds and sets a new stem
    buildStem() {
        const stem = new _stem__WEBPACK_IMPORTED_MODULE_3__.Stem();
        this.setStem(stem);
        return this;
    }
    buildFlag() {
        var _a, _b, _c;
        const { glyphProps } = this;
        if (this.hasFlag()) {
            const flagCode = 
            // codeFlagDown = codeFlagUp + 1
            // if codeFlagUp is undefined, codePoint will be 0
            this.getStemDirection() === _stem__WEBPACK_IMPORTED_MODULE_3__.Stem.DOWN
                ? String.fromCodePoint(((_b = (_a = glyphProps.codeFlagUp) === null || _a === void 0 ? void 0 : _a.codePointAt(0)) !== null && _b !== void 0 ? _b : -1) + 1)
                : (_c = glyphProps.codeFlagUp) !== null && _c !== void 0 ? _c : _glyphs__WEBPACK_IMPORTED_MODULE_1__.Glyphs.null;
            this.flag.setText(flagCode);
            this.flag.fontInfo = this.fontInfo;
        }
    }
    // Get the custom glyph associated with the outer note head on the base of the stem.
    getBaseCustomNoteHeadGlyphProps() {
        if (this.getStemDirection() === _stem__WEBPACK_IMPORTED_MODULE_3__.Stem.DOWN) {
            return this.customGlyphs[this.customGlyphs.length - 1];
        }
        else {
            return this.customGlyphs[0];
        }
    }
    // Get the full length of stem
    getStemLength() {
        return _stem__WEBPACK_IMPORTED_MODULE_3__.Stem.HEIGHT + this.getStemExtension();
    }
    // Get the number of beams for this duration
    getBeamCount() {
        const glyphProps = this.getGlyphProps();
        if (glyphProps) {
            return glyphProps.beamCount;
        }
        else {
            return 0;
        }
    }
    // Get the minimum length of stem
    getStemMinimumLength() {
        const frac = _tables__WEBPACK_IMPORTED_MODULE_4__.Tables.durationToFraction(this.duration);
        const beamIsUndefined = this.beam === undefined;
        let length = frac.value() <= 1 ? 0 : 20;
        // if note is flagged, cannot shorten beam
        switch (this.duration) {
            case '8':
            case '16':
                length = beamIsUndefined ? 35 : 25;
                break;
            case '32':
                length = beamIsUndefined ? 45 : 35;
                break;
            case '64':
                length = beamIsUndefined ? 50 : 40;
                break;
            case '128':
                length = beamIsUndefined ? 55 : 45;
                break;
            default:
                break;
        }
        return length;
    }
    // Get/set the direction of the stem
    getStemDirection() {
        if (!this.stemDirection)
            throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('NoStem', 'No stem attached to this note.');
        return this.stemDirection;
    }
    setStemDirection(direction) {
        if (!direction)
            direction = _stem__WEBPACK_IMPORTED_MODULE_3__.Stem.UP;
        if (direction !== _stem__WEBPACK_IMPORTED_MODULE_3__.Stem.UP && direction !== _stem__WEBPACK_IMPORTED_MODULE_3__.Stem.DOWN) {
            throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('BadArgument', `Invalid stem direction: ${direction}`);
        }
        this.stemDirection = direction;
        // Reset and reformat everything. Flag has to be built before calling getStemExtension.
        this.reset();
        if (this.hasFlag()) {
            this.buildFlag();
        }
        this.beam = undefined;
        if (this.stem) {
            this.stem.setDirection(direction);
            this.stem.setExtension(this.getStemExtension());
        }
        if (this.preFormatted) {
            this.preFormat();
        }
        return this;
    }
    // Get the `x` coordinate of the stem
    getStemX() {
        const xBegin = this.getAbsoluteX() + this.xShift;
        const xEnd = this.getAbsoluteX() + this.xShift + this.getGlyphWidth();
        const stemX = this.stemDirection === _stem__WEBPACK_IMPORTED_MODULE_3__.Stem.DOWN ? xBegin : xEnd;
        return stemX;
    }
    // Get the `x` coordinate for the center of the glyph.
    // Used for `TabNote` stems and stemlets over rests
    getCenterGlyphX() {
        return this.getAbsoluteX() + this.xShift + this.getGlyphWidth() / 2;
    }
    // Get the stem extension for the current duration
    getStemExtension() {
        const glyphProps = this.getGlyphProps();
        const flagHeight = this.flag.getHeight();
        const scale = this.getFontScale();
        if (this.stemExtensionOverride !== undefined) {
            return this.stemExtensionOverride;
        }
        // Use stemBeamExtension with beams
        if (this.beam) {
            return glyphProps.stemBeamExtension * scale;
        }
        // If the flag is longer than the stem, extend the stem by the difference.
        return flagHeight > _stem__WEBPACK_IMPORTED_MODULE_3__.Stem.HEIGHT * scale ? flagHeight - _stem__WEBPACK_IMPORTED_MODULE_3__.Stem.HEIGHT * scale : 0;
    }
    // Set the stem length to a specific. Will override the default length.
    setStemLength(height) {
        this.stemExtensionOverride = height - _stem__WEBPACK_IMPORTED_MODULE_3__.Stem.HEIGHT;
        return this;
    }
    // Get the top and bottom `y` values of the stem.
    getStemExtents() {
        if (!this.stem)
            throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('NoStem', 'No stem attached to this note.');
        return this.stem.getExtents();
    }
    /** Gets the `y` value for the top modifiers at a specific `textLine`. */
    getYForTopText(textLine) {
        const stave = this.checkStave();
        if (this.hasStem()) {
            const extents = this.getStemExtents();
            if (!extents)
                throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('InvalidState', 'Stem does not have extents.');
            return Math.min(stave.getYForTopText(textLine), extents.topY - this.renderOptions.annotationSpacing * (textLine + 1));
        }
        else {
            return stave.getYForTopText(textLine);
        }
    }
    /** Gets the `y` value for the bottom modifiers at a specific `textLine`. */
    getYForBottomText(textLine) {
        const stave = this.checkStave();
        if (this.hasStem()) {
            const extents = this.getStemExtents();
            if (!extents)
                throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('InvalidState', 'Stem does not have extents.');
            return Math.max(stave.getYForTopText(textLine), extents.baseY + this.renderOptions.annotationSpacing * textLine);
        }
        else {
            return stave.getYForBottomText(textLine);
        }
    }
    hasFlag() {
        return this.glyphProps.codeFlagUp !== undefined && !this.beam && !this.isRest();
    }
    /** Post formats the note. */
    postFormat() {
        var _a;
        (_a = this.beam) === null || _a === void 0 ? void 0 : _a.postFormat();
        this.postFormatted = true;
        return this;
    }
    /** Renders the stem onto the canvas. */
    drawStem(stemOptions) {
        var _a;
        this.checkContext();
        this.setRendered();
        this.setStem(new _stem__WEBPACK_IMPORTED_MODULE_3__.Stem(stemOptions));
        (_a = this.stem) === null || _a === void 0 ? void 0 : _a.setContext(this.getContext()).draw();
    }
}


/***/ }),

/***/ "./src/stringnumber.ts":
/*!*****************************!*\
  !*** ./src/stringnumber.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StringNumber: () => (/* binding */ StringNumber)
/* harmony export */ });
/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./metrics */ "./src/metrics.ts");
/* harmony import */ var _modifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifier */ "./src/modifier.ts");
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./renderer */ "./src/renderer.ts");
/* harmony import */ var _stem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stem */ "./src/stem.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// @author Larry Kuhns
//
// This file implements the `StringNumber` class which renders string
// number annotations beside notes.







class StringNumber extends _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_5__.Category.StringNumber;
    }
    // ## Static Methods
    // Arrange string numbers inside a `ModifierContext`
    static format(nums, state) {
        /**
         * The modifier context's leftShift state.
         */
        const leftShift = state.leftShift;
        /**
         * The modifier context's rightShift state.
         */
        const rightShift = state.rightShift;
        const numSpacing = 1;
        if (!nums || nums.length === 0)
            return false;
        const numsList = [];
        let prevNote = null;
        let extraXSpaceForDisplacedNotehead = 0;
        let shiftRight = 0;
        const modLines = 0;
        for (let i = 0; i < nums.length; ++i) {
            const num = nums[i];
            const note = num.getNote();
            const pos = num.getPosition();
            if (!(0,_typeguard__WEBPACK_IMPORTED_MODULE_5__.isStaveNote)(note)) {
                throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('NoStaveNote');
            }
            const index = num.checkIndex();
            const props = note.getKeyProps()[index];
            const mc = note.getModifierContext();
            const verticalSpaceNeeded = (num.radius * 2) / _tables__WEBPACK_IMPORTED_MODULE_4__.Tables.STAVE_LINE_DISTANCE + 0.5;
            if (mc) {
                if (pos === _modifier__WEBPACK_IMPORTED_MODULE_1__.ModifierPosition.ABOVE) {
                    num.textLine = mc.getState().topTextLine;
                    state.topTextLine += verticalSpaceNeeded;
                }
                else if (pos === _modifier__WEBPACK_IMPORTED_MODULE_1__.ModifierPosition.BELOW) {
                    num.textLine = mc.getState().textLine;
                    state.textLine += verticalSpaceNeeded;
                }
            }
            if (note !== prevNote) {
                for (let n = 0; n < note.keys.length; ++n) {
                    if (pos === _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.LEFT) {
                        extraXSpaceForDisplacedNotehead = Math.max(note.getLeftDisplacedHeadPx(), extraXSpaceForDisplacedNotehead);
                    }
                    if (rightShift === 0) {
                        shiftRight = Math.max(note.getRightDisplacedHeadPx(), shiftRight);
                    }
                }
                prevNote = note;
            }
            const glyphLine = modLines === 0 ? props.line : modLines;
            numsList.push({
                pos,
                note,
                num,
                line: glyphLine,
                shiftL: extraXSpaceForDisplacedNotehead,
                shiftR: shiftRight,
            });
        }
        // Sort string numbers by line number.
        numsList.sort((a, b) => b.line - a.line);
        let numShiftR = 0;
        let xWidthL = 0;
        let xWidthR = 0;
        let lastLine = null;
        let lastNote = null;
        for (let i = 0; i < numsList.length; ++i) {
            const note = numsList[i].note;
            const pos = numsList[i].pos;
            const num = numsList[i].num;
            const line = numsList[i].line;
            const shiftR = numsList[i].shiftR;
            // Reset the position of the string number every line.
            if (line !== lastLine || note !== lastNote) {
                numShiftR = rightShift + shiftR;
            }
            const numWidth = num.getWidth() + numSpacing;
            let numXShift = 0;
            if (pos === _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.LEFT) {
                num.setXShift(leftShift + extraXSpaceForDisplacedNotehead);
                numXShift = numWidth; // spacing
                xWidthL = Math.max(numXShift, xWidthL);
            }
            else if (pos === _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.RIGHT) {
                num.setXShift(numShiftR);
                numXShift += numWidth; // spacing
                xWidthR = numXShift > xWidthR ? numXShift : xWidthR;
            }
            lastLine = line;
            lastNote = note;
        }
        state.leftShift += xWidthL;
        state.rightShift += xWidthR;
        return true;
    }
    constructor(number) {
        super();
        this.stringNumber = number;
        this.position = _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.ABOVE; // Default position above stem or note head
        this.xShift = 0;
        this.yShift = 0;
        this.textLine = 0;
        this.stemOffset = 0;
        this.xOffset = 0; // Horizontal offset from default
        this.yOffset = 0; // Vertical offset from default
        this.dashed = true; // true - draw dashed extension  false - no extension
        this.leg = _renderer__WEBPACK_IMPORTED_MODULE_2__.Renderer.LineEndType.NONE; // draw upward/downward leg at the of extension line
        this.radius = 8;
        this.drawCircle = true;
        this.setWidth(this.radius * 2 + 4);
    }
    setLineEndType(leg) {
        if (leg >= _renderer__WEBPACK_IMPORTED_MODULE_2__.Renderer.LineEndType.NONE && leg <= _renderer__WEBPACK_IMPORTED_MODULE_2__.Renderer.LineEndType.DOWN) {
            this.leg = leg;
        }
        return this;
    }
    setStringNumber(number) {
        this.stringNumber = number;
        return this;
    }
    setOffsetX(x) {
        this.xOffset = x;
        return this;
    }
    setOffsetY(y) {
        this.yOffset = y;
        return this;
    }
    setLastNote(note) {
        this.lastNote = note;
        return this;
    }
    setDashed(dashed) {
        this.dashed = dashed;
        return this;
    }
    setDrawCircle(drawCircle) {
        this.drawCircle = drawCircle;
        return this;
    }
    draw() {
        const ctx = this.checkContext();
        const note = this.checkAttachedNote();
        this.setRendered();
        const start = note.getModifierStartXY(this.position, this.index);
        const stemDirection = note.hasStem() ? note.getStemDirection() : _stem__WEBPACK_IMPORTED_MODULE_3__.Stem.UP;
        let dotX = start.x + this.xShift + this.xOffset;
        let stemExt = {};
        if (note.hasStem()) {
            stemExt = note.checkStem().getExtents();
        }
        let dotY = start.y + this.yShift + this.yOffset;
        switch (this.position) {
            case _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.ABOVE:
                {
                    const ys = note.getYs();
                    dotY = ys.reduce((a, b) => (a < b ? a : b));
                    if (note.hasStem() && stemDirection === _stem__WEBPACK_IMPORTED_MODULE_3__.Stem.UP) {
                        dotY = stemExt.topY + _metrics__WEBPACK_IMPORTED_MODULE_0__.Metrics.get('StringNumber.stemPadding');
                    }
                    dotY -=
                        this.radius +
                            _metrics__WEBPACK_IMPORTED_MODULE_0__.Metrics.get('StringNumber.verticalPadding') +
                            this.textLine * _tables__WEBPACK_IMPORTED_MODULE_4__.Tables.STAVE_LINE_DISTANCE;
                }
                break;
            case _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.BELOW:
                {
                    const ys = note.getYs();
                    dotY = ys.reduce((a, b) => (a > b ? a : b));
                    if (note.hasStem() && stemDirection === _stem__WEBPACK_IMPORTED_MODULE_3__.Stem.DOWN) {
                        dotY = stemExt.topY - _metrics__WEBPACK_IMPORTED_MODULE_0__.Metrics.get('StringNumber.stemPadding');
                    }
                    dotY +=
                        this.radius +
                            _metrics__WEBPACK_IMPORTED_MODULE_0__.Metrics.get('StringNumber.verticalPadding') +
                            this.textLine * _tables__WEBPACK_IMPORTED_MODULE_4__.Tables.STAVE_LINE_DISTANCE;
                }
                break;
            case _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.LEFT:
                dotX -= this.radius / 2 + _metrics__WEBPACK_IMPORTED_MODULE_0__.Metrics.get('StringNumber.leftPadding');
                break;
            case _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.RIGHT:
                dotX += this.radius / 2 + _metrics__WEBPACK_IMPORTED_MODULE_0__.Metrics.get('StringNumber.rightPadding');
                break;
            default:
                throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('InvalidPosition', `The position ${this.position} is invalid`);
        }
        ctx.save();
        if (this.drawCircle) {
            ctx.beginPath();
            ctx.arc(dotX, dotY, this.radius, 0, Math.PI * 2, false);
            ctx.setLineWidth(1.5);
            ctx.stroke();
        }
        ctx.setFont(this.fontInfo);
        const x = dotX - ctx.measureText(this.stringNumber).width / 2;
        ctx.fillText('' + this.stringNumber, x, dotY + 4.5);
        const lastNote = this.lastNote;
        if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_5__.isStemmableNote)(lastNote)) {
            // Only StemmableNote objects have getStemX().
            const end = lastNote.getStemX() - note.getX() + 5;
            ctx.setStrokeStyle('#000000');
            ctx.setLineCap('round');
            ctx.setLineWidth(0.6);
            if (this.dashed) {
                _renderer__WEBPACK_IMPORTED_MODULE_2__.Renderer.drawDashedLine(ctx, dotX + 10, dotY, dotX + end, dotY, [3, 3]);
            }
            else {
                _renderer__WEBPACK_IMPORTED_MODULE_2__.Renderer.drawDashedLine(ctx, dotX + 10, dotY, dotX + end, dotY, [3, 0]);
            }
            let len;
            let pattern;
            switch (this.leg) {
                case _renderer__WEBPACK_IMPORTED_MODULE_2__.Renderer.LineEndType.UP:
                    len = -10;
                    pattern = this.dashed ? [3, 3] : [3, 0];
                    _renderer__WEBPACK_IMPORTED_MODULE_2__.Renderer.drawDashedLine(ctx, dotX + end, dotY, dotX + end, dotY + len, pattern);
                    break;
                case _renderer__WEBPACK_IMPORTED_MODULE_2__.Renderer.LineEndType.DOWN:
                    len = 10;
                    pattern = this.dashed ? [3, 3] : [3, 0];
                    _renderer__WEBPACK_IMPORTED_MODULE_2__.Renderer.drawDashedLine(ctx, dotX + end, dotY, dotX + end, dotY + len, pattern);
                    break;
                default:
                    break;
            }
        }
        ctx.restore();
    }
}


/***/ }),

/***/ "./src/strokes.ts":
/*!************************!*\
  !*** ./src/strokes.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Stroke: () => (/* binding */ Stroke)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./metrics */ "./src/metrics.ts");
/* harmony import */ var _modifier__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifier */ "./src/modifier.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// @author Larry Kuhns
//
// This file implements the `Stroke` class which renders chord strokes
// that can be arpeggiated, brushed, rasquedo, etc.





class Stroke extends _modifier__WEBPACK_IMPORTED_MODULE_2__.Modifier {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_3__.Category.Stroke;
    }
    // Arrange strokes inside `ModifierContext`
    static format(strokes, state) {
        const leftShift = state.leftShift;
        const strokeSpacing = 5;
        if (!strokes || strokes.length === 0)
            return false;
        const strokeList = strokes.map((stroke) => {
            const note = stroke.getNote();
            const index = stroke.checkIndex();
            if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_3__.isStaveNote)(note)) {
                // Only StaveNote objects have getKeyProps().
                const { line } = note.getKeyProps()[index];
                const shift = note.getLeftDisplacedHeadPx();
                return { line, shift, stroke };
            }
            else if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_3__.isTabNote)(note)) {
                // Only TabNote objects have getPositions().
                const { str: string } = note.getPositions()[index];
                return { line: string, shift: 0, stroke };
            }
            else {
                throw new _util__WEBPACK_IMPORTED_MODULE_4__.RuntimeError('Internal', 'Unexpected instance.');
            }
        });
        const strokeShift = leftShift;
        // There can only be one stroke .. if more than one, they overlay each other
        const xShift = strokeList.reduce((xShift, { stroke, shift }) => {
            stroke.setXShift(strokeShift + shift);
            return Math.max(stroke.getWidth() + strokeSpacing, xShift);
        }, 0);
        state.leftShift += xShift;
        return true;
    }
    constructor(type, options) {
        super();
        this.options = Object.assign({ allVoices: true }, options);
        // multi voice - span stroke across all voices if true
        this.allVoices = this.options.allVoices;
        // multi voice - end note of stroke, set in draw()
        this.type = type;
        this.position = _modifier__WEBPACK_IMPORTED_MODULE_2__.Modifier.Position.LEFT;
        this.renderOptions = {
            fontScale: _metrics__WEBPACK_IMPORTED_MODULE_1__.Metrics.get('Stroke.fontSize'),
        };
        this.setXShift(0);
        this.setWidth(10);
    }
    getPosition() {
        return this.position;
    }
    addEndNote(note) {
        this.noteEnd = note;
        return this;
    }
    draw() {
        const ctx = this.checkContext();
        const note = this.checkAttachedNote();
        this.setRendered();
        const start = note.getModifierStartXY(this.position, this.index);
        let yPositions = note.getYs();
        let topY = start.y;
        let botY = start.y;
        const x = start.x - 5;
        const lineSpace = note.checkStave().getSpacingBetweenLines();
        const notes = this.checkModifierContext().getMembers(note.getCategory());
        for (let i = 0; i < notes.length; i++) {
            const note = notes[i];
            if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_3__.isNote)(note)) {
                // Only Note objects have getYs().
                // note is an instance of either StaveNote or TabNote.
                yPositions = note.getYs();
                for (let n = 0; n < yPositions.length; n++) {
                    if (this.note === notes[i] || this.allVoices) {
                        topY = Math.min(topY, yPositions[n]);
                        botY = Math.max(botY, yPositions[n]);
                    }
                }
            }
        }
        let arrow = '';
        let arrowY = 0;
        let textY = 0;
        switch (this.type) {
            case Stroke.Type.BRUSH_DOWN:
            case Stroke.Type.ROLL_DOWN:
            case Stroke.Type.RASQUEDO_DOWN:
                arrow = '\ueb78' /*arrowheadBlackUp*/;
                arrowY = topY;
                topY -= lineSpace / 2;
                botY += lineSpace / 2;
                break;
            case Stroke.Type.BRUSH_UP:
            case Stroke.Type.ROLL_UP:
            case Stroke.Type.RASQUEDO_UP:
                arrow = '\ueb7c' /*arrowheadBlackDown*/;
                arrowY = botY + lineSpace;
                topY -= lineSpace / 2;
                break;
            case Stroke.Type.ARPEGGIO_DIRECTIONLESS:
                topY -= lineSpace / 2;
                botY += lineSpace / 2;
                break;
            default:
                throw new _util__WEBPACK_IMPORTED_MODULE_4__.RuntimeError('InvalidType', `The stroke type ${this.type} does not exist`);
        }
        // Draw the stroke
        if (this.type === Stroke.Type.BRUSH_DOWN || this.type === Stroke.Type.BRUSH_UP) {
            ctx.fillRect(x + this.xShift, topY, 1, botY - topY);
        }
        else {
            // Select the wiggle glyph depending on the arrow direction
            const lineGlyph = arrow === '\ueb7c' /*arrowheadBlackDown*/ ? '\ueaaa' /*wiggleArpeggiatoDown*/ : '\ueaa9'; /*wiggleArpeggiatoUp*/
            let txt = '';
            const el = new _element__WEBPACK_IMPORTED_MODULE_0__.Element();
            // add glyphs until the required length is achieved
            while (el.getWidth() < botY - topY) {
                txt += lineGlyph;
                el.setText(txt);
            }
            if (this.type === Stroke.Type.RASQUEDO_DOWN ||
                this.type === Stroke.Type.ROLL_DOWN ||
                this.type === Stroke.Type.ARPEGGIO_DIRECTIONLESS) {
                ctx.openRotation(90, x + this.xShift, topY);
                el.renderText(ctx, x + this.xShift, topY - el.getTextMetrics().actualBoundingBoxDescent + el.getHeight() / 2);
                ctx.closeRotation();
                textY = topY + el.getWidth() + 5;
            }
            else {
                ctx.openRotation(-90, x + this.xShift, botY);
                el.renderText(ctx, x + this.xShift, botY - el.getTextMetrics().actualBoundingBoxDescent + el.getHeight() / 2);
                ctx.closeRotation();
                textY = botY - el.getWidth() - 5;
            }
        }
        // Draw the arrow head
        if (arrowY !== 0) {
            const el = new _element__WEBPACK_IMPORTED_MODULE_0__.Element();
            el.setText(arrow);
            el.renderText(ctx, 
            // Center the arrow head substracting its width / 2
            x + this.xShift - el.getWidth() / 2, arrowY);
        }
        // Draw the rasquedo "R"
        if (this.type === Stroke.Type.RASQUEDO_DOWN || this.type === Stroke.Type.RASQUEDO_UP) {
            const el = new _element__WEBPACK_IMPORTED_MODULE_0__.Element('Stroke.text');
            el.setText('R');
            el.renderText(ctx, x + this.xShift - el.getWidth() / 2, textY + (this.type === Stroke.Type.RASQUEDO_DOWN ? el.getHeight() : 0));
        }
    }
}
Stroke.Type = {
    BRUSH_DOWN: 1,
    BRUSH_UP: 2,
    ROLL_DOWN: 3,
    ROLL_UP: 4,
    RASQUEDO_DOWN: 5,
    RASQUEDO_UP: 6,
    ARPEGGIO_DIRECTIONLESS: 7, // Arpeggiated chord without upwards or downwards arrow
};


/***/ }),

/***/ "./src/svgcontext.ts":
/*!***************************!*\
  !*** ./src/svgcontext.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SVGContext: () => (/* binding */ SVGContext)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _font__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./font */ "./src/font.ts");
/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./metrics */ "./src/metrics.ts");
/* harmony import */ var _rendercontext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rendercontext */ "./src/rendercontext.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
// @author Gregory Ristow (2015)
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SVGContext_instances, _SVGContext_getShadowStyle;






/** For a particular element type (e.g., rect), we will not apply certain presentation attributes. */
const ATTRIBUTES_TO_IGNORE = {
    path: {
        x: true,
        y: true,
        width: true,
        height: true,
        'font-family': true,
        'font-weight': true,
        'font-style': true,
        'font-size': true,
    },
    rect: {
        'font-family': true,
        'font-weight': true,
        'font-style': true,
        'font-size': true,
    },
    text: {
        width: true,
        height: true,
    },
};
/** Create the SVG in the SVG namespace. */
const SVG_NS = 'http://www.w3.org/2000/svg';
const TWO_PI = 2 * Math.PI;
/**
 * SVG rendering context with an API similar to CanvasRenderingContext2D.
 */
class SVGContext extends _rendercontext__WEBPACK_IMPORTED_MODULE_3__.RenderContext {
    constructor(element) {
        super();
        _SVGContext_instances.add(this);
        this.width = 0;
        this.height = 0;
        this.precision = 1;
        this.backgroundFillStyle = 'white';
        /** Formatted as CSS font shorthand (e.g., 'italic bold 12pt Arial') */
        this.fontCSSString = '';
        this.element = element;
        this.precision = Math.pow(10, _tables__WEBPACK_IMPORTED_MODULE_4__.Tables.RENDER_PRECISION_PLACES);
        // Create a SVG element and add it to the container element.
        const svg = this.create('svg');
        this.element.appendChild(svg);
        this.svg = svg;
        this.parent = this.svg;
        this.groups = [this.svg];
        this.path = '';
        this.pen = { x: NaN, y: NaN };
        this.lineWidth = 1.0;
        const defaultFontAttributes = {
            'font-family': _metrics__WEBPACK_IMPORTED_MODULE_2__.Metrics.get('fontFamily'),
            'font-size': '10pt',
            'font-weight': _font__WEBPACK_IMPORTED_MODULE_1__.FontWeight.NORMAL,
            'font-style': _font__WEBPACK_IMPORTED_MODULE_1__.FontStyle.NORMAL,
        };
        this.state = Object.assign({ scaleX: 1, scaleY: 1 }, defaultFontAttributes);
        this.attributes = Object.assign({ 'stroke-width': 0.3, 'stroke-dasharray': 'none', fill: 'black', stroke: 'black' }, defaultFontAttributes);
        this.groupAttributes = [];
        this.applyAttributes(svg, this.attributes);
        this.groupAttributes.push(Object.assign({}, this.attributes));
        this.shadowAttributes = {
            width: 0,
            color: 'black',
        };
        this.stateStack = [];
    }
    round(n) {
        return Math.round(n * this.precision) / this.precision;
    }
    create(svgElementType) {
        return document.createElementNS(SVG_NS, svgElementType);
    }
    // Allow grouping elements in containers for interactivity.
    openGroup(cls, id, attrs) {
        const group = this.create('g');
        this.groups.push(group);
        this.parent.appendChild(group);
        this.parent = group;
        if (cls)
            group.setAttribute('class', (0,_util__WEBPACK_IMPORTED_MODULE_5__.prefix)(cls));
        if (id)
            group.setAttribute('id', (0,_util__WEBPACK_IMPORTED_MODULE_5__.prefix)(id));
        if (attrs && attrs.pointerBBox) {
            group.setAttribute('pointer-events', 'bounding-box');
        }
        this.applyAttributes(group, this.attributes);
        this.groupAttributes.push(Object.assign(Object.assign({}, this.groupAttributes[this.groupAttributes.length - 1]), this.attributes));
        return group;
    }
    closeGroup() {
        this.groups.pop();
        this.groupAttributes.pop();
        this.parent = this.groups[this.groups.length - 1];
    }
    openRotation(angleDegrees, x, y) {
        this.openGroup().setAttribute('transform', `translate(${x},${y}) rotate(${angleDegrees}) translate(-${x},-${y})`);
    }
    closeRotation() {
        this.closeGroup();
    }
    add(elem) {
        this.parent.appendChild(elem);
    }
    setFillStyle(style) {
        this.attributes.fill = style;
        return this;
    }
    /**
     * Used to set the fill color for `clearRect()`. This allows us to simulate
     * cutting a "hole" into the SVG drawing.
     */
    setBackgroundFillStyle(style) {
        this.backgroundFillStyle = style;
        return this;
    }
    setStrokeStyle(style) {
        this.attributes.stroke = style;
        return this;
    }
    setShadowColor(color) {
        this.shadowAttributes.color = color;
        return this;
    }
    /**
     * @param blur A non-negative float specifying the level of shadow blur, where 0
     *             represents no blur and larger numbers represent increasingly more blur.
     * @returns this
     */
    setShadowBlur(blur) {
        this.shadowAttributes.width = blur;
        return this;
    }
    /**
     * @param width
     * @returns this
     */
    setLineWidth(width) {
        this.attributes['stroke-width'] = width;
        this.lineWidth = width;
        return this;
    }
    /**
     * @param lineDash an array of integers in the form of [dash, space, dash, space, etc...]
     * @returns this
     *
     * See: [SVG `stroke-dasharray` attribute](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray)
     */
    setLineDash(lineDash) {
        if (Object.prototype.toString.call(lineDash) === '[object Array]') {
            this.attributes['stroke-dasharray'] = lineDash.join(',');
            return this;
        }
        else {
            throw new _util__WEBPACK_IMPORTED_MODULE_5__.RuntimeError('ArgumentError', 'lineDash must be an array of integers.');
        }
    }
    /**
     * @param capType
     * @returns this
     */
    setLineCap(capType) {
        this.attributes['stroke-linecap'] = capType;
        return this;
    }
    // ### Sizing & Scaling Methods:
    // TODO (GCR): See note at scale() -- separate our internal
    // conception of pixel-based width/height from the style.width
    // and style.height properties eventually to allow users to
    // apply responsive sizing attributes to the SVG.
    resize(width, height) {
        this.width = width;
        this.height = height;
        this.element.style.width = width.toString();
        this.svg.style.width = width.toString();
        this.svg.style.height = height.toString();
        const attributes = {
            width,
            height,
        };
        this.applyAttributes(this.svg, attributes);
        this.scale(this.state.scaleX, this.state.scaleY);
        return this;
    }
    scale(x, y) {
        // uses viewBox to scale
        // TODO (GCR): we may at some point want to distinguish the
        // style.width / style.height properties that are applied to
        // the SVG object from our internal conception of the SVG
        // width/height.  This would allow us to create automatically
        // scaling SVG's that filled their containers, for instance.
        //
        // As this isn't implemented in Canvas contexts,
        // I've left as is for now, but in using the viewBox to
        // handle internal scaling, am trying to make it possible
        // for us to eventually move in that direction.
        this.state.scaleX = this.state.scaleX ? this.state.scaleX * x : x;
        this.state.scaleY = this.state.scaleY ? this.state.scaleY * y : y;
        const visibleWidth = this.width / this.state.scaleX;
        const visibleHeight = this.height / this.state.scaleY;
        this.setViewBox(0, 0, visibleWidth, visibleHeight);
        return this;
    }
    /**
     * 1 arg: string in the "x y w h" format
     * 4 args: x:number, y:number, w:number, h:number
     */
    setViewBox(viewBoxOrMinX, minY, width, height) {
        if (typeof viewBoxOrMinX === 'string') {
            this.svg.setAttribute('viewBox', viewBoxOrMinX);
        }
        else {
            const viewBoxString = viewBoxOrMinX + ' ' + minY + ' ' + width + ' ' + height;
            this.svg.setAttribute('viewBox', viewBoxString);
        }
    }
    // ### Drawing helper methods:
    applyAttributes(element, attributes) {
        const attrNamesToIgnore = ATTRIBUTES_TO_IGNORE[element.nodeName];
        for (const attrName in attributes) {
            if (attrNamesToIgnore && attrNamesToIgnore[attrName]) {
                continue;
            }
            if (attributes[attrName] &&
                (this.groupAttributes.length === 0 ||
                    attributes[attrName] != this.groupAttributes[this.groupAttributes.length - 1][attrName]))
                element.setAttributeNS(null, attrName, attributes[attrName]);
        }
        return element;
    }
    // ### Shape & Path Methods:
    clear() {
        // Clear the SVG by removing all inner children.
        // (This approach is usually slightly more efficient
        // than removing the old SVG & adding a new one to
        // the container element, since it does not cause the
        // container to resize twice.  Also, the resize
        // triggered by removing the entire SVG can trigger
        // a touchcancel event when the element resizes away
        // from a touch point.)
        while (this.svg.lastChild) {
            this.svg.removeChild(this.svg.lastChild);
        }
        // Replace the viewbox attribute we just removed.
        this.scale(this.state.scaleX, this.state.scaleY);
    }
    // ## Rectangles:
    rect(x, y, width, height, attributes) {
        // Avoid invalid negative height attributes by flipping the rectangle on its head:
        if (height < 0) {
            y += height;
            height *= -1;
        }
        const rectangle = this.create('rect');
        attributes = attributes !== null && attributes !== void 0 ? attributes : { fill: 'none', 'stroke-width': this.lineWidth, stroke: 'black' };
        x = this.round(x);
        y = this.round(y);
        width = this.round(width);
        height = this.round(height);
        this.applyAttributes(rectangle, Object.assign({ x, y, width, height }, attributes));
        this.add(rectangle);
        return this;
    }
    fillRect(x, y, width, height) {
        const attributes = { fill: this.attributes.fill, stroke: 'none' };
        this.rect(x, y, width, height, attributes);
        return this;
    }
    clearRect(x, y, width, height) {
        // Currently this fills a rect with the backgroundFillStyle, rather
        // than "cut a hole" into the existing shapes.
        //
        // Since tabNote seems to be the only module that makes use of this
        // it may be worth creating a separate tabStave that would
        // draw lines around locations of tablature fingering.
        this.rect(x, y, width, height, { fill: this.backgroundFillStyle, stroke: 'none' });
        return this;
    }
    // ## Paths:
    beginPath() {
        this.path = '';
        this.pen.x = NaN;
        this.pen.y = NaN;
        return this;
    }
    moveTo(x, y) {
        x = this.round(x);
        y = this.round(y);
        this.path += 'M' + x + ' ' + y;
        this.pen.x = x;
        this.pen.y = y;
        return this;
    }
    lineTo(x, y) {
        x = this.round(x);
        y = this.round(y);
        this.path += 'L' + x + ' ' + y;
        this.pen.x = x;
        this.pen.y = y;
        return this;
    }
    bezierCurveTo(x1, y1, x2, y2, x, y) {
        x = this.round(x);
        y = this.round(y);
        x1 = this.round(x1);
        y1 = this.round(y1);
        x2 = this.round(x2);
        y2 = this.round(y2);
        this.path += 'C' + x1 + ' ' + y1 + ',' + x2 + ' ' + y2 + ',' + x + ' ' + y;
        this.pen.x = x;
        this.pen.y = y;
        return this;
    }
    quadraticCurveTo(x1, y1, x, y) {
        x = this.round(x);
        y = this.round(y);
        x1 = this.round(x1);
        y1 = this.round(y1);
        this.path += 'Q' + x1 + ' ' + y1 + ',' + x + ' ' + y;
        this.pen.x = x;
        this.pen.y = y;
        return this;
    }
    arc(x, y, radius, startAngle, endAngle, counterclockwise) {
        let x0 = x + radius * Math.cos(startAngle);
        let y0 = y + radius * Math.sin(startAngle);
        x0 = this.round(x0);
        y0 = this.round(y0);
        // svg behavior different from canvas.  Don't normalize angles if
        // we are drawing a circle because they both normalize to 0
        const tmpStartTest = (0,_util__WEBPACK_IMPORTED_MODULE_5__.normalizeAngle)(startAngle);
        const tmpEndTest = (0,_util__WEBPACK_IMPORTED_MODULE_5__.normalizeAngle)(endAngle);
        if ((!counterclockwise && endAngle - startAngle >= TWO_PI) ||
            (counterclockwise && startAngle - endAngle >= TWO_PI) ||
            tmpStartTest === tmpEndTest) {
            let x1 = x + radius * Math.cos(startAngle + Math.PI);
            let y1 = y + radius * Math.sin(startAngle + Math.PI);
            // There's no way to specify a completely circular arc in SVG so we have to
            // use two semi-circular arcs.
            x1 = this.round(x1);
            y1 = this.round(y1);
            radius = this.round(radius);
            this.path += `M${x0} ${y0} A${radius} ${radius} 0 0 0 ${x1} ${y1} `;
            this.path += `A${radius} ${radius} 0 0 0 ${x0} ${y0}`;
            this.pen.x = x0;
            this.pen.y = y0;
        }
        else {
            let x1 = x + radius * Math.cos(endAngle);
            let y1 = y + radius * Math.sin(endAngle);
            startAngle = tmpStartTest;
            endAngle = tmpEndTest;
            let large;
            if (Math.abs(endAngle - startAngle) < Math.PI) {
                large = counterclockwise;
            }
            else {
                large = !counterclockwise;
            }
            if (startAngle > endAngle) {
                large = !large;
            }
            const sweep = !counterclockwise;
            x1 = this.round(x1);
            y1 = this.round(y1);
            radius = this.round(radius);
            this.path += `M${x0} ${y0} A${radius} ${radius} 0 ${+large} ${+sweep} ${x1} ${y1}`;
            this.pen.x = x1;
            this.pen.y = y1;
        }
        return this;
    }
    closePath() {
        this.path += 'Z';
        return this;
    }
    fill(attributes) {
        const path = this.create('path');
        if (typeof attributes === 'undefined') {
            attributes = Object.assign(Object.assign({}, this.attributes), { stroke: 'none' });
        }
        attributes.d = this.path;
        if (this.shadowAttributes.width > 0) {
            attributes.style = __classPrivateFieldGet(this, _SVGContext_instances, "m", _SVGContext_getShadowStyle).call(this);
        }
        this.applyAttributes(path, attributes);
        this.add(path);
        return this;
    }
    stroke() {
        const path = this.create('path');
        const attributes = Object.assign(Object.assign({}, this.attributes), { fill: 'none', 'stroke-width': this.lineWidth, d: this.path });
        if (this.shadowAttributes.width > 0) {
            attributes.style = __classPrivateFieldGet(this, _SVGContext_instances, "m", _SVGContext_getShadowStyle).call(this);
        }
        this.applyAttributes(path, attributes);
        this.add(path);
        return this;
    }
    // ## Text Methods:
    measureText(text) {
        SVGContext.measureTextElement.setText(text);
        SVGContext.measureTextElement.setFont(this.attributes['font-family'], this.attributes['font-size'], this.attributes['font-weight'], this.attributes['font-style']);
        const bb = SVGContext.measureTextElement.getBoundingBox();
        return { x: bb.x, y: bb.y, width: bb.w, height: bb.h };
    }
    fillText(text, x, y) {
        if (!text || text.length <= 0) {
            return this;
        }
        x = this.round(x);
        y = this.round(y);
        const attributes = Object.assign(Object.assign({}, this.attributes), { stroke: 'none', x,
            y });
        const txt = this.create('text');
        txt.textContent = text;
        this.applyAttributes(txt, attributes);
        this.add(txt);
        return this;
    }
    // TODO: State should be deep-copied.
    save() {
        this.stateStack.push({
            state: {
                'font-family': this.state['font-family'],
                'font-weight': this.state['font-weight'],
                'font-style': this.state['font-style'],
                'font-size': this.state['font-size'],
                scale: this.state.scale,
            },
            attributes: {
                'font-family': this.attributes['font-family'],
                'font-weight': this.attributes['font-weight'],
                'font-style': this.attributes['font-style'],
                'font-size': this.attributes['font-size'],
                fill: this.attributes.fill,
                stroke: this.attributes.stroke,
                'stroke-width': this.attributes['stroke-width'],
                'stroke-dasharray': this.attributes['stroke-dasharray'],
            },
            shadowAttributes: {
                width: this.shadowAttributes.width,
                color: this.shadowAttributes.color,
            },
            lineWidth: this.lineWidth,
        });
        return this;
    }
    // TODO: State should be deep-restored.
    restore() {
        const savedState = this.stateStack.pop();
        if (savedState) {
            const state = savedState;
            this.state['font-family'] = state.state['font-family'];
            this.state['font-weight'] = state.state['font-weight'];
            this.state['font-style'] = state.state['font-style'];
            this.state['font-size'] = state.state['font-size'];
            this.state.scale = state.state.scale;
            this.attributes['font-family'] = state.attributes['font-family'];
            this.attributes['font-weight'] = state.attributes['font-weight'];
            this.attributes['font-style'] = state.attributes['font-style'];
            this.attributes['font-size'] = state.attributes['font-size'];
            this.attributes.fill = state.attributes.fill;
            this.attributes.stroke = state.attributes.stroke;
            this.attributes['stroke-width'] = state.attributes['stroke-width'];
            this.attributes['stroke-dasharray'] = state.attributes['stroke-dasharray'];
            this.shadowAttributes.width = state.shadowAttributes.width;
            this.shadowAttributes.color = state.shadowAttributes.color;
            this.lineWidth = state.lineWidth;
        }
        return this;
    }
    set fillStyle(style) {
        this.setFillStyle(style);
    }
    get fillStyle() {
        return this.attributes.fill;
    }
    set strokeStyle(style) {
        this.setStrokeStyle(style);
    }
    get strokeStyle() {
        return this.attributes.stroke;
    }
    /**
     * @param f is 1) a `FontInfo` object or
     *             2) a string formatted as CSS font shorthand (e.g., 'bold 10pt Arial') or
     *             3) a string representing the font family (one of `size`, `weight`, or `style` must also be provided).
     * @param size a string specifying the font size and unit (e.g., '16pt'), or a number (the unit is assumed to be 'pt').
     * @param weight is a string (e.g., 'bold', 'normal') or a number (100, 200, ... 900). It is inserted
     *               into the font-weight attribute (e.g., font-weight="bold")
     * @param style is a string (e.g., 'italic', 'normal') that is inserted into the
     *              font-style attribute (e.g., font-style="italic")
     */
    setFont(f, size, weight, style) {
        const fontInfo = _font__WEBPACK_IMPORTED_MODULE_1__.Font.validate(f, size, weight, style);
        this.fontCSSString = _font__WEBPACK_IMPORTED_MODULE_1__.Font.toCSSString(fontInfo);
        const fontAttributes = {
            'font-family': fontInfo.family,
            'font-size': fontInfo.size,
            'font-weight': fontInfo.weight,
            'font-style': fontInfo.style,
        };
        this.attributes = Object.assign(Object.assign({}, this.attributes), fontAttributes);
        this.state = Object.assign(Object.assign({}, this.state), fontAttributes);
        return this;
    }
    /** Return a string of the form `'italic bold 15pt Arial'` */
    getFont() {
        return this.fontCSSString;
    }
}
_SVGContext_instances = new WeakSet(), _SVGContext_getShadowStyle = function _SVGContext_getShadowStyle() {
    const sa = this.shadowAttributes;
    // A CSS drop-shadow filter blur looks different than a canvas shadowBlur
    // of the same radius, so we scale the drop-shadow radius here to make it
    // look close to the canvas shadow.
    return `filter: drop-shadow(0 0 ${sa.width / 1.5}px ${sa.color})`;
};
SVGContext.measureTextElement = new _element__WEBPACK_IMPORTED_MODULE_0__.Element();


/***/ }),

/***/ "./src/system.ts":
/*!***********************!*\
  !*** ./src/system.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   System: () => (/* binding */ System)
/* harmony export */ });
/* harmony import */ var _boundingbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boundingbox */ "./src/boundingbox.ts");
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatter */ "./src/formatter.ts");
/* harmony import */ var _note__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./note */ "./src/note.ts");
/* harmony import */ var _stave__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stave */ "./src/stave.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License







/**
 * System implements a musical system, which is a collection of staves,
 * each which can have one or more voices. All voices across all staves in
 * the system are formatted together.
 */
class System extends _element__WEBPACK_IMPORTED_MODULE_1__.Element {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_5__.Category.System;
    }
    constructor(params = {}) {
        super();
        this.setOptions(params);
        this.partStaves = [];
        this.partStaveInfos = [];
        this.partVoices = [];
    }
    /** Set formatting options. */
    setOptions(options = {}) {
        if (!options.factory) {
            throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('NoFactory', 'System.setOptions(options) requires a factory.');
        }
        this.factory = options.factory;
        this.options = Object.assign(Object.assign({ factory: this.factory, x: 10, y: 10, width: 500, spaceBetweenStaves: 12, autoWidth: false, noJustification: false, debugFormatter: false, formatIterations: 0, noPadding: false }, options), { details: Object.assign({ alpha: 0.5 }, options.details), formatOptions: Object.assign({}, options.formatOptions) });
        if (this.options.noJustification === false && typeof options.width === 'undefined') {
            this.options.autoWidth = true;
        }
    }
    /** Get origin X. */
    getX() {
        return this.options.x;
    }
    /** Set origin X. */
    setX(x) {
        this.options.x = x;
        this.partStaves.forEach((s) => {
            s.setX(x);
        });
        return this;
    }
    /** Get origin y. */
    getY() {
        return this.options.y;
    }
    /** Set origin y. */
    setY(y) {
        this.options.y = y;
        this.partStaves.forEach((s) => {
            s.setY(y);
        });
        return this;
    }
    /** Get associated staves. */
    getStaves() {
        return this.partStaves;
    }
    /** Get associated voices. */
    getVoices() {
        return this.partVoices;
    }
    /** Set associated context. */
    setContext(context) {
        super.setContext(context);
        this.factory.setContext(context);
        return this;
    }
    /**
     * Add connector between staves.
     * @param type see {@link StaveConnector.typeString}
     */
    addConnector(type = 'double') {
        this.connector = this.factory.StaveConnector({
            topStave: this.partStaves[0],
            bottomStave: this.partStaves[this.partStaves.length - 1],
            type,
        });
        return this.connector;
    }
    /**
     * Add a stave to the system.
     *
     * Example (one voice):
     *
     * `system.addStave({voices: [score.voice(score.notes('C#5/q, B4, A4, G#4'))]});`
     *
     * Example (two voices):
     *
     * `system.addStave({voices: [`
     *   `score.voice(score.notes('C#5/q, B4, A4, G#4', {stem: 'up'})),`
     *   `score.voice(score.notes('C#4/h, C#4', {stem: 'down'}))`
     * `]});`
     */
    addStave(params) {
        var _a;
        const staveOptions = Object.assign({ leftBar: false }, params.options);
        const stave = (_a = params.stave) !== null && _a !== void 0 ? _a : this.factory.Stave({ x: this.options.x, y: this.options.y, width: this.options.width, options: staveOptions });
        const p = Object.assign(Object.assign({ spaceAbove: 0, spaceBelow: 0, debugNoteMetrics: false, noJustification: false }, params), { options: staveOptions });
        const ctx = this.getContext();
        p.voices.forEach((voice) => {
            voice
                .setContext(ctx)
                .setStave(stave)
                .getTickables()
                .forEach((tickable) => tickable.setStave(stave));
            this.partVoices.push(voice);
        });
        this.partStaves.push(stave);
        this.partStaveInfos.push(p);
        return stave;
    }
    /**
     * Add voices to the system with stave already assigned.
     */
    addVoices(voices) {
        const ctx = this.getContext();
        voices.forEach((voice) => {
            voice.setContext(ctx);
            this.partVoices.push(voice);
        });
    }
    /** Format the system. */
    format() {
        const optionsDetails = this.options.details;
        let justifyWidth = 0;
        const formatter = new _formatter__WEBPACK_IMPORTED_MODULE_2__.Formatter(optionsDetails);
        this.formatter = formatter;
        let y = this.options.y;
        let startX = 0;
        const debugNoteMetricsYs = [];
        this.partStaves.forEach((part, index) => {
            y = y + part.space(this.partStaveInfos[index].spaceAbove);
            part.setY(y);
            y = y + part.space(this.partStaveInfos[index].spaceBelow);
            y = y + part.space(this.options.spaceBetweenStaves);
            if (this.partStaveInfos[index].debugNoteMetrics) {
                debugNoteMetricsYs.push({ y, stave: part });
                y += 15;
            }
            startX = Math.max(startX, part.getNoteStartX());
        });
        // Re-assign Stave to update y position
        this.partVoices.forEach((voice) => {
            voice.getTickables().forEach((tickable) => {
                const stave = tickable.getStave();
                if (stave)
                    tickable.setStave(stave);
            });
        });
        // Join the voices
        formatter.joinVoices(this.partVoices);
        // Update the start position of all staves.
        this.partStaves.forEach((part) => part.setNoteStartX(startX));
        if (this.options.autoWidth && this.partVoices.length > 0) {
            justifyWidth = formatter.preCalculateMinTotalWidth(this.partVoices);
            this.options.width = justifyWidth + _stave__WEBPACK_IMPORTED_MODULE_4__.Stave.rightPadding + (startX - this.options.x);
            this.partStaves.forEach((part) => {
                part.setWidth(this.options.width);
            });
        }
        else {
            justifyWidth = this.options.noPadding
                ? this.options.width - (startX - this.options.x)
                : this.options.width - (startX - this.options.x) - _stave__WEBPACK_IMPORTED_MODULE_4__.Stave.defaultPadding;
        }
        if (this.partVoices.length > 0) {
            formatter.format(this.partVoices, this.options.noJustification ? 0 : justifyWidth, this.options.formatOptions);
        }
        formatter.postFormat();
        for (let i = 0; i < this.options.formatIterations; i++) {
            formatter.tune(optionsDetails);
        }
        this.startX = startX;
        this.debugNoteMetricsYs = debugNoteMetricsYs;
        this.lastY = y;
        _stave__WEBPACK_IMPORTED_MODULE_4__.Stave.formatBegModifiers(this.partStaves);
    }
    /** Get the boundingBox. */
    getBoundingBox() {
        var _a;
        return new _boundingbox__WEBPACK_IMPORTED_MODULE_0__.BoundingBox(this.options.x, this.options.y, this.options.width, ((_a = this.lastY) !== null && _a !== void 0 ? _a : 0) - this.options.y);
    }
    /** Render the system. */
    draw() {
        // Render debugging information, if requested.
        const ctx = this.checkContext();
        if (!this.formatter || !this.startX || !this.lastY || !this.debugNoteMetricsYs) {
            throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('NoFormatter', 'format() must be called before draw()');
        }
        this.setRendered();
        if (this.options.debugFormatter) {
            _formatter__WEBPACK_IMPORTED_MODULE_2__.Formatter.plotDebugging(ctx, this.formatter, this.startX, this.options.y, this.lastY);
        }
        this.debugNoteMetricsYs.forEach((d) => {
            this.partVoices.forEach((voice) => {
                voice.getTickables().forEach((tickable) => {
                    if (tickable.getStave() === d.stave)
                        _note__WEBPACK_IMPORTED_MODULE_3__.Note.plotMetrics(ctx, tickable, d.y);
                });
            });
        });
    }
}


/***/ }),

/***/ "./src/tables.ts":
/*!***********************!*\
  !*** ./src/tables.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tables: () => (/* binding */ Tables)
/* harmony export */ });
/* harmony import */ var _fraction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fraction */ "./src/fraction.ts");
/* harmony import */ var _glyphs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./glyphs */ "./src/glyphs.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors



const RESOLUTION = 16384;
/**
 * Map duration numbers to 'ticks', the unit of duration used throughout VexFlow.
 * For example, a quarter note is 4, so it maps to RESOLUTION / 4 = 4096 ticks.
 */
const durations = {
    '1/2': RESOLUTION * 2,
    1: RESOLUTION / 1,
    2: RESOLUTION / 2,
    4: RESOLUTION / 4,
    8: RESOLUTION / 8,
    16: RESOLUTION / 16,
    32: RESOLUTION / 32,
    64: RESOLUTION / 64,
    128: RESOLUTION / 128,
    256: RESOLUTION / 256,
};
const durationAliases = {
    w: '1',
    h: '2',
    q: '4',
    // This is the default duration used to render bars (BarNote). Bars no longer
    // consume ticks, so this should be a no-op.
    // TODO(0xfe): This needs to be cleaned up.
    b: '256',
};
const keySignatures = {
    C: { num: 0 },
    Am: { num: 0 },
    F: { accidental: 'b', num: 1 },
    Dm: { accidental: 'b', num: 1 },
    Bb: { accidental: 'b', num: 2 },
    Gm: { accidental: 'b', num: 2 },
    Eb: { accidental: 'b', num: 3 },
    Cm: { accidental: 'b', num: 3 },
    Ab: { accidental: 'b', num: 4 },
    Fm: { accidental: 'b', num: 4 },
    Db: { accidental: 'b', num: 5 },
    Bbm: { accidental: 'b', num: 5 },
    Gb: { accidental: 'b', num: 6 },
    Ebm: { accidental: 'b', num: 6 },
    Cb: { accidental: 'b', num: 7 },
    Abm: { accidental: 'b', num: 7 },
    G: { accidental: '#', num: 1 },
    Em: { accidental: '#', num: 1 },
    D: { accidental: '#', num: 2 },
    Bm: { accidental: '#', num: 2 },
    A: { accidental: '#', num: 3 },
    'F#m': { accidental: '#', num: 3 },
    E: { accidental: '#', num: 4 },
    'C#m': { accidental: '#', num: 4 },
    B: { accidental: '#', num: 5 },
    'G#m': { accidental: '#', num: 5 },
    'F#': { accidental: '#', num: 6 },
    'D#m': { accidental: '#', num: 6 },
    'C#': { accidental: '#', num: 7 },
    'A#m': { accidental: '#', num: 7 },
};
const clefs = {
    treble: { lineShift: 0 },
    bass: { lineShift: 6 },
    tenor: { lineShift: 4 },
    alto: { lineShift: 3 },
    soprano: { lineShift: 1 },
    percussion: { lineShift: 0 },
    'mezzo-soprano': { lineShift: 2 },
    'baritone-c': { lineShift: 5 },
    'baritone-f': { lineShift: 5 },
    subbass: { lineShift: 7 },
    french: { lineShift: -1 },
};
const notesInfo = {
    C: { index: 0, intVal: 0 },
    CN: { index: 0, intVal: 0 },
    'C#': { index: 0, intVal: 1 },
    'C##': { index: 0, intVal: 2 },
    CB: { index: 0, intVal: 11 },
    CBB: { index: 0, intVal: 10 },
    D: { index: 1, intVal: 2 },
    DN: { index: 1, intVal: 2 },
    'D#': { index: 1, intVal: 3 },
    'D##': { index: 1, intVal: 4 },
    DB: { index: 1, intVal: 1 },
    DBB: { index: 1, intVal: 0 },
    E: { index: 2, intVal: 4 },
    EN: { index: 2, intVal: 4 },
    'E#': { index: 2, intVal: 5 },
    'E##': { index: 2, intVal: 6 },
    EB: { index: 2, intVal: 3 },
    EBB: { index: 2, intVal: 2 },
    F: { index: 3, intVal: 5 },
    FN: { index: 3, intVal: 5 },
    'F#': { index: 3, intVal: 6 },
    'F##': { index: 3, intVal: 7 },
    FB: { index: 3, intVal: 4 },
    FBB: { index: 3, intVal: 3 },
    G: { index: 4, intVal: 7 },
    GN: { index: 4, intVal: 7 },
    'G#': { index: 4, intVal: 8 },
    'G##': { index: 4, intVal: 9 },
    GB: { index: 4, intVal: 6 },
    GBB: { index: 4, intVal: 5 },
    A: { index: 5, intVal: 9 },
    AN: { index: 5, intVal: 9 },
    'A#': { index: 5, intVal: 10 },
    'A##': { index: 5, intVal: 11 },
    AB: { index: 5, intVal: 8 },
    ABB: { index: 5, intVal: 7 },
    B: { index: 6, intVal: 11 },
    BN: { index: 6, intVal: 11 },
    'B#': { index: 6, intVal: 12 },
    'B##': { index: 6, intVal: 13 },
    BB: { index: 6, intVal: 10 },
    BBB: { index: 6, intVal: 9 },
    R: { index: 6 },
    X: { index: 6 },
};
const validNoteTypes = {
    n: { name: 'note' },
    r: { name: 'rest' },
    h: { name: 'harmonic' },
    m: { name: 'muted' },
    s: { name: 'slash' },
    g: { name: 'ghost' },
    d: { name: 'diamond' },
    x: { name: 'x' },
    ci: { name: 'circled' },
    cx: { name: 'circle x' },
    sf: { name: 'slashed' },
    sb: { name: 'slashed backward' },
    sq: { name: 'square' },
    tu: { name: 'triangle up' },
    td: { name: 'triangle down' },
};
const accidentals = {
    '#': '\ue262' /*accidentalSharp*/,
    '##': '\ue263' /*accidentalDoubleSharp*/,
    b: '\ue260' /*accidentalFlat*/,
    bb: '\ue264' /*accidentalDoubleFlat*/,
    n: '\ue261' /*accidentalNatural*/,
    '{': '\ue26a' /*accidentalParensLeft*/,
    '}': '\ue26b' /*accidentalParensRight*/,
    db: '\ue281' /*accidentalThreeQuarterTonesFlatZimmermann*/,
    d: '\ue280' /*accidentalQuarterToneFlatStein*/,
    '++': '\ue283' /*accidentalThreeQuarterTonesSharpStein*/,
    '+': '\ue282' /*accidentalQuarterToneSharpStein*/,
    '+-': '\ue446' /*accidentalKucukMucennebSharp*/,
    bs: '\ue442' /*accidentalBakiyeFlat*/,
    bss: '\ue440' /*accidentalBuyukMucennebFlat*/,
    o: '\ue461' /*accidentalSori*/,
    k: '\ue460' /*accidentalKoron*/,
    bbs: '\ue447' /*accidentalBuyukMucennebSharp*/,
    '++-': '\ue447' /*accidentalBuyukMucennebSharp*/,
    ashs: '\ue447' /*accidentalBuyukMucennebSharp*/,
    afhf: '\ue447' /*accidentalBuyukMucennebSharp*/,
};
// Helps determine the layout of accidentals.
const accidentalColumns = {
    1: {
        a: [1],
        b: [1],
    },
    2: {
        a: [1, 2],
    },
    3: {
        a: [1, 3, 2],
        b: [1, 2, 1],
        secondOnBottom: [1, 2, 3],
    },
    4: {
        a: [1, 3, 4, 2],
        b: [1, 2, 3, 1],
        spacedOutTetrachord: [1, 2, 1, 2],
    },
    5: {
        a: [1, 3, 5, 4, 2],
        b: [1, 2, 4, 3, 1],
        spacedOutPentachord: [1, 2, 3, 2, 1],
        verySpacedOutPentachord: [1, 2, 1, 2, 1],
    },
    6: {
        a: [1, 3, 5, 6, 4, 2],
        b: [1, 2, 4, 5, 3, 1],
        spacedOutHexachord: [1, 3, 2, 1, 3, 2],
        verySpacedOutHexachord: [1, 2, 1, 2, 1, 2],
    },
};
const articulations = {
    'a.': { code: '\ue1e7' /*augmentationDot*/, betweenLines: true },
    av: {
        aboveCode: '\ue4a6' /*articStaccatissimoAbove*/,
        belowCode: '\ue4a7' /*articStaccatissimoBelow*/,
        betweenLines: true,
    },
    'a>': {
        aboveCode: '\ue4a0' /*articAccentAbove*/,
        belowCode: '\ue4a1' /*articAccentBelow*/,
        betweenLines: true,
    },
    'a-': {
        aboveCode: '\ue4a4' /*articTenutoAbove*/,
        belowCode: '\ue4a5' /*articTenutoBelow*/,
        betweenLines: true,
    },
    'a^': {
        aboveCode: '\ue4ac' /*articMarcatoAbove*/,
        belowCode: '\ue4ad' /*articMarcatoBelow*/,
        betweenLines: false,
    },
    'a+': { code: '\ue633' /*pluckedLeftHandPizzicato*/, betweenLines: false },
    ao: {
        aboveCode: '\ue631' /*pluckedSnapPizzicatoAbove*/,
        belowCode: '\ue630' /*pluckedSnapPizzicatoBelow*/,
        betweenLines: false,
    },
    ah: { code: '\ue614' /*stringsHarmonic*/, betweenLines: false },
    'a@': { aboveCode: '\ue4c0' /*fermataAbove*/, belowCode: '\ue4c1' /*fermataBelow*/, betweenLines: false },
    'a@a': { code: '\ue4c0' /*fermataAbove*/, betweenLines: false },
    'a@u': { code: '\ue4c1' /*fermataBelow*/, betweenLines: false },
    'a@s': { aboveCode: '\ue4c4' /*fermataShortAbove*/, belowCode: '\ue4c5' /*fermataShortBelow*/, betweenLines: false },
    'a@as': { code: '\ue4c4' /*fermataShortAbove*/, betweenLines: false },
    'a@us': { code: '\ue4c5' /*fermataShortBelow*/, betweenLines: false },
    'a@l': { aboveCode: '\ue4c6' /*fermataLongAbove*/, belowCode: '\ue4c7' /*fermataLongBelow*/, betweenLines: false },
    'a@al': { code: '\ue4c6' /*fermataLongAbove*/, betweenLines: false },
    'a@ul': { code: '\ue4c7' /*fermataLongBelow*/, betweenLines: false },
    'a@vl': {
        aboveCode: '\ue4c8' /*fermataVeryLongAbove*/,
        belowCode: '\ue4c9' /*fermataVeryLongBelow*/,
        betweenLines: false,
    },
    'a@avl': { code: '\ue4c8' /*fermataVeryLongAbove*/, betweenLines: false },
    'a@uvl': { code: '\ue4c9' /*fermataVeryLongBelow*/, betweenLines: false },
    'a|': { code: '\ue612' /*stringsUpBow*/, betweenLines: false },
    am: { code: '\ue610' /*stringsDownBow*/, betweenLines: false },
    'a,': { code: '\ue805' /*pictChokeCymbal*/, betweenLines: false }, // Choked
};
const ornaments = {
    mordent: '\ue56c' /*ornamentShortTrill*/,
    mordentInverted: '\ue56d' /*ornamentMordent*/,
    turn: '\ue567' /*ornamentTurn*/,
    turnInverted: '\ue569' /*ornamentTurnSlash*/,
    tr: '\ue566' /*ornamentTrill*/,
    upprall: '\ue5b5' /*ornamentPrecompSlideTrillDAnglebert*/,
    downprall: '\ue5c3' /*ornamentPrecompDoubleCadenceUpperPrefix*/,
    prallup: '\ue5bb' /*ornamentPrecompTrillSuffixDandrieu*/,
    pralldown: '\ue5c8' /*ornamentPrecompTrillLowerSuffix*/,
    upmordent: '\ue5b8' /*ornamentPrecompSlideTrillBach*/,
    downmordent: '\ue5c4' /*ornamentPrecompDoubleCadenceUpperPrefixTurn*/,
    lineprall: '\ue5b2' /*ornamentPrecompAppoggTrill*/,
    prallprall: '\ue56e' /*ornamentTremblement*/,
    scoop: '\ue5d0' /*brassScoop*/,
    doit: '\ue5d5' /*brassDoitMedium*/,
    fall: '\ue5d7' /*brassFallLipShort*/,
    doitLong: '\ue5d2' /*brassLiftMedium*/,
    fallLong: '\ue5de' /*brassFallRoughMedium*/,
    bend: '\ue5e3' /*brassBend*/,
    plungerClosed: '\ue5e5' /*brassMuteClosed*/,
    plungerOpen: '\ue5e7' /*brassMuteOpen*/,
    flip: '\ue5e1' /*brassFlip*/,
    jazzTurn: '\ue5e4' /*brassJazzTurn*/,
    smear: '\ue5e2' /*brassSmear*/,
};
class Tables {
    /**
     * @returns the `Font` object at the head of the music font stack.
     */
    static currentMusicFont() {
        if (Tables.MUSIC_FONT_STACK.length === 0) {
            throw new _util__WEBPACK_IMPORTED_MODULE_2__.RuntimeError('NoFonts', 'The font stack is empty. See: await Flow.fetchMusicFont(...); Flow.setMusicFont(...).');
        }
        else {
            return Tables.MUSIC_FONT_STACK[0];
        }
    }
    static clefProperties(clef) {
        if (!clef || !(clef in clefs))
            throw new _util__WEBPACK_IMPORTED_MODULE_2__.RuntimeError('BadArgument', 'Invalid clef: ' + clef);
        return clefs[clef];
    }
    /**
     * @param keyOctaveGlyph a string in the format "key/octave" (e.g., "c/5") or "key/octave/custom-note-head-code" (e.g., "g/5/t3").
     * @param clef
     * @param params a struct with one option, `octaveShift` for clef ottavation (0 = default; 1 = 8va; -1 = 8vb, etc.).
     * @returns properties for the specified note.
     */
    static keyProperties(keyOctaveGlyph, clef = 'treble', type = 'N', params) {
        let options = { octaveShift: 0, duration: '4' };
        if (typeof params === 'object') {
            options = Object.assign(Object.assign({}, options), params);
        }
        const duration = Tables.sanitizeDuration(options.duration);
        const pieces = keyOctaveGlyph.split('/');
        if (pieces.length < 2) {
            throw new _util__WEBPACK_IMPORTED_MODULE_2__.RuntimeError('BadArguments', `First argument must be note/octave or note/octave/glyph-code: ${keyOctaveGlyph}`);
        }
        const key = pieces[0].toUpperCase();
        type = type.toUpperCase();
        const value = notesInfo[key];
        if (!value)
            throw new _util__WEBPACK_IMPORTED_MODULE_2__.RuntimeError('BadArguments', 'Invalid key name: ' + key);
        let octave = parseInt(pieces[1], 10);
        // .octaveShift is the shift to compensate for clef 8va/8vb.
        octave -= options.octaveShift;
        const baseIndex = octave * 7 - 4 * 7;
        let line = (baseIndex + value.index) / 2;
        line += Tables.clefProperties(clef).lineShift;
        // Integer value for note arithmetic.
        const intValue = typeof value.intVal !== 'undefined' ? octave * 12 + value.intVal : undefined;
        // If the user specified a glyph, overwrite the glyph code.
        let code = '';
        let glyphName = 'N';
        if (pieces.length > 2 && pieces[2]) {
            glyphName = pieces[2].toUpperCase();
        }
        else if (type !== 'N') {
            glyphName = type;
        }
        else
            glyphName = key;
        code = this.codeNoteHead(glyphName, duration);
        return {
            key,
            octave,
            line,
            intValue,
            code,
            displaced: false,
        };
    }
    static integerToNote(integer) {
        if (typeof integer === 'undefined' || integer < 0 || integer > 11) {
            throw new _util__WEBPACK_IMPORTED_MODULE_2__.RuntimeError('BadArguments', `integerToNote() requires an integer in the range [0, 11]: ${integer}`);
        }
        const table = {
            0: 'C',
            1: 'C#',
            2: 'D',
            3: 'D#',
            4: 'E',
            5: 'F',
            6: 'F#',
            7: 'G',
            8: 'G#',
            9: 'A',
            10: 'A#',
            11: 'B',
        };
        const noteValue = table[integer];
        if (!noteValue) {
            throw new _util__WEBPACK_IMPORTED_MODULE_2__.RuntimeError('BadArguments', `Unknown note value for integer: ${integer}`);
        }
        return noteValue;
    }
    // Used by annotation.ts and bend.ts. Clearly this implementation only works for the default font size.
    // TODO: The actual width depends on the font family, size, weight, style.
    static textWidth(text) {
        return 7 * text.toString().length;
    }
    static articulationCodes(artic) {
        return articulations[artic];
    }
    static accidentalCodes(accidental) {
        var _a;
        return (_a = accidentals[accidental]) !== null && _a !== void 0 ? _a : accidental;
    }
    static ornamentCodes(ornament) {
        var _a;
        return (_a = ornaments[ornament]) !== null && _a !== void 0 ? _a : ornament;
    }
    static keySignature(spec) {
        const keySpec = keySignatures[spec];
        if (!keySpec) {
            throw new _util__WEBPACK_IMPORTED_MODULE_2__.RuntimeError('BadKeySignature', `Bad key signature spec: '${spec}'`);
        }
        if (!keySpec.accidental) {
            return [];
        }
        const accidentalList = {
            b: [2, 0.5, 2.5, 1, 3, 1.5, 3.5],
            '#': [0, 1.5, -0.5, 1, 2.5, 0.5, 2],
        };
        const notes = accidentalList[keySpec.accidental];
        const accList = [];
        for (let i = 0; i < keySpec.num; ++i) {
            const line = notes[i];
            accList.push({ type: keySpec.accidental, line });
        }
        return accList;
    }
    static getKeySignatures() {
        return keySignatures;
    }
    static hasKeySignature(spec) {
        return spec in keySignatures;
    }
    /**
     * Convert duration aliases to the number based duration.
     * If the input isn't an alias, simply return the input.
     * @param duration
     * @returns Example: 'q' -> '4', '8' -> '8'
     */
    static sanitizeDuration(duration) {
        const durationNumber = durationAliases[duration];
        if (durationNumber !== undefined) {
            duration = durationNumber;
        }
        if (durations[duration] === undefined) {
            throw new _util__WEBPACK_IMPORTED_MODULE_2__.RuntimeError('BadArguments', `The provided duration is not valid: ${duration}`);
        }
        return duration;
    }
    /** Convert the `duration` to a fraction. */
    static durationToFraction(duration) {
        return new _fraction__WEBPACK_IMPORTED_MODULE_0__.Fraction().parse(Tables.sanitizeDuration(duration));
    }
    /** Convert the `duration` to a number. */
    static durationToNumber(duration) {
        return Tables.durationToFraction(duration).value();
    }
    /* Convert the `duration` to total ticks. */
    static durationToTicks(duration) {
        duration = Tables.sanitizeDuration(duration);
        const ticks = durations[duration];
        if (ticks === undefined) {
            throw new _util__WEBPACK_IMPORTED_MODULE_2__.RuntimeError('InvalidDuration');
        }
        return ticks;
    }
    static codeNoteHead(type, duration) {
        switch (type) {
            /* Diamond */
            case 'D0':
                return '\ue0d8' /*noteheadDiamondWhole*/;
            case 'D1':
                return '\ue0d9' /*noteheadDiamondHalf*/;
            case 'D2':
                return '\ue0db' /*noteheadDiamondBlack*/;
            case 'D3':
                return '\ue0db' /*noteheadDiamondBlack*/;
            /* Triangle */
            case 'T0':
                return '\ue0bb' /*noteheadTriangleUpWhole*/;
            case 'T1':
                return '\ue0bc' /*noteheadTriangleUpHalf*/;
            case 'T2':
                return '\ue0be' /*noteheadTriangleUpBlack*/;
            case 'T3':
                return '\ue0be' /*noteheadTriangleUpBlack*/;
            /* Cross */
            case 'X0':
                return '\ue0a7' /*noteheadXWhole*/;
            case 'X1':
                return '\ue0a8' /*noteheadXHalf*/;
            case 'X2':
                return '\ue0a9' /*noteheadXBlack*/;
            case 'X3':
                return '\ue0b3' /*noteheadCircleX*/;
            /* Square */
            case 'S1':
                return '\ue0b8' /*noteheadSquareWhite*/;
            case 'S2':
                return '\ue0b9' /*noteheadSquareBlack*/;
            /* Rectangle */
            case 'R1':
                return '\ue0b8' /*noteheadSquareWhite*/; // no smufl code
            case 'R2':
                return '\ue0b8' /*noteheadSquareWhite*/; // no smufl code
            case 'DO':
                return '\ue0be' /*noteheadTriangleUpBlack*/;
            case 'RE':
                return '\ue0cb' /*noteheadMoonBlack*/;
            case 'MI':
                return '\ue0db' /*noteheadDiamondBlack*/;
            case 'FA':
                return '\ue0c0' /*noteheadTriangleLeftBlack*/;
            case 'FAUP':
                return '\ue0c2' /*noteheadTriangleRightBlack*/;
            case 'SO':
                return '\ue0a4' /*noteheadBlack*/;
            case 'LA':
                return '\ue0b9' /*noteheadSquareBlack*/;
            case 'TI':
                return '\ue0cd' /*noteheadTriangleRoundDownBlack*/;
            case 'DI': // Diamond
            case 'H': // Harmonics
                switch (duration) {
                    case '1/2':
                        return '\ue0d7' /*noteheadDiamondDoubleWhole*/;
                    case '1':
                        return '\ue0d8' /*noteheadDiamondWhole*/;
                    case '2':
                        return '\ue0d9' /*noteheadDiamondHalf*/;
                    default:
                        return '\ue0db' /*noteheadDiamondBlack*/;
                }
            case 'X':
            case 'M': // Muted
                switch (duration) {
                    case '1/2':
                        return '\ue0a6' /*noteheadXDoubleWhole*/;
                    case '1':
                        return '\ue0a7' /*noteheadXWhole*/;
                    case '2':
                        return '\ue0a8' /*noteheadXHalf*/;
                    default:
                        return '\ue0a9' /*noteheadXBlack*/;
                }
            case 'CX':
                switch (duration) {
                    case '1/2':
                        return '\ue0b0' /*noteheadCircleXDoubleWhole*/;
                    case '1':
                        return '\ue0b1' /*noteheadCircleXWhole*/;
                    case '2':
                        return '\ue0b2' /*noteheadCircleXHalf*/;
                    default:
                        return '\ue0b3' /*noteheadCircleX*/;
                }
            case 'CI':
                switch (duration) {
                    case '1/2':
                        return '\ue0e7' /*noteheadCircledDoubleWhole*/;
                    case '1':
                        return '\ue0e6' /*noteheadCircledWhole*/;
                    case '2':
                        return '\ue0e5' /*noteheadCircledHalf*/;
                    default:
                        return '\ue0e4' /*noteheadCircledBlack*/;
                }
            case 'SQ':
                switch (duration) {
                    case '1/2':
                        return '\ue0a1' /*noteheadDoubleWholeSquare*/;
                    case '1':
                        return '\ue0b8' /*noteheadSquareWhite*/;
                    case '2':
                        return '\ue0b8' /*noteheadSquareWhite*/;
                    default:
                        return '\ue0b9' /*noteheadSquareBlack*/;
                }
            case 'TU':
                switch (duration) {
                    case '1/2':
                        return '\ue0ba' /*noteheadTriangleUpDoubleWhole*/;
                    case '1':
                        return '\ue0bb' /*noteheadTriangleUpWhole*/;
                    case '2':
                        return '\ue0bc' /*noteheadTriangleUpHalf*/;
                    default:
                        return '\ue0be' /*noteheadTriangleUpBlack*/;
                }
            case 'TD':
                switch (duration) {
                    case '1/2':
                        return '\ue0c3' /*noteheadTriangleDownDoubleWhole*/;
                    case '1':
                        return '\ue0c4' /*noteheadTriangleDownWhole*/;
                    case '2':
                        return '\ue0c5' /*noteheadTriangleDownHalf*/;
                    default:
                        return '\ue0c7' /*noteheadTriangleDownBlack*/;
                }
            case 'SF':
                switch (duration) {
                    case '1/2':
                        return '\ue0d5' /*noteheadSlashedDoubleWhole1*/;
                    case '1':
                        return '\ue0d3' /*noteheadSlashedWhole1*/;
                    case '2':
                        return '\ue0d1' /*noteheadSlashedHalf1*/;
                    default:
                        return '\ue0cf' /*noteheadSlashedBlack1*/;
                }
            case 'SB':
                switch (duration) {
                    case '1/2':
                        return '\ue0d6' /*noteheadSlashedDoubleWhole2*/;
                    case '1':
                        return '\ue0d4' /*noteheadSlashedWhole2*/;
                    case '2':
                        return '\ue0d2' /*noteheadSlashedHalf2*/;
                    default:
                        return '\ue0d0' /*noteheadSlashedBlack2*/;
                }
            case 'R':
                switch (duration) {
                    case '1/2':
                        return '\ue4e2' /*restDoubleWhole*/;
                    case '1':
                        return '\ue4e3' /*restWhole*/;
                    case '2':
                        return '\ue4e4' /*restHalf*/;
                    case '4':
                        return '\ue4e5' /*restQuarter*/;
                    case '8':
                        return '\ue4e6' /*rest8th*/;
                    case '16':
                        return '\ue4e7' /*rest16th*/;
                    case '32':
                        return '\ue4e8' /*rest32nd*/;
                    case '64':
                        return '\ue4e9' /*rest64th*/;
                    case '128':
                        return '\ue4ea' /*rest128th*/;
                }
                break;
            case 'S':
                switch (duration) {
                    case '1/2':
                        return '\ue10a' /*noteheadSlashWhiteDoubleWhole*/;
                    case '1':
                        return '\ue102' /*noteheadSlashWhiteWhole*/;
                    case '2':
                        return '\ue103' /*noteheadSlashWhiteHalf*/;
                    default:
                        return '\ue100' /*noteheadSlashVerticalEnds*/;
                }
            default:
                switch (duration) {
                    case '1/2':
                        return '\ue0a0' /*noteheadDoubleWhole*/;
                    case '1':
                        return '\ue0a2' /*noteheadWhole*/;
                    case '2':
                        return '\ue0a3' /*noteheadHalf*/;
                    default:
                        return '\ue0a4' /*noteheadBlack*/;
                }
        }
        return _glyphs__WEBPACK_IMPORTED_MODULE_1__.Glyphs.null;
    }
}
Tables.UNISON = true;
Tables.SOFTMAX_FACTOR = 10;
Tables.STEM_WIDTH = 1.5;
Tables.STEM_HEIGHT = 35;
Tables.STAVE_LINE_THICKNESS = 1;
Tables.RENDER_PRECISION_PLACES = 3;
Tables.RESOLUTION = RESOLUTION;
// 1/2, 1, 2, 4, 8, 16, 32, 64, 128
// NOTE: There is no 256 here! However, there are other mentions of 256 in this file.
// For example, in durations has a 256 key, and sanitizeDuration() can return 256.
// The sanitizeDuration() bit may need to be removed by 0xfe.
Tables.durationCodes = {
    '1/2': {
        stem: false,
    },
    1: {
        stem: false,
    },
    2: {
        stem: true,
    },
    4: {
        stem: true,
    },
    8: {
        stem: true,
        beamCount: 1,
        stemBeamExtension: 0,
        codeFlagUp: '\ue240' /*flag8thUp*/,
    },
    16: {
        beamCount: 2,
        stemBeamExtension: 0,
        stem: true,
        codeFlagUp: '\ue242' /*flag16thUp*/,
    },
    32: {
        beamCount: 3,
        stemBeamExtension: 7.5,
        stem: true,
        codeFlagUp: '\ue244' /*flag32ndUp*/,
    },
    64: {
        beamCount: 4,
        stemBeamExtension: 15,
        stem: true,
        codeFlagUp: '\ue246' /*flag64thUp*/,
    },
    128: {
        beamCount: 5,
        stemBeamExtension: 22.5,
        stem: true,
        codeFlagUp: '\ue248' /*flag128thUp*/,
    },
};
/**
 * Customize this by calling Flow.setMusicFont(...fontNames);
 */
Tables.MUSIC_FONT_STACK = [];
Tables.NOTATION_FONT_SCALE = 39;
Tables.TABLATURE_FONT_SCALE = 39;
Tables.SLASH_NOTEHEAD_WIDTH = 15;
Tables.STAVE_LINE_DISTANCE = 10;
// HACK:
// Since text origins are positioned at the baseline, we must
// compensate for the ascender of the text. Of course, 1 staff space is
// a very poor approximation.
//
// This will be deprecated in the future. This is a temporary solution until
// we have more robust text metrics.
Tables.TEXT_HEIGHT_OFFSET_HACK = 1;
Tables.accidentalColumnsTable = accidentalColumns;
Tables.unicode = {
    //  accidental sharp
    sharp: '\u266f',
    //  accidental flat
    flat: '\u266d',
    //  accidental natural
    natural: '\u266e',
    //  major seventh
    triangle: '\u25b3',
    //  half-diminished
    'o-with-slash': '\u00f8',
    //  diminished
    degrees: '\u00b0',
    //  diminished
    circle: '\u25cb',
};
/* The list of valid note types. Used by note.ts during parseNoteStruct(). */
Tables.validTypes = validNoteTypes;
// Default time signature.
Tables.TIME4_4 = {
    numBeats: 4,
    beatValue: 4,
    resolution: RESOLUTION,
};


/***/ }),

/***/ "./src/tabnote.ts":
/*!************************!*\
  !*** ./src/tabnote.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TabNote: () => (/* binding */ TabNote)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _modifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifier */ "./src/modifier.ts");
/* harmony import */ var _note__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./note */ "./src/note.ts");
/* harmony import */ var _stem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stem */ "./src/stem.ts");
/* harmony import */ var _stemmablenote__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stemmablenote */ "./src/stemmablenote.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
//
// ## Description
//
// The file implements notes for Tablature notation. This consists of one or
// more fret positions, and can either be drawn with or without stems.
//
// See `tests/tabnote_tests.ts` for usage examples.







/**
 * Gets the unused strings grouped together if consecutive.
 * @param numLines The number of lines.
 * @param stringsUsed An array of numbers representing which strings have fret positions.
 * @returns
 */
function getUnusedStringGroups(numLines, stringsUsed) {
    const stemThrough = [];
    let group = [];
    for (let string = 1; string <= numLines; string++) {
        const isUsed = stringsUsed.indexOf(string) > -1;
        if (!isUsed) {
            group.push(string);
        }
        else {
            stemThrough.push(group);
            group = [];
        }
    }
    if (group.length > 0)
        stemThrough.push(group);
    return stemThrough;
}
// Gets groups of points that outline the partial stem lines
// between fret positions
//
// Parameters:
// * stemY - The `y` coordinate the stem is located on
// * unusedStrings - An array of groups of unused strings
// * stave - The stave to use for reference
// * stemDirection - The direction of the stem
function getPartialStemLines(stemY, unusedStrings, stave, stemDirection) {
    const upStem = stemDirection !== 1;
    const downStem = stemDirection !== -1;
    const lineSpacing = stave.getSpacingBetweenLines();
    const totalLines = stave.getNumLines();
    const stemLines = [];
    unusedStrings.forEach((strings) => {
        const containsLastString = strings.indexOf(totalLines) > -1;
        const containsFirstString = strings.indexOf(1) > -1;
        if ((upStem && containsFirstString) || (downStem && containsLastString)) {
            return;
        }
        // If there's only one string in the group, push a duplicate value.
        // We do this because we need 2 strings to convert into upper/lower y
        // values.
        if (strings.length === 1) {
            strings.push(strings[0]);
        }
        const lineYs = [];
        // Iterate through each group string and store it's y position
        strings.forEach((string, index, strings) => {
            const isTopBound = string === 1;
            const isBottomBound = string === totalLines;
            // Get the y value for the appropriate staff line,
            // we adjust for a 0 index array, since string numbers are index 1
            let y = stave.getYForLine(string - 1);
            // Unless the string is the first or last, add padding to each side
            // of the line
            if (index === 0 && !isTopBound) {
                y -= lineSpacing / 2 - 1;
            }
            else if (index === strings.length - 1 && !isBottomBound) {
                y += lineSpacing / 2 - 1;
            }
            // Store the y value
            lineYs.push(y);
            // Store a subsequent y value connecting this group to the main
            // stem above/below the stave if it's the top/bottom string
            if (stemDirection === 1 && isTopBound) {
                lineYs.push(stemY - 2);
            }
            else if (stemDirection === -1 && isBottomBound) {
                lineYs.push(stemY + 2);
            }
        });
        // Add the sorted y values to the
        stemLines.push(lineYs.sort((a, b) => a - b));
    });
    return stemLines;
}
class TabNote extends _stemmablenote__WEBPACK_IMPORTED_MODULE_4__.StemmableNote {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_5__.Category.TabNote;
    }
    // Initialize the TabNote with a `noteStruct` full of properties
    // and whether to `drawStem` when rendering the note
    constructor(noteStruct, drawStem = false) {
        super(noteStruct);
        this.fretElement = [];
        // Return the number of the greatest string, which is the string lowest on the display
        this.greatestString = () => {
            return this.positions.map((x) => x.str).reduce((a, b) => (a > b ? a : b));
        };
        // Return the number of the least string, which is the string highest on the display
        this.leastString = () => {
            return this.positions.map((x) => x.str).reduce((a, b) => (a < b ? a : b));
        };
        this.ghost = false; // Renders parenthesis around notes
        // Note properties
        // The fret positions in the note. An array of `{ str: X, fret: X }`
        this.positions = noteStruct.positions || [];
        // Render Options
        this.renderOptions = Object.assign(Object.assign({}, this.renderOptions), { 
            // Flag to draw a stem
            drawStem, 
            // Flag to draw dot modifiers
            drawDots: drawStem, 
            // Flag to extend the main stem through the stave and fret positions
            drawStemThroughStave: false, 
            // vertical shift from stave line
            yShift: 0 });
        this.glyphProps = _note__WEBPACK_IMPORTED_MODULE_2__.Note.getGlyphProps(this.duration, this.noteType);
        (0,_util__WEBPACK_IMPORTED_MODULE_6__.defined)(this.glyphProps, 'BadArguments', `No glyph found for duration '${this.duration}' and type '${this.noteType}'`);
        this.buildStem();
        if (noteStruct.stemDirection) {
            this.setStemDirection(noteStruct.stemDirection);
        }
        else {
            this.setStemDirection(_stem__WEBPACK_IMPORTED_MODULE_3__.Stem.UP);
        }
        // Renders parenthesis around notes
        this.ghost = false;
        this.updateWidth();
    }
    reset() {
        super.reset();
        if (this.stave)
            this.setStave(this.stave);
        return this;
    }
    // Set as ghost `TabNote`, surrounds the fret positions with parenthesis.
    // Often used for indicating frets that are being bent to
    setGhost(ghost) {
        this.ghost = ghost;
        this.updateWidth();
        return this;
    }
    // Determine if the note has a stem
    hasStem() {
        if (this.renderOptions.drawStem)
            return true;
        return false;
    }
    // Get the default stem extension for the note
    getStemExtension() {
        if (this.stemExtensionOverride !== undefined) {
            return this.stemExtensionOverride;
        }
        return this.flag.getHeight() > _stem__WEBPACK_IMPORTED_MODULE_3__.Stem.HEIGHT ? this.flag.getHeight() - _stem__WEBPACK_IMPORTED_MODULE_3__.Stem.HEIGHT : 0;
    }
    static tabToElement(fret) {
        let el;
        if (fret.toUpperCase() === 'X') {
            el = new _element__WEBPACK_IMPORTED_MODULE_0__.Element('TabNote');
            el.setText('\ue263' /*accidentalDoubleSharp*/);
        }
        else {
            el = new _element__WEBPACK_IMPORTED_MODULE_0__.Element('TabNote.text');
            el.setText(fret);
            el.setYShift(el.getHeight() / 2);
        }
        return el;
    }
    // Calculate and store the width of the note
    updateWidth() {
        this.fretElement = [];
        this.width = 0;
        for (let i = 0; i < this.positions.length; ++i) {
            let fret = this.positions[i].fret;
            if (this.ghost)
                fret = '(' + fret + ')';
            const el = TabNote.tabToElement(fret.toString());
            this.fretElement.push(el);
            this.width = Math.max(el.getWidth(), this.width);
        }
    }
    // Set the `stave` to the note
    setStave(stave) {
        super.setStave(stave);
        const ctx = stave.getContext();
        this.setContext(ctx);
        // we subtract 1 from `line` because getYForLine expects a 0-based index,
        // while the position.str is a 1-based index
        const ys = this.positions.map(({ str: line }) => stave.getYForLine(Number(line) - 1));
        this.setYs(ys);
        if (this.stem) {
            this.stem.setYBounds(this.getStemY(), this.getStemY());
        }
        return this;
    }
    // Get the fret positions for the note
    getPositions() {
        return this.positions;
    }
    // Get the default `x` and `y` coordinates for a modifier at a specific
    // `position` at a fret position `index`
    getModifierStartXY(position, index) {
        if (!this.preFormatted) {
            throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('UnformattedNote', "Can't call GetModifierStartXY on an unformatted note");
        }
        if (this.ys.length === 0) {
            throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('NoYValues', 'No Y-Values calculated for this note.');
        }
        let x = 0;
        if (position === _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.LEFT) {
            x = -1 * 2; // FIXME: modifier padding, move to font file
        }
        else if (position === _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.RIGHT) {
            x = this.width + 2; // FIXME: modifier padding, move to font file
        }
        else if (position === _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.BELOW || position === _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.ABOVE) {
            const noteGlyphWidth = this.width;
            x = noteGlyphWidth / 2;
        }
        return {
            x: this.getAbsoluteX() + x,
            y: this.ys[index],
        };
    }
    // Get the default line for rest
    getLineForRest() {
        return Number(this.positions[0].str);
    }
    // Pre-render formatting
    preFormat() {
        if (this.preFormatted)
            return;
        if (this.modifierContext)
            this.modifierContext.preFormat();
        // width is already set during init()
        this.preFormatted = true;
    }
    // Get the x position for the stem
    getStemX() {
        return this.getCenterGlyphX();
    }
    // Get the y position for the stem
    getStemY() {
        const numLines = this.checkStave().getNumLines();
        // The decimal staff line amounts provide optimal spacing between the
        // fret number and the stem
        const stemUpLine = -0.5;
        const stemDownLine = numLines - 0.5;
        const stemStartLine = _stem__WEBPACK_IMPORTED_MODULE_3__.Stem.UP === this.stemDirection ? stemUpLine : stemDownLine;
        return this.checkStave().getYForLine(stemStartLine);
    }
    // Get the stem extents for the tabnote
    getStemExtents() {
        return this.checkStem().getExtents();
    }
    // Draw the fal onto the context
    drawFlag() {
        const { beam, glyphProps, renderOptions: { drawStem }, } = this;
        const context = this.checkContext();
        const shouldDrawFlag = beam === undefined && drawStem;
        // Now it's the flag's turn.
        if (glyphProps.codeFlagUp && shouldDrawFlag) {
            const flagX = this.getStemX();
            const flagY = this.getStemDirection() === _stem__WEBPACK_IMPORTED_MODULE_3__.Stem.DOWN
                ? // Down stems are below the note head and have flags on the right.
                    this.getStemY() - this.checkStem().getHeight() - this.getStemExtension()
                : // Up stems are above the note head and have flags on the right.
                    this.getStemY() - this.checkStem().getHeight() + this.getStemExtension();
            // Draw the Flag
            this.applyStyle(context, this.flagStyle);
            this.flag.renderText(context, flagX, flagY);
            this.restoreStyle(context, this.flagStyle);
        }
    }
    // Render the modifiers onto the context.
    drawModifiers() {
        this.modifiers.forEach((modifier) => {
            // Only draw the dots if enabled.
            if ((0,_typeguard__WEBPACK_IMPORTED_MODULE_5__.isDot)(modifier) && !this.renderOptions.drawDots) {
                return;
            }
            modifier.setContext(this.getContext());
            modifier.drawWithStyle();
        });
    }
    // Render the stem extension through the fret positions
    drawStemThrough() {
        const stemX = this.getStemX();
        const stemY = this.getStemY();
        const ctx = this.checkContext();
        const drawStem = this.renderOptions.drawStem;
        const stemThrough = this.renderOptions.drawStemThroughStave;
        if (drawStem && stemThrough) {
            const numLines = this.checkStave().getNumLines();
            const stringsUsed = this.positions.map((position) => Number(position.str));
            const unusedStrings = getUnusedStringGroups(numLines, stringsUsed);
            const stemLines = getPartialStemLines(stemY, unusedStrings, this.checkStave(), this.getStemDirection());
            ctx.save();
            ctx.setLineWidth(_stem__WEBPACK_IMPORTED_MODULE_3__.Stem.WIDTH);
            stemLines.forEach((bounds) => {
                if (bounds.length === 0)
                    return;
                ctx.beginPath();
                ctx.moveTo(stemX, bounds[0]);
                ctx.lineTo(stemX, bounds[bounds.length - 1]);
                ctx.stroke();
                ctx.closePath();
            });
            ctx.restore();
        }
    }
    // Render the fret positions onto the context
    drawPositions() {
        const ctx = this.checkContext();
        const x = this.getAbsoluteX();
        const ys = this.ys;
        for (let i = 0; i < this.positions.length; ++i) {
            const y = ys[i] + this.renderOptions.yShift;
            const el = this.fretElement[i];
            // Center the fret text beneath the stem
            const tabX = x - el.getWidth() / 2;
            // FIXME: Magic numbers.
            ctx.clearRect(tabX - 2, y - 3, el.getWidth() + 4, 6);
            el.renderText(ctx, tabX, y);
        }
    }
    // The main rendering function for the entire note.
    draw() {
        const ctx = this.checkContext();
        if (this.ys.length === 0) {
            throw new _util__WEBPACK_IMPORTED_MODULE_6__.RuntimeError('NoYValues', "Can't draw note without Y values.");
        }
        this.setRendered();
        const renderStem = this.beam === undefined && this.renderOptions.drawStem;
        this.applyStyle();
        ctx.openGroup('tabnote', this.getAttribute('id'), { pointerBBox: true });
        this.drawPositions();
        this.drawStemThrough();
        if (this.stem && renderStem) {
            const stemX = this.getStemX();
            this.stem.setNoteHeadXBounds(stemX, stemX);
            this.stem.setContext(ctx).draw();
        }
        this.drawFlag();
        this.drawModifiers();
        ctx.closeGroup();
        this.restoreStyle();
    }
}


/***/ }),

/***/ "./src/tabslide.ts":
/*!*************************!*\
  !*** ./src/tabslide.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TabSlide: () => (/* binding */ TabSlide)
/* harmony export */ });
/* harmony import */ var _tabtie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tabtie */ "./src/tabtie.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// This class implements varies types of ties between contiguous notes. The
// ties include: regular ties, hammer ons, pull offs, and slides.



class TabSlide extends _tabtie__WEBPACK_IMPORTED_MODULE_0__.TabTie {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_1__.Category.TabSlide;
    }
    static get SLIDE_UP() {
        return 1;
    }
    static get SLIDE_DOWN() {
        return -1;
    }
    static createSlideUp(notes) {
        return new TabSlide(notes, TabSlide.SLIDE_UP);
    }
    static createSlideDown(notes) {
        return new TabSlide(notes, TabSlide.SLIDE_DOWN);
    }
    /**
     * @param notes is a struct of the form:
     *  {
     *    firstNote: Note,
     *    lastNote: Note,
     *    firstIndexes: [n1, n2, n3],
     *    lastIndexes: [n1, n2, n3]
     *  }
     * @param notes.firstNote the starting note of the slide
     * @param notes.lastNote the ending note of the slide
     * @param notes.firstIndexes specifies which string + fret positions of the TabNote are used in this slide. zero indexed.
     * @param notes.lastIndexes currently unused. we assume it's the same as firstIndexes.
     *
     * @param direction TabSlide.SLIDE_UP or TabSlide.SLIDE_DOWN
     */
    constructor(notes, direction) {
        super(notes, 'sl.');
        // Determine the direction automatically if it is not provided.
        if (!direction) {
            let firstFret = notes.firstNote.getPositions()[0].fret;
            if (typeof firstFret === 'string') {
                firstFret = parseInt(firstFret, 10);
            }
            let lastFret = notes.lastNote.getPositions()[0].fret;
            if (typeof lastFret === 'string') {
                lastFret = parseInt(lastFret, 10);
            }
            // If either of the frets are 'X', parseInt() above will return NaN.
            // Choose TabSlide.SLIDE_UP by default.
            if (isNaN(firstFret) || isNaN(lastFret)) {
                direction = TabSlide.SLIDE_UP;
            }
            else {
                direction = firstFret > lastFret ? TabSlide.SLIDE_DOWN : TabSlide.SLIDE_UP;
            }
        }
        this.direction = direction;
        this.renderOptions.cp1 = 11;
        this.renderOptions.cp2 = 14;
        this.renderOptions.yShift = 0.5;
    }
    /**
     * @param params.firstX is specified in pixels.
     * @param params.lastX is specified in pixels.
     */
    renderTie(params) {
        if (params.firstYs.length === 0 || params.lastYs.length === 0) {
            throw new _util__WEBPACK_IMPORTED_MODULE_2__.RuntimeError('BadArguments', 'No Y-values to render');
        }
        const ctx = this.checkContext();
        const firstX = params.firstX; // pixel units
        const firstYs = params.firstYs;
        const lastX = params.lastX; // pixel units
        const direction = params.direction;
        if (direction !== TabSlide.SLIDE_UP && direction !== TabSlide.SLIDE_DOWN) {
            throw new _util__WEBPACK_IMPORTED_MODULE_2__.RuntimeError('BadSlide', 'Invalid slide direction');
        }
        // eslint-disable-next-line
        const firstIndexes = this.notes.firstIndexes;
        for (let i = 0; i < firstIndexes.length; ++i) {
            const slideY = firstYs[firstIndexes[i]] + this.renderOptions.yShift;
            if (isNaN(slideY)) {
                throw new _util__WEBPACK_IMPORTED_MODULE_2__.RuntimeError('BadArguments', 'Bad indexes for slide rendering.');
            }
            ctx.beginPath();
            ctx.moveTo(firstX, slideY + 3 * direction);
            ctx.lineTo(lastX, slideY - 3 * direction);
            ctx.closePath();
            ctx.stroke();
        }
        this.setRendered();
    }
}


/***/ }),

/***/ "./src/tabstave.ts":
/*!*************************!*\
  !*** ./src/tabstave.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TabStave: () => (/* binding */ TabStave)
/* harmony export */ });
/* harmony import */ var _stave__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stave */ "./src/stave.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors


class TabStave extends _stave__WEBPACK_IMPORTED_MODULE_0__.Stave {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_1__.Category.TabStave;
    }
    constructor(x, y, width, options) {
        const tabOptions = Object.assign({ spacingBetweenLinesPx: 13, numLines: 6, topTextPosition: 1 }, options);
        super(x, y, width, tabOptions);
    }
    getYForGlyphs() {
        return this.getYForLine(2.5);
    }
    // Deprecated
    addTabGlyph() {
        this.addClef('tab');
        return this;
    }
}


/***/ }),

/***/ "./src/tabtie.ts":
/*!***********************!*\
  !*** ./src/tabtie.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TabTie: () => (/* binding */ TabTie)
/* harmony export */ });
/* harmony import */ var _stavetie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stavetie */ "./src/stavetie.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// ## Description
// This class implements varies types of ties between contiguous notes. The
// ties include: regular ties, hammer ons, pull offs, and slides.


class TabTie extends _stavetie__WEBPACK_IMPORTED_MODULE_0__.StaveTie {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_1__.Category.TabTie;
    }
    static createHammeron(notes) {
        return new TabTie(notes, 'H');
    }
    static createPulloff(notes) {
        return new TabTie(notes, 'P');
    }
    /**
     * @param notes is a struct that has:
     *  {
     *    firstNote: Note,
     *    lastNote: Note,
     *    firstIndexes: [n1, n2, n3],
     *    lastIndexes: [n1, n2, n3]
     *  }
     *
     * @param text
     */
    constructor(notes, text) {
        super(notes, text);
        this.renderOptions.cp1 = 9;
        this.renderOptions.cp2 = 11;
        this.renderOptions.yShift = 3;
        this.direction = -1; // Tab tie's are always face up.
    }
}


/***/ }),

/***/ "./src/textbracket.ts":
/*!****************************!*\
  !*** ./src/textbracket.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextBracket: () => (/* binding */ TextBracket),
/* harmony export */   TextBracketPosition: () => (/* binding */ TextBracketPosition)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _font__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./font */ "./src/font.ts");
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./renderer */ "./src/renderer.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// @author Cyril Silverman
//
// This file implements `TextBrackets` which extend between two notes.
// The octave transposition markings (8va, 8vb, 15va, 15vb) can be created
// using this class.






// To enable logging for this class. Set `Vex.Flow.TextBracket.DEBUG` to `true`.
// eslint-disable-next-line
function L(...args) {
    if (TextBracket.DEBUG)
        (0,_util__WEBPACK_IMPORTED_MODULE_5__.log)('Vex.Flow.TextBracket', args);
}
var TextBracketPosition;
(function (TextBracketPosition) {
    TextBracketPosition[TextBracketPosition["TOP"] = 1] = "TOP";
    TextBracketPosition[TextBracketPosition["BOTTOM"] = -1] = "BOTTOM";
})(TextBracketPosition || (TextBracketPosition = {}));
class TextBracket extends _element__WEBPACK_IMPORTED_MODULE_0__.Element {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_4__.Category.TextBracket;
    }
    static get Position() {
        return TextBracketPosition;
    }
    static get PositionString() {
        return {
            top: TextBracketPosition.TOP,
            bottom: TextBracketPosition.BOTTOM,
        };
    }
    constructor({ start, stop, text = '', superscript = '', position = TextBracketPosition.TOP }) {
        super();
        this.start = start;
        this.stop = stop;
        this.textElement = new _element__WEBPACK_IMPORTED_MODULE_0__.Element('TextBracket');
        this.textElement.setText(text);
        this.superscriptElement = new _element__WEBPACK_IMPORTED_MODULE_0__.Element('TextBracket');
        this.superscriptElement.setText(superscript);
        const smallerFontSize = _font__WEBPACK_IMPORTED_MODULE_1__.Font.scaleSize(this.fontInfo.size, 0.714286);
        this.superscriptElement.setFontSize(smallerFontSize);
        this.position = typeof position === 'string' ? TextBracket.PositionString[position] : position;
        this.line = 1;
        this.renderOptions = {
            dashed: true,
            dash: [5],
            color: 'black',
            lineWidth: 1,
            showBracket: true,
            bracketHeight: 8,
            // In the BOTTOM position, the bracket line can extend
            // under the superscript.
            underlineSuperscript: true,
        };
    }
    /**
     * Apply the text backet styling to the provided context.
     * @param ctx
     * @returns this
     */
    applyStyle(ctx) {
        this.textElement.setFont(this.fontInfo);
        // We called this.resetFont() in the constructor, so we know this.textFont is available.
        const { family, size, weight, style } = this.fontInfo;
        // To draw the superscript, we scale the font size by 1/1.4.
        const smallerFontSize = _font__WEBPACK_IMPORTED_MODULE_1__.Font.scaleSize(size, 0.714286);
        this.superscriptElement.setFont(family, smallerFontSize, weight, style);
        const options = this.renderOptions;
        ctx.setStrokeStyle(options.color);
        ctx.setFillStyle(options.color);
        ctx.setLineWidth(options.lineWidth);
        return this;
    }
    // Set whether the bracket line should be `dashed`. You can also
    // optionally set the `dash` pattern by passing in an array of numbers
    setDashed(dashed, dash) {
        this.renderOptions.dashed = dashed;
        if (dash)
            this.renderOptions.dash = dash;
        return this;
    }
    // Set the rendering `context` for the octave bracket
    setLine(line) {
        this.line = line;
        return this;
    }
    // Draw the octave bracket on the rendering context
    draw() {
        const ctx = this.checkContext();
        this.setRendered();
        let y = 0;
        switch (this.position) {
            case TextBracketPosition.TOP:
                y = this.start.checkStave().getYForTopText(this.line);
                break;
            case TextBracketPosition.BOTTOM:
                y = this.start.checkStave().getYForBottomText(this.line + _tables__WEBPACK_IMPORTED_MODULE_3__.Tables.TEXT_HEIGHT_OFFSET_HACK);
                break;
            default:
                throw new _util__WEBPACK_IMPORTED_MODULE_5__.RuntimeError('InvalidPosition', `The position ${this.position} is invalid.`);
        }
        // Get the preliminary start and stop coordintates for the bracket
        const start = { x: this.start.getAbsoluteX(), y };
        const stop = { x: this.stop.getAbsoluteX(), y };
        L('Rendering TextBracket: start:', start, 'stop:', stop, 'y:', y);
        const bracketHeight = this.renderOptions.bracketHeight * this.position;
        ctx.save();
        this.applyStyle(ctx);
        // Draw text
        this.textElement.renderText(ctx, start.x, start.y);
        // Get the width and height for the octave number
        const mainWidth = this.textElement.getWidth();
        const mainHeight = this.textElement.getHeight();
        // Calculate the y position for the super script
        const superY = start.y - mainHeight / 2.5;
        // To draw the superscript, we scale the font size by 1/1.4.
        this.superscriptElement.renderText(ctx, start.x + mainWidth + 1, superY);
        // Determine width and height of the superscript
        const superWidth = this.superscriptElement.getWidth();
        const superHeight = this.superscriptElement.getHeight();
        // Setup initial coordinates for the bracket line
        let startX = start.x;
        let lineY = superY;
        const endX = stop.x + this.stop.getGlyphWidth();
        // Adjust x and y coordinates based on position
        if (this.position === TextBracketPosition.TOP) {
            startX += mainWidth + superWidth + 5;
            lineY -= superHeight / 2.7;
        }
        else if (this.position === TextBracketPosition.BOTTOM) {
            lineY += superHeight / 2.7;
            startX += mainWidth + 2;
            if (!this.renderOptions.underlineSuperscript) {
                startX += superWidth;
            }
        }
        if (this.renderOptions.dashed) {
            // Main line
            _renderer__WEBPACK_IMPORTED_MODULE_2__.Renderer.drawDashedLine(ctx, startX, lineY, endX, lineY, this.renderOptions.dash);
            // Ending Bracket
            if (this.renderOptions.showBracket) {
                _renderer__WEBPACK_IMPORTED_MODULE_2__.Renderer.drawDashedLine(ctx, endX, lineY + 1 * this.position, endX, lineY + bracketHeight, this.renderOptions.dash);
            }
        }
        else {
            ctx.beginPath();
            ctx.moveTo(startX, lineY);
            // Main line
            ctx.lineTo(endX, lineY);
            if (this.renderOptions.showBracket) {
                // Ending bracket
                ctx.lineTo(endX, lineY + bracketHeight);
            }
            ctx.stroke();
            ctx.closePath();
        }
        ctx.restore();
    }
}
TextBracket.DEBUG = false;


/***/ }),

/***/ "./src/textdynamics.ts":
/*!*****************************!*\
  !*** ./src/textdynamics.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextDynamics: () => (/* binding */ TextDynamics)
/* harmony export */ });
/* harmony import */ var _note__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./note */ "./src/note.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License



// eslint-disable-next-line
function L(...args) {
    if (TextDynamics.DEBUG)
        (0,_util__WEBPACK_IMPORTED_MODULE_2__.log)('Vex.Flow.TextDynamics', args);
}
/**
 * `TextDynamics` renders traditional
 * text dynamics markings, **ie: p, f, sfz, rfz, ppp**
 *
 * You can render any dynamics string that contains a combination of
 * the following letters:  P, M, F, Z, R, S
 */
class TextDynamics extends _note__WEBPACK_IMPORTED_MODULE_0__.Note {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_1__.Category.TextDynamics;
    }
    /** The glyph data for each dynamics letter. */
    static get GLYPHS() {
        return {
            f: '\uE522' /*dynamicForte*/,
            p: '\uE520' /*dynamicPiano*/,
            m: '\uE521' /*dynamicMezzo*/,
            s: '\uE524' /*dynamicSforzando*/,
            z: '\uE525' /*dynamicZ*/,
            r: '\uE523' /*dynamicRinforzando*/,
        };
    }
    /**
     * Create the dynamics marking.
     *
     * A `TextDynamics` object inherits from `Note` so that it can be formatted
     * within a `Voice`.
     *
     * @param noteStruct an object that contains a `duration` property and a
     * `sequence` of letters that represents the letters to render.
     */
    constructor(noteStruct) {
        var _a, _b;
        super(noteStruct);
        this.sequence = ((_a = noteStruct.text) !== null && _a !== void 0 ? _a : '').toLowerCase();
        this.line = (_b = noteStruct.line) !== null && _b !== void 0 ? _b : 0;
        this.text = '';
        L('New Dynamics Text: ', this.sequence);
    }
    /** Set the Stave line on which the note should be placed. */
    setLine(line) {
        this.line = line;
        return this;
    }
    /** Preformat the dynamics text. */
    preFormat() {
        // length of this.glyphs must be <=
        // length of this.sequence, so if we're formatted before
        // create new glyphs.
        this.text = '';
        // Iterate through each letter
        this.sequence.split('').forEach((letter) => {
            // Get the glyph data for the letter
            const glyph = TextDynamics.GLYPHS[letter];
            if (!glyph)
                throw new _util__WEBPACK_IMPORTED_MODULE_2__.RuntimeError('Invalid dynamics character: ' + letter);
            // Add the glyph
            this.text += glyph;
        });
        this.preFormatted = true;
        return this;
    }
    /** Draw the dynamics text on the rendering context. */
    draw() {
        this.setRendered();
        const x = this.getAbsoluteX();
        const y = this.checkStave().getYForLine(this.line + -3);
        L('Rendering Dynamics: ', this.sequence);
        this.renderText(this.checkContext(), x, y);
    }
}
/** To enable logging for this class. Set `Vex.Flow.TextDynamics.DEBUG` to `true`. */
TextDynamics.DEBUG = false;


/***/ }),

/***/ "./src/textnote.ts":
/*!*************************!*\
  !*** ./src/textnote.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextJustification: () => (/* binding */ TextJustification),
/* harmony export */   TextNote: () => (/* binding */ TextNote)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _font__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./font */ "./src/font.ts");
/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./metrics */ "./src/metrics.ts");
/* harmony import */ var _note__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./note */ "./src/note.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License





var TextJustification;
(function (TextJustification) {
    TextJustification[TextJustification["LEFT"] = 1] = "LEFT";
    TextJustification[TextJustification["CENTER"] = 2] = "CENTER";
    TextJustification[TextJustification["RIGHT"] = 3] = "RIGHT";
})(TextJustification || (TextJustification = {}));
/**
 * `TextNote` is a notation element that is positioned in time. Generally
 * meant for objects that sit above/below the staff and inline with each other.
 * `TextNote` has to be assigned to a `Stave` before rendering by means of `setStave`.
 * Examples of this would be such as dynamics, lyrics, chord changes, etc.
 */
class TextNote extends _note__WEBPACK_IMPORTED_MODULE_3__.Note {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_4__.Category.TextNote;
    }
    /** Glyph data. */
    static get GLYPHS() {
        return {
            segno: '\uE047' /*segno*/,
            tr: '\uE566' /*ornamentTrill*/,
            mordent: '\uE56D' /*ornamentMordent*/,
            mordentUpper: '\uE56C' /*ornamentShortTrill*/,
            mordentLower: '\uE56D' /*ornamentMordent*/,
            f: '\uE522' /*dynamicForte*/,
            p: '\uE520' /*dynamicPiano*/,
            m: '\uE521' /*dynamicMezzo*/,
            s: '\uE524' /*dynamicSforzando*/,
            z: '\uE525' /*dynamicZ*/,
            coda: '\uE048' /*coda*/,
            pedalOpen: '\uE650' /*keyboardPedalPed*/,
            pedalClose: '\uE655' /*keyboardPedalUp*/,
            caesuraStraight: '\uE4D1' /*caesura*/,
            caesuraCurved: '\uE4D4' /*caesuraCurved*/,
            breath: '\uE4CE' /*breathMarkComma*/,
            tick: '\uE4CF' /*breathMarkTick*/,
            turn: '\uE567' /*ornamentTurn*/,
            turnInverted: '\uE569' /*ornamentTurnSlash*/,
        };
    }
    constructor(noteStruct) {
        var _a, _b;
        super(noteStruct);
        this.text = (_a = noteStruct.text) !== null && _a !== void 0 ? _a : '';
        if (noteStruct.glyph) {
            this.text += TextNote.GLYPHS[noteStruct.glyph] || noteStruct.glyph;
        }
        if (noteStruct.font) {
            this.setFont(noteStruct.font);
        }
        else if (noteStruct.glyph === undefined) {
            this.setFont(_metrics__WEBPACK_IMPORTED_MODULE_2__.Metrics.getFontInfo('TextNote.text.fontSize'));
        }
        // Scale the font size by 1/1.3.
        const smallerFontSize = _font__WEBPACK_IMPORTED_MODULE_1__.Font.convertSizeToPointValue(this.fontInfo.size) * 0.769231;
        if (noteStruct.superscript) {
            this.superscript = new _element__WEBPACK_IMPORTED_MODULE_0__.Element('TexNote.subSuper');
            this.superscript.setText(noteStruct.superscript);
            this.superscript.setFontSize(smallerFontSize);
        }
        if (noteStruct.subscript) {
            this.subscript = new _element__WEBPACK_IMPORTED_MODULE_0__.Element('TexNote.subSuper');
            this.subscript.setText(noteStruct.subscript);
            this.subscript.setFontSize(smallerFontSize);
        }
        this.line = (_b = noteStruct.line) !== null && _b !== void 0 ? _b : 0;
        this.smooth = noteStruct.smooth || false;
        this.ignoreTicks = noteStruct.ignoreTicks || false;
        this.justification = TextJustification.LEFT;
    }
    /** Set the horizontal justification of the TextNote. */
    setJustification(just) {
        this.justification = just;
        return this;
    }
    /** Set the Stave line on which the note should be placed. */
    setLine(line) {
        this.line = line;
        return this;
    }
    /** Return the Stave line on which the TextNote is placed. */
    getLine() {
        return this.line;
    }
    /** Pre-render formatting. */
    preFormat() {
        if (this.preFormatted)
            return;
        const tickContext = this.checkTickContext(`Can't preformat without a TickContext.`);
        if (this.justification === TextJustification.CENTER) {
            this.leftDisplacedHeadPx = this.width / 2;
        }
        else if (this.justification === TextJustification.RIGHT) {
            this.leftDisplacedHeadPx = this.width;
        }
        // We reposition to the center of the note head
        this.rightDisplacedHeadPx = tickContext.getMetrics().glyphPx / 2;
        this.preFormatted = true;
    }
    /**
     * Renders the TextNote.
     * `TextNote` has to be assigned to a `Stave` before rendering by means of `setStave`.
     */
    draw() {
        const ctx = this.checkContext();
        const stave = this.checkStave();
        const tickContext = this.checkTickContext(`Can't draw without a TickContext.`);
        this.setRendered();
        // Reposition to center of note head
        let x = this.getAbsoluteX() + tickContext.getMetrics().glyphPx / 2;
        // Align based on tick-context width.
        const width = this.getWidth();
        if (this.justification === TextJustification.CENTER) {
            x -= width / 2;
        }
        else if (this.justification === TextJustification.RIGHT) {
            x -= width;
        }
        const y = stave.getYForLine(this.line + -3);
        this.applyStyle(ctx);
        this.renderText(ctx, x, y);
        const height = this.getHeight();
        if (this.superscript) {
            this.superscript.renderText(ctx, x + this.width + 2, y - height / 2.2);
        }
        if (this.subscript) {
            this.subscript.renderText(ctx, x + this.width + 2, y + height / 2.2 - 1);
        }
        this.restoreStyle(ctx);
    }
}
TextNote.Justification = TextJustification;


/***/ }),

/***/ "./src/tickable.ts":
/*!*************************!*\
  !*** ./src/tickable.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tickable: () => (/* binding */ Tickable)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _fraction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fraction */ "./src/fraction.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Tickable_preFormatted, _Tickable_postFormatted;





/**
 * Tickable represents a element that sit on a score and
 * has a duration, i.e., Tickables occupy space in the musical rendering dimension.
 */
class Tickable extends _element__WEBPACK_IMPORTED_MODULE_0__.Element {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_3__.Category.Tickable;
    }
    constructor() {
        super();
        _Tickable_preFormatted.set(this, false);
        _Tickable_postFormatted.set(this, false);
        // These properties represent the duration of
        // this tickable element.
        this.ticks = new _fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction(0, 1); // Fractional value of ticks
        this.intrinsicTicks = 0; // Floating point value of ticks
        this.tickMultiplier = new _fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction(1, 1);
        this.modifiers = [];
        this.tupletStack = [];
        this.alignCenter = false;
        this.centerXShift = 0; // Shift from tick context if center aligned
        // This flag tells the formatter to ignore this tickable during
        // formatting and justification. It is set by tickables such as BarNote.
        this.ignoreTicks = false;
        // This is a space for an external formatting class or function to maintain
        // metrics.
        this.formatterMetrics = {
            // The freedom of a tickable is the distance it can move without colliding
            // with neighboring elements. A formatter can set these values during its
            // formatting pass, which a different formatter can then use to fine tune.
            freedom: { left: 0, right: 0 },
            // The simplified rational duration of this tick as a string. It can be
            // used as an index to a map or hashtable.
            duration: '',
            // The number of formatting iterations undergone.
            iterations: 0,
            // The space in pixels allocated by this formatter, along with the mean space
            // for tickables of this duration, and the deviation from the mean.
            space: {
                used: 0,
                mean: 0,
                deviation: 0,
            },
        };
    }
    /** Reset the Tickable, this function will be overloaded. */
    reset() {
        return this;
    }
    /** Return the ticks. */
    getTicks() {
        return this.ticks;
    }
    /** Check if it ignores the ticks. */
    shouldIgnoreTicks() {
        return this.ignoreTicks;
    }
    /** Ignore the ticks. */
    setIgnoreTicks(flag) {
        this.ignoreTicks = flag;
        return this;
    }
    /** Get width of note. Used by the formatter for positioning. */
    getWidth() {
        if (!__classPrivateFieldGet(this, _Tickable_preFormatted, "f")) {
            throw new _util__WEBPACK_IMPORTED_MODULE_4__.RuntimeError('UnformattedNote', "Can't call GetWidth on an unformatted note.");
        }
        return this.width + (this.modifierContext ? this.modifierContext.getWidth() : 0);
    }
    /** Get `x` position of this tick context. */
    getX() {
        const tickContext = this.checkTickContext(`Can't getX() without a TickContext.`);
        return tickContext.getX() + this.xShift;
    }
    /** Return the formatterMetrics. */
    getFormatterMetrics() {
        return this.formatterMetrics;
    }
    /** Return the center `x` shift. */
    getCenterXShift() {
        if (this.isCenterAligned()) {
            return this.centerXShift;
        }
        return 0;
    }
    /** Set the center `x` shift. */
    setCenterXShift(centerXShift) {
        this.centerXShift = centerXShift;
        return this;
    }
    // Check if tickable is center aligned. */
    isCenterAligned() {
        return this.alignCenter;
    }
    // Set/unset center alignment. */
    setCenterAlignment(alignCenter) {
        this.alignCenter = alignCenter;
        return this;
    }
    /**
     * Return the associated voice. Every tickable must be associated with a voice.
     * This allows formatters and preFormatter to associate them with the right modifierContexts.
     */
    getVoice() {
        return (0,_util__WEBPACK_IMPORTED_MODULE_4__.defined)(this.voice, 'NoVoice', 'Tickable has no voice.');
    }
    /** Set the associated voice. */
    setVoice(voice) {
        this.voice = voice;
    }
    /** Get the tuplet. */
    getTuplet() {
        return this.tuplet;
    }
    /** Return a list of Tuplets. */
    getTupletStack() {
        return this.tupletStack;
    }
    /**
     * Reset the specific Tuplet (if this is not provided, all tuplets are reset).
     * Remove any prior tuplets from the tick calculation and
     * reset the intrinsic tick value.
     */
    resetTuplet(tuplet) {
        let noteCount;
        let notesOccupied;
        if (tuplet) {
            const i = this.tupletStack.indexOf(tuplet);
            if (i !== -1) {
                this.tupletStack.splice(i, 1);
                noteCount = tuplet.getNoteCount();
                notesOccupied = tuplet.getNotesOccupied();
                // Revert old multiplier by inverting numerator & denom.:
                this.applyTickMultiplier(noteCount, notesOccupied);
            }
            return this;
        }
        while (this.tupletStack.length) {
            tuplet = this.tupletStack.pop();
            noteCount = tuplet.getNoteCount();
            notesOccupied = tuplet.getNotesOccupied();
            // Revert old multiplier by inverting numerator & denom.:
            this.applyTickMultiplier(noteCount, notesOccupied);
        }
        return this;
    }
    /** Attach to new tuplet. */
    setTuplet(tuplet) {
        if (tuplet) {
            this.tupletStack.push(tuplet);
            const noteCount = tuplet.getNoteCount();
            const notesOccupied = tuplet.getNotesOccupied();
            this.applyTickMultiplier(notesOccupied, noteCount);
        }
        this.tuplet = tuplet;
        return this;
    }
    /**
     * Add self to the provided ModifierContext `mc`.
     * If this tickable has modifiers, set modifierContext.
     * @returns this
     */
    addToModifierContext(mc) {
        this.modifierContext = mc;
        for (let i = 0; i < this.modifiers.length; ++i) {
            this.modifierContext.addMember(this.modifiers[i]);
        }
        this.modifierContext.addMember(this);
        __classPrivateFieldSet(this, _Tickable_preFormatted, false, "f");
        return this;
    }
    /**
     * Optional, if tickable has modifiers, associate a Modifier.
     * @param mod the modifier
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    addModifier(modifier, index = 0) {
        this.modifiers.push(modifier);
        __classPrivateFieldSet(this, _Tickable_preFormatted, false, "f");
        return this;
    }
    /** Get the list of associated modifiers. */
    getModifiers() {
        return this.modifiers;
    }
    /** Set the Tick Context. */
    setTickContext(tc) {
        this.tickContext = tc;
        __classPrivateFieldSet(this, _Tickable_preFormatted, false, "f");
    }
    checkTickContext(message = 'Tickable has no tick context.') {
        return (0,_util__WEBPACK_IMPORTED_MODULE_4__.defined)(this.tickContext, 'NoTickContext', message);
    }
    /** Preformat the Tickable. */
    preFormat() {
        if (__classPrivateFieldGet(this, _Tickable_preFormatted, "f"))
            return;
        this.width = 0;
        if (this.modifierContext) {
            this.modifierContext.preFormat();
            this.width += this.modifierContext.getWidth();
        }
    }
    /** Set preformatted status. */
    set preFormatted(value) {
        __classPrivateFieldSet(this, _Tickable_preFormatted, value, "f");
    }
    get preFormatted() {
        return __classPrivateFieldGet(this, _Tickable_preFormatted, "f");
    }
    /** Postformat the Tickable. */
    postFormat() {
        if (__classPrivateFieldGet(this, _Tickable_postFormatted, "f"))
            return this;
        __classPrivateFieldSet(this, _Tickable_postFormatted, true, "f");
        return this;
    }
    /** Set postformatted status. */
    set postFormatted(value) {
        __classPrivateFieldSet(this, _Tickable_postFormatted, value, "f");
    }
    get postFormatted() {
        return __classPrivateFieldGet(this, _Tickable_postFormatted, "f");
    }
    /** Return the intrinsic ticks. */
    getIntrinsicTicks() {
        return this.intrinsicTicks;
    }
    /** Set the intrinsic ticks. */
    setIntrinsicTicks(intrinsicTicks) {
        this.intrinsicTicks = intrinsicTicks;
        this.ticks = this.tickMultiplier.clone().multiply(this.intrinsicTicks);
    }
    /** Get the tick multiplier. */
    getTickMultiplier() {
        return this.tickMultiplier;
    }
    /** Apply a tick multiplier. */
    applyTickMultiplier(numerator, denominator) {
        this.tickMultiplier.multiply(numerator, denominator);
        this.ticks = this.tickMultiplier.clone().multiply(this.intrinsicTicks);
    }
    /** Set the duration. */
    setDuration(duration) {
        const ticks = duration.numerator * (_tables__WEBPACK_IMPORTED_MODULE_2__.Tables.RESOLUTION / duration.denominator);
        this.ticks = this.tickMultiplier.clone().multiply(ticks);
        this.intrinsicTicks = this.ticks.value();
    }
    getAbsoluteX() {
        const tickContext = this.checkTickContext(`Can't getAbsoluteX() without a TickContext.`);
        return tickContext.getX();
    }
    /** Attach this note to a modifier context. */
    setModifierContext(mc) {
        this.modifierContext = mc;
        return this;
    }
    /** Get `ModifierContext`. */
    getModifierContext() {
        return this.modifierContext;
    }
    /** Check and get `ModifierContext`. */
    checkModifierContext() {
        return (0,_util__WEBPACK_IMPORTED_MODULE_4__.defined)(this.modifierContext, 'NoModifierContext', 'No modifier context attached to this tickable.');
    }
}
_Tickable_preFormatted = new WeakMap(), _Tickable_postFormatted = new WeakMap();


/***/ }),

/***/ "./src/tickcontext.ts":
/*!****************************!*\
  !*** ./src/tickcontext.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TickContext: () => (/* binding */ TickContext)
/* harmony export */ });
/* harmony import */ var _fraction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fraction */ "./src/fraction.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
//
// ## Description
// A formatter for abstract tickable objects, such as notes, chords,
// tabs, etc.


/**
 * TickContext formats abstract tickable objects, such as notes, chords, tabs, etc.
 */
class TickContext {
    static getNextContext(tContext) {
        const contexts = tContext.tContexts;
        const index = contexts.indexOf(tContext);
        if (index + 1 < contexts.length)
            return contexts[index + 1];
    }
    constructor(options) {
        this.preFormatted = false;
        this.postFormatted = false;
        this.tickID = options && options.tickID ? options.tickID : 0;
        this.currentTick = new _fraction__WEBPACK_IMPORTED_MODULE_0__.Fraction(0, 1);
        this.maxTicks = new _fraction__WEBPACK_IMPORTED_MODULE_0__.Fraction(0, 1);
        this.maxTickable = undefined; // Biggest tickable
        this.minTicks = undefined; // this can remian null if all tickables have ignoreTicks
        this.minTickable = undefined;
        this.padding = 1; // padding on each side (width += padding * 2)
        this.x = 0;
        this.xBase = 0; // base x position without xOffset
        this.xOffset = 0; // xBase and xOffset are an alternative way to describe x (x = xB + xO)
        this.tickables = []; // Notes, tabs, chords, lyrics.
        this.tickablesByVoice = {}; // Tickables indexed by voice number
        // Formatting metrics
        this.notePx = 0; // width of widest note in this context
        this.glyphPx = 0; // width of glyph (note head)
        this.leftDisplacedHeadPx = 0; // Extra left pixels for displaced notes
        this.rightDisplacedHeadPx = 0; // Extra right pixels for displaced notes
        this.modLeftPx = 0; // Left modifier pixels
        this.modRightPx = 0; // Right modifier pixels
        this.totalLeftPx = 0; // Total left pixels
        this.totalRightPx = 0; // Total right pixels
        this.tContexts = []; // Parent array of tick contexts
        this.width = 0;
        this.formatterMetrics = {
            // The freedom of a tickcontext is the distance it can move without colliding
            // with neighboring elements. A formatter can set these values during its
            // formatting pass, which a different formatter can then use to fine tune.
            freedom: { left: 0, right: 0 },
        };
    }
    getTickID() {
        return this.tickID;
    }
    getX() {
        return this.x;
    }
    setX(x) {
        this.x = x;
        this.xBase = x;
        this.xOffset = 0;
        return this;
    }
    getXBase() {
        return this.xBase;
    } // use of xBase and xOffset is optional, avoids offset creep
    setXBase(xBase) {
        this.xBase = xBase;
        this.x = xBase + this.xOffset;
    }
    getXOffset() {
        return this.xOffset;
    }
    setXOffset(xOffset) {
        this.xOffset = xOffset;
        this.x = this.xBase + xOffset;
    }
    getWidth() {
        return this.width + this.padding * 2;
    }
    setPadding(padding) {
        this.padding = padding;
        return this;
    }
    getMaxTicks() {
        return this.maxTicks;
    }
    getMinTicks() {
        return this.minTicks;
    }
    getMaxTickable() {
        return this.maxTickable;
    }
    getMinTickable() {
        return this.minTickable;
    }
    getTickables() {
        return this.tickables;
    }
    /**
     * Introduced on 2020-04-17 as getTickablesForVoice(voiceIndex).
     *   https://github.com/0xfe/vexflow/blame/dc97b0cc5bb93171c0038638c34362dc958222ca/src/tickcontext.js#L63
     * Renamed on 2021-08-05 to getTickableForVoice(voiceIndex). Method renamed to singular, since it returns one Tickable.
     */
    getTickableForVoice(voiceIndex) {
        return this.tickablesByVoice[voiceIndex];
    }
    getTickablesByVoice() {
        return this.tickablesByVoice;
    }
    getCenterAlignedTickables() {
        return this.tickables.filter((tickable) => tickable.isCenterAligned());
    }
    /** Gets widths context, note and left/right modifiers for formatting. */
    getMetrics() {
        const { width, glyphPx, notePx, leftDisplacedHeadPx, rightDisplacedHeadPx, modLeftPx, modRightPx, totalLeftPx, totalRightPx, } = this;
        return {
            width,
            glyphPx,
            notePx,
            leftDisplacedHeadPx,
            rightDisplacedHeadPx,
            modLeftPx,
            modRightPx,
            totalLeftPx,
            totalRightPx,
        };
    }
    getCurrentTick() {
        return this.currentTick;
    }
    setCurrentTick(tick) {
        this.currentTick = tick;
        this.preFormatted = false;
    }
    addTickable(tickable, voiceIndex) {
        if (!tickable) {
            throw new _util__WEBPACK_IMPORTED_MODULE_1__.RuntimeError('BadArgument', 'Invalid tickable added.');
        }
        if (!tickable.shouldIgnoreTicks()) {
            const ticks = tickable.getTicks();
            if (ticks.greaterThan(this.maxTicks)) {
                this.maxTicks = ticks.clone();
                this.maxTickable = tickable;
            }
            if (this.minTicks === undefined) {
                this.minTicks = ticks.clone();
                this.minTickable = tickable;
            }
            else if (ticks.lessThan(this.minTicks)) {
                this.minTicks = ticks.clone();
                this.minTickable = tickable;
            }
        }
        tickable.setTickContext(this);
        this.tickables.push(tickable);
        this.tickablesByVoice[voiceIndex !== null && voiceIndex !== void 0 ? voiceIndex : 0] = tickable;
        this.preFormatted = false;
        return this;
    }
    preFormat() {
        var _a;
        if (this.preFormatted)
            return this;
        for (let i = 0; i < this.tickables.length; ++i) {
            const tickable = this.tickables[i];
            tickable.preFormat();
            const metrics = tickable.getMetrics();
            // Maintain max displaced head pixels from all tickables in the context
            this.leftDisplacedHeadPx = Math.max(this.leftDisplacedHeadPx, metrics.leftDisplacedHeadPx);
            this.rightDisplacedHeadPx = Math.max(this.rightDisplacedHeadPx, metrics.rightDisplacedHeadPx);
            // Maintain the widest note for all tickables in the context
            this.notePx = Math.max(this.notePx, metrics.notePx);
            // Maintain the widest note head
            this.glyphPx = Math.max(this.glyphPx, (_a = metrics.glyphWidth) !== null && _a !== void 0 ? _a : 0);
            // Total modifier shift
            this.modLeftPx = Math.max(this.modLeftPx, metrics.modLeftPx);
            this.modRightPx = Math.max(this.modRightPx, metrics.modRightPx);
            // Total shift
            this.totalLeftPx = Math.max(this.totalLeftPx, metrics.modLeftPx + metrics.leftDisplacedHeadPx);
            this.totalRightPx = Math.max(this.totalRightPx, metrics.modRightPx + metrics.rightDisplacedHeadPx);
            // Recalculate the tick context total width
            this.width = this.notePx + this.totalLeftPx + this.totalRightPx;
        }
        return this;
    }
    postFormat() {
        if (this.postFormatted)
            return this;
        this.postFormatted = true;
        return this;
    }
    getFormatterMetrics() {
        return this.formatterMetrics;
    }
}


/***/ }),

/***/ "./src/timesignature.ts":
/*!******************************!*\
  !*** ./src/timesignature.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TimeSignature: () => (/* binding */ TimeSignature)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _glyphs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./glyphs */ "./src/glyphs.ts");
/* harmony import */ var _stavemodifier__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stavemodifier */ "./src/stavemodifier.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
//
// ## Description
// Implements time signatures glyphs for staffs
// See tables.js for the internal time signatures
// representation





const assertIsValidTimeSig = (timeSpec) => {
    const numbers = timeSpec.split('/');
    if (numbers.length !== 2 && numbers[0] !== '+' && numbers[0] !== '-') {
        throw new _util__WEBPACK_IMPORTED_MODULE_4__.RuntimeError('BadTimeSignature', `Invalid time spec: ${timeSpec}. Must be in the form "<numerator>/<denominator>"`);
    }
    numbers.forEach((number) => {
        // Characters consisting in number 0..9, '+', '-', '(' or ')'
        if (/^[0-9+\-()]+$/.test(number) === false) {
            throw new _util__WEBPACK_IMPORTED_MODULE_4__.RuntimeError('BadTimeSignature', `Invalid time spec: ${timeSpec}. Must contain valid signatures.`);
        }
    });
};
/**
 * A TimeSignature is a StaveModifier that can make its appropriate Glyphs directly from
 * a provided "timeSpec" such as "4/4", "C|" (cut time), or even something more advanced
 * such as "3/4(6/8)" or "2/4+5/8".
 */
class TimeSignature extends _stavemodifier__WEBPACK_IMPORTED_MODULE_2__.StaveModifier {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_3__.Category.TimeSignature;
    }
    constructor(timeSpec = '4/4', customPadding = 15, validateArgs = true) {
        super();
        this.timeSpec = '4/4';
        this.line = 0;
        this.isNumeric = true;
        this.topStartX = 0;
        this.botStartX = 0;
        this.lineShift = 0;
        this.topText = new _element__WEBPACK_IMPORTED_MODULE_0__.Element();
        this.botText = new _element__WEBPACK_IMPORTED_MODULE_0__.Element();
        this.validateArgs = validateArgs;
        const padding = customPadding;
        this.topLine = 1;
        this.bottomLine = 3;
        this.setPosition(_stavemodifier__WEBPACK_IMPORTED_MODULE_2__.StaveModifierPosition.BEGIN);
        this.setTimeSig(timeSpec);
        this.setPadding(padding);
    }
    static getTimeSigCode(key, smallSig = false) {
        let code = _glyphs__WEBPACK_IMPORTED_MODULE_1__.Glyphs.null;
        switch (key) {
            case 'C':
                code = _glyphs__WEBPACK_IMPORTED_MODULE_1__.Glyphs.timeSigCommon;
                break;
            case 'C|':
                code = _glyphs__WEBPACK_IMPORTED_MODULE_1__.Glyphs.timeSigCutCommon;
                break;
            case '+':
                code = smallSig ? _glyphs__WEBPACK_IMPORTED_MODULE_1__.Glyphs.timeSigPlusSmall : _glyphs__WEBPACK_IMPORTED_MODULE_1__.Glyphs.timeSigPlus;
                break;
            case '-':
                code = _glyphs__WEBPACK_IMPORTED_MODULE_1__.Glyphs.timeSigMinus;
                break;
            case '(':
                code = smallSig ? _glyphs__WEBPACK_IMPORTED_MODULE_1__.Glyphs.timeSigParensLeftSmall : _glyphs__WEBPACK_IMPORTED_MODULE_1__.Glyphs.timeSigParensLeft;
                break;
            case ')':
                code = smallSig ? _glyphs__WEBPACK_IMPORTED_MODULE_1__.Glyphs.timeSigParensRightSmall : _glyphs__WEBPACK_IMPORTED_MODULE_1__.Glyphs.timeSigParensRight;
                break;
            default:
                code = String.fromCodePoint(0xe080 + Number(key[0])) /* timeSigN = Glyphs.timeSig0 + N */;
                break;
        }
        return code;
    }
    /**
     * Returns a new TimeSignatureGlyph (a Glyph subclass that knows how to draw both
     * top and bottom digits along with plus signs etc.)
     */
    makeTimeSignatureGlyph(topDigits, botDigits) {
        // note that 'code' is ignored by TimeSignatureGlyph when rendering.
        let txt = '';
        let topWidth = 0;
        let height = 0;
        for (let i = 0; i < topDigits.length; ++i) {
            const code = TimeSignature.getTimeSigCode(topDigits[i], botDigits.length > 0);
            txt += code;
        }
        this.topText.setText(txt);
        topWidth = this.topText.getWidth();
        height = this.topText.getHeight();
        let botWidth = 0;
        txt = '';
        for (let i = 0; i < botDigits.length; ++i) {
            const code = TimeSignature.getTimeSigCode(botDigits[i], true);
            txt += code;
        }
        this.botText.setText(txt);
        botWidth = this.botText.getWidth();
        height = Math.max(height, this.botText.getHeight());
        // If the height of the digits is more than two staff spaces (20), shift to the next line
        // in order to center the digits on lines 1 and 5 rather than 2 and 4.
        this.lineShift = height > 24 ? 1 : 0;
        this.width = Math.max(topWidth, botWidth);
        this.topStartX = (this.width - topWidth) / 2.0;
        this.botStartX = (this.width - botWidth) / 2.0;
    }
    /**
     * Set a new time signature specification without changing customPadding, etc.
     *
     * The getter for this is `getTimeSpec` not `getTimeSig`.
     */
    setTimeSig(timeSpec) {
        var _a, _b;
        this.timeSpec = timeSpec;
        if (timeSpec === 'C' || timeSpec === 'C|') {
            const code = TimeSignature.getTimeSigCode(timeSpec);
            this.line = 2;
            this.text = code;
            this.isNumeric = false;
        }
        else {
            if (this.validateArgs) {
                assertIsValidTimeSig(timeSpec);
            }
            const parts = timeSpec.split('/');
            this.line = 0;
            this.isNumeric = true;
            this.makeTimeSignatureGlyph((_a = parts[0]) !== null && _a !== void 0 ? _a : '', (_b = parts[1]) !== null && _b !== void 0 ? _b : '');
        }
        return this;
    }
    /**
     * Return the timeSpec (such as '4/4' or 'C|' or even '2/4+3/8') of the TimeSignature
     */
    getTimeSpec() {
        return this.timeSpec;
    }
    /**
     * Return the staff line that the TimeSignature sits on.  Generally 0 for numerator/
     * denominator time signatures such as 3/4 and 2 for cut/common.
     */
    getLine() {
        return this.line;
    }
    /**
     * Set the line number that the TimeSignature sits on.  Half-values are acceptable
     * for spaces, etc. Can be altered, for instance, for signatures that sit above the
     * staff in large orchestral scores.
     */
    setLine(line) {
        this.line = line;
    }
    /**
     * Return a boolean on whether this TimeSignature is drawn with one or more numbers
     * (such as 4/4) or not (as in cut time).
     */
    getIsNumeric() {
        return this.isNumeric;
    }
    /**
     * Set whether this TimeSignature is drawn with one or more numbers.
     */
    setIsNumeric(isNumeric) {
        this.isNumeric = isNumeric;
    }
    /**
     * Draw the time signature on a Stave using its RenderContext.  Both setStave
     * and setContext must already be run.
     */
    draw() {
        const stave = this.checkStave();
        const ctx = stave.checkContext();
        this.setRendered();
        this.drawAt(ctx, stave, this.x);
    }
    drawAt(ctx, stave, x) {
        this.setRendered();
        this.applyStyle(ctx);
        ctx.openGroup('timesignature', this.getAttribute('id'));
        if (this.isNumeric) {
            let startX = x + this.topStartX;
            let y = 0;
            if (this.botText.getText().length > 0)
                y = stave.getYForLine(this.topLine - this.lineShift);
            else
                y = (stave.getYForLine(this.topLine) + stave.getYForLine(this.bottomLine)) / 2;
            this.topText.renderText(ctx, startX, y);
            startX = x + this.botStartX;
            y = stave.getYForLine(this.bottomLine + this.lineShift);
            this.botText.renderText(ctx, startX, y);
        }
        else {
            this.renderText(ctx, x - this.x, stave.getYForLine(this.line));
        }
        ctx.closeGroup();
        this.restoreStyle(ctx);
    }
}


/***/ }),

/***/ "./src/timesignote.ts":
/*!****************************!*\
  !*** ./src/timesignote.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TimeSigNote: () => (/* binding */ TimeSigNote)
/* harmony export */ });
/* harmony import */ var _note__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./note */ "./src/note.ts");
/* harmony import */ var _timesignature__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./timesignature */ "./src/timesignature.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// @author: Taehoon Moon 2014



class TimeSigNote extends _note__WEBPACK_IMPORTED_MODULE_0__.Note {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_2__.Category.TimeSigNote;
    }
    constructor(timeSpec, customPadding) {
        super({ duration: 'b' });
        this.timeSig = new _timesignature__WEBPACK_IMPORTED_MODULE_1__.TimeSignature(timeSpec, customPadding);
        this.setWidth(this.timeSig.getWidth());
        // Note properties
        this.ignoreTicks = true;
    }
    /* Overridden to ignore */
    // eslint-disable-next-line
    addToModifierContext(mc) {
        // DO NOTHING.
        return this;
    }
    preFormat() {
        this.preFormatted = true;
        return this;
    }
    draw() {
        const stave = this.checkStave();
        const ctx = this.checkContext();
        this.setRendered();
        this.timeSig.drawAt(ctx, stave, this.getAbsoluteX());
    }
}


/***/ }),

/***/ "./src/tremolo.ts":
/*!************************!*\
  !*** ./src/tremolo.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tremolo: () => (/* binding */ Tremolo)
/* harmony export */ });
/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./metrics */ "./src/metrics.ts");
/* harmony import */ var _modifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifier */ "./src/modifier.ts");
/* harmony import */ var _stem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stem */ "./src/stem.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// @author Mike Corrigan <corrigan@gmail.com>
// MIT License




/** Tremolo implements tremolo notation. */
class Tremolo extends _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_3__.Category.Tremolo;
    }
    /**
     * @param num number of bars
     */
    constructor(num) {
        super();
        this.num = num;
        this.position = _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.CENTER;
        this.text = '\uE220' /*tremolo1*/;
    }
    /** Draw the tremolo on the rendering context. */
    draw() {
        const ctx = this.checkContext();
        const note = this.checkAttachedNote();
        this.setRendered();
        const stemDirection = note.getStemDirection();
        const scale = note.getFontScale();
        const ySpacing = _metrics__WEBPACK_IMPORTED_MODULE_0__.Metrics.get(`Tremolo.spacing`) * stemDirection * scale;
        const x = note.getAbsoluteX() + (stemDirection === _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.UP ? note.getGlyphWidth() - _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.WIDTH / 2 : _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.WIDTH / 2);
        let y = note.getStemExtents().topY + (this.num <= 3 ? ySpacing : 0);
        this.fontInfo.size = _metrics__WEBPACK_IMPORTED_MODULE_0__.Metrics.get(`Tremolo.fontSize`) * scale;
        for (let i = 0; i < this.num; ++i) {
            this.renderText(ctx, x, y);
            y += ySpacing;
        }
    }
}


/***/ }),

/***/ "./src/tuning.ts":
/*!***********************!*\
  !*** ./src/tuning.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tuning: () => (/* binding */ Tuning)
/* harmony export */ });
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License


/** `Tuning` implements varies types of tunings for tablature. */
class Tuning {
    static get names() {
        return {
            standard: 'E/5,B/4,G/4,D/4,A/3,E/3',
            dagdad: 'D/5,A/4,G/4,D/4,A/3,D/3',
            dropd: 'E/5,B/4,G/4,D/4,A/3,D/3',
            eb: 'Eb/5,Bb/4,Gb/4,Db/4,Ab/3,Db/3',
            standardBanjo: 'D/5,B/4,G/4,D/4,G/5',
        };
    }
    /**
     * Constructor.
     * @param tuningString tuning name (eg. 'dagdad') or comma separated note strings
     */
    constructor(tuningString = 'E/5,B/4,G/4,D/4,A/3,E/3,B/2,E/2') {
        this.tuningValues = [];
        // Default to standard tuning.
        this.setTuning(tuningString);
    }
    /** Return the note number associated to the note string. */
    noteToInteger(noteString) {
        var _a;
        return (_a = _tables__WEBPACK_IMPORTED_MODULE_0__.Tables.keyProperties(noteString).intValue) !== null && _a !== void 0 ? _a : -1;
    }
    /**
     * Set tuning identified by tuning name (eg. 'dagdad')
     * @param tuningString tuning name (eg. 'dagdad') or comma separated note strings
     */
    setTuning(tuningString) {
        if (Tuning.names[tuningString]) {
            tuningString = Tuning.names[tuningString];
        }
        this.tuningValues = [];
        const keys = tuningString.split(/\s*,\s*/);
        if (keys.length === 0) {
            throw new _util__WEBPACK_IMPORTED_MODULE_1__.RuntimeError('BadArguments', `Invalid tuning string: ${tuningString}`);
        }
        for (let i = 0; i < keys.length; ++i) {
            this.tuningValues[i] = this.noteToInteger(keys[i]);
        }
    }
    /** Return the note number associated with a tablature string. */
    getValueForString(stringNum) {
        const s = Number(stringNum);
        if (s < 1 || s > this.tuningValues.length) {
            throw new _util__WEBPACK_IMPORTED_MODULE_1__.RuntimeError('BadArguments', `String number must be between 1 and ${this.tuningValues.length}:${stringNum}`);
        }
        return this.tuningValues[s - 1];
    }
    /** Return the note number associated with a tablature string and fret. */
    getValueForFret(fretNum, stringNum) {
        const stringValue = this.getValueForString(stringNum);
        const f = Number(fretNum);
        if (f < 0) {
            throw new _util__WEBPACK_IMPORTED_MODULE_1__.RuntimeError('BadArguments', `Fret number must be 0 or higher: ${fretNum}`);
        }
        return stringValue + f;
    }
    /** Return the note string associated with tablature string and fret. */
    getNoteForFret(fretNum, stringNum) {
        const noteValue = this.getValueForFret(fretNum, stringNum);
        const octave = Math.floor(noteValue / 12);
        const value = noteValue % 12;
        return `${_tables__WEBPACK_IMPORTED_MODULE_0__.Tables.integerToNote(value)}/${octave}`;
    }
}


/***/ }),

/***/ "./src/tuplet.ts":
/*!***********************!*\
  !*** ./src/tuplet.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tuplet: () => (/* binding */ Tuplet),
/* harmony export */   TupletLocation: () => (/* binding */ TupletLocation)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatter */ "./src/formatter.ts");
/* harmony import */ var _stem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stem */ "./src/stem.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
/**
 * ## Description
 *
 * Create a new tuplet from the specified notes. The notes must
 * be part of the same voice. If they are of different rhythmic
 * values, then options.numNotes must be set.
 *
 * @constructor
 * @param {Array.<Vex.Flow.StaveNote>} A set of notes: staveNotes,
 *   notes, etc... any class that inherits stemmableNote at some
 *   point in its prototype chain.
 * @param options: object {
 *
 *   numNotes: fit this many notes into...
 *   notesOccupied: ...the space of this many notes
 *
 *       Together, these two properties make up the tuplet ratio
 *     in the form of numNotes : notesOccupied.
 *       numNotes defaults to the number of notes passed in, so
 *     it is important that if you omit this property, all of
 *     the notes passed should be of the same note value.
 *       notesOccupied defaults to 2 -- so you should almost
 *     certainly pass this parameter for anything other than
 *     a basic triplet.
 *
 *   location:
 *     default 1, which is above the notes:  3 
 *      -1 is below the notes  3 
 *
 *   bracketed: boolean, draw a bracket around the tuplet number
 *     when true:  3    when false: 3
 *     defaults to true if notes are not beamed, false otherwise
 *
 *   ratioed: boolean
 *     when true:  7:8 , when false:  7 
 *     defaults to true if the difference between numNotes and
 *     notesOccupied is greater than 1.
 *
 *   yOffset: int, default 0
 *     manually offset a tuplet, for instance to avoid collisions
 *     with articulations, etc...
 * }
 */






var TupletLocation;
(function (TupletLocation) {
    TupletLocation[TupletLocation["BOTTOM"] = -1] = "BOTTOM";
    TupletLocation[TupletLocation["TOP"] = 1] = "TOP";
})(TupletLocation || (TupletLocation = {}));
class Tuplet extends _element__WEBPACK_IMPORTED_MODULE_0__.Element {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_4__.Category.Tuplet;
    }
    static get LOCATION_TOP() {
        return TupletLocation.TOP;
    }
    static get LOCATION_BOTTOM() {
        return TupletLocation.BOTTOM;
    }
    static get NESTING_OFFSET() {
        return 15;
    }
    constructor(notes, options = {}) {
        super();
        if (!notes || !notes.length) {
            throw new _util__WEBPACK_IMPORTED_MODULE_5__.RuntimeError('BadArguments', 'No notes provided for tuplet.');
        }
        this.options = options;
        this.notes = notes;
        this.numNotes = this.options.numNotes !== undefined ? this.options.numNotes : notes.length;
        this.notesOccupied = this.options.notesOccupied || 2;
        if (this.options.bracketed !== undefined) {
            this.bracketed = this.options.bracketed;
        }
        else {
            this.bracketed = notes.some((note) => !note.hasBeam());
        }
        this.ratioed =
            this.options.ratioed !== undefined ? this.options.ratioed : Math.abs(this.notesOccupied - this.numNotes) > 1;
        this.textElement = new _element__WEBPACK_IMPORTED_MODULE_0__.Element('Tuplet');
        this.setTupletLocation(this.options.location || Tuplet.LOCATION_TOP);
        _formatter__WEBPACK_IMPORTED_MODULE_1__.Formatter.AlignRestsToNotes(notes, true, true);
        this.resolveGlyphs();
        this.attach();
    }
    attach() {
        for (let i = 0; i < this.notes.length; i++) {
            const note = this.notes[i];
            note.setTuplet(this);
        }
    }
    detach() {
        for (let i = 0; i < this.notes.length; i++) {
            const note = this.notes[i];
            note.resetTuplet(this);
        }
    }
    /**
     * Set whether or not the bracket is drawn.
     */
    setBracketed(bracketed) {
        this.bracketed = !!bracketed;
        return this;
    }
    /**
     * Set whether or not the ratio is shown.
     */
    setRatioed(ratioed) {
        this.ratioed = !!ratioed;
        return this;
    }
    /**
     * Set the tuplet indicator to be displayed either on the top or bottom of the stave.
     */
    setTupletLocation(location) {
        if (location !== Tuplet.LOCATION_TOP && location !== Tuplet.LOCATION_BOTTOM) {
            // eslint-disable-next-line
            console.warn(`Invalid tuplet location [${location}]. Using Tuplet.LOCATION_TOP.`);
            location = Tuplet.LOCATION_TOP;
        }
        this.location = location;
        return this;
    }
    getNotes() {
        return this.notes;
    }
    getNoteCount() {
        return this.numNotes;
    }
    getNotesOccupied() {
        return this.notesOccupied;
    }
    setNotesOccupied(notes) {
        this.detach();
        this.notesOccupied = notes;
        this.resolveGlyphs();
        this.attach();
    }
    resolveGlyphs() {
        let numerator = '';
        let denominator = '';
        let n = this.numNotes;
        while (n >= 1) {
            numerator = String.fromCharCode(0xe880 /* tuplet0 */ + (n % 10)) + numerator;
            n = Math.floor(n / 10);
        }
        if (this.ratioed) {
            n = this.notesOccupied;
            while (n >= 1) {
                denominator = String.fromCharCode(0xe880 /* tuplet0 */ + (n % 10)) + denominator;
                n = Math.floor(n / 10);
            }
            denominator = '\uE88A' /* tupletColon */ + denominator;
        }
        this.textElement.setText(numerator + denominator);
    }
    // determine how many tuplets are nested within this tuplet
    // on the same side (above/below), to calculate a y
    // offset for this tuplet:
    getNestedTupletCount() {
        const location = this.location;
        const firstNote = this.notes[0];
        let maxTupletCount = countTuplets(firstNote, location);
        let minTupletCount = countTuplets(firstNote, location);
        // Count the tuplets that are on the same side (above/below)
        // as this tuplet:
        function countTuplets(note, location) {
            return note.getTupletStack().filter((tuplet) => tuplet.location === location).length;
        }
        this.notes.forEach((note) => {
            const tupletCount = countTuplets(note, location);
            maxTupletCount = tupletCount > maxTupletCount ? tupletCount : maxTupletCount;
            minTupletCount = tupletCount < minTupletCount ? tupletCount : minTupletCount;
        });
        return maxTupletCount - minTupletCount;
    }
    // determine the y position of the tuplet:
    getYPosition() {
        var _a;
        // offset the tuplet for any nested tuplets between
        // it and the notes:
        const nestedTupletYOffset = this.getNestedTupletCount() * Tuplet.NESTING_OFFSET * -this.location;
        // offset the tuplet for any manual yOffset:
        const yOffset = (_a = this.options.yOffset) !== null && _a !== void 0 ? _a : 0;
        // now iterate through the notes and find our highest
        // or lowest locations, to form a base yPosition
        const firstNote = this.notes[0];
        let yPosition;
        if (this.location === Tuplet.LOCATION_TOP) {
            yPosition = firstNote.checkStave().getYForLine(0) - 1.5 * _tables__WEBPACK_IMPORTED_MODULE_3__.Tables.STAVE_LINE_DISTANCE;
            // check modifiers above note to see if they will collide with tuplet beam
            for (let i = 0; i < this.notes.length; ++i) {
                const note = this.notes[i];
                let modLines = 0;
                const mc = note.getModifierContext();
                if (mc) {
                    modLines = Math.max(modLines, mc.getState().topTextLine);
                }
                const modY = note.getYForTopText(modLines) - 2 * _tables__WEBPACK_IMPORTED_MODULE_3__.Tables.STAVE_LINE_DISTANCE;
                if (note.hasStem() || note.isRest()) {
                    const topY = note.getStemDirection() === _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.UP
                        ? note.getStemExtents().topY - _tables__WEBPACK_IMPORTED_MODULE_3__.Tables.STAVE_LINE_DISTANCE
                        : note.getStemExtents().baseY - 2 * _tables__WEBPACK_IMPORTED_MODULE_3__.Tables.STAVE_LINE_DISTANCE;
                    yPosition = Math.min(topY, yPosition);
                    if (modLines > 0) {
                        yPosition = Math.min(modY, yPosition);
                    }
                }
            }
        }
        else {
            let lineCheck = 4; // tuplet default on line 4
            // check modifiers below note to see if they will collide with tuplet beam
            this.notes.forEach((nn) => {
                const mc = nn.getModifierContext();
                if (mc) {
                    lineCheck = Math.max(lineCheck, mc.getState().textLine + 1);
                }
            });
            yPosition = firstNote.checkStave().getYForLine(lineCheck) + 2 * _tables__WEBPACK_IMPORTED_MODULE_3__.Tables.STAVE_LINE_DISTANCE;
            for (let i = 0; i < this.notes.length; ++i) {
                if (this.notes[i].hasStem() || this.notes[i].isRest()) {
                    const bottomY = this.notes[i].getStemDirection() === _stem__WEBPACK_IMPORTED_MODULE_2__.Stem.UP
                        ? this.notes[i].getStemExtents().baseY + 2 * _tables__WEBPACK_IMPORTED_MODULE_3__.Tables.STAVE_LINE_DISTANCE
                        : this.notes[i].getStemExtents().topY + _tables__WEBPACK_IMPORTED_MODULE_3__.Tables.STAVE_LINE_DISTANCE;
                    if (bottomY > yPosition) {
                        yPosition = bottomY;
                    }
                }
            }
        }
        return yPosition + nestedTupletYOffset + yOffset;
    }
    draw() {
        const ctx = this.checkContext();
        let xPos = 0;
        let yPos = 0;
        this.setRendered();
        // determine x value of left bound of tuplet
        const firstNote = this.notes[0];
        const lastNote = this.notes[this.notes.length - 1];
        if (!this.bracketed) {
            xPos = firstNote.getStemX();
            this.width = lastNote.getStemX() - xPos;
        }
        else {
            xPos = firstNote.getTieLeftX() - 5;
            this.width = lastNote.getTieRightX() - xPos + 5;
        }
        // determine y value for tuplet
        yPos = this.getYPosition();
        const notationCenterX = xPos + this.width / 2;
        const notationStartX = notationCenterX - this.textElement.getWidth() / 2;
        // draw bracket if the tuplet is not beamed
        if (this.bracketed) {
            const lineWidth = this.width / 2 - this.textElement.getWidth() / 2 - 5;
            // only draw the bracket if it has positive length
            if (lineWidth > 0) {
                ctx.fillRect(xPos, yPos, lineWidth, 1);
                ctx.fillRect(xPos + this.width / 2 + this.textElement.getWidth() / 2 + 5, yPos, lineWidth, 1);
                ctx.fillRect(xPos, yPos + (this.location === Tuplet.LOCATION_BOTTOM ? 1 : 0), 1, this.location * 10);
                ctx.fillRect(xPos + this.width, yPos + (this.location === Tuplet.LOCATION_BOTTOM ? 1 : 0), 1, this.location * 10);
            }
        }
        // draw text
        this.textElement.renderText(ctx, notationStartX, yPos + this.textElement.getHeight() / 2);
    }
}


/***/ }),

/***/ "./src/typeguard.ts":
/*!**************************!*\
  !*** ./src/typeguard.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Category: () => (/* binding */ Category),
/* harmony export */   isAccidental: () => (/* binding */ isAccidental),
/* harmony export */   isAnnotation: () => (/* binding */ isAnnotation),
/* harmony export */   isBarline: () => (/* binding */ isBarline),
/* harmony export */   isCategory: () => (/* binding */ isCategory),
/* harmony export */   isDot: () => (/* binding */ isDot),
/* harmony export */   isGraceNote: () => (/* binding */ isGraceNote),
/* harmony export */   isGraceNoteGroup: () => (/* binding */ isGraceNoteGroup),
/* harmony export */   isNote: () => (/* binding */ isNote),
/* harmony export */   isRenderContext: () => (/* binding */ isRenderContext),
/* harmony export */   isStaveNote: () => (/* binding */ isStaveNote),
/* harmony export */   isStemmableNote: () => (/* binding */ isStemmableNote),
/* harmony export */   isTabNote: () => (/* binding */ isTabNote)
/* harmony export */ });
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// @author Ron B. Yeh
// MIT License
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Use instead of `instanceof` as a more flexible type guard.
 * @param obj check if this object's CATEGORY matches the provided category.
 * @param category a string representing a category of VexFlow objects.
 * @param checkAncestors defaults to `true`, so we walk up the prototype chain to look for a matching `CATEGORY`.
 *        If `false`, we do not check the superclass or other ancestors.
 * @returns true if `obj` has a static `CATEGORY` property that matches `category`.
 */
function isCategory(obj, category, checkAncestors = true) {
    // obj is undefined, a number, a primitive string, or null.
    if (typeof obj !== 'object' || obj === null) {
        return false;
    }
    // `obj.constructor` is a reference to the constructor function that created the `obj` instance.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor
    let constructorFcn = obj.constructor;
    // Check if the object's static .CATEGORY matches the provided category.
    if (checkAncestors) {
        // Walk up the prototype chain to look for a matching obj.constructor.CATEGORY.
        while (obj !== null) {
            constructorFcn = obj.constructor;
            if ('CATEGORY' in constructorFcn && constructorFcn.CATEGORY === category) {
                return true;
            }
            obj = Object.getPrototypeOf(obj);
        }
        return false;
    }
    else {
        // Do not walk up the prototype chain. Just check this particular object's static .CATEGORY string.
        return 'CATEGORY' in constructorFcn && constructorFcn.CATEGORY === category;
    }
}
const isAccidental = (obj) => isCategory(obj, Category.Accidental);
const isAnnotation = (obj) => isCategory(obj, Category.Annotation);
const isBarline = (obj) => isCategory(obj, Category.Barline);
const isDot = (obj) => isCategory(obj, Category.Dot);
const isGraceNote = (obj) => isCategory(obj, Category.GraceNote);
const isGraceNoteGroup = (obj) => isCategory(obj, Category.GraceNoteGroup);
const isNote = (obj) => isCategory(obj, Category.Note);
const isRenderContext = (obj) => isCategory(obj, Category.RenderContext);
const isStaveNote = (obj) => isCategory(obj, Category.StaveNote);
const isStemmableNote = (obj) => isCategory(obj, Category.StemmableNote);
const isTabNote = (obj) => isCategory(obj, Category.TabNote);
// 'const' enums are erased by the TypeScript compiler. The string values are inlined at all the use sites.
// See: https://www.typescriptlang.org/docs/handbook/enums.html#const-enums
var Category;
(function (Category) {
    Category["Accidental"] = "Accidental";
    Category["Annotation"] = "Annotation";
    Category["Articulation"] = "Articulation";
    Category["Barline"] = "Barline";
    Category["BarNote"] = "BarNote";
    Category["Beam"] = "Beam";
    Category["Bend"] = "Bend";
    Category["ChordSymbol"] = "ChordSymbol";
    Category["Clef"] = "Clef";
    Category["ClefNote"] = "ClefNote";
    Category["Crescendo"] = "Crescendo";
    Category["Curve"] = "Curve";
    Category["Dot"] = "Dot";
    Category["Element"] = "Element";
    Category["Fraction"] = "Fraction";
    Category["FretHandFinger"] = "FretHandFinger";
    Category["GhostNote"] = "GhostNote";
    Category["Glyph"] = "Glyph";
    Category["GlyphNote"] = "GlyphNote";
    Category["GraceNote"] = "GraceNote";
    Category["GraceNoteGroup"] = "GraceNoteGroup";
    Category["GraceTabNote"] = "GraceTabNote";
    Category["KeySignature"] = "KeySignature";
    Category["KeySigNote"] = "KeySigNote";
    Category["Modifier"] = "Modifier";
    Category["MultiMeasureRest"] = "MultiMeasureRest";
    Category["Note"] = "Note";
    Category["NoteHead"] = "NoteHead";
    Category["NoteSubGroup"] = "NoteSubGroup";
    Category["Ornament"] = "Ornament";
    Category["Parenthesis"] = "Parenthesis";
    Category["PedalMarking"] = "PedalMarking";
    Category["RenderContext"] = "RenderContext";
    Category["RepeatNote"] = "RepeatNote";
    Category["Repetition"] = "Repetition";
    Category["Stave"] = "Stave";
    Category["StaveConnector"] = "StaveConnector";
    Category["StaveHairpin"] = "StaveHairpin";
    Category["StaveLine"] = "StaveLine";
    Category["StaveModifier"] = "StaveModifier";
    Category["StaveNote"] = "StaveNote";
    Category["StaveSection"] = "StaveSection";
    Category["StaveTempo"] = "StaveTempo";
    Category["StaveText"] = "StaveText";
    Category["StaveTie"] = "StaveTie";
    Category["Stem"] = "Stem";
    Category["StemmableNote"] = "StemmableNote";
    Category["StringNumber"] = "StringNumber";
    Category["Stroke"] = "Stroke";
    Category["System"] = "System";
    Category["TabNote"] = "TabNote";
    Category["TabSlide"] = "TabSlide";
    Category["TabStave"] = "TabStave";
    Category["TabTie"] = "TabTie";
    Category["TextBracket"] = "TextBracket";
    Category["TextDynamics"] = "TextDynamics";
    Category["TextNote"] = "TextNote";
    Category["Tickable"] = "Tickable";
    Category["TimeSignature"] = "TimeSignature";
    Category["TimeSigNote"] = "TimeSigNote";
    Category["Tremolo"] = "Tremolo";
    Category["Tuplet"] = "Tuplet";
    Category["Vibrato"] = "Vibrato";
    Category["VibratoBracket"] = "VibratoBracket";
    Category["Voice"] = "Voice";
    Category["Volta"] = "Volta";
})(Category || (Category = {}));


/***/ }),

/***/ "./src/util.ts":
/*!*********************!*\
  !*** ./src/util.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RuntimeError: () => (/* binding */ RuntimeError),
/* harmony export */   defined: () => (/* binding */ defined),
/* harmony export */   globalObject: () => (/* binding */ globalObject),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   midLine: () => (/* binding */ midLine),
/* harmony export */   normalizeAngle: () => (/* binding */ normalizeAngle),
/* harmony export */   prefix: () => (/* binding */ prefix),
/* harmony export */   sumArray: () => (/* binding */ sumArray),
/* harmony export */   upperFirst: () => (/* binding */ upperFirst),
/* harmony export */   warn: () => (/* binding */ warn)
/* harmony export */ });
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
// Note: Keep this module free of imports to reduce the chance of circular dependencies.
/** `RuntimeError` will be thrown by VexFlow classes in case of error. */
class RuntimeError extends Error {
    constructor(code, message = '') {
        super('[RuntimeError] ' + code + ': ' + message);
        this.code = code;
    }
}
/** VexFlow can be used outside of the browser (e.g., Node) where `window` may not be defined. */
// eslint-disable-next-line
function globalObject() {
    if (typeof globalThis !== 'undefined') {
        return globalThis;
    }
    if (typeof self !== 'undefined') {
        return self;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    if (typeof __webpack_require__.g !== 'undefined') {
        return __webpack_require__.g;
    }
    return Function('return this')();
}
/**
 * Check that `x` is of type `T` and not `undefined`.
 * If `x` is `undefined`, throw a RuntimeError with the optionally provided error code and message.
 */
function defined(x, code = 'undefined', message = '') {
    if (x === undefined) {
        throw new RuntimeError(code, message);
    }
    return x;
}
/** Default log function sends all arguments to console. */
// eslint-disable-next-line
function log(block, ...args) {
    if (!args)
        return;
    const line = Array.prototype.slice.call(args).join(' ');
    globalObject().console.log(block + ': ' + line);
}
/** Dump warning to console. */
// eslint-disable-next-line
function warn(...args) {
    const line = args.join(' ');
    const err = new Error();
    globalObject().console.log('Warning: ', line, err.stack);
}
/** Round number to nearest fractional value (`.5`, `.25`, etc.) */
function roundN(x, n) {
    return x % n >= n / 2 ? parseInt(`${x / n}`, 10) * n + n : parseInt(`${x / n}`, 10) * n;
}
/** Locate the mid point between stave lines. Returns a fractional line if a space. */
function midLine(a, b) {
    let midLine = b + (a - b) / 2;
    if (midLine % 2 > 0) {
        midLine = roundN(midLine * 10, 5) / 10;
    }
    return midLine;
}
/**
 * Used by various classes (e.g., SVGContext) to provide a
 * unique prefix to element names (or other keys in shared namespaces).
 */
function prefix(text) {
    return `vf-${text}`;
}
/**
 * @param s
 * @returns `s` with the first letter capitalized.
 */
function upperFirst(s = '') {
    return s.charAt(0).toUpperCase() + s.slice(1);
}
/**
 * Convert an arbitrary angle in radians to the equivalent one in the range [0, pi).
 */
function normalizeAngle(a) {
    a = a % (2 * Math.PI);
    if (a < 0) {
        a += 2 * Math.PI;
    }
    return a;
}
/**
 * Return the sum of an array of numbers.
 */
function sumArray(arr) {
    return arr.reduce((a, b) => a + b, 0);
}


/***/ }),

/***/ "./src/vex.ts":
/*!********************!*\
  !*** ./src/vex.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Vex: () => (/* binding */ Vex)
/* harmony export */ });
/* harmony import */ var _flow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./flow */ "./src/flow.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
//
// Utility methods used by the rest of the VexFlow codebase.


class Vex {
    // Users of `Vex.forEach(a, fn)` should use `Array.prototype.forEach()` instead.
    // static forEach<T>(arr: T[], callbackFn: (value: T, index: number, array: T[]) => void) {
    //   arr.forEach(callbackFn);
    // }
    /**
     * Take `arr` and return a new list consisting of the sorted, unique,
     * contents of arr. Does not modify `arr`.
     */
    // eslint-disable-next-line
    static sortAndUnique(arr, cmp, eq) {
        if (arr.length > 1) {
            const newArr = [];
            let last;
            arr.sort(cmp);
            for (let i = 0; i < arr.length; ++i) {
                if (i === 0 || !eq(arr[i], last)) {
                    newArr.push(arr[i]);
                }
                last = arr[i];
            }
            return newArr;
        }
        else {
            return arr;
        }
    }
    /** Check if array `arr` contains `obj`. */
    // eslint-disable-next-line
    static contains(arr, obj) {
        let i = arr.length;
        while (i--) {
            if (arr[i] === obj) {
                return true;
            }
        }
        return false;
    }
    // Get the 2D Canvas context from DOM element with id `canvasId`.
    static getCanvasContext(canvasId) {
        if (!canvasId) {
            throw new _util__WEBPACK_IMPORTED_MODULE_1__.RuntimeError('BadArgument', 'Invalid canvas selector: ' + canvasId);
        }
        const canvas = document.getElementById(canvasId);
        if (!(canvas && canvas.getContext)) {
            throw new _util__WEBPACK_IMPORTED_MODULE_1__.RuntimeError('UnsupportedBrowserError', 'This browser does not support HTML5 Canvas');
        }
        return canvas.getContext('2d');
    }
    /** Benchmark. Run function `f` once and report time elapsed shifted by `s` milliseconds. */
    // eslint-disable-next-line
    static benchmark(s, f) {
        const startTime = new Date().getTime();
        f();
        const elapsed = new Date().getTime() - startTime;
        (0,_util__WEBPACK_IMPORTED_MODULE_1__.log)(s, elapsed + 'ms');
    }
    // Get stack trace.
    static stackTrace() {
        const err = new Error();
        return err.stack;
    }
}
Vex.Flow = _flow__WEBPACK_IMPORTED_MODULE_0__.Flow;


/***/ }),

/***/ "./src/vibrato.ts":
/*!************************!*\
  !*** ./src/vibrato.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Vibrato: () => (/* binding */ Vibrato)
/* harmony export */ });
/* harmony import */ var _bend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bend */ "./src/bend.ts");
/* harmony import */ var _modifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifier */ "./src/modifier.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License




/** `Vibrato` implements diverse vibratos. */
class Vibrato extends _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_3__.Category.Vibrato;
    }
    /** Arrange vibratos inside a `ModifierContext`. */
    static format(vibratos, state, context) {
        if (!vibratos || vibratos.length === 0)
            return false;
        // Vibratos are always on top.
        let textLine = state.topTextLine;
        let width = 0;
        let shift = state.rightShift - 7;
        // If there's a bend, drop the text line
        const bends = context.getMembers(_bend__WEBPACK_IMPORTED_MODULE_0__.Bend.CATEGORY);
        if (bends && bends.length > 0) {
            const bendHeight = bends.map((bb) => bb.getTextHeight()).reduce((a, b) => (a > b ? a : b)) / _tables__WEBPACK_IMPORTED_MODULE_2__.Tables.STAVE_LINE_DISTANCE;
            textLine = textLine - (bendHeight + 1);
        }
        else {
            state.topTextLine += 1;
        }
        // Format Vibratos
        for (let i = 0; i < vibratos.length; ++i) {
            const vibrato = vibratos[i];
            vibrato.setXShift(shift);
            vibrato.setTextLine(textLine);
            width += vibrato.getWidth();
            shift += width;
        }
        state.rightShift += width;
        return true;
    }
    constructor() {
        super();
        this.position = _modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.RIGHT;
        this.renderOptions = {
            code: 0xeab0,
            width: 20,
        };
        this.setVibratoWidth(this.renderOptions.width);
    }
    /** Set vibrato width in pixels. */
    setVibratoWidth(width) {
        this.renderOptions.width = width;
        this.text = String.fromCodePoint(this.renderOptions.code);
        const items = Math.round(this.renderOptions.width / this.getWidth());
        for (let i = 1; i < items; i++) {
            this.text += String.fromCodePoint(this.renderOptions.code);
        }
        return this;
    }
    /** Set vibrato code. */
    setVibratoCode(code) {
        this.renderOptions.code = code;
        return this.setVibratoWidth(this.renderOptions.width);
    }
    /** Draw the vibrato on the rendering context. */
    draw() {
        const ctx = this.checkContext();
        const note = this.checkAttachedNote();
        this.setRendered();
        const start = note.getModifierStartXY(_modifier__WEBPACK_IMPORTED_MODULE_1__.Modifier.Position.RIGHT, this.index);
        const vx = start.x;
        const vy = note.getYForTopText(this.textLine) + 5;
        this.renderText(ctx, vx, vy);
    }
}


/***/ }),

/***/ "./src/vibratobracket.ts":
/*!*******************************!*\
  !*** ./src/vibratobracket.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VibratoBracket: () => (/* binding */ VibratoBracket)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./src/util.ts");
/* harmony import */ var _vibrato__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vibrato */ "./src/vibrato.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// @author Balazs Forian-Szabo
// MIT License




// eslint-disable-next-line
function L(...args) {
    if (VibratoBracket.DEBUG)
        (0,_util__WEBPACK_IMPORTED_MODULE_2__.log)('Vex.Flow.VibratoBracket', args);
}
/** `VibratoBracket` renders vibrato effect between two notes. */
class VibratoBracket extends _element__WEBPACK_IMPORTED_MODULE_0__.Element {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_1__.Category.VibratoBracket;
    }
    /**
     * Either the stop or start note must be set, or both of them.
     * An undefined value for the start or stop note indicates that the vibrato
     * is drawn from the beginning or until the end of the stave accordingly.
     */
    constructor(bracketData) {
        super();
        this.vibrato = new _vibrato__WEBPACK_IMPORTED_MODULE_3__.Vibrato();
        if (bracketData.start)
            this.start = bracketData.start;
        if (bracketData.stop)
            this.stop = bracketData.stop;
        this.line = 1;
    }
    /** Set line position of the vibrato bracket. */
    setLine(line) {
        this.line = line;
        return this;
    }
    /** Set vibrato code. */
    setVibratoCode(code) {
        this.vibrato.setVibratoCode(code);
        return this;
    }
    /** Draw the vibrato bracket on the rendering context. */
    draw() {
        const ctx = this.checkContext();
        this.setRendered();
        const y = (this.start && this.start.checkStave().getYForTopText(this.line)) ||
            (this.stop && this.stop.checkStave().getYForTopText(this.line)) ||
            0;
        // If start note is not set then vibrato will be drawn
        // from the beginning of the stave
        const startX = (this.start && this.start.getAbsoluteX()) || (this.stop && this.stop.checkStave().getTieStartX()) || 0;
        // If stop note is not set then vibrato will be drawn
        // until the end of the stave
        const stopX = (this.stop && this.stop.getAbsoluteX() - this.stop.getWidth() - 5) ||
            (this.start && this.start.checkStave().getTieEndX() - 10) ||
            0;
        this.vibrato.setVibratoWidth(stopX - startX);
        L('Rendering VibratoBracket: startX:', startX, 'stopX:', stopX, 'y:', y);
        this.vibrato.renderText(ctx, startX, y);
    }
}
/** To enable logging for this class. Set `Vex.Flow.VibratoBracket.DEBUG` to `true`. */
VibratoBracket.DEBUG = false;


/***/ }),

/***/ "./src/voice.ts":
/*!**********************!*\
  !*** ./src/voice.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Voice: () => (/* binding */ Voice),
/* harmony export */   VoiceMode: () => (/* binding */ VoiceMode)
/* harmony export */ });
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element */ "./src/element.ts");
/* harmony import */ var _fraction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fraction */ "./src/fraction.ts");
/* harmony import */ var _tables__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tables */ "./src/tables.ts");
/* harmony import */ var _typeguard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./typeguard */ "./src/typeguard.ts");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License





var VoiceMode;
(function (VoiceMode) {
    VoiceMode[VoiceMode["STRICT"] = 1] = "STRICT";
    VoiceMode[VoiceMode["SOFT"] = 2] = "SOFT";
    VoiceMode[VoiceMode["FULL"] = 3] = "FULL";
})(VoiceMode || (VoiceMode = {}));
/**
 * `Voice` is mainly a container object to group `Tickables` for formatting.
 */
class Voice extends _element__WEBPACK_IMPORTED_MODULE_0__.Element {
    static get CATEGORY() {
        return _typeguard__WEBPACK_IMPORTED_MODULE_3__.Category.Voice;
    }
    /**
     * Modes allow the addition of ticks in three different ways:
     * - STRICT: This is the default. Ticks must fill the voice.
     * - SOFT: Ticks can be added without restrictions.
     * - FULL: Ticks do not need to fill the voice, but can't exceed the maximum tick length.
     */
    static get Mode() {
        return VoiceMode;
    }
    constructor(time) {
        super();
        this.resolutionMultiplier = 1;
        this.mode = VoiceMode.STRICT;
        this.preFormatted = false;
        this.ticksUsed = new _fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction(0, 1);
        this.largestTickWidth = 0;
        this.tickables = [];
        this.options = {
            softmaxFactor: _tables__WEBPACK_IMPORTED_MODULE_2__.Tables.SOFTMAX_FACTOR,
        };
        // Convert the `time` string into a VoiceTime object if necessary.
        let voiceTime;
        if (typeof time === 'string') {
            // Time signature shortcut: "4/4", "3/8", etc.
            const match = time.match(/(\d+)\/(\d+)/);
            if (match) {
                voiceTime = {
                    numBeats: parseInt(match[1]),
                    beatValue: parseInt(match[2]),
                };
            }
        }
        else {
            voiceTime = time;
        }
        // Default time signature is 4/4.
        this.time = Object.assign({ numBeats: 4, beatValue: 4, resolution: _tables__WEBPACK_IMPORTED_MODULE_2__.Tables.RESOLUTION }, voiceTime);
        // Recalculate total ticks.
        this.totalTicks = new _fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction(this.time.numBeats * (this.time.resolution / this.time.beatValue), 1);
        // until tickables are added, the smallestTickCount is the same as the stated totalTicks duration.
        this.smallestTickCount = this.totalTicks.clone();
    }
    /** Get the total ticks in the voice. */
    getTotalTicks() {
        return this.totalTicks;
    }
    /** Get the total ticks used in the voice by all the tickables. */
    getTicksUsed() {
        return this.ticksUsed;
    }
    /** Get the largest width of all the tickables. */
    getLargestTickWidth() {
        return this.largestTickWidth;
    }
    /** Get the tick count for the shortest tickable */
    getSmallestTickCount() {
        return this.smallestTickCount;
    }
    /** Get the tickables in the voice. */
    getTickables() {
        return this.tickables;
    }
    /** Get the voice mode (Voice.Mode.SOFT, STRICT, or FULL) */
    getMode() {
        return this.mode;
    }
    /**
     * Set the voice mode.
     * @param mode value from `VoiceMode` or Voice.Mode
     */
    setMode(mode) {
        this.mode = mode;
        return this;
    }
    /** Get the resolution multiplier for the voice. */
    getResolutionMultiplier() {
        return this.resolutionMultiplier;
    }
    /** Get the actual tick resolution for the voice. */
    getActualResolution() {
        return this.resolutionMultiplier * this.time.resolution;
    }
    /** Set the voice's stave. */
    setStave(stave) {
        this.stave = stave;
        return this;
    }
    getStave() {
        return this.stave;
    }
    /** Get the bounding box for the voice. */
    getBoundingBox() {
        const boundingBox = this.tickables[0].getBoundingBox();
        for (let i = 1; i < this.tickables.length; ++i) {
            const tickable = this.tickables[i];
            if (!tickable.getStave() && this.stave)
                tickable.setStave(this.stave);
            const bb = tickable.getBoundingBox();
            boundingBox.mergeWith(bb);
        }
        return boundingBox;
    }
    /** Set the voice mode to strict or soft. */
    setStrict(strict) {
        this.mode = strict ? VoiceMode.STRICT : VoiceMode.SOFT;
        return this;
    }
    /** Determine if the voice is complete according to the voice mode. */
    isComplete() {
        if (this.mode === VoiceMode.STRICT || this.mode === VoiceMode.FULL) {
            return this.ticksUsed.equals(this.totalTicks);
        }
        else {
            return true;
        }
    }
    /**
     * We use softmax to layout the tickables proportional to the exponent of
     * their duration. The softmax factor is used to determine the 'linearness' of
     * the layout.
     *
     * The softmax of all the tickables in this voice should sum to 1.
     */
    setSoftmaxFactor(factor) {
        this.options.softmaxFactor = factor;
        this.expTicksUsed = 0; // reset
        return this;
    }
    /**
     * Calculate the sum of the exponents of all the ticks in this voice to use
     * as the denominator of softmax.  (It is not the sum of the softmax(t) over all tickables)
     *
     * Note that the "exp" of "expTicksUsed" stands for "expontential" ticks used,
     * not "expected" ticks used.
     */
    reCalculateExpTicksUsed() {
        const totalTicks = this.ticksUsed.value();
        const exp = (tickable) => Math.pow(this.options.softmaxFactor, tickable.getTicks().value() / totalTicks);
        this.expTicksUsed = (0,_util__WEBPACK_IMPORTED_MODULE_4__.sumArray)(this.tickables.map(exp));
        return this.expTicksUsed;
    }
    /** Get the softmax-scaled value of a tick duration. 'tickValue' is a number. */
    softmax(tickValue) {
        if (!this.expTicksUsed) {
            this.expTicksUsed = this.reCalculateExpTicksUsed();
        }
        const totalTicks = this.ticksUsed.value();
        const exp = (v) => Math.pow(this.options.softmaxFactor, v / totalTicks);
        const sm = exp(tickValue) / this.expTicksUsed;
        return sm;
    }
    /** Add a tickable to the voice. */
    addTickable(tickable) {
        if (!tickable.shouldIgnoreTicks()) {
            const ticks = tickable.getTicks();
            // Update the total ticks for this line.
            this.ticksUsed.add(ticks);
            this.expTicksUsed = 0; // reset
            if ((this.mode === VoiceMode.STRICT || this.mode === VoiceMode.FULL) &&
                this.ticksUsed.greaterThan(this.totalTicks)) {
                this.ticksUsed.subtract(ticks);
                throw new _util__WEBPACK_IMPORTED_MODULE_4__.RuntimeError('BadArgument', 'Too many ticks.');
            }
            // Track the smallest tickable for formatting.
            if (ticks.lessThan(this.smallestTickCount)) {
                this.smallestTickCount = ticks.clone();
            }
            this.resolutionMultiplier = this.ticksUsed.denominator;
            // Expand total ticks using denominator from ticks used.
            this.totalTicks.add(0, this.ticksUsed.denominator);
        }
        // Add the tickable to the line.
        this.tickables.push(tickable);
        tickable.setVoice(this);
        return this;
    }
    /** Add an array of tickables to the voice. */
    addTickables(tickables) {
        for (let i = 0; i < tickables.length; ++i) {
            this.addTickable(tickables[i]);
        }
        return this;
    }
    /** Preformat the voice by applying the voice's stave to each note. */
    preFormat() {
        if (this.preFormatted)
            return this;
        const stave = this.checkStave();
        this.tickables.forEach((tickable) => {
            if (!tickable.getStave()) {
                tickable.setStave(stave);
            }
        });
        this.preFormatted = true;
        return this;
    }
    checkStave() {
        return (0,_util__WEBPACK_IMPORTED_MODULE_4__.defined)(this.stave, 'NoStave', 'No stave attached to instance.');
    }
    /**
     * Render the voice onto the canvas `context` and an optional `stave`.
     * If `stave` is omitted, it is expected that the notes have staves
     * already set.
     *
     * This method also calculates the voice's boundingBox while drawing
     * the notes. Note the similarities with this.getBoundingBox().
     */
    draw(context = this.checkContext(), stave) {
        stave = stave !== null && stave !== void 0 ? stave : this.stave;
        this.setRendered();
        for (let i = 0; i < this.tickables.length; ++i) {
            const tickable = this.tickables[i];
            // Set the stave if provided.
            if (stave) {
                tickable.setStave(stave);
            }
            (0,_util__WEBPACK_IMPORTED_MODULE_4__.defined)(tickable.getStave(), 'MissingStave', 'The voice cannot draw tickables without staves.');
            tickable.setContext(context);
            tickable.drawWithStyle();
        }
    }
}


/***/ }),

/***/ "./src/web.ts":
/*!********************!*\
  !*** ./src/web.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isHTMLCanvas: () => (/* binding */ isHTMLCanvas),
/* harmony export */   isHTMLDiv: () => (/* binding */ isHTMLDiv)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// @author Ron B. Yeh
// MIT License
//
// Utilities for working with Web APIs.
// See: https://developer.mozilla.org/en-US/docs/Web/API

// eslint-disable-next-line
function isHTMLCanvas(element) {
    if (!element)
        return false;
    const global = (0,_util__WEBPACK_IMPORTED_MODULE_0__.globalObject)();
    return (
    // It's either an instance of the HTMLCanvasElement class,
    (typeof global.HTMLCanvasElement === 'function' && element instanceof global.HTMLCanvasElement) ||
        // OR it's pretending to be a <canvas> element. Good enough!
        // Do not rely on .tagName, because node-canvas doesn't provide a tagName.
        (typeof element.getContext === 'function' && typeof element.toDataURL === 'function'));
}
// eslint-disable-next-line
function isHTMLDiv(element) {
    if (!element)
        return false;
    const global = (0,_util__WEBPACK_IMPORTED_MODULE_0__.globalObject)();
    return (
    // It's either an instance of the HTMLDivElement class.
    (typeof global.HTMLDivElement === 'function' && element instanceof global.HTMLDivElement) ||
        // OR it's pretending to be a <div>. See: svgcontext.ts.
        (typeof element.appendChild === 'function' && typeof element.style === 'object'));
}


/***/ }),

/***/ "./tests/accidental_tests.ts":
/*!***********************************!*\
  !*** ./tests/accidental_tests.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AccidentalTests: () => (/* binding */ AccidentalTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_accidental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/accidental */ "./src/accidental.ts");
/* harmony import */ var _src_beam__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/beam */ "./src/beam.ts");
/* harmony import */ var _src_dot__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/dot */ "./src/dot.ts");
/* harmony import */ var _src_formatter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/formatter */ "./src/formatter.ts");
/* harmony import */ var _src_glyphs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/glyphs */ "./src/glyphs.ts");
/* harmony import */ var _src_modifiercontext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/modifiercontext */ "./src/modifiercontext.ts");
/* harmony import */ var _src_note__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/note */ "./src/note.ts");
/* harmony import */ var _src_stave__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/stave */ "./src/stave.ts");
/* harmony import */ var _src_stavenote__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/stavenote */ "./src/stavenote.ts");
/* harmony import */ var _src_stem__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../src/stem */ "./src/stem.ts");
/* harmony import */ var _src_tickcontext__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../src/tickcontext */ "./src/tickcontext.ts");
/* harmony import */ var _src_timesignote__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../src/timesignote */ "./src/timesignote.ts");
/* harmony import */ var _src_typeguard__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../src/typeguard */ "./src/typeguard.ts");
/* harmony import */ var _src_voice__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../src/voice */ "./src/voice.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Accidental Tests















const AccidentalTests = {
    Start() {
        QUnit.module('Accidental');
        QUnit.test('Automatic Accidentals - Simple Tests', autoAccidentalWorking);
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Accidental Padding', formatAccidentalSpaces);
        run('Basic', basic);
        run('Stem Down', basicStemDown);
        run('Cautionary Accidental', cautionary);
        run('Accidental Arrangement Special Cases', specialCases);
        run('Multi Voice', multiVoice);
        run('Microtonal', microtonal);
        run('Microtonal (Iranian)', microtonalIranian);
        run('Sagittal', sagittal);
        run('Automatic Accidentals', automaticAccidentals0);
        run('Automatic Accidentals - C major scale in Ab', automaticAccidentals1);
        run('Automatic Accidentals - No Accidentals Necessary', automaticAccidentals2);
        run('Automatic Accidentals - No Accidentals Necessary (EasyScore)', automaticAccidentals3);
        run('Automatic Accidentals - Multi Voice Inline', automaticAccidentalsMultiVoiceInline);
        run('Automatic Accidentals - Multi Voice Offset', automaticAccidentalsMultiVoiceOffset);
        run('Automatic Accidentals - Key C, Single Octave', automaticAccidentalsCornerCases1);
        run('Automatic Accidentals - Key C, Two Octaves', automaticAccidentalsCornerCases2);
        run('Automatic Accidentals - Key C#, Single Octave', automaticAccidentalsCornerCases3);
        run('Automatic Accidentals - Key C#, Two Octaves', automaticAccidentalsCornerCases4);
        run('Factory API', factoryAPI);
    },
};
// Check that at least one of the note's modifiers is an Accidental.
function hasAccidental(note) {
    return note.getModifiers().some((modifier) => (0,_src_typeguard__WEBPACK_IMPORTED_MODULE_13__.isAccidental)(modifier));
}
// Return a convenience function for building accidentals from a string.
function makeNewAccid(factory) {
    return (type) => factory.Accidental({ type });
}
/**
 *
 */
function autoAccidentalWorking(assert) {
    const createStaveNote = (noteStruct) => new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote(noteStruct);
    let notes = [
        { keys: ['bb/4'], duration: '4' },
        { keys: ['bb/4'], duration: '4' },
        { keys: ['g#/4'], duration: '4' },
        { keys: ['g/4'], duration: '4' },
        { keys: ['b/4'], duration: '4' },
        { keys: ['b/4'], duration: '4' },
        { keys: ['a#/4'], duration: '4' },
        { keys: ['g#/4'], duration: '4' },
    ].map(createStaveNote);
    let voice = new _src_voice__WEBPACK_IMPORTED_MODULE_14__.Voice().setMode(_src_voice__WEBPACK_IMPORTED_MODULE_14__.Voice.Mode.SOFT).addTickables(notes);
    // F Major (Bb)
    _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental.applyAccidentals([voice], 'F');
    assert.equal(hasAccidental(notes[0]), false, 'No flat because of key signature');
    assert.equal(hasAccidental(notes[1]), false, 'No flat because of key signature');
    assert.equal(hasAccidental(notes[2]), true, 'Added a sharp');
    assert.equal(hasAccidental(notes[3]), true, 'Back to natural');
    assert.equal(hasAccidental(notes[4]), true, 'Back to natural');
    assert.equal(hasAccidental(notes[5]), false, 'Natural remembered');
    assert.equal(hasAccidental(notes[6]), true, 'Added sharp');
    assert.equal(hasAccidental(notes[7]), true, 'Added sharp');
    notes = [
        { keys: ['e#/4'], duration: '4' },
        { keys: ['cb/4'], duration: '4' },
        { keys: ['fb/4'], duration: '4' },
        { keys: ['b#/4'], duration: '4' },
        { keys: ['b#/4'], duration: '4' },
        { keys: ['cb/5'], duration: '4' },
        { keys: ['fb/5'], duration: '4' },
        { keys: ['e#/4'], duration: '4' },
    ].map(createStaveNote);
    voice = new _src_voice__WEBPACK_IMPORTED_MODULE_14__.Voice().setMode(_src_voice__WEBPACK_IMPORTED_MODULE_14__.Voice.Mode.SOFT).addTickables(notes);
    // A Major (F#,G#,C#)
    _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental.applyAccidentals([voice], 'A');
    assert.equal(hasAccidental(notes[0]), true, 'Added sharp');
    assert.equal(hasAccidental(notes[1]), true, 'Added flat');
    assert.equal(hasAccidental(notes[2]), true, 'Added flat');
    assert.equal(hasAccidental(notes[3]), true, 'Added sharp');
    assert.equal(hasAccidental(notes[4]), false, 'Sharp remembered');
    assert.equal(hasAccidental(notes[5]), true, 'Added flat(different octave)');
    assert.equal(hasAccidental(notes[6]), true, 'Added flat(different octave)');
    assert.equal(hasAccidental(notes[7]), false, 'sharp remembered');
    notes = [
        { keys: ['c/4'], duration: '4' },
        { keys: ['cb/4'], duration: '4' },
        { keys: ['cb/4'], duration: '4' },
        { keys: ['c#/4'], duration: '4' },
        { keys: ['c#/4'], duration: '4' },
        { keys: ['cbb/4'], duration: '4' },
        { keys: ['cbb/4'], duration: '4' },
        { keys: ['c##/4'], duration: '4' },
        { keys: ['c##/4'], duration: '4' },
        { keys: ['c/4'], duration: '4' },
        { keys: ['c/4'], duration: '4' },
    ].map(createStaveNote);
    voice = new _src_voice__WEBPACK_IMPORTED_MODULE_14__.Voice().setMode(_src_voice__WEBPACK_IMPORTED_MODULE_14__.Voice.Mode.SOFT).addTickables(notes);
    // C Major (no sharps/flats)
    _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental.applyAccidentals([voice], 'C');
    assert.equal(hasAccidental(notes[0]), false, 'No accidental');
    assert.equal(hasAccidental(notes[1]), true, 'Added flat');
    assert.equal(hasAccidental(notes[2]), false, 'Flat remembered');
    assert.equal(hasAccidental(notes[3]), true, 'Sharp added');
    assert.equal(hasAccidental(notes[4]), false, 'Sharp remembered');
    assert.equal(hasAccidental(notes[5]), true, 'Added doubled flat');
    assert.equal(hasAccidental(notes[6]), false, 'Double flat remembered');
    assert.equal(hasAccidental(notes[7]), true, 'Added double sharp');
    assert.equal(hasAccidental(notes[8]), false, 'Double sharp rememberd');
    assert.equal(hasAccidental(notes[9]), true, 'Added natural');
    assert.equal(hasAccidental(notes[10]), false, 'Natural remembered');
}
/**
 *
 */
function formatAccidentalSpaces(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 750, 280);
    const context = f.getContext();
    const softmaxFactor = 100;
    // Create the notes
    const notes = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({
            keys: ['e##/5'],
            duration: '8d',
        }).addModifier(new _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental('##'), 0),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({
            keys: ['b/4'],
            duration: '16',
        }).addModifier(new _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental('b'), 0),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({
            keys: ['f/3'],
            duration: '8',
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({
            keys: ['a/3'],
            duration: '16',
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({
            keys: ['e/4', 'g/4'],
            duration: '16',
        })
            .addModifier(new _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental('bb'), 0)
            .addModifier(new _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental('bb'), 1),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({
            keys: ['d/4'],
            duration: '16',
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({
            keys: ['e/4', 'g/4'],
            duration: '16',
        })
            .addModifier(new _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental('#'), 0)
            .addModifier(new _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental('#'), 1),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({
            keys: ['g/4'],
            duration: '32',
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({
            keys: ['a/4'],
            duration: '32',
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({
            keys: ['g/4'],
            duration: '16',
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({
            keys: ['d/4'],
            duration: 'q',
        }),
    ];
    _src_dot__WEBPACK_IMPORTED_MODULE_3__.Dot.buildAndAttach([notes[0]], { all: true });
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_2__.Beam.generateBeams(notes);
    const voice = new _src_voice__WEBPACK_IMPORTED_MODULE_14__.Voice({
        numBeats: 4,
        beatValue: 4,
    });
    voice.addTickables(notes);
    const formatter = new _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter({ softmaxFactor }).joinVoices([voice]);
    const width = formatter.preCalculateMinTotalWidth([voice]);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_8__.Stave(10, 40, width + 20);
    stave.setContext(context).draw();
    formatter.format([voice], width);
    voice.draw(context, stave);
    beams.forEach((b) => b.setContext(context).draw());
    notes.forEach((note) => _src_note__WEBPACK_IMPORTED_MODULE_7__.Note.plotMetrics(context, note, 30));
    _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.plotLegendForNoteWidth(context, 300, 150);
    options.assert.ok(true);
}
function basic(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 240);
    const accid = makeNewAccid(f);
    f.Stave({ x: 10, y: 10, width: 550 });
    const notes = [
        f
            .StaveNote({ keys: ['c/4', 'e/4', 'a/4'], duration: '1' })
            .addModifier(accid('b'), 0)
            .addModifier(accid('#'), 1),
        // Notes keys out of alphabetic order
        f
            .StaveNote({ keys: ['e/4', 'f/4', 'a/4', 'c/5', 'e/5', 'g/5', 'd/4'], duration: '2' })
            .addModifier(accid('##'), 6)
            .addModifier(accid('n'), 0)
            .addModifier(accid('bb'), 1)
            .addModifier(accid('b'), 2)
            .addModifier(accid('#'), 3)
            .addModifier(accid('n'), 4)
            .addModifier(accid('bb'), 5),
        // Notes keys out of alphabetic order
        f
            .StaveNote({ keys: ['g/5', 'f/4', 'g/4', 'a/4', 'b/4', 'c/5', 'e/5'], duration: '16' })
            .addModifier(accid('n'), 1)
            .addModifier(accid('#'), 2)
            .addModifier(accid('#'), 3)
            .addModifier(accid('b'), 4)
            .addModifier(accid('bb'), 5)
            .addModifier(accid('##'), 6)
            .addModifier(accid('#'), 0),
        f
            .StaveNote({ keys: ['a/3', 'c/4', 'e/4', 'b/4', 'd/5', 'g/5'], duration: '1' })
            .addModifier(accid('#'), 0)
            .addModifier(accid('##').setAsCautionary(), 1)
            .addModifier(accid('#').setAsCautionary(), 2)
            .addModifier(accid('b'), 3)
            .addModifier(accid('bb').setAsCautionary(), 4)
            .addModifier(accid('b').setAsCautionary(), 5),
    ];
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.SimpleFormat(notes, 10, { paddingBetween: 45 });
    notes.forEach((note, index) => {
        _src_note__WEBPACK_IMPORTED_MODULE_7__.Note.plotMetrics(f.getContext(), note, 140);
        options.assert.ok(note.getModifiersByType('Accidental').length > 0, 'Note ' + index + ' has accidentals');
        note.getModifiersByType('Accidental').forEach((accid, index) => {
            options.assert.ok(accid.getWidth() > 0, 'Accidental ' + index + ' has set width');
        });
    });
    f.draw();
    _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.plotLegendForNoteWidth(f.getContext(), 480, 140);
    options.assert.ok(true, 'Full Accidental');
}
function genAccidentals() {
    const accs = ['#', '##', 'b', 'bb', 'n', '{', '}', 'db', 'd', '++', '+', '+-'];
    accs.push('bs', 'bss', 'o', 'k', 'bbs', '++-', 'ashs', 'afhf');
    // Standard accidentals (12-EDO)
    for (let u = 0xe260; u <= 0xe269; u++) {
        accs.push(String.fromCodePoint(u));
    }
    // Gould arrow quartertone accidentals (24-EDO)
    for (let u = 0xe270; u <= 0xe27b; u++) {
        accs.push(String.fromCodePoint(u));
    }
    // Stein-Zimmermann accidentals (24-EDO)
    for (let u = 0xe280; u <= 0xe285; u++) {
        accs.push(String.fromCodePoint(u));
    }
    // Extended Stein-Zimmermann accidentals
    for (let u = 0xe290; u <= 0xe29c; u++) {
        accs.push(String.fromCodePoint(u));
    }
    // Sims accidentals (72-EDO)
    for (let u = 0xe2a0; u <= 0xe2a5; u++) {
        accs.push(String.fromCodePoint(u));
    }
    // Johnston accidentals (just intonation)
    for (let u = 0xe2b0; u <= 0xe2b7; u++) {
        accs.push(String.fromCodePoint(u));
    }
    // Extended Helmholtz-Ellis accidentals (just intonation)
    for (let u = 0xe2c0; u <= 0xe2fb; u++) {
        accs.push(String.fromCodePoint(u));
    }
    // Spartan Sagittal single-shaft accidentals
    for (let u = 0xe300; u <= 0xe30f; u++) {
        accs.push(String.fromCodePoint(u));
    }
    // Spartan Sagittal multi-shaft accidentals
    for (let u = 0xe310; u <= 0xe335; u++) {
        accs.push(String.fromCodePoint(u));
    }
    // Athenian Sagittal extension (medium precision) accidentals
    for (let u = 0xe340; u <= 0xe367; u++) {
        accs.push(String.fromCodePoint(u));
    }
    // Trojan Sagittal extension (12-EDO relative) accidentals
    for (let u = 0xe370; u <= 0xe387; u++) {
        accs.push(String.fromCodePoint(u));
    }
    // Promethean Sagittal extension (high precision) single-shaft accidentals
    for (let u = 0xe390; u <= 0xe3ad; u++) {
        accs.push(String.fromCodePoint(u));
    }
    // Promethean Sagittal extension (high precision) multi-shaft accidentals
    for (let u = 0xe3b0; u <= 0xe3ef; u++) {
        accs.push(String.fromCodePoint(u));
    }
    // Herculean Sagittal extension (very high precision) accidental diacritics
    for (let u = 0xe3f0; u <= 0xe3f3; u++) {
        accs.push(String.fromCodePoint(u));
    }
    // Olympian Sagittal extension (extreme precision) accidental diacritics
    for (let u = 0xe3f4; u <= 0xe3f7; u++) {
        accs.push(String.fromCodePoint(u));
    }
    // Wyschnegradsky accidentals (72-EDO)
    for (let u = 0xe420; u <= 0xe435; u++) {
        accs.push(String.fromCodePoint(u));
    }
    // Arel-Ezgi-Uzdilek (AEU) accidentals
    for (let u = 0xe440; u <= 0xe447; u++) {
        accs.push(String.fromCodePoint(u));
    }
    // Turkish folk music accidentals
    for (let u = 0xe450; u <= 0xe457; u++) {
        accs.push(String.fromCodePoint(u));
    }
    // Persian accidentals
    for (let u = 0xe460; u <= 0xe461; u++) {
        accs.push(String.fromCodePoint(u));
    }
    // Other accidentals
    for (let u = 0xe470; u <= 0xe48f; u++) {
        accs.push(String.fromCodePoint(u));
    }
    return accs;
}
const accidentals = genAccidentals();
function cautionary(options) {
    const staveCount = 21;
    const scale = 0.85;
    const staveWidth = 840;
    let i = 0;
    let j = 0;
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, staveWidth + 10, 175 * staveCount + 10);
    f.getContext().scale(scale, scale);
    const accids = Object.values(accidentals).filter((accid) => accid !== '{' && accid !== '}');
    const mod = Math.round(accids.length / staveCount);
    for (i = 0; i < staveCount; ++i) {
        const stave = f.Stave({ x: 0, y: 10 + 100 * i, width: staveWidth / scale });
        const score = f.EasyScore();
        const rowMap = [];
        for (j = 0; j < mod && j + i * staveCount < accids.length; ++j) {
            rowMap.push(accids[j + i * staveCount]);
        }
        const notes = rowMap.map((accidType) => f
            .StaveNote({ keys: ['a/4'], duration: '4', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_10__.Stem.UP })
            .addModifier(f.Accidental({ type: accidType }), 0));
        const voice = score.voice(notes, { time: rowMap.length + '/4' });
        voice.getTickables().forEach((tickable) => {
            tickable
                .getModifiers()
                .filter((modifier) => modifier.getAttribute('type') === _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental.CATEGORY)
                .forEach((accid) => accid.setAsCautionary());
        });
        f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
        f.draw();
    }
    options.assert.ok(true, 'Must successfully render cautionary accidentals');
}
function specialCases(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 240);
    const accid = makeNewAccid(f);
    f.Stave({ x: 10, y: 10, width: 550 });
    const notes = [
        f
            .StaveNote({ keys: ['f/4', 'd/5'], duration: '1' })
            .addModifier(accid('#'), 0)
            .addModifier(accid('b'), 1),
        f
            .StaveNote({ keys: ['c/4', 'g/4'], duration: '2' })
            .addModifier(accid('##'), 0)
            .addModifier(accid('##'), 1),
        f
            .StaveNote({ keys: ['b/3', 'd/4', 'f/4'], duration: '16' })
            .addModifier(accid('#'), 0)
            .addModifier(accid('#'), 1)
            .addModifier(accid('##'), 2),
        f
            .StaveNote({ keys: ['g/4', 'a/4', 'c/5', 'e/5'], duration: '16' })
            .addModifier(accid('b'), 0)
            .addModifier(accid('b'), 1)
            .addModifier(accid('n'), 3),
        f
            .StaveNote({ keys: ['e/4', 'g/4', 'b/4', 'c/5'], duration: '4' })
            .addModifier(accid('b').setAsCautionary(), 0)
            .addModifier(accid('b').setAsCautionary(), 1)
            .addModifier(accid('bb'), 2)
            .addModifier(accid('b'), 3),
        f
            .StaveNote({ keys: ['b/3', 'e/4', 'a/4', 'd/5', 'g/5'], duration: '8' })
            .addModifier(accid('bb'), 0)
            .addModifier(accid('b').setAsCautionary(), 1)
            .addModifier(accid('n').setAsCautionary(), 2)
            .addModifier(accid('#'), 3)
            .addModifier(accid('n').setAsCautionary(), 4),
    ];
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.SimpleFormat(notes, 0, { paddingBetween: 20 });
    notes.forEach((note, index) => {
        _src_note__WEBPACK_IMPORTED_MODULE_7__.Note.plotMetrics(f.getContext(), note, 140);
        options.assert.ok(note.getModifiersByType('Accidental').length > 0, 'Note ' + index + ' has accidentals');
        note.getModifiersByType('Accidental').forEach((accid, index) => {
            options.assert.ok(accid.getWidth() > 0, 'Accidental ' + index + ' has set width');
        });
    });
    f.draw();
    _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.plotLegendForNoteWidth(f.getContext(), 480, 140);
    options.assert.ok(true, 'Full Accidental');
}
function basicStemDown(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 240);
    const accid = makeNewAccid(f);
    f.Stave({ x: 10, y: 10, width: 550 });
    const notes = [
        f
            .StaveNote({ keys: ['c/4', 'e/4', 'a/4'], duration: 'w', stemDirection: -1 })
            .addModifier(accid('b'), 0)
            .addModifier(accid('#'), 1),
        f
            .StaveNote({ keys: ['d/4', 'e/4', 'f/4', 'a/4', 'c/5', 'e/5', 'g/5'], duration: '2', stemDirection: -1 })
            .addModifier(accid('##'), 0)
            .addModifier(accid('n'), 1)
            .addModifier(accid('bb'), 2)
            .addModifier(accid('b'), 3)
            .addModifier(accid('#'), 4)
            .addModifier(accid('n'), 5)
            .addModifier(accid('bb'), 6),
        f
            .StaveNote({ keys: ['f/4', 'g/4', 'a/4', 'b/4', 'c/5', 'e/5', 'g/5'], duration: '16', stemDirection: -1 })
            .addModifier(accid('n'), 0)
            .addModifier(accid('#'), 1)
            .addModifier(accid('#'), 2)
            .addModifier(accid('b'), 3)
            .addModifier(accid('bb'), 4)
            .addModifier(accid('##'), 5)
            .addModifier(accid('#'), 6),
    ];
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.SimpleFormat(notes, 0, { paddingBetween: 30 });
    notes.forEach((note, noteIndex) => {
        _src_note__WEBPACK_IMPORTED_MODULE_7__.Note.plotMetrics(f.getContext(), note, 140);
        options.assert.ok(note.getModifiersByType('Accidental').length > 0, 'Note ' + noteIndex + ' has accidentals');
        note.getModifiersByType('Accidental').forEach((accid, accidIndex) => {
            options.assert.ok(accid.getWidth() > 0, 'Accidental ' + accidIndex + ' has set width');
        });
    });
    f.draw();
    _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.plotLegendForNoteWidth(f.getContext(), 480, 140);
    options.assert.ok(true, 'Full Accidental');
}
function multiVoice(options) {
    // Helper function for visualizing
    function showNotes(note1, note2, stave, ctx, x) {
        const modifierContext = new _src_modifiercontext__WEBPACK_IMPORTED_MODULE_6__.ModifierContext();
        note1.addToModifierContext(modifierContext);
        note2.addToModifierContext(modifierContext);
        new _src_tickcontext__WEBPACK_IMPORTED_MODULE_11__.TickContext().addTickable(note1).addTickable(note2).preFormat().setX(x);
        note1.setContext(ctx).draw();
        note2.setContext(ctx).draw();
        _src_note__WEBPACK_IMPORTED_MODULE_7__.Note.plotMetrics(ctx, note1, 180);
        _src_note__WEBPACK_IMPORTED_MODULE_7__.Note.plotMetrics(ctx, note2, 15);
    }
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 460, 250);
    const accid = makeNewAccid(f);
    const stave = f.Stave({ x: 10, y: 45, width: 420 });
    const ctx = f.getContext();
    stave.draw();
    let note1 = f
        .StaveNote({ keys: ['c/4', 'e/4', 'a/4'], duration: '2', stemDirection: -1 })
        .addModifier(accid('b'), 0)
        .addModifier(accid('n'), 1)
        .addModifier(accid('#'), 2)
        .setStave(stave);
    let note2 = f
        .StaveNote({ keys: ['d/5', 'a/5', 'b/5'], duration: '2', stemDirection: 1 })
        .addModifier(accid('b'), 0)
        .addModifier(accid('bb'), 1)
        .addModifier(accid('##'), 2)
        .setStave(stave);
    showNotes(note1, note2, stave, ctx, 60);
    note1 = f
        .StaveNote({ keys: ['c/4', 'e/4', 'c/5'], duration: '2', stemDirection: -1 })
        .addModifier(accid('b'), 0)
        .addModifier(accid('n'), 1)
        .addModifier(accid('#'), 2)
        .setStave(stave);
    note2 = f
        .StaveNote({ keys: ['d/5', 'a/5', 'b/5'], duration: '4', stemDirection: 1 })
        .addModifier(accid('b'), 0)
        .setStave(stave);
    showNotes(note1, note2, stave, ctx, 150);
    note1 = f
        .StaveNote({ keys: ['d/4', 'c/5', 'd/5'], duration: '2', stemDirection: -1 })
        .addModifier(accid('b'), 0)
        .addModifier(accid('n'), 1)
        .addModifier(accid('#'), 2)
        .setStave(stave);
    note2 = f
        .StaveNote({ keys: ['d/5', 'a/5', 'b/5'], duration: '4', stemDirection: 1 })
        .addModifier(accid('b'), 0)
        .setStave(stave);
    showNotes(note1, note2, stave, ctx, 250);
    _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.plotLegendForNoteWidth(ctx, 350, 150);
    options.assert.ok(true, 'Full Accidental');
}
function microtonal(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 240);
    const accid = makeNewAccid(f);
    const ctx = f.getContext();
    f.Stave({ x: 10, y: 10, width: 650 });
    const notes = [
        f
            .StaveNote({ keys: ['c/4', 'e/4', 'a/4'], duration: '1' })
            .addModifier(accid('db'), 0)
            .addModifier(accid('d'), 1),
        f
            .StaveNote({ keys: ['d/4', 'e/4', 'f/4', 'a/4', 'c/5', 'e/5', 'g/5'], duration: '2' })
            .addModifier(accid('bbs'), 0)
            .addModifier(accid('++'), 1)
            .addModifier(accid('+'), 2)
            .addModifier(accid('d'), 3)
            .addModifier(accid('db'), 4)
            .addModifier(accid('+'), 5)
            .addModifier(accid('##'), 6),
        f
            .StaveNote({ keys: ['f/4', 'g/4', 'a/4', 'b/4', 'c/5', 'e/5', 'g/5'], duration: '16' })
            .addModifier(accid('++'), 0)
            .addModifier(accid('bbs'), 1)
            .addModifier(accid('+'), 2)
            .addModifier(accid('b'), 3)
            .addModifier(accid('db'), 4)
            .addModifier(accid('##'), 5)
            .addModifier(accid('#'), 6),
        f
            .StaveNote({ keys: ['a/3', 'c/4', 'e/4', 'b/4', 'd/5', 'g/5'], duration: '1' })
            .addModifier(accid('#'), 0)
            .addModifier(accid('db').setAsCautionary(), 1)
            .addModifier(accid('bbs').setAsCautionary(), 2)
            .addModifier(accid('b'), 3)
            .addModifier(accid('++').setAsCautionary(), 4)
            .addModifier(accid('d').setAsCautionary(), 5),
        f
            .StaveNote({ keys: ['f/4', 'g/4', 'a/4', 'b/4', 'd/5', 'g/5'], duration: '16' })
            .addModifier(accid('++-'), 0)
            .addModifier(accid('+-'), 1)
            .addModifier(accid('bs'), 2)
            .addModifier(accid('bss'), 3)
            .addModifier(accid('afhf'), 4)
            .addModifier(accid('ashs'), 5),
    ];
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.SimpleFormat(notes, 0, { paddingBetween: 35 });
    notes.forEach((note, index) => {
        _src_note__WEBPACK_IMPORTED_MODULE_7__.Note.plotMetrics(f.getContext(), note, 140);
        options.assert.ok(note.getModifiersByType('Accidental').length > 0, 'Note ' + index + ' has accidentals');
        note.getModifiersByType('Accidental').forEach((accid, index) => {
            options.assert.ok(accid.getWidth() > 0, 'Accidental ' + index + ' has set width');
        });
    });
    f.draw();
    _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.plotLegendForNoteWidth(ctx, 580, 140);
    options.assert.ok(true, 'Microtonal Accidental');
}
function microtonalIranian(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 240);
    const accid = makeNewAccid(f);
    const ctx = f.getContext();
    f.Stave({ x: 10, y: 10, width: 650 });
    const notes = [
        f
            .StaveNote({ keys: ['c/4', 'e/4', 'a/4'], duration: '1' })
            .addModifier(accid('k'), 0)
            .addModifier(accid('o'), 1),
        f
            .StaveNote({ keys: ['d/4', 'e/4', 'f/4', 'a/4', 'c/5', 'e/5', 'g/5'], duration: '2' })
            .addModifier(accid('b'), 0)
            .addModifier(accid('k'), 1)
            .addModifier(accid('n'), 2)
            .addModifier(accid('o'), 3)
            .addModifier(accid('#'), 4)
            .addModifier(accid('bb'), 5)
            .addModifier(accid('##'), 6),
        f
            .StaveNote({ keys: ['f/4', 'g/4', 'a/4', 'b/4', 'c/5', 'e/5', 'g/5'], duration: '16' })
            .addModifier(accid('o'), 0)
            .addModifier(accid('k'), 1)
            .addModifier(accid('n'), 2)
            .addModifier(accid('b'), 3)
            .addModifier(accid('bb'), 4)
            .addModifier(accid('##'), 5)
            .addModifier(accid('#'), 6),
        f
            .StaveNote({ keys: ['a/3', 'c/4', 'e/4', 'b/4', 'd/5', 'g/5'], duration: '1' })
            .addModifier(accid('#'), 0)
            .addModifier(accid('o').setAsCautionary(), 1)
            .addModifier(accid('n').setAsCautionary(), 2)
            .addModifier(accid('b'), 3)
            .addModifier(accid('k').setAsCautionary(), 4),
        f
            .StaveNote({ keys: ['f/4', 'g/4', 'a/4', 'b/4'], duration: '16' })
            .addModifier(accid('k'), 0)
            .addModifier(accid('k'), 1)
            .addModifier(accid('k'), 2)
            .addModifier(accid('k'), 3),
    ];
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.SimpleFormat(notes, 0, { paddingBetween: 35 });
    notes.forEach((note, index) => {
        _src_note__WEBPACK_IMPORTED_MODULE_7__.Note.plotMetrics(f.getContext(), note, 140);
        options.assert.ok(note.getModifiersByType('Accidental').length > 0, 'Note ' + index + ' has accidentals');
        note.getModifiersByType('Accidental').forEach((accid, index) => {
            options.assert.ok(accid.getWidth() > 0, 'Accidental ' + index + ' has set width');
        });
    });
    f.draw();
    _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.plotLegendForNoteWidth(ctx, 580, 140);
    options.assert.ok(true, 'Microtonal Accidental (Iranian)');
}
function sagittal(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 240);
    const accid = makeNewAccid(f);
    const ctx = f.getContext();
    f.Stave({ x: 10, y: 10, width: 650 });
    // Use these SMUFL glyphs.
    const { accSagittal11LargeDiesisDown, accSagittal11MediumDiesisUp, accSagittal35LargeDiesisDown, accSagittal5CommaDown, accSagittal7CommaDown, accSagittalFlat7CDown, } = _src_glyphs__WEBPACK_IMPORTED_MODULE_5__.Glyphs;
    const notes = [
        f
            .StaveNote({ keys: ['d/4', 'f/4', 'b/4', 'b/4'], duration: '4' })
            .addModifier(accid(accSagittal11MediumDiesisUp), 1)
            .addModifier(accid(accSagittal5CommaDown), 2)
            .addModifier(accid('b'), 3)
            .addModifier(accid(accSagittal7CommaDown), 3),
        f
            .StaveNote({ keys: ['d/4', 'f/4', 'a/4', 'b/4'], duration: '4' })
            .addModifier(accid(accSagittal35LargeDiesisDown), 2),
        f.StaveNote({ keys: ['c/4', 'e/4', 'g/4', 'c/5'], duration: '8' }).addModifier(accid(accSagittal5CommaDown), 1),
        f
            .StaveNote({ keys: ['c/4', 'e/4', 'g/4', 'b/4'], duration: '8' })
            .addModifier(accid('b'), 1)
            .addModifier(accid(accSagittal7CommaDown), 1)
            .addModifier(accid(accSagittal11LargeDiesisDown), 3),
        f
            .StaveNote({ keys: ['d/4', 'f/4', 'b/4', 'b/4'], duration: '4' })
            .addModifier(accid(accSagittal11MediumDiesisUp), 1)
            .addModifier(accid(accSagittal5CommaDown), 2)
            .addModifier(accid(accSagittalFlat7CDown), 3),
        f
            .StaveNote({ keys: ['d/4', 'f/4', 'a/4', 'b/4'], duration: '4' })
            .addModifier(accid(accSagittal35LargeDiesisDown), 2),
        f.StaveNote({ keys: ['c/4', 'e/4', 'g/4', 'c/5'], duration: '8' }).addModifier(accid(accSagittal5CommaDown), 1),
        f
            .StaveNote({ keys: ['c/4', 'e/4', 'g/4', 'b/4'], duration: '8' })
            .addModifier(accid(accSagittalFlat7CDown), 1)
            .addModifier(accid(accSagittal11LargeDiesisDown), 3),
    ];
    f.StaveTie({
        from: notes[0],
        to: notes[1],
        firstIndexes: [0, 1],
        lastIndexes: [0, 1],
    });
    f.StaveTie({
        from: notes[0],
        to: notes[1],
        firstIndexes: [3],
        lastIndexes: [3],
        options: {
            direction: _src_stem__WEBPACK_IMPORTED_MODULE_10__.Stem.DOWN,
        },
    });
    f.StaveTie({
        from: notes[4],
        to: notes[5],
        firstIndexes: [0, 1],
        lastIndexes: [0, 1],
    });
    f.StaveTie({
        from: notes[4],
        to: notes[5],
        firstIndexes: [3],
        lastIndexes: [3],
        options: {
            direction: _src_stem__WEBPACK_IMPORTED_MODULE_10__.Stem.DOWN,
        },
    });
    f.Beam({ notes: notes.slice(2, 4) });
    f.Beam({ notes: notes.slice(6, 8) });
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.SimpleFormat(notes);
    notes.forEach((note, index) => {
        _src_note__WEBPACK_IMPORTED_MODULE_7__.Note.plotMetrics(f.getContext(), note, 140);
        options.assert.ok(note.getModifiersByType('Accidental').length > 0, 'Note ' + index + ' has accidentals');
    });
    f.draw();
    _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.plotLegendForNoteWidth(ctx, 580, 140);
    options.assert.ok(true, 'Sagittal');
}
function automaticAccidentals0(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 200);
    const stave = f.Stave();
    const notes = [
        { keys: ['c/4', 'c/5'], duration: '4' },
        { keys: ['c#/4', 'c#/5'], duration: '4' },
        { keys: ['c#/4', 'c#/5'], duration: '4' },
        { keys: ['c##/4', 'c##/5'], duration: '4' },
        { keys: ['c##/4', 'c##/5'], duration: '4' },
        { keys: ['c/4', 'c/5'], duration: '4' },
        { keys: ['cn/4', 'cn/5'], duration: '4' },
        { keys: ['cbb/4', 'cbb/5'], duration: '4' },
        { keys: ['cbb/4', 'cbb/5'], duration: '4' },
        { keys: ['cb/4', 'cb/5'], duration: '4' },
        { keys: ['cb/4', 'cb/5'], duration: '4' },
        { keys: ['c/4', 'c/5'], duration: '4' },
    ].map(f.StaveNote.bind(f));
    const gracenotes = [{ keys: ['d#/4'], duration: '16', slash: true }].map(f.GraceNote.bind(f));
    notes[0].addModifier(f.GraceNoteGroup({ notes: gracenotes }).beamNotes(), 0);
    const voice = f
        .Voice()
        .setMode(_src_voice__WEBPACK_IMPORTED_MODULE_14__.Voice.Mode.SOFT)
        .addTickable(new _src_timesignote__WEBPACK_IMPORTED_MODULE_12__.TimeSigNote('12/4').setStave(stave))
        .addTickables(notes);
    _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental.applyAccidentals([voice], 'C');
    new _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true);
}
function automaticAccidentals1(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 150);
    const stave = f.Stave().addKeySignature('Ab');
    const notes = [
        { keys: ['c/4'], duration: '4' },
        { keys: ['d/4'], duration: '4' },
        { keys: ['e/4'], duration: '4' },
        { keys: ['f/4'], duration: '4' },
        { keys: ['g/4'], duration: '4' },
        { keys: ['a/4'], duration: '4' },
        { keys: ['b/4'], duration: '4' },
        { keys: ['c/5'], duration: '4' },
    ].map(f.StaveNote.bind(f));
    const voice = f.Voice().setMode(_src_voice__WEBPACK_IMPORTED_MODULE_14__.Voice.Mode.SOFT).addTickables(notes);
    _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental.applyAccidentals([voice], 'Ab');
    new _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true);
}
function automaticAccidentals2(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 150);
    const stave = f.Stave().addKeySignature('A');
    const notes = [
        { keys: ['a/4'], duration: '4' },
        { keys: ['b/4'], duration: '4' },
        { keys: ['c#/5'], duration: '4' },
        { keys: ['d/5'], duration: '4' },
        { keys: ['e/5'], duration: '4' },
        { keys: ['f#/5'], duration: '4' },
        { keys: ['g#/5'], duration: '4' },
        { keys: ['a/5'], duration: '4' },
    ].map(f.StaveNote.bind(f));
    const voice = f.Voice().setMode(_src_voice__WEBPACK_IMPORTED_MODULE_14__.Voice.Mode.SOFT).addTickables(notes);
    _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental.applyAccidentals([voice], 'A');
    new _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true);
}
function automaticAccidentals3(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 150);
    const stave = f.Stave().addKeySignature('A');
    const score = f.EasyScore();
    score.set({ time: '8/4' });
    const notes = score.notes('A4/q, B4/q, C#5/q, D5/q, E5/q,F#5/q, G#5/q, A5/q', { stem: 'UP' });
    const voice = f.Voice().setMode(_src_voice__WEBPACK_IMPORTED_MODULE_14__.Voice.Mode.SOFT).addTickables(notes);
    _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental.applyAccidentals([voice], 'A');
    new _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true);
}
function automaticAccidentalsMultiVoiceInline(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 150);
    const stave = f.Stave().addKeySignature('Ab');
    const notes0 = [
        { keys: ['c/4'], duration: '4', stemDirection: -1 },
        { keys: ['d/4'], duration: '4', stemDirection: -1 },
        { keys: ['e/4'], duration: '4', stemDirection: -1 },
        { keys: ['f/4'], duration: '4', stemDirection: -1 },
        { keys: ['g/4'], duration: '4', stemDirection: -1 },
        { keys: ['a/4'], duration: '4', stemDirection: -1 },
        { keys: ['b/4'], duration: '4', stemDirection: -1 },
        { keys: ['c/5'], duration: '4', stemDirection: -1 },
    ].map(f.StaveNote.bind(f));
    const notes1 = [
        { keys: ['c/5'], duration: '4' },
        { keys: ['d/5'], duration: '4' },
        { keys: ['e/5'], duration: '4' },
        { keys: ['f/5'], duration: '4' },
        { keys: ['g/5'], duration: '4' },
        { keys: ['a/5'], duration: '4' },
        { keys: ['b/5'], duration: '4' },
        { keys: ['c/6'], duration: '4' },
    ].map(f.StaveNote.bind(f));
    const voice0 = f.Voice().setMode(_src_voice__WEBPACK_IMPORTED_MODULE_14__.Voice.Mode.SOFT).addTickables(notes0);
    const voice1 = f.Voice().setMode(_src_voice__WEBPACK_IMPORTED_MODULE_14__.Voice.Mode.SOFT).addTickables(notes1);
    // Ab Major
    _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental.applyAccidentals([voice0, voice1], 'Ab');
    options.assert.equal(hasAccidental(notes0[0]), false);
    options.assert.equal(hasAccidental(notes0[1]), true);
    options.assert.equal(hasAccidental(notes0[2]), true);
    options.assert.equal(hasAccidental(notes0[3]), false);
    options.assert.equal(hasAccidental(notes0[4]), false);
    options.assert.equal(hasAccidental(notes0[5]), true);
    options.assert.equal(hasAccidental(notes0[6]), true);
    options.assert.equal(hasAccidental(notes0[7]), false);
    options.assert.equal(hasAccidental(notes1[0]), false);
    options.assert.equal(hasAccidental(notes1[1]), true);
    options.assert.equal(hasAccidental(notes1[2]), true);
    options.assert.equal(hasAccidental(notes1[3]), false);
    options.assert.equal(hasAccidental(notes1[4]), false);
    options.assert.equal(hasAccidental(notes1[5]), true);
    options.assert.equal(hasAccidental(notes1[6]), true);
    options.assert.equal(hasAccidental(notes1[7]), false);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter().joinVoices([voice0, voice1]).formatToStave([voice0, voice1], stave);
    f.draw();
    options.assert.ok(true);
}
function automaticAccidentalsMultiVoiceOffset(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 150);
    const stave = f.Stave().addKeySignature('Cb');
    const notes0 = [
        { keys: ['c/4'], duration: '4', stemDirection: -1 },
        { keys: ['d/4'], duration: '4', stemDirection: -1 },
        { keys: ['e/4'], duration: '4', stemDirection: -1 },
        { keys: ['f/4'], duration: '4', stemDirection: -1 },
        { keys: ['g/4'], duration: '4', stemDirection: -1 },
        { keys: ['a/4'], duration: '4', stemDirection: -1 },
        { keys: ['b/4'], duration: '4', stemDirection: -1 },
        { keys: ['c/5'], duration: '4', stemDirection: -1 },
    ].map(f.StaveNote.bind(f));
    const notes1 = [
        { keys: ['c/5'], duration: '8' },
        { keys: ['c/5'], duration: '4' },
        { keys: ['d/5'], duration: '4' },
        { keys: ['e/5'], duration: '4' },
        { keys: ['f/5'], duration: '4' },
        { keys: ['g/5'], duration: '4' },
        { keys: ['a/5'], duration: '4' },
        { keys: ['b/5'], duration: '4' },
        { keys: ['c/6'], duration: '4' },
    ].map(f.StaveNote.bind(f));
    const voice0 = f.Voice().setMode(_src_voice__WEBPACK_IMPORTED_MODULE_14__.Voice.Mode.SOFT).addTickables(notes0);
    const voice1 = f.Voice().setMode(_src_voice__WEBPACK_IMPORTED_MODULE_14__.Voice.Mode.SOFT).addTickables(notes1);
    // Cb Major (All flats)
    _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental.applyAccidentals([voice0, voice1], 'Cb');
    options.assert.equal(hasAccidental(notes0[0]), true);
    options.assert.equal(hasAccidental(notes0[1]), true);
    options.assert.equal(hasAccidental(notes0[2]), true);
    options.assert.equal(hasAccidental(notes0[3]), true);
    options.assert.equal(hasAccidental(notes0[4]), true);
    options.assert.equal(hasAccidental(notes0[5]), true);
    options.assert.equal(hasAccidental(notes0[6]), true);
    options.assert.equal(hasAccidental(notes0[7]), false, 'Natural Remembered');
    options.assert.equal(hasAccidental(notes1[0]), true);
    options.assert.equal(hasAccidental(notes1[1]), false);
    options.assert.equal(hasAccidental(notes1[2]), true);
    options.assert.equal(hasAccidental(notes1[3]), true);
    options.assert.equal(hasAccidental(notes1[4]), true);
    options.assert.equal(hasAccidental(notes1[5]), true);
    options.assert.equal(hasAccidental(notes1[6]), true);
    options.assert.equal(hasAccidental(notes1[7]), true);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter().joinVoices([voice0, voice1]).formatToStave([voice0, voice1], stave);
    f.draw();
    options.assert.ok(true);
}
function automaticAccidentalsCornerCases1(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 150);
    const stave = f.Stave().addKeySignature('C');
    const notes0 = [
        { keys: ['c/4'], duration: '4', stemDirection: -1 },
        { keys: ['c#/4'], duration: '4', stemDirection: -1 },
        { keys: ['c#/4'], duration: '4', stemDirection: -1 },
        { keys: ['c/4'], duration: '4', stemDirection: -1 },
        { keys: ['c/4'], duration: '4', stemDirection: -1 },
        { keys: ['cb/4'], duration: '4', stemDirection: -1 },
        { keys: ['cb/4'], duration: '4', stemDirection: -1 },
        { keys: ['c/4'], duration: '4', stemDirection: -1 },
        { keys: ['c/4'], duration: '4', stemDirection: -1 },
    ].map(f.StaveNote.bind(f));
    const voice0 = f.Voice().setMode(_src_voice__WEBPACK_IMPORTED_MODULE_14__.Voice.Mode.SOFT).addTickables(notes0);
    _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental.applyAccidentals([voice0], 'C');
    options.assert.equal(hasAccidental(notes0[0]), false);
    options.assert.equal(hasAccidental(notes0[1]), true);
    options.assert.equal(hasAccidental(notes0[2]), false);
    options.assert.equal(hasAccidental(notes0[3]), true);
    options.assert.equal(hasAccidental(notes0[4]), false);
    options.assert.equal(hasAccidental(notes0[5]), true);
    options.assert.equal(hasAccidental(notes0[6]), false);
    options.assert.equal(hasAccidental(notes0[7]), true);
    options.assert.equal(hasAccidental(notes0[8]), false);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter().joinVoices([voice0]).formatToStave([voice0], stave);
    f.draw();
    options.assert.ok(true);
}
function automaticAccidentalsCornerCases2(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 150);
    const stave = f.Stave().addKeySignature('C');
    const notes0 = [
        { keys: ['c/4'], duration: '4', stemDirection: -1 },
        { keys: ['c/5'], duration: '4', stemDirection: -1 },
        { keys: ['c#/4'], duration: '4', stemDirection: -1 },
        { keys: ['c#/5'], duration: '4', stemDirection: -1 },
        { keys: ['c#/4'], duration: '4', stemDirection: -1 },
        { keys: ['c#/5'], duration: '4', stemDirection: -1 },
        { keys: ['c/4'], duration: '4', stemDirection: -1 },
        { keys: ['c/5'], duration: '4', stemDirection: -1 },
        { keys: ['c/4'], duration: '4', stemDirection: -1 },
        { keys: ['c/5'], duration: '4', stemDirection: -1 },
        { keys: ['cb/4'], duration: '4', stemDirection: -1 },
        { keys: ['cb/5'], duration: '4', stemDirection: -1 },
        { keys: ['cb/4'], duration: '4', stemDirection: -1 },
        { keys: ['cb/5'], duration: '4', stemDirection: -1 },
        { keys: ['c/4'], duration: '4', stemDirection: -1 },
        { keys: ['c/5'], duration: '4', stemDirection: -1 },
        { keys: ['c/4'], duration: '4', stemDirection: -1 },
        { keys: ['c/5'], duration: '4', stemDirection: -1 },
    ].map(f.StaveNote.bind(f));
    const voice0 = f.Voice().setMode(_src_voice__WEBPACK_IMPORTED_MODULE_14__.Voice.Mode.SOFT).addTickables(notes0);
    _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental.applyAccidentals([voice0], 'C');
    options.assert.equal(hasAccidental(notes0[0]), false);
    options.assert.equal(hasAccidental(notes0[2]), true);
    options.assert.equal(hasAccidental(notes0[4]), false);
    options.assert.equal(hasAccidental(notes0[6]), true);
    options.assert.equal(hasAccidental(notes0[8]), false);
    options.assert.equal(hasAccidental(notes0[10]), true);
    options.assert.equal(hasAccidental(notes0[12]), false);
    options.assert.equal(hasAccidental(notes0[14]), true);
    options.assert.equal(hasAccidental(notes0[16]), false);
    options.assert.equal(hasAccidental(notes0[1]), false);
    options.assert.equal(hasAccidental(notes0[3]), true);
    options.assert.equal(hasAccidental(notes0[5]), false);
    options.assert.equal(hasAccidental(notes0[7]), true);
    options.assert.equal(hasAccidental(notes0[9]), false);
    options.assert.equal(hasAccidental(notes0[11]), true);
    options.assert.equal(hasAccidental(notes0[13]), false);
    options.assert.equal(hasAccidental(notes0[15]), true);
    options.assert.equal(hasAccidental(notes0[17]), false);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter().joinVoices([voice0]).formatToStave([voice0], stave);
    f.draw();
    options.assert.ok(true);
}
function automaticAccidentalsCornerCases3(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 150);
    const stave = f.Stave().addKeySignature('C#');
    const notes0 = [
        { keys: ['c/4'], duration: '4', stemDirection: -1 },
        { keys: ['c#/4'], duration: '4', stemDirection: -1 },
        { keys: ['c#/4'], duration: '4', stemDirection: -1 },
        { keys: ['c/4'], duration: '4', stemDirection: -1 },
        { keys: ['c/4'], duration: '4', stemDirection: -1 },
        { keys: ['cb/4'], duration: '4', stemDirection: -1 },
        { keys: ['cb/4'], duration: '4', stemDirection: -1 },
        { keys: ['c/4'], duration: '4', stemDirection: -1 },
        { keys: ['c/4'], duration: '4', stemDirection: -1 },
    ].map(f.StaveNote.bind(f));
    const voice0 = f.Voice().setMode(_src_voice__WEBPACK_IMPORTED_MODULE_14__.Voice.Mode.SOFT).addTickables(notes0);
    _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental.applyAccidentals([voice0], 'C#');
    options.assert.equal(hasAccidental(notes0[0]), true);
    options.assert.equal(hasAccidental(notes0[1]), true);
    options.assert.equal(hasAccidental(notes0[2]), false);
    options.assert.equal(hasAccidental(notes0[3]), true);
    options.assert.equal(hasAccidental(notes0[4]), false);
    options.assert.equal(hasAccidental(notes0[5]), true);
    options.assert.equal(hasAccidental(notes0[6]), false);
    options.assert.equal(hasAccidental(notes0[7]), true);
    options.assert.equal(hasAccidental(notes0[8]), false);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter().joinVoices([voice0]).formatToStave([voice0], stave);
    f.draw();
    options.assert.ok(true);
}
function automaticAccidentalsCornerCases4(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 150);
    const stave = f.Stave().addKeySignature('C#');
    const notes0 = [
        { keys: ['c/4'], duration: '4', stemDirection: -1 },
        { keys: ['c/5'], duration: '4', stemDirection: -1 },
        { keys: ['c#/4'], duration: '4', stemDirection: -1 },
        { keys: ['c#/5'], duration: '4', stemDirection: -1 },
        { keys: ['c#/4'], duration: '4', stemDirection: -1 },
        { keys: ['c#/5'], duration: '4', stemDirection: -1 },
        { keys: ['c/4'], duration: '4', stemDirection: -1 },
        { keys: ['c/5'], duration: '4', stemDirection: -1 },
        { keys: ['c/4'], duration: '4', stemDirection: -1 },
        { keys: ['c/5'], duration: '4', stemDirection: -1 },
        { keys: ['cb/4'], duration: '4', stemDirection: -1 },
        { keys: ['cb/5'], duration: '4', stemDirection: -1 },
        { keys: ['cb/4'], duration: '4', stemDirection: -1 },
        { keys: ['cb/5'], duration: '4', stemDirection: -1 },
        { keys: ['c/4'], duration: '4', stemDirection: -1 },
        { keys: ['c/5'], duration: '4', stemDirection: -1 },
        { keys: ['c/4'], duration: '4', stemDirection: -1 },
        { keys: ['c/5'], duration: '4', stemDirection: -1 },
    ].map(f.StaveNote.bind(f));
    const voice0 = f.Voice().setMode(_src_voice__WEBPACK_IMPORTED_MODULE_14__.Voice.Mode.SOFT).addTickables(notes0);
    _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental.applyAccidentals([voice0], 'C#');
    options.assert.equal(hasAccidental(notes0[0]), true);
    options.assert.equal(hasAccidental(notes0[2]), true);
    options.assert.equal(hasAccidental(notes0[4]), false);
    options.assert.equal(hasAccidental(notes0[6]), true);
    options.assert.equal(hasAccidental(notes0[8]), false);
    options.assert.equal(hasAccidental(notes0[10]), true);
    options.assert.equal(hasAccidental(notes0[12]), false);
    options.assert.equal(hasAccidental(notes0[14]), true);
    options.assert.equal(hasAccidental(notes0[16]), false);
    options.assert.equal(hasAccidental(notes0[1]), true);
    options.assert.equal(hasAccidental(notes0[3]), true);
    options.assert.equal(hasAccidental(notes0[5]), false);
    options.assert.equal(hasAccidental(notes0[7]), true);
    options.assert.equal(hasAccidental(notes0[9]), false);
    options.assert.equal(hasAccidental(notes0[11]), true);
    options.assert.equal(hasAccidental(notes0[13]), false);
    options.assert.equal(hasAccidental(notes0[15]), true);
    options.assert.equal(hasAccidental(notes0[17]), false);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter().joinVoices([voice0]).formatToStave([voice0], stave);
    f.draw();
    options.assert.ok(true);
}
function factoryAPI(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 240);
    f.Stave({ x: 10, y: 10, width: 550 });
    const accid = makeNewAccid(f);
    const notes = [
        f
            .StaveNote({ keys: ['c/4', 'e/4', 'a/4'], duration: 'w' })
            .addModifier(accid('b'), 0)
            .addModifier(accid('#'), 1),
        f
            .StaveNote({ keys: ['d/4', 'e/4', 'f/4', 'a/4', 'c/5', 'e/5', 'g/5'], duration: 'h' })
            .addModifier(accid('##'), 0)
            .addModifier(accid('n'), 1)
            .addModifier(accid('bb'), 2)
            .addModifier(accid('b'), 3)
            .addModifier(accid('#'), 4)
            .addModifier(accid('n'), 5)
            .addModifier(accid('bb'), 6),
        f
            .StaveNote({ keys: ['f/4', 'g/4', 'a/4', 'b/4', 'c/5', 'e/5', 'g/5'], duration: '16' })
            .addModifier(accid('n'), 0)
            .addModifier(accid('#'), 1)
            .addModifier(accid('#'), 2)
            .addModifier(accid('b'), 3)
            .addModifier(accid('bb'), 4)
            .addModifier(accid('##'), 5)
            .addModifier(accid('#'), 6),
        f
            .StaveNote({ keys: ['a/3', 'c/4', 'e/4', 'b/4', 'd/5', 'g/5'], duration: 'w' })
            .addModifier(accid('#'), 0)
            .addModifier(accid('##').setAsCautionary(), 1)
            .addModifier(accid('#').setAsCautionary(), 2)
            .addModifier(accid('b'), 3)
            .addModifier(accid('bb').setAsCautionary(), 4)
            .addModifier(accid('b').setAsCautionary(), 5),
    ];
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.SimpleFormat(notes);
    notes.forEach((n, i) => {
        options.assert.ok(n.getModifiersByType('Accidental').length > 0, 'Note ' + i + ' has accidentals');
    });
    f.draw();
    options.assert.ok(true, 'Factory API');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(AccidentalTests);



/***/ }),

/***/ "./tests/annotation_tests.ts":
/*!***********************************!*\
  !*** ./tests/annotation_tests.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnnotationTests: () => (/* binding */ AnnotationTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_annotation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/annotation */ "./src/annotation.ts");
/* harmony import */ var _src_articulation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/articulation */ "./src/articulation.ts");
/* harmony import */ var _src_beam__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/beam */ "./src/beam.ts");
/* harmony import */ var _src_bend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/bend */ "./src/bend.ts");
/* harmony import */ var _src_flow__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/flow */ "./src/flow.ts");
/* harmony import */ var _src_formatter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/formatter */ "./src/formatter.ts");
/* harmony import */ var _src_metrics__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/metrics */ "./src/metrics.ts");
/* harmony import */ var _src_modifier__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/modifier */ "./src/modifier.ts");
/* harmony import */ var _src_registry__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/registry */ "./src/registry.ts");
/* harmony import */ var _src_stave__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../src/stave */ "./src/stave.ts");
/* harmony import */ var _src_stavenote__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../src/stavenote */ "./src/stavenote.ts");
/* harmony import */ var _src_stem__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../src/stem */ "./src/stem.ts");
/* harmony import */ var _src_tabnote__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../src/tabnote */ "./src/tabnote.ts");
/* harmony import */ var _src_tabstave__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../src/tabstave */ "./src/tabstave.ts");
/* harmony import */ var _src_vibrato__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../src/vibrato */ "./src/vibrato.ts");
/* harmony import */ var _src_voice__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../src/voice */ "./src/voice.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Annotation Tests
// TODO: Formatter.FormatAndDraw(ctx, stave, notes, ???number???);
//       Did a previous version of the API accept a number as the fourth argument?
//       We removed the fourth argument from all of our test cases.

















const AnnotationTests = {
    Start() {
        QUnit.module('Annotation');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Placement', placement);
        run('Lyrics', lyrics);
        run('Simple Annotation', simple);
        run('Styled Annotation', styling);
        run('Standard Notation Annotation', standard);
        run('Harmonics', harmonic);
        run('Fingerpicking', picking);
        run('Bottom Annotation', bottom);
        run('Bottom Annotations with Beams', bottomWithBeam);
        run('Test Justification Annotation Stem Up', justificationStemUp);
        run('Test Justification Annotation Stem Down', justificationStemDown);
        run('TabNote Annotations', tabNotes);
    },
};
const FONT_SIZE = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.Font.size;
// Helper functions to create TabNote and StaveNote objects.
const tabNote = (noteStruct) => new _src_tabnote__WEBPACK_IMPORTED_MODULE_13__.TabNote(noteStruct);
const staveNote = (noteStruct) => new _src_stavenote__WEBPACK_IMPORTED_MODULE_11__.StaveNote(noteStruct);
/**
 * Show lyrics using Annotation objects.
 */
function lyrics(options) {
    let fontSize = FONT_SIZE;
    let x = 10;
    let width = 170;
    let ratio = 1;
    const registry = new _src_registry__WEBPACK_IMPORTED_MODULE_9__.Registry();
    _src_registry__WEBPACK_IMPORTED_MODULE_9__.Registry.enableDefaultRegistry(registry);
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 750, 260);
    // Add three groups of staves. Each time we increase the fontSize by 2.
    for (let i = 0; i < 3; ++i) {
        const score = f.EasyScore();
        score.set({ time: '3/4' });
        const system = f.System({ width, x });
        system.addStave({
            voices: [
                score.voice(score.notes('(C4 F4)/2[id="n0"]').concat(score.beam(score.notes('(C4 A4)/8[id="n1"], (C4 A4)/8[id="n2"]')))),
            ],
        });
        // Add lyrics under the first row.
        ['hand,', 'and', 'me', 'pears', 'lead', 'the'].forEach((text, ix) => {
            const verse = Math.floor(ix / 3);
            const noteGroupID = 'n' + (ix % 3);
            const noteGroup = registry.getElementById(noteGroupID);
            const lyricsAnnotation = f.Annotation({ text }).setFontSize(fontSize);
            lyricsAnnotation.setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_8__.ModifierPosition.BELOW);
            noteGroup.addModifier(lyricsAnnotation, verse);
        });
        // Second row doesn't have any lyrics.
        system.addStave({
            voices: [score.voice(score.notes('(F4 D5)/2').concat(score.beam(score.notes('(F4 F5)/8, (F4 F5)/8'))))],
        });
        f.draw();
        ratio = (fontSize + 2) / fontSize;
        width = width * ratio;
        x = x + width;
        fontSize = fontSize + 2;
    }
    options.assert.ok(true);
}
function simple(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 500, 240);
    ctx.scale(1.5, 1.5);
    ctx.font = '10pt Arial, sans-serif';
    const stave = new _src_tabstave__WEBPACK_IMPORTED_MODULE_14__.TabStave(10, 10, 450).addTabGlyph().setContext(ctx).draw();
    const notes = [
        tabNote({
            positions: [
                { str: 2, fret: 10 },
                { str: 4, fret: 9 },
            ],
            duration: 'h',
        }).addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('T'), 0),
        tabNote({
            positions: [{ str: 2, fret: 10 }],
            duration: 'h',
        }).addModifier(new _src_bend__WEBPACK_IMPORTED_MODULE_4__.Bend([{ type: _src_bend__WEBPACK_IMPORTED_MODULE_4__.Bend.UP, text: 'Full' }]).setTap('T'), 0),
    ];
    _src_formatter__WEBPACK_IMPORTED_MODULE_6__.Formatter.FormatAndDraw(ctx, stave, notes);
    options.assert.ok(true, 'Simple Annotation');
}
function standard(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 500, 240);
    ctx.scale(1.5, 1.5);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_10__.Stave(10, 10, 450).addClef('treble').setContext(ctx).draw();
    const annotation = (text) => new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation(text).setFont(_src_metrics__WEBPACK_IMPORTED_MODULE_7__.Metrics.get('Annotation.fontFamily'), FONT_SIZE, 'normal', 'italic');
    const notes = [
        staveNote({ keys: ['c/4', 'e/4'], duration: 'h' }).addModifier(annotation('quiet'), 0),
        staveNote({ keys: ['c/4', 'e/4', 'c/5'], duration: 'h' }).addModifier(annotation('Allegro'), 2),
    ];
    _src_formatter__WEBPACK_IMPORTED_MODULE_6__.Formatter.FormatAndDraw(ctx, stave, notes);
    options.assert.ok(true, 'Standard Notation Annotation');
}
function styling(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 500, 240);
    ctx.scale(1.5, 1.5);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_10__.Stave(10, 10, 450).addClef('treble').setContext(ctx).draw();
    const annotation = (text, style) => new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation(text)
        .setFont(_src_metrics__WEBPACK_IMPORTED_MODULE_7__.Metrics.get('Annotation.fontFamily'), FONT_SIZE, 'normal', 'italic')
        .setStyle(style);
    const notes = [
        staveNote({ keys: ['c/4', 'e/4'], duration: 'h' }).addModifier(annotation('quiet', { fillStyle: '#0F0' }), 0),
        staveNote({ keys: ['c/4', 'e/4', 'c/5'], duration: 'h' }).addModifier(annotation('Allegro', { fillStyle: '#00F' }), 2),
    ];
    _src_formatter__WEBPACK_IMPORTED_MODULE_6__.Formatter.FormatAndDraw(ctx, stave, notes);
    options.assert.ok(true, 'Standard Notation Annotation');
}
function harmonic(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 500, 240);
    ctx.scale(1.5, 1.5);
    ctx.font = '10pt Arial';
    const stave = new _src_tabstave__WEBPACK_IMPORTED_MODULE_14__.TabStave(10, 10, 450).addClef('tab').setContext(ctx).draw();
    const notes = [
        tabNote({
            positions: [
                { str: 2, fret: 12 },
                { str: 3, fret: 12 },
            ],
            duration: 'h',
        }).addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('Harm.'), 0),
        tabNote({
            positions: [{ str: 2, fret: 9 }],
            duration: 'h',
        })
            .addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('(8va)').setFont(_src_metrics__WEBPACK_IMPORTED_MODULE_7__.Metrics.get('Annotation.fontFamily'), FONT_SIZE, 'normal', 'italic'), 0)
            .addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('A.H.'), 0),
    ];
    _src_formatter__WEBPACK_IMPORTED_MODULE_6__.Formatter.FormatAndDraw(ctx, stave, notes);
    options.assert.ok(true, 'Simple Annotation');
}
function picking(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 500, 240);
    ctx.setFont(_src_metrics__WEBPACK_IMPORTED_MODULE_7__.Metrics.get('fontFamily'), FONT_SIZE);
    const stave = new _src_tabstave__WEBPACK_IMPORTED_MODULE_14__.TabStave(10, 10, 450).addClef('tab').setContext(ctx).draw();
    const annotation = (text) => new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation(text).setFont(_src_metrics__WEBPACK_IMPORTED_MODULE_7__.Metrics.get('Annotation.fontFamily'), FONT_SIZE, 'normal', 'italic');
    const notes = [
        tabNote({
            positions: [
                { str: 1, fret: 0 },
                { str: 2, fret: 1 },
                { str: 3, fret: 2 },
                { str: 4, fret: 2 },
                { str: 5, fret: 0 },
            ],
            duration: 'h',
        }).addModifier(new _src_vibrato__WEBPACK_IMPORTED_MODULE_15__.Vibrato().setVibratoWidth(40), 0),
        tabNote({
            positions: [{ str: 6, fret: 9 }],
            duration: '8',
        }).addModifier(annotation('p').setVerticalJustification(_src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.TOP), 0),
        tabNote({
            positions: [{ str: 3, fret: 9 }],
            duration: '8',
        }).addModifier(annotation('i').setVerticalJustification(_src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.TOP), 0),
        tabNote({
            positions: [{ str: 2, fret: 9 }],
            duration: '8',
        }).addModifier(annotation('m').setVerticalJustification(_src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.TOP), 0),
        tabNote({
            positions: [{ str: 1, fret: 9 }],
            duration: '8',
        }).addModifier(annotation('a').setVerticalJustification(_src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.TOP), 0),
    ];
    _src_formatter__WEBPACK_IMPORTED_MODULE_6__.Formatter.FormatAndDraw(ctx, stave, notes);
    options.assert.ok(true, 'Fingerpicking');
}
function placement(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 750, 300);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_10__.Stave(10, 50, 750).addClef('treble').setContext(ctx).draw();
    const annotation = (text, fontSize, vj) => new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation(text).setFontSize(fontSize).setVerticalJustification(vj);
    const notes = [
        staveNote({ keys: ['e/4'], duration: 'q', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_12__.Stem.DOWN })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_2__.Articulation('a.').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_8__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_2__.Articulation('a-').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_8__.ModifierPosition.ABOVE), 0)
            .addModifier(annotation('v1', 10, _src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.TOP), 0)
            .addModifier(annotation('v2', 10, _src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.TOP), 0),
        staveNote({ keys: ['b/4'], duration: 'q', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_12__.Stem.DOWN })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_2__.Articulation('a.').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_8__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_2__.Articulation('a-').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_8__.ModifierPosition.ABOVE), 0)
            .addModifier(annotation('v1', 10, _src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.TOP), 0)
            .addModifier(annotation('v2', 10, _src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.TOP), 0),
        staveNote({ keys: ['c/5'], duration: 'q', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_12__.Stem.DOWN })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_2__.Articulation('a.').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_8__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_2__.Articulation('a-').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_8__.ModifierPosition.ABOVE), 0)
            .addModifier(annotation('v1', 10, _src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.TOP), 0)
            .addModifier(annotation('v2', 10, _src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.TOP), 0),
        staveNote({ keys: ['f/4'], duration: 'q' })
            .addModifier(annotation('v1', 14, _src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.TOP), 0)
            .addModifier(annotation('v2', 14, _src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.TOP), 0),
        staveNote({ keys: ['f/4'], duration: 'q', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_12__.Stem.DOWN })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_2__.Articulation('am').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_8__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_2__.Articulation('a.').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_8__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_2__.Articulation('a-').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_8__.ModifierPosition.ABOVE), 0)
            .addModifier(annotation('v1', 10, _src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.TOP), 0)
            .addModifier(annotation('v2', 20, _src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.TOP), 0),
        staveNote({ keys: ['f/5'], duration: 'q' })
            .addModifier(annotation('v1', 11, _src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.TOP), 0)
            .addModifier(annotation('v2', 11, _src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.TOP), 0),
        staveNote({ keys: ['f/5'], duration: 'q' })
            .addModifier(annotation('v1', 11, _src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.TOP), 0)
            .addModifier(annotation('v2', 20, _src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.TOP), 0),
        staveNote({ keys: ['f/4'], duration: 'q' })
            .addModifier(annotation('v1', 12, _src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.BOTTOM), 0)
            .addModifier(annotation('v2', 12, _src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.BOTTOM), 0),
        staveNote({ keys: ['f/5'], duration: 'q' })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_2__.Articulation('a.').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_8__.ModifierPosition.BELOW), 0)
            .addModifier(annotation('v1', 11, _src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.BOTTOM), 0)
            .addModifier(annotation('v2', 20, _src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.BOTTOM), 0),
        staveNote({ keys: ['f/5'], duration: 'q', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_12__.Stem.DOWN })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_2__.Articulation('am').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_8__.ModifierPosition.BELOW), 0)
            .addModifier(annotation('v1', 10, _src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.BOTTOM), 0)
            .addModifier(annotation('v2', 20, _src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.BOTTOM), 0),
        staveNote({ keys: ['f/4'], duration: 'q', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_12__.Stem.DOWN })
            .addModifier(annotation('v1', 10, _src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.BOTTOM), 0)
            .addModifier(annotation('v2', 20, _src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.BOTTOM), 0),
        staveNote({ keys: ['f/5'], duration: 'w' })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_2__.Articulation('a@u').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_8__.ModifierPosition.BELOW), 0)
            .addModifier(annotation('v1', 11, _src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.BOTTOM), 0)
            .addModifier(annotation('v2', 16, _src_annotation__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.BOTTOM), 0),
    ];
    _src_formatter__WEBPACK_IMPORTED_MODULE_6__.Formatter.FormatAndDraw(ctx, stave, notes);
    options.assert.ok(true, ' Annotation Placement');
}
function bottom(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 500, 240);
    ctx.scale(1.5, 1.5);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_10__.Stave(10, 10, 300).addClef('treble').setContext(ctx).draw();
    const annotation = (text) => new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation(text).setFontSize(FONT_SIZE).setVerticalJustification(_src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation.VerticalJustify.BOTTOM);
    const notes = [
        staveNote({ keys: ['f/4'], duration: 'w' }).addModifier(annotation('F'), 0),
        staveNote({ keys: ['a/4'], duration: 'w' }).addModifier(annotation('A'), 0),
        staveNote({ keys: ['c/5'], duration: 'w' }).addModifier(annotation('C'), 0),
        staveNote({ keys: ['e/5'], duration: 'w' }).addModifier(annotation('E'), 0),
    ];
    _src_formatter__WEBPACK_IMPORTED_MODULE_6__.Formatter.FormatAndDraw(ctx, stave, notes);
    options.assert.ok(true, 'Bottom Annotation');
}
function bottomWithBeam(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 500, 240);
    ctx.scale(1.5, 1.5);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_10__.Stave(10, 10, 300).addClef('treble').setContext(ctx).draw();
    const notes = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_11__.StaveNote({ keys: ['a/3'], duration: '8' }).addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('good').setVerticalJustification(_src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation.VerticalJustify.BOTTOM)),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_11__.StaveNote({ keys: ['g/3'], duration: '8' }).addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('even').setVerticalJustification(_src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation.VerticalJustify.BOTTOM)),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_11__.StaveNote({ keys: ['c/4'], duration: '8' }).addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('under').setVerticalJustification(_src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation.VerticalJustify.BOTTOM)),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_11__.StaveNote({ keys: ['d/4'], duration: '8' }).addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('beam').setVerticalJustification(_src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation.VerticalJustify.BOTTOM)),
    ];
    const beam = new _src_beam__WEBPACK_IMPORTED_MODULE_3__.Beam(notes.slice(1));
    _src_formatter__WEBPACK_IMPORTED_MODULE_6__.Formatter.FormatAndDraw(ctx, stave, notes);
    beam.setContext(ctx).draw();
    options.assert.ok(true, 'Bottom Annotation with Beams');
}
function justificationStemUp(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 650, 950);
    ctx.scale(1.5, 1.5);
    const annotation = (text, hJustification, vJustification) => new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation(text)
        .setFontSize(FONT_SIZE)
        .setJustification(hJustification)
        .setVerticalJustification(vJustification);
    for (let v = 1; v <= 4; ++v) {
        const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_10__.Stave(10, (v - 1) * 150 + 40, 400).addClef('treble').setContext(ctx).draw();
        const notes = [
            staveNote({ keys: ['c/3'], duration: 'q' }).addModifier(annotation('Text', 1, v), 0),
            staveNote({ keys: ['c/4'], duration: 'q' }).addModifier(annotation('Text', 2, v), 0),
            staveNote({ keys: ['c/4', 'e/4', 'c/5'], duration: 'q' }).addModifier(annotation('Text', 3, v), 0),
            staveNote({ keys: ['c/6'], duration: 'q' }).addModifier(annotation('Text', 4, v), 0),
        ];
        _src_formatter__WEBPACK_IMPORTED_MODULE_6__.Formatter.FormatAndDraw(ctx, stave, notes);
    }
    options.assert.ok(true, 'Test Justification Annotation');
}
function justificationStemDown(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 650, 1000);
    ctx.scale(1.5, 1.5);
    const annotation = (text, hJustification, vJustification) => new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation(text)
        .setFontSize(FONT_SIZE)
        .setJustification(hJustification)
        .setVerticalJustification(vJustification);
    for (let v = 1; v <= 4; ++v) {
        const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_10__.Stave(10, (v - 1) * 150 + 40, 400).addClef('treble').setContext(ctx).draw();
        const notes = [
            staveNote({ keys: ['c/3'], duration: 'q', stemDirection: -1 }).addModifier(annotation('Text', 1, v), 0),
            staveNote({ keys: ['c/4', 'e/4', 'c/5'], duration: 'q', stemDirection: -1 }).addModifier(annotation('Text', 2, v), 0),
            staveNote({ keys: ['c/5'], duration: 'q', stemDirection: -1 }).addModifier(annotation('Text', 3, v), 0),
            staveNote({ keys: ['c/6'], duration: 'q', stemDirection: -1 }).addModifier(annotation('Text', 4, v), 0),
        ];
        _src_formatter__WEBPACK_IMPORTED_MODULE_6__.Formatter.FormatAndDraw(ctx, stave, notes);
    }
    options.assert.ok(true, 'Test Justification Annotation');
}
function tabNotes(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 600, 200);
    ctx.font = '10pt Arial, sans-serif';
    const stave = new _src_tabstave__WEBPACK_IMPORTED_MODULE_14__.TabStave(10, 10, 550);
    stave.setContext(ctx);
    stave.draw();
    const specs = [
        {
            positions: [
                { str: 3, fret: 6 },
                { str: 4, fret: 25 },
            ],
            duration: '8',
        },
        {
            positions: [
                { str: 2, fret: 10 },
                { str: 5, fret: 12 },
            ],
            duration: '8',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 3, fret: 5 },
            ],
            duration: '8',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 3, fret: 5 },
            ],
            duration: '8',
        },
    ];
    const notes1 = specs.map((noteSpec) => {
        const note = new _src_tabnote__WEBPACK_IMPORTED_MODULE_13__.TabNote(noteSpec);
        note.renderOptions.drawStem = true;
        return note;
    });
    const notes2 = specs.map((noteSpec) => {
        const note = new _src_tabnote__WEBPACK_IMPORTED_MODULE_13__.TabNote(noteSpec);
        note.renderOptions.drawStem = true;
        note.setStemDirection(-1);
        return note;
    });
    const notes3 = specs.map((noteSpec) => new _src_tabnote__WEBPACK_IMPORTED_MODULE_13__.TabNote(noteSpec));
    notes1[0].addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('Text').setJustification(1).setVerticalJustification(1)); // U
    notes1[1].addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('Text').setJustification(2).setVerticalJustification(2)); // D
    notes1[2].addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('Text').setJustification(3).setVerticalJustification(3)); // U
    notes1[3].addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('Text').setJustification(4).setVerticalJustification(4)); // D
    notes2[0].addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('Text').setJustification(3).setVerticalJustification(1)); // U
    notes2[1].addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('Text').setJustification(3).setVerticalJustification(2)); // D
    notes2[2].addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('Text').setJustification(3).setVerticalJustification(3)); // U
    notes2[3].addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('Text').setJustification(3).setVerticalJustification(4)); // D
    notes3[0].addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('Text').setVerticalJustification(1)); // U
    notes3[1].addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('Text').setVerticalJustification(2)); // D
    notes3[2].addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('Text').setVerticalJustification(3)); // U
    notes3[3].addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('Text').setVerticalJustification(4)); // D
    const voice = new _src_voice__WEBPACK_IMPORTED_MODULE_16__.Voice(_src_flow__WEBPACK_IMPORTED_MODULE_5__.Flow.TIME4_4).setMode(_src_voice__WEBPACK_IMPORTED_MODULE_16__.Voice.Mode.SOFT);
    voice.addTickables(notes1);
    voice.addTickables(notes2);
    voice.addTickables(notes3);
    // Alternatively, you could add all the notes in one big array with spread syntax.
    // voice.addTickables([...notes1, ...notes2, ...notes3]);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_6__.Formatter().joinVoices([voice]).formatToStave([voice], stave, { stave });
    voice.draw(ctx, stave);
    options.assert.ok(true, 'TabNotes successfully drawn');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(AnnotationTests);



/***/ }),

/***/ "./tests/articulation_tests.ts":
/*!*************************************!*\
  !*** ./tests/articulation_tests.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArticulationTests: () => (/* binding */ ArticulationTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_articulation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/articulation */ "./src/articulation.ts");
/* harmony import */ var _src_beam__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/beam */ "./src/beam.ts");
/* harmony import */ var _src_flow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/flow */ "./src/flow.ts");
/* harmony import */ var _src_formatter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/formatter */ "./src/formatter.ts");
/* harmony import */ var _src_metrics__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/metrics */ "./src/metrics.ts");
/* harmony import */ var _src_modifier__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/modifier */ "./src/modifier.ts");
/* harmony import */ var _src_stave__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/stave */ "./src/stave.ts");
/* harmony import */ var _src_stavebarline__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/stavebarline */ "./src/stavebarline.ts");
/* harmony import */ var _src_stavenote__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/stavenote */ "./src/stavenote.ts");
/* harmony import */ var _src_stem__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../src/stem */ "./src/stem.ts");
/* harmony import */ var _src_tabnote__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../src/tabnote */ "./src/tabnote.ts");
/* harmony import */ var _src_tabstave__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../src/tabstave */ "./src/tabstave.ts");
/* harmony import */ var _src_voice__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../src/voice */ "./src/voice.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Articulation Tests














const ArticulationTests = {
    Start() {
        QUnit.module('Articulation');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Articulation - Vertical Placement', verticalPlacement);
        run('Articulation - Vertical Placement (Glyph codes)', verticalPlacement2);
        run('Articulation - Staccato/Staccatissimo', drawArticulations, { sym1: 'a.', sym2: 'av' });
        run('Articulation - Accent/Tenuto', drawArticulations, { sym1: 'a>', sym2: 'a-' });
        run('Articulation - Marcato/L.H. Pizzicato', drawArticulations, { sym1: 'a^', sym2: 'a+' });
        run('Articulation - Snap Pizzicato/Fermata', drawArticulations, { sym1: 'ao', sym2: 'ao' });
        run('Articulation - Up-stroke/Down-Stroke', drawArticulations, { sym1: 'a|', sym2: 'am' });
        run('Articulation - Fermata Above/Below', drawFermata, { sym1: 'a@a', sym2: 'a@u' });
        run('Articulation - Fermata Short Above/Below', drawFermata, { sym1: 'a@as', sym2: 'a@us' });
        run('Articulation - Fermata Long Above/Below', drawFermata, { sym1: 'a@al', sym2: 'a@ul' });
        run('Articulation - Fermata Very Long Above/Below', drawFermata, { sym1: 'a@avl', sym2: 'a@uvl' });
        run('Articulation - Inline/Multiple', drawArticulations2, { sym1: 'a.', sym2: 'a.' });
        run('TabNote Articulation', tabNotes, { sym1: 'a.', sym2: 'a.' });
    },
};
// Helper function for creating StaveNotes.
function drawArticulations(options) {
    const sym1 = options.params.sym1;
    const sym2 = options.params.sym2;
    const width = 125 - _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave.defaultPadding;
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 675, 195);
    const ctx = f.getContext();
    options.assert.expect(0);
    let x = 10;
    const y = 30;
    const score = f.EasyScore();
    const formatAndDrawToWidth = (x, y, width, notes, barline) => {
        const voices = [score.voice(notes, { time: '4/4' })];
        const formatter = f.Formatter();
        voices.forEach((v) => formatter.joinVoices([v]));
        const nwidth = Math.max(formatter.preCalculateMinTotalWidth(voices), width);
        formatter.format(voices, nwidth);
        const stave = f
            .Stave({ x, y, width: nwidth + _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave.defaultPadding })
            .setEndBarType(barline)
            .setContext(ctx)
            .draw();
        voices.forEach((voice) => voice.draw(ctx, stave));
        return stave.getWidth();
    };
    // bar 1
    const notesBar1 = [
        f.StaveNote({ keys: ['a/3'], duration: 'q', stemDirection: 1 }),
        f.StaveNote({ keys: ['a/4'], duration: 'q', stemDirection: 1 }),
        f.StaveNote({ keys: ['c/4'], duration: 'q', stemDirection: 1 }),
        f.StaveNote({ keys: ['a/4'], duration: 'q', stemDirection: 1 }),
    ];
    notesBar1[0].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation(sym1).setPosition(4), 0);
    notesBar1[1].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation(sym1).setPosition(4), 0);
    notesBar1[2].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation(sym1).setPosition(3), 0);
    notesBar1[3].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation(sym1).setPosition(3), 0);
    // Helper function to justify and draw a 4/4 voice
    x += formatAndDrawToWidth(x, y, width, notesBar1, _src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.Barline.type.NONE);
    // bar 2 - juxtaposing second bar next to first bar
    const notesBar2 = [
        f.StaveNote({ keys: ['c/5'], duration: 'q', stemDirection: -1 }),
        f.StaveNote({ keys: ['a/5'], duration: 'q', stemDirection: -1 }),
        f.StaveNote({ keys: ['c/5'], duration: 'q', stemDirection: -1 }),
        f.StaveNote({ keys: ['a/5'], duration: 'q', stemDirection: -1 }),
    ];
    notesBar2[0].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation(sym1).setPosition(3), 0);
    notesBar2[1].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation(sym1).setPosition(3), 0);
    notesBar2[2].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation(sym1).setPosition(4), 0);
    notesBar2[3].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation(sym1).setPosition(4), 0);
    // Helper function to justify and draw a 4/4 voice
    x += formatAndDrawToWidth(x, y, width, notesBar2, _src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.Barline.type.DOUBLE);
    // bar 3 - juxtaposing second bar next to first bar
    const notesBar3 = [
        f.StaveNote({ keys: ['c/4'], duration: 'q', stemDirection: 1 }),
        f.StaveNote({ keys: ['c/5'], duration: 'q', stemDirection: 1 }),
        f.StaveNote({ keys: ['c/4'], duration: 'q', stemDirection: 1 }),
        f.StaveNote({ keys: ['a/4'], duration: 'q', stemDirection: 1 }),
    ];
    notesBar3[0].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation(sym2).setPosition(4), 0);
    notesBar3[1].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation(sym2).setPosition(4), 0);
    notesBar3[2].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation(sym2).setPosition(3), 0);
    notesBar3[3].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation(sym2).setPosition(3), 0);
    // Helper function to justify and draw a 4/4 voice
    x += formatAndDrawToWidth(x, y, width, notesBar3, _src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.Barline.type.NONE);
    // bar 4 - juxtaposing second bar next to first bar
    const notesBar4 = [
        f.StaveNote({ keys: ['a/4'], duration: 'q', stemDirection: -1 }),
        f.StaveNote({ keys: ['a/5'], duration: 'q', stemDirection: -1 }),
        f.StaveNote({ keys: ['c/5'], duration: 'q', stemDirection: -1 }),
        f.StaveNote({ keys: ['a/5'], duration: 'q', stemDirection: -1 }),
    ];
    notesBar4[0].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation(sym2).setPosition(3), 0);
    notesBar4[1].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation(sym2).setPosition(3), 0);
    notesBar4[2].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation(sym2).setPosition(4), 0);
    notesBar4[3].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation(sym2).setPosition(4), 0);
    // Helper function to justify and draw a 4/4 voice
    formatAndDrawToWidth(x, y, width, notesBar4, _src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.Barline.type.END);
}
function drawFermata(options) {
    const sym1 = options.params.sym1;
    const sym2 = options.params.sym2;
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 400, 195);
    const ctx = f.getContext();
    const score = f.EasyScore();
    const width = 150 - _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave.defaultPadding;
    let x = 50;
    const y = 30;
    const formatAndDrawToWidth = (x, y, width, notes, barline) => {
        const voices = [score.voice(notes, { time: '4/4' })];
        const formatter = f.Formatter();
        voices.forEach((v) => formatter.joinVoices([v]));
        const nwidth = Math.max(formatter.preCalculateMinTotalWidth(voices), width);
        formatter.format(voices, nwidth);
        const stave = f
            .Stave({ x, y, width: nwidth + _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave.defaultPadding })
            .setEndBarType(barline)
            .setContext(ctx)
            .draw();
        voices.forEach((voice) => voice.draw(ctx, stave));
        return stave.getWidth();
    };
    options.assert.expect(0);
    const notesBar1 = [
        f.StaveNote({ keys: ['c/4'], duration: 'q', stemDirection: 1 }),
        f.StaveNote({ keys: ['a/4'], duration: 'q', stemDirection: 1 }),
        f.StaveNote({ keys: ['c/4'], duration: 'q', stemDirection: -1 }),
        f.StaveNote({ keys: ['a/4'], duration: 'q', stemDirection: -1 }),
    ];
    notesBar1[0].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation(sym1).setPosition(3), 0);
    notesBar1[1].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation(sym1).setPosition(3), 0);
    notesBar1[2].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation(sym2).setPosition(4), 0);
    notesBar1[3].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation(sym2).setPosition(4), 0);
    x += formatAndDrawToWidth(x, y, width, notesBar1, _src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.Barline.type.NONE);
    // bar 2 - juxtaposing second bar next to first bar
    const notesBar2 = [
        f.StaveNote({ keys: ['c/5'], duration: 'q', stemDirection: 1 }),
        f.StaveNote({ keys: ['a/5'], duration: 'q', stemDirection: 1 }),
        f.StaveNote({ keys: ['c/5'], duration: 'q', stemDirection: -1 }),
        f.StaveNote({ keys: ['a/5'], duration: 'q', stemDirection: -1 }),
    ];
    notesBar2[0].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation(sym1).setPosition(3), 0);
    notesBar2[1].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation(sym1).setPosition(3), 0);
    notesBar2[2].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation(sym2).setPosition(4), 0);
    notesBar2[3].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation(sym2).setPosition(4), 0);
    // Helper function to justify and draw a 4/4 voice
    formatAndDrawToWidth(x, y, width, notesBar2, _src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.Barline.type.DOUBLE);
}
function verticalPlacement(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 750, 300);
    const staveNote = (noteStruct) => new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote(noteStruct);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(10, 50, 750).addClef('treble').setContext(ctx).draw();
    const notes = [
        staveNote({ keys: ['f/4'], duration: 'q' })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a@u').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a.').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a-').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.BELOW), 0),
        staveNote({ keys: ['g/4'], duration: 'q', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_10__.Stem.DOWN })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a@u').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a.').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a-').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.BELOW), 0),
        staveNote({ keys: ['c/5'], duration: 'q' })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a@u').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a.').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a-').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.BELOW), 0),
        staveNote({ keys: ['f/4'], duration: 'q' })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a.').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a-').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a@u').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.BELOW), 0),
        staveNote({ keys: ['g/4'], duration: 'q', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_10__.Stem.DOWN })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a.').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a-').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a@u').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.BELOW), 0),
        staveNote({ keys: ['c/5'], duration: 'q' })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a.').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a-').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a@u').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.BELOW), 0),
        staveNote({ keys: ['a/5'], duration: 'q', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_10__.Stem.DOWN })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a@a').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a.').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a-').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.ABOVE), 0),
        staveNote({ keys: ['f/5'], duration: 'q' })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a@a').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a.').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a-').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.ABOVE), 0),
        staveNote({ keys: ['b/4'], duration: 'q', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_10__.Stem.DOWN })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a@a').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a.').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a-').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.ABOVE), 0),
        staveNote({ keys: ['a/5'], duration: 'q', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_10__.Stem.DOWN })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a.').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a-').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a@a').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.ABOVE), 0),
        staveNote({ keys: ['f/5'], duration: 'q' })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a.').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a-').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a@a').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.ABOVE), 0),
        staveNote({ keys: ['b/4'], duration: 'q', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_10__.Stem.DOWN })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a.').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a-').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a@a').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.ABOVE), 0),
    ];
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, stave, notes);
    options.assert.ok(true, ' Annotation Placement');
}
function verticalPlacement2(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 750, 300);
    const staveNote = (noteStruct) => new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote(noteStruct);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(10, 50, 750).addClef('treble').setContext(ctx).draw();
    const notes = [
        staveNote({ keys: ['f/4'], duration: 'q' })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue4c1' /*fermataBelow*/), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue1e7' /*augmentationDot*/).setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue4a5' /*articTenutoBelow*/), 0),
        staveNote({ keys: ['g/4'], duration: 'q', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_10__.Stem.DOWN })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue4c5' /*fermataShortBelow*/), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue1e7' /*augmentationDot*/).setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue4a5' /*articTenutoBelow*/), 0),
        staveNote({ keys: ['c/5'], duration: 'q' })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue4c7' /*fermataLongBelow*/), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue1e7' /*augmentationDot*/).setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue4a5' /*articTenutoBelow*/), 0),
        staveNote({ keys: ['f/4'], duration: 'q' })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue1e7' /*augmentationDot*/).setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue4a5' /*articTenutoBelow*/), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue4c3' /*fermataVeryShortBelow*/), 0),
        staveNote({ keys: ['g/4'], duration: 'q', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_10__.Stem.DOWN })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue1e7' /*augmentationDot*/).setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue4a5' /*articTenutoBelow*/), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue4c9' /*fermataVeryLongBelow*/), 0),
        staveNote({ keys: ['c/5'], duration: 'q' })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue1e7' /*augmentationDot*/).setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.BELOW).setBetweenLines(), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue4a5' /*articTenutoBelow*/).setBetweenLines(), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue4c1' /*fermataBelow*/), 0),
        staveNote({ keys: ['a/5'], duration: 'q', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_10__.Stem.DOWN })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue4c0' /*fermataAbove*/), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue1e7' /*augmentationDot*/).setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue4a4' /*articTenutoAbove*/), 0),
        staveNote({ keys: ['f/5'], duration: 'q' })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue4c4' /*fermataShortAbove*/), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue1e7' /*augmentationDot*/).setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue4a4' /*articTenutoAbove*/), 0),
        staveNote({ keys: ['b/4'], duration: 'q', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_10__.Stem.DOWN })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue4c6' /*fermataLongAbove*/), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue1e7' /*augmentationDot*/).setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue4a4' /*articTenutoAbove*/), 0),
        staveNote({ keys: ['a/5'], duration: 'q', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_10__.Stem.DOWN })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue1e7' /*augmentationDot*/).setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue4a4' /*articTenutoAbove*/), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue4c2' /*fermataVeryShortAbove*/), 0),
        staveNote({ keys: ['f/5'], duration: 'q' })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue1e7' /*augmentationDot*/).setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue4a4' /*articTenutoAbove*/), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue4c8' /*fermataVeryLongAbove*/), 0),
        staveNote({ keys: ['b/4'], duration: 'q', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_10__.Stem.DOWN })
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue1e7' /*augmentationDot*/).setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_6__.ModifierPosition.ABOVE).setBetweenLines(), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue4a4' /*articTenutoAbove*/).setBetweenLines(), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('\ue4c0' /*fermataAbove*/), 0),
    ];
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, stave, notes);
    options.assert.ok(true, ' Annotation Placement (Glyph codes)');
}
function drawArticulations2(options) {
    options.assert.expect(0);
    const scale = 0.8;
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 1500, 195);
    // Get the rendering context
    const ctx = f.getContext();
    ctx.scale(scale, scale);
    // bar 1
    const stave1 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(10, 50, 500).setContext(ctx).draw();
    const notesBar1 = [
        f.StaveNote({ keys: ['c/4'], duration: '16', stemDirection: 1 }),
        f.StaveNote({ keys: ['d/4'], duration: '16', stemDirection: 1 }),
        f.StaveNote({ keys: ['e/4'], duration: '16', stemDirection: 1 }),
        f.StaveNote({ keys: ['f/4'], duration: '16', stemDirection: 1 }),
        f.StaveNote({ keys: ['g/4'], duration: '16', stemDirection: 1 }),
        f.StaveNote({ keys: ['a/4'], duration: '16', stemDirection: 1 }),
        f.StaveNote({ keys: ['b/4'], duration: '16', stemDirection: 1 }),
        f.StaveNote({ keys: ['c/5'], duration: '16', stemDirection: 1 }),
        f.StaveNote({ keys: ['d/5'], duration: '16', stemDirection: -1 }),
        f.StaveNote({ keys: ['e/5'], duration: '16', stemDirection: -1 }),
        f.StaveNote({ keys: ['f/5'], duration: '16', stemDirection: -1 }),
        f.StaveNote({ keys: ['g/5'], duration: '16', stemDirection: -1 }),
        f.StaveNote({ keys: ['a/5'], duration: '16', stemDirection: -1 }),
        f.StaveNote({ keys: ['b/5'], duration: '16', stemDirection: -1 }),
        f.StaveNote({ keys: ['c/6'], duration: '16', stemDirection: -1 }),
        f.StaveNote({ keys: ['d/6'], duration: '16', stemDirection: -1 }),
    ];
    let i;
    for (i = 0; i < 16; i++) {
        notesBar1[i].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a.').setPosition(4), 0);
        notesBar1[i].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a>').setPosition(4), 0);
        if (i === 15) {
            notesBar1[i].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a@u').setPosition(4), 0);
        }
    }
    const beam1 = new _src_beam__WEBPACK_IMPORTED_MODULE_2__.Beam(notesBar1.slice(0, 8));
    const beam2 = new _src_beam__WEBPACK_IMPORTED_MODULE_2__.Beam(notesBar1.slice(8, 16));
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, stave1, notesBar1);
    beam1.setContext(ctx).draw();
    beam2.setContext(ctx).draw();
    // bar 2 - juxtaposing second bar next to first bar
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(510, 50, 500).setContext(ctx).draw();
    const notesBar2 = [
        f.StaveNote({ keys: ['f/3'], duration: '16', stemDirection: 1 }),
        f.StaveNote({ keys: ['g/3'], duration: '16', stemDirection: 1 }),
        f.StaveNote({ keys: ['a/3'], duration: '16', stemDirection: 1 }),
        f.StaveNote({ keys: ['b/3'], duration: '16', stemDirection: 1 }),
        f.StaveNote({ keys: ['c/4'], duration: '16', stemDirection: 1 }),
        f.StaveNote({ keys: ['d/4'], duration: '16', stemDirection: 1 }),
        f.StaveNote({ keys: ['e/4'], duration: '16', stemDirection: 1 }),
        f.StaveNote({ keys: ['f/4'], duration: '16', stemDirection: 1 }),
        f.StaveNote({ keys: ['g/4'], duration: '16', stemDirection: -1 }),
        f.StaveNote({ keys: ['a/4'], duration: '16', stemDirection: -1 }),
        f.StaveNote({ keys: ['b/4'], duration: '16', stemDirection: -1 }),
        f.StaveNote({ keys: ['c/5'], duration: '16', stemDirection: -1 }),
        f.StaveNote({ keys: ['d/5'], duration: '16', stemDirection: -1 }),
        f.StaveNote({ keys: ['e/5'], duration: '16', stemDirection: -1 }),
        f.StaveNote({ keys: ['f/5'], duration: '16', stemDirection: -1 }),
        f.StaveNote({ keys: ['g/5'], duration: '16', stemDirection: -1 }),
    ];
    for (i = 0; i < 16; i++) {
        notesBar2[i].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a-').setPosition(3), 0);
        notesBar2[i].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a^').setPosition(3), 0);
        if (i === 15) {
            notesBar2[i].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a@u').setPosition(4), 0);
        }
    }
    const beam3 = new _src_beam__WEBPACK_IMPORTED_MODULE_2__.Beam(notesBar2.slice(0, 8));
    const beam4 = new _src_beam__WEBPACK_IMPORTED_MODULE_2__.Beam(notesBar2.slice(8, 16));
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, stave2, notesBar2);
    beam3.setContext(ctx).draw();
    beam4.setContext(ctx).draw();
    // bar 3 - juxtaposing second bar next to first bar
    const stave3 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(1010, 50, 100).setContext(ctx).draw();
    const notesBar3 = [f.StaveNote({ keys: ['c/4'], duration: 'w', stemDirection: 1 })];
    notesBar3[0].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a-').setPosition(3), 0);
    notesBar3[0].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a>').setPosition(3), 0);
    notesBar3[0].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a@a').setPosition(3), 0);
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, stave3, notesBar3);
    // bar 4 - juxtaposing second bar next to first bar
    const stave4 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(1110, 50, 250).setContext(ctx).draw();
    const notesBar4 = [
        f.StaveNote({ keys: ['c/5'], duration: 'q', stemDirection: -1 }),
        f.StaveNote({ keys: ['a/5'], duration: 'q', stemDirection: -1 }),
        f.StaveNote({ keys: ['c/5'], duration: 'q', stemDirection: -1 }),
        f.StaveNote({ keys: ['a/5'], duration: 'q', stemDirection: -1 }),
    ];
    for (i = 0; i < 4; i++) {
        let position1 = 3;
        if (i > 1) {
            position1 = 4;
        }
        notesBar4[i].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a-').setPosition(position1), 0);
    }
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, stave4, notesBar4);
}
function tabNotes(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 600, 200);
    ctx.font = '10pt ' + _src_metrics__WEBPACK_IMPORTED_MODULE_5__.Metrics.get('fontFamily');
    const stave = new _src_tabstave__WEBPACK_IMPORTED_MODULE_12__.TabStave(10, 10, 550);
    stave.setContext(ctx);
    stave.draw();
    const specs = [
        {
            positions: [
                { str: 3, fret: 6 },
                { str: 4, fret: 25 },
            ],
            duration: '8',
        },
        {
            positions: [
                { str: 2, fret: 10 },
                { str: 5, fret: 12 },
            ],
            duration: '8',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 3, fret: 5 },
            ],
            duration: '8',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 3, fret: 5 },
            ],
            duration: '8',
        },
    ];
    const notes1 = specs.map((noteSpec) => {
        const tabNote = new _src_tabnote__WEBPACK_IMPORTED_MODULE_11__.TabNote(noteSpec);
        tabNote.renderOptions.drawStem = true;
        return tabNote;
    });
    const notes2 = specs.map((noteSpec) => {
        const tabNote = new _src_tabnote__WEBPACK_IMPORTED_MODULE_11__.TabNote(noteSpec);
        tabNote.renderOptions.drawStem = true;
        tabNote.setStemDirection(-1);
        return tabNote;
    });
    const notes3 = specs.map((noteSpec) => new _src_tabnote__WEBPACK_IMPORTED_MODULE_11__.TabNote(noteSpec));
    notes1[0].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a>').setPosition(3), 0); // U
    notes1[1].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a>').setPosition(4), 0); // D
    notes1[2].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a.').setPosition(3), 0); // U
    notes1[3].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a.').setPosition(4), 0); // D
    notes2[0].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a>').setPosition(3), 0);
    notes2[1].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a>').setPosition(4), 0);
    notes2[2].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a.').setPosition(3), 0);
    notes2[3].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a.').setPosition(4), 0);
    notes3[0].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a>').setPosition(3), 0);
    notes3[1].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a>').setPosition(4), 0);
    notes3[2].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a.').setPosition(3), 0);
    notes3[3].addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation('a.').setPosition(4), 0);
    const voice = new _src_voice__WEBPACK_IMPORTED_MODULE_13__.Voice(_src_flow__WEBPACK_IMPORTED_MODULE_3__.Flow.TIME4_4).setMode(_src_voice__WEBPACK_IMPORTED_MODULE_13__.Voice.Mode.SOFT);
    voice.addTickables(notes1);
    voice.addTickables(notes2);
    voice.addTickables(notes3);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    voice.draw(ctx, stave);
    options.assert.ok(true, 'TabNotes successfully drawn');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(ArticulationTests);



/***/ }),

/***/ "./tests/auto_beam_formatting_tests.ts":
/*!*********************************************!*\
  !*** ./tests/auto_beam_formatting_tests.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AutoBeamFormattingTests: () => (/* binding */ AutoBeamFormattingTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_beam__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/beam */ "./src/beam.ts");
/* harmony import */ var _src_fraction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/fraction */ "./src/fraction.ts");
/* harmony import */ var _src_stave__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/stave */ "./src/stave.ts");
/* harmony import */ var _src_stem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/stem */ "./src/stem.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Auto Beaming Tests
// TODO: Beam.generateBeams(voice.getTickables() as StemmableNote[], ...) requires a cast to StemmableNote[].
//       Is there a cleaner way to handle this?





const AutoBeamFormattingTests = {
    Start() {
        QUnit.module('Auto-Beaming');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Simple Auto Beaming', simpleAuto);
        run('Auto Beaming With Overflow Group', simpleAutoWithOverflowGroup);
        run('Even Group Stem Directions', evenGroupStemDirections);
        run('Odd Group Stem Directions', oddGroupStemDirections);
        run('Odd Beam Groups Auto Beaming', oddBeamGroups);
        run('More Simple Auto Beaming 0', moreSimple0);
        run('More Simple Auto Beaming 1', moreSimple1);
        run('Beam Across All Rests', beamAcrossAllRests);
        run('Beam Across All Rests with Stemlets', beamAcrossAllRestsWithStemlets);
        run('Break Beams on Middle Rests Only', beamAcrossMiddleRests);
        run('Break Beams on Rest', breakBeamsOnRests);
        run('Maintain Stem Directions', maintainStemDirections);
        run('Maintain Stem Directions - Beam Over Rests', maintainStemDirectionsBeamAcrossRests);
        run('Beat group with unbeamable note - 2/2', groupWithUnbeamableNote);
        run('Offset beat grouping - 6/8 ', groupWithUnbeamableNote1);
        run('Odd Time - Guessing Default Beam Groups', autoOddBeamGroups);
        run('Custom Beam Groups', customBeamGroups);
        run('Simple Tuplet Auto Beaming', simpleTuplets);
        run('More Simple Tuplet Auto Beaming', moreSimpleTuplets);
        run('More Automatic Beaming', moreBeaming);
        run('Automatic Beaming 4/4 with  3, 3, 2 Pattern', beamingWithSeveralGroups1);
        run('Automatic Beaming 4/4 with  3, 3, 2 Pattern and Overflow', beamingWithSeveralGroupsOverflow);
        run('Automatic Beaming 8/4 with  3, 2, 3 Pattern and 2 Overflows', beamingWithSeveralGroupsOverflow2);
        run('Automatic Beaming 8/4 with  3, 2, 3 Pattern and 3 Overflows', beamingWithSeveralGroupsOverflow3);
        run('Duration-Based Secondary Beam Breaks', secondaryBreaks1);
        run('Duration-Based Secondary Beam Breaks 2', secondaryBreaks2);
        run('Flat Beams Up', flatBeamsUp);
        run('Flat Beams Down', flatBeamsDown);
        run('Flat Beams Mixed Direction', flatBeamsMixed);
        run('Flat Beams Up (uniform)', flatBeamsUpUniform);
        run('Flat Beams Down (uniform)', flatBeamsDownUniform);
        run('Flat Beams Up Bounds', flatBeamsUpBounds);
        run('Flat Beams Down Bounds', flatBeamsDownBounds);
    },
};
function simpleAuto(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const voice = score.voice(score.notes('f5/8, e5, d5, c5/16, c5, d5/8, e5, f5, f5/32, f5, f5, f5'), { time: '4/4' });
    // Takes a voice and returns its auto beams.
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voice);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Auto Beaming Applicator Test');
}
function simpleAutoWithOverflowGroup(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    // Add a . after a note (e.g., f5/4.) to make it a dotted note.
    const voice = score.voice(score.notes('f5/4., e5/8, d5/8, d5/16, c5/16, c5/16, c5/16, f5/16, f5/32, f5/32'), {
        time: '4/4',
    });
    // Takes a voice and returns its auto beams.
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voice);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Auto Beaming Applicator Test');
}
function evenGroupStemDirections(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const voice = score.voice(score.notes('a4/8, b4, g4, c5, f4, d5, e4, e5, b4, b4, g4, d5'), { time: '6/4' });
    // Takes a voice and returns its auto beams.
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voice);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.equal(beams[0].getStemDirection(), _src_stem__WEBPACK_IMPORTED_MODULE_4__.Stem.UP);
    options.assert.equal(beams[1].getStemDirection(), _src_stem__WEBPACK_IMPORTED_MODULE_4__.Stem.UP);
    options.assert.equal(beams[2].getStemDirection(), _src_stem__WEBPACK_IMPORTED_MODULE_4__.Stem.UP);
    options.assert.equal(beams[3].getStemDirection(), _src_stem__WEBPACK_IMPORTED_MODULE_4__.Stem.UP);
    options.assert.equal(beams[4].getStemDirection(), _src_stem__WEBPACK_IMPORTED_MODULE_4__.Stem.DOWN);
    options.assert.equal(beams[5].getStemDirection(), _src_stem__WEBPACK_IMPORTED_MODULE_4__.Stem.DOWN);
    options.assert.ok(true, 'Auto Beaming Applicator Test');
}
function oddGroupStemDirections(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const voice = score.voice(score.notes('g4/8, b4, d5, c5, f4, d5, e4, g5, g4, b4, g4, d5, a4, c5, a4'), {
        time: '15/8',
    });
    const groups = [new _src_fraction__WEBPACK_IMPORTED_MODULE_2__.Fraction(3, 8)];
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voice, undefined, groups);
    options.assert.equal(beams[0].getStemDirection(), _src_stem__WEBPACK_IMPORTED_MODULE_4__.Stem.DOWN, 'Notes are equidistant from middle line');
    options.assert.equal(beams[1].getStemDirection(), _src_stem__WEBPACK_IMPORTED_MODULE_4__.Stem.DOWN);
    options.assert.equal(beams[2].getStemDirection(), _src_stem__WEBPACK_IMPORTED_MODULE_4__.Stem.UP);
    options.assert.equal(beams[3].getStemDirection(), _src_stem__WEBPACK_IMPORTED_MODULE_4__.Stem.DOWN, 'Notes are equidistant from middle line');
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Auto Beaming Applicator Test');
}
function oddBeamGroups(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const voice = score.voice(score.notes('f5, e5, d5, c5, c5, d5, e5, f5, f5, f4, f3, f5/16, f5'), { time: '6/4' });
    const groups = [new _src_fraction__WEBPACK_IMPORTED_MODULE_2__.Fraction(2, 8), new _src_fraction__WEBPACK_IMPORTED_MODULE_2__.Fraction(3, 8), new _src_fraction__WEBPACK_IMPORTED_MODULE_2__.Fraction(1, 8)];
    // Takes a voice and returns its auto beams.
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voice, undefined, groups);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Auto Beam Applicator Test');
}
function moreSimple0(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const voice = score.voice(score.notes('c4/8, g4, c5, g5, a5, c4, d4, a5'), { time: '4/4' });
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voice);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Auto Beam Applicator Test');
}
function moreSimple1(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const voice = score.voice(score.notes('c5/16, g5, c5, c5/r, c5/r, (c4 e4 g4), d4, a5, c4, g4, c5, b4/r, (c4 e4), b4/r, b4/r, a4'), { time: '4/4' });
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voice);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Auto Beam Applicator Test');
}
function breakBeamsOnRests(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const voice = score.voice(score.notes('c5/16, g5, c5, c5/r, c5/r, (c4 e4 g4), d4, a5, c4, g4, c5, b4/r, (c4 e4), b4/r, b4/r, a4'), { time: '4/4' });
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.generateBeams(voice.getTickables(), {
        beamRests: false,
    });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Auto Beam Applicator Test');
}
function beamAcrossAllRestsWithStemlets(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const voice = score.voice(score.notes('c5/16, g5, c5, c5/r, c5/r, (c4 e4 g4), d4, a5, c4, g4, c5, b4/r, (c4 e4), b4/r, b4/r, a4'), { time: '4/4' });
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.generateBeams(voice.getTickables(), {
        beamRests: true,
        showStemlets: true,
    });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Auto Beam Applicator Test');
}
function beamAcrossAllRests(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const voice = score.voice(score.notes('c5/16, g5, c5, c5/r, c5/r, (c4 e4 g4), d4, a5, c4, g4, c5, b4/r, (c4 e4), b4/r, b4/r, a4'), { time: '4/4' });
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.generateBeams(voice.getTickables(), {
        beamRests: true,
    });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Auto Beam Applicator Test');
}
function beamAcrossMiddleRests(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const voice = score.voice(score.notes('c5/16, g5, c5, c5/r, c5/r, (c4 e4 g4), d4, a5, c4, g4, c5, b4/r, (c4 e4), b4/r, b4/r, a4'), { time: '4/4' });
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.generateBeams(voice.getTickables(), {
        beamRests: true,
        beamMiddleOnly: true,
    });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Auto Beam Applicator Test');
}
function maintainStemDirections(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 450, 200);
    const stave = f.Stave();
    const score = f.EasyScore();
    // EasyScore.notes(line, ...) ignores whitespace in the line string.
    const voice = score.voice(score.notes([
        'b4/16,            b4,              b4[stem="down"], b4/r',
        'b4/r,             b4[stem="down"], b4,              b4',
        'b4[stem="down"],  b4[stem="down"], b4,              b4/r',
        'b4/32,            b4[stem="down"], b4[stem="down"], b4, b4/16/r, b4',
    ].join(', '), { stem: 'up' }), { time: '4/4' });
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.generateBeams(voice.getTickables(), {
        beamRests: false,
        maintainStemDirections: true,
    });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Auto Beam Applicator Test');
}
function maintainStemDirectionsBeamAcrossRests(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 450, 200);
    const stave = f.Stave();
    const score = f.EasyScore();
    const voice = score.voice(score.notes([
        'b4/16,            b4,              b4[stem="down"], b4/r',
        'b4/r,             b4[stem="down"], b4,              b4',
        'b4[stem="down"],  b4[stem="down"], b4,              b4/r',
        'b4/32,            b4[stem="down"], b4[stem="down"], b4, b4/16/r, b4',
    ].join(', '), { stem: 'up' }), { time: '4/4' });
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.generateBeams(voice.getTickables(), {
        beamRests: true,
        maintainStemDirections: true,
    });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Auto Beam Applicator Test');
}
function groupWithUnbeamableNote(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 450, 200);
    const stave = f.Stave().addTimeSignature('2/4');
    const score = f.EasyScore();
    const voice = score.voice(score.notes('b4/16, b4, b4/4, b4/16, b4'), { time: '2/4' });
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.generateBeams(voice.getTickables(), {
        groups: [new _src_fraction__WEBPACK_IMPORTED_MODULE_2__.Fraction(2, 2)],
        beamRests: false,
        maintainStemDirections: true,
    });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Auto Beam Applicator Test');
}
function groupWithUnbeamableNote1(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 450, 200);
    const stave = f.Stave().addTimeSignature('6/8');
    const score = f.EasyScore();
    const voice = score.voice(score.notes('b4/4, b4/4, b4/8, b4/8'), { time: '6/8' });
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.generateBeams(voice.getTickables(), {
        groups: [new _src_fraction__WEBPACK_IMPORTED_MODULE_2__.Fraction(3, 8)],
        beamRests: false,
        maintainStemDirections: true,
    });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Auto Beam Applicator Test');
}
function autoOddBeamGroups(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 450, 400);
    const score = f.EasyScore();
    const stave1 = f.Stave({ y: 10 }).addTimeSignature('5/4');
    const voice1 = score.voice(score.notes('c5/8, g5, c5, b4, b4, c4, d4, a5, c4, g4'), { time: '5/4' });
    const stave2 = f.Stave({ y: 150 }).addTimeSignature('5/8');
    const voice2 = score.voice(score.notes('c5/8, g5, c5, b4, b4'), { time: '5/8' });
    const stave3 = f.Stave({ y: 290 }).addTimeSignature('13/16');
    const voice3 = score.voice(score.notes('c5/16, g5, c5, b4, b4, c5, g5, c5, b4, b4, c5, b4, b4'), {
        time: '13/16',
    });
    // Flatten the arrays into a single Beam[].
    const beams = [
        ..._src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voice1, undefined, _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.getDefaultBeamGroups('5/4')),
        ..._src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voice2, undefined, _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.getDefaultBeamGroups('5/8')),
        ..._src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voice3, undefined, _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.getDefaultBeamGroups('13/16')),
    ];
    f.Formatter().formatToStave([voice1], stave1).formatToStave([voice2], stave2).formatToStave([voice3], stave3);
    _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave.formatBegModifiers([stave1, stave2, stave3]);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Auto Beam Applicator Test');
}
function customBeamGroups(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 450, 400);
    const score = f.EasyScore();
    const stave1 = f.Stave({ y: 10 }).addTimeSignature('5/4');
    const voice1 = score.voice(score.notes('c5/8, g5, c5, b4, b4, c4, d4, a5, c4, g4'), { time: '5/4' });
    const stave2 = f.Stave({ y: 150 }).addTimeSignature('5/8');
    const voice2 = score.voice(score.notes('c5/8, g5, c5, b4, b4'), { time: '5/8' });
    const stave3 = f.Stave({ y: 290 }).addTimeSignature('13/16');
    const voice3 = score.voice(score.notes('c5/16, g5, c5, b4, b4, c5, g5, c5, b4, b4, c5, b4, b4'), { time: '13/16' });
    const group1 = [new _src_fraction__WEBPACK_IMPORTED_MODULE_2__.Fraction(5, 8)];
    const group2 = [new _src_fraction__WEBPACK_IMPORTED_MODULE_2__.Fraction(3, 8), new _src_fraction__WEBPACK_IMPORTED_MODULE_2__.Fraction(2, 8)];
    const group3 = [new _src_fraction__WEBPACK_IMPORTED_MODULE_2__.Fraction(7, 16), new _src_fraction__WEBPACK_IMPORTED_MODULE_2__.Fraction(2, 16), new _src_fraction__WEBPACK_IMPORTED_MODULE_2__.Fraction(4, 16)];
    // Flatten the three Beam[] into a single Beam[].
    // Alternatively, you can use .reduce(concat) flatten arrays, where concat is defined as (a, b) => a.concat(b).
    const beams = [
        ..._src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voice1, undefined, group1),
        ..._src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voice2, undefined, group2),
        ..._src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voice3, undefined, group3),
    ];
    f.Formatter().formatToStave([voice1], stave1).formatToStave([voice2], stave2).formatToStave([voice3], stave3);
    _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave.formatBegModifiers([stave1, stave2, stave3]);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Auto Beam Applicator Test');
}
/**
 * Helper function which uses Function.prototype.bind() to create shortcut methods.
 * This can improve the readability of large blocks of EasyScore code.
 */
function createShortcuts(score) {
    return {
        notes: score.notes.bind(score),
        tuplet: score.tuplet.bind(score),
    };
}
function simpleTuplets(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const { notes, tuplet } = createShortcuts(score);
    const voice = score.voice([
        ...tuplet(notes('c4/8, g4, c5')),
        ...notes('g5/8, a5'),
        ...tuplet(notes('a5/16, (c5 e5), a5, d5, a5'), { ratioed: false, notesOccupied: 4 }),
    ], { time: '3/4' });
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voice);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Auto Beam Applicator Test');
}
function moreSimpleTuplets(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const { notes, tuplet } = createShortcuts(score);
    const voice = score.voice([...tuplet(notes('d4/4, g4, c5')), ...notes('g5/16, a5, a5, (c5 e5)')], { time: '3/4' });
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voice);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Auto Beam Applicator Test');
}
function moreBeaming(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const voice = score.voice(score.notes('c4/8, g4/4, c5/8., g5/16, a5/4, a5/16, (c5 e5)/16, a5/8'), { time: '9/8' });
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voice, undefined, _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.getDefaultBeamGroups('9/8'));
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Auto Beam Applicator Test');
}
function beamingWithSeveralGroups1(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const voice = score.voice(score.notes('c4/8, g4/4, c5/8, g5, a5, a5, f5'), { time: '4/4' });
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voice, undefined, [new _src_fraction__WEBPACK_IMPORTED_MODULE_2__.Fraction(3, 8), new _src_fraction__WEBPACK_IMPORTED_MODULE_2__.Fraction(3, 8), new _src_fraction__WEBPACK_IMPORTED_MODULE_2__.Fraction(2, 8)]);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Auto Beam Applicator Test');
}
function beamingWithSeveralGroupsOverflow(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const voice = score.voice(score.notes('c4/8, g4/4., c5/8, g5, a5, a5'), { time: '4/4' });
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voice, undefined, [new _src_fraction__WEBPACK_IMPORTED_MODULE_2__.Fraction(3, 8), new _src_fraction__WEBPACK_IMPORTED_MODULE_2__.Fraction(3, 8), new _src_fraction__WEBPACK_IMPORTED_MODULE_2__.Fraction(2, 8)]);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Auto Beam Applicator Test');
}
function beamingWithSeveralGroupsOverflow2(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const voice = score.voice(score.notes('c4/16, g4/2, f4/16, c5/8, a4/16, c4/16, g4/8, b4, c5, g5, f5, e5, c5, a4/4'), {
        time: '8/4',
    });
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voice, undefined, [new _src_fraction__WEBPACK_IMPORTED_MODULE_2__.Fraction(3, 8), new _src_fraction__WEBPACK_IMPORTED_MODULE_2__.Fraction(2, 8), new _src_fraction__WEBPACK_IMPORTED_MODULE_2__.Fraction(3, 8)]);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Auto Beam Applicator Test');
}
function beamingWithSeveralGroupsOverflow3(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const voice = score.voice(score.notes('c4/16, g4/1, f4/16, c5/8, g5, f5, e5, c5, a4/4'), { time: '8/4' });
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voice, undefined, [new _src_fraction__WEBPACK_IMPORTED_MODULE_2__.Fraction(3, 8), new _src_fraction__WEBPACK_IMPORTED_MODULE_2__.Fraction(2, 8), new _src_fraction__WEBPACK_IMPORTED_MODULE_2__.Fraction(3, 8)]);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Auto Beam Applicator Test');
}
function secondaryBreaks1(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const voice = score.voice(score.notes([
        'f5/32, f5, f5, f5, f5/16., f5/32',
        'f5/16, f5/8, f5/16',
        'f5/32, f5/16., f5., f5/32',
        'f5/16., f5/32, f5, f5/16.',
    ].join(',')));
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.generateBeams(voice.getTickables(), { secondaryBreaks: '8' });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Duration-Based Secondary Breaks Test');
}
function secondaryBreaks2(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const { notes, tuplet } = createShortcuts(score);
    const voice = score.voice([
        tuplet(notes('e5/16, f5, f5')),
        tuplet(notes('f5/16, f5, c5')),
        notes('a4/16., f4/32'),
        tuplet(notes('d4/16, d4, d4')),
        tuplet(notes('a5/8, (e5 g5), a5')),
        tuplet(notes('f5/16, f5, f5')),
        tuplet(notes('f5/16, f5, a4')),
    ].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat));
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.generateBeams(voice.getTickables(), { secondaryBreaks: '8' });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Duration-Based Secondary Breaks Test');
}
function flatBeamsUp(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave({ y: 40 });
    const score = f.EasyScore();
    const { notes, tuplet } = createShortcuts(score);
    const voice = score.voice([
        tuplet(notes('c4/8, g4, f5')),
        notes('d5/8'),
        tuplet(notes('c5/16, (c4 e4 g4), f4')),
        notes('d5/8, e5, c4, f5/32, f5, f5, f5'),
    ].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat));
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.generateBeams(voice.getTickables(), {
        flatBeams: true,
        stemDirection: 1,
    });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Flat Beams Up Test');
}
function flatBeamsDown(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 450, 200);
    const stave = f.Stave({ y: 40 });
    const score = f.EasyScore();
    const voice = score.voice(score.notes('c5/64, c5, c5, c5, c5, c5, c5, c5, a5/8, g5, (d4 f4 a4)/16, d4, d5/8, e5, g5, a6/32, a6, a6, g4/64, g4'));
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.generateBeams(voice.getTickables(), {
        flatBeams: true,
        stemDirection: -1,
    });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Flat Beams Down Test');
}
function flatBeamsMixed(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 450, 200);
    const stave = f.Stave({ y: 40 });
    const score = f.EasyScore();
    const voice = score.voice(score.notes('c5/64, d5, e5, c5, f5, c5, a5, c5, a5/8, g5, (d4 f4 a4)/16, d4, d5/8, e5, c4, a4/32, a4, a4, g4/64, g4'));
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.generateBeams(voice.getTickables(), { flatBeams: true });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Flat Beams Mixed Direction Test');
}
function flatBeamsUpUniform(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave({ y: 40 });
    const score = f.EasyScore();
    const { notes, tuplet } = createShortcuts(score);
    const voice = score.voice([
        ...tuplet(notes('c4/8, g4, g5')),
        ...notes('d5/8, c5/16, (c4 e4 g4), d5/8, e5, c4, f5/32, f5, f5, f5'),
    ]);
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.generateBeams(voice.getTickables(), {
        flatBeams: true,
        flatBeamOffset: 50,
        stemDirection: 1,
    });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Flat Beams Up (uniform) Test');
}
function flatBeamsDownUniform(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 450, 200);
    const stave = f.Stave({ y: 40 });
    const score = f.EasyScore();
    const voice = score.voice(score.notes('c5/64, c5, c5, c5, c5, c5, c5, c5, a5/8, g5, (e4 g4 b4)/16, e5, d5/8, e5/8, g5/8, a6/32, a6, a6, g4/64, g4'));
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.generateBeams(voice.getTickables(), {
        flatBeams: true,
        flatBeamOffset: 155,
        stemDirection: -1,
    });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Flat Beams Down (uniform) Test');
}
function flatBeamsUpBounds(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave({ y: 40 });
    const score = f.EasyScore();
    const { notes, tuplet } = createShortcuts(score);
    const voice = score.voice([
        ...tuplet(notes('c4/8, g4/8, g5/8')),
        ...notes('d5/8, c5/16, (c4 e4 g4)/16, d5/8, e5/8, c4/8, f5/32, f5/32, f5/32, f5/32'),
    ]);
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.generateBeams(voice.getTickables(), {
        flatBeams: true,
        flatBeamOffset: 60,
        stemDirection: 1,
    });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Flat Beams Up (uniform) Test');
}
function flatBeamsDownBounds(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 450, 200);
    const stave = f.Stave({ y: 40 });
    const score = f.EasyScore();
    const voice = score.voice(score.notes([
        'g5/8, a6/32, a6/32, a6/32, g4/64, g4/64',
        'c5/64, c5/64, c5/64, c5/64, c5/64, c5/64, c5/64, c5/64, a5/8',
        'g5/8, (e4 g4 b4)/16, e5/16',
        'd5/8, e5/8',
    ].join(','), { stem: 'down' }));
    const beams = _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.generateBeams(voice.getTickables(), {
        flatBeams: true,
        flatBeamOffset: 145,
        stemDirection: -1,
    });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'Flat Beams Down (uniform) Test');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(AutoBeamFormattingTests);



/***/ }),

/***/ "./tests/bach_tests.ts":
/*!*****************************!*\
  !*** ./tests/bach_tests.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BachDemoTests: () => (/* binding */ BachDemoTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/index */ "./src/index.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Bach Demo


const BachDemoTests = {
    Start() {
        QUnit.module('Bach Demo');
        _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests('Minuet 1', minuet1);
    },
};
function minuet1(options) {
    const registry = new _src_index__WEBPACK_IMPORTED_MODULE_1__.Registry();
    _src_index__WEBPACK_IMPORTED_MODULE_1__.Registry.enableDefaultRegistry(registry);
    // Retrieve the element from the registry and cast to StaveNote, so we can call .addModifier( ) later.
    const id = (id) => registry.getElementById(id);
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 1100, 900);
    const score = f.EasyScore({ throwOnError: true });
    // Bind these three functions so the code looks cleaner.
    // Instead of score.voice(...), just call voice(...).
    const voice = score.voice.bind(score);
    const notes = score.notes.bind(score);
    const beam = score.beam.bind(score);
    let x = 120;
    let y = 80;
    function appendSystem(width) {
        const system = f.System({ x, y, width, spaceBetweenStaves: 10 });
        x += width;
        return system;
    }
    score.set({ time: '3/4' });
    /*  Measure 1 */
    let system = appendSystem(220);
    system
        .addStave({
        voices: [
            voice([notes('D5/q[id="m1a"]'), beam(notes('G4/8, A4, B4, C5', { stem: 'up' }))].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat)),
            voice([f.TextDynamics({ text: 'p', duration: 'h', dots: 1, line: 9 })]),
        ],
    })
        .addClef('treble')
        .addKeySignature('G')
        .addTimeSignature('3/4')
        .setTempo({ name: 'Allegretto', duration: 'h', dots: 1, bpm: 66 }, -30);
    system
        .addStave({ voices: [voice(notes('(G3 B3 D4)/h, A3/q', { clef: 'bass' }))] })
        .addClef('bass')
        .addKeySignature('G')
        .addTimeSignature('3/4');
    system.addConnector('brace');
    system.addConnector('singleRight');
    system.addConnector('singleLeft');
    id('m1a').addModifier(f.Fingering({ number: '5' }), 0);
    /*  Measure 2 */
    system = appendSystem(150);
    system.addStave({ voices: [voice(notes('D5/q[id="m2a"], G4[id="m2b"], G4[id="m2c"]'))] });
    system.addStave({ voices: [voice(notes('B3/h.', { clef: 'bass' }))] });
    system.addConnector('singleRight');
    id('m2a').addModifier(f.Articulation({ type: 'a.', position: 'above' }), 0);
    id('m2b').addModifier(f.Articulation({ type: 'a.', position: 'below' }), 0);
    id('m2c').addModifier(f.Articulation({ type: 'a.', position: 'below' }), 0);
    f.Curve({
        from: id('m1a'),
        to: id('m2a'),
        options: {
            cps: [
                { x: 0, y: 40 },
                { x: 0, y: 40 },
            ],
        },
    });
    /*  Measure 3 */
    system = appendSystem(150);
    system.addStave({
        voices: [voice([notes('E5/q[id="m3a"]'), beam(notes('C5/8, D5, E5, F5', { stem: 'down' }))].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat))],
    });
    id('m3a').addModifier(f.Fingering({ number: '3', position: 'above' }), 0);
    system.addStave({ voices: [voice(notes('C4/h.', { clef: 'bass' }))] });
    system.addConnector('singleRight');
    /*  Measure 4 */
    system = appendSystem(150);
    system.addStave({ voices: [voice(notes('G5/q[id="m4a"], G4[id="m4b"], G4[id="m4c"]'))] });
    system.addStave({ voices: [voice(notes('B3/h.', { clef: 'bass' }))] });
    system.addConnector('singleRight');
    id('m4a').addModifier(f.Articulation({ type: 'a.', position: 'above' }), 0);
    id('m4b').addModifier(f.Articulation({ type: 'a.', position: 'below' }), 0);
    id('m4c').addModifier(f.Articulation({ type: 'a.', position: 'below' }), 0);
    f.Curve({
        from: id('m3a'),
        to: id('m4a'),
        options: {
            cps: [
                { x: 0, y: 20 },
                { x: 0, y: 20 },
            ],
        },
    });
    /*  Measure 5 */
    system = appendSystem(150);
    system.addStave({
        voices: [voice([notes('C5/q[id="m5a"]'), beam(notes('D5/8, C5, B4, A4', { stem: 'down' }))].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat))],
    });
    id('m5a').addModifier(f.Fingering({ number: '4', position: 'above' }), 0);
    system.addStave({ voices: [voice(notes('A3/h.', { clef: 'bass' }))] });
    system.addConnector('singleRight');
    /*  Measure 6 */
    system = appendSystem(150);
    system.addStave({
        voices: [voice([notes('B4/q'), beam(notes('C5/8, B4, A4, G4[id="m6a"]', { stem: 'up' }))].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat))],
    });
    system.addStave({ voices: [voice(notes('G3/h.', { clef: 'bass' }))] });
    system.addConnector('singleRight');
    f.Curve({
        from: id('m5a'),
        to: id('m6a'),
        options: {
            cps: [
                { x: 0, y: 20 },
                { x: 0, y: 20 },
            ],
            invert: true,
            positionEnd: 'nearTop',
            yShift: 20,
        },
    });
    /*  Measure 7 (New system) */
    x = 20;
    y += 230;
    system = appendSystem(220);
    system
        .addStave({
        voices: [
            voice([notes('F4/q[id="m7a"]'), beam(notes('G4/8[id="m7b"], A4, B4, G4', { stem: 'up' }))].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat)),
        ],
    })
        .addClef('treble')
        .addKeySignature('G');
    system
        .addStave({ voices: [voice(notes('D4/q, B3[id="m7c"], G3', { clef: 'bass' }))] })
        .addClef('bass')
        .addKeySignature('G');
    system.addConnector('brace');
    system.addConnector('singleRight');
    system.addConnector('singleLeft');
    id('m7a').addModifier(f.Fingering({ number: '2', position: 'below' }), 0);
    id('m7b').addModifier(f.Fingering({ number: '1' }), 0);
    id('m7c').addModifier(f.Fingering({ number: '3', position: 'above' }), 0);
    /*  Measure 8 */
    system = appendSystem(180);
    const grace = f.GraceNote({ keys: ['d/3'], clef: 'bass', duration: '4', slash: false });
    system.addStave({ voices: [voice(notes('A4/h.[id="m8c"]'))] });
    system.addStave({
        voices: [
            score
                .set({ clef: 'bass' })
                .voice([notes('D4/q[id="m8a"]'), beam(notes('D3/8, C4, B3[id="m8b"], A3', { stem: 'down' }))].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat)),
        ],
    });
    system.addConnector('singleRight');
    id('m8b').addModifier(f.Fingering({ number: '1', position: 'above' }), 0);
    id('m8c').addModifier(f.GraceNoteGroup({ notes: [grace] }), 0);
    f.Curve({
        from: id('m7a'),
        to: id('m8c'),
        options: {
            cps: [
                { x: 0, y: 20 },
                { x: 0, y: 20 },
            ],
            invert: true,
            position: 'nearTop',
            positionEnd: 'nearTop',
        },
    });
    f.StaveTie({ from: grace, to: id('m8c') });
    /*  Measure 9 */
    system = appendSystem(180);
    system.addStave({
        voices: [
            score
                .set({ clef: 'treble' })
                .voice([notes('D5/q[id="m9a"]'), beam(notes('G4/8, A4, B4, C5', { stem: 'up' }))].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat)),
        ],
    });
    system.addStave({ voices: [voice(notes('B3/h, A3/q', { clef: 'bass' }))] });
    system.addConnector('singleRight');
    id('m9a').addModifier(f.Fingering({ number: '5' }), 0);
    /*  Measure 10 */
    system = appendSystem(170);
    system.addStave({ voices: [voice(notes('D5/q[id="m10a"], G4[id="m10b"], G4[id="m10c"]'))] });
    system.addStave({ voices: [voice(notes('G3/q[id="m10d"], B3, G3', { clef: 'bass' }))] });
    system.addConnector('singleRight');
    id('m10a').addModifier(f.Articulation({ type: 'a.', position: 'above' }), 0);
    id('m10b').addModifier(f.Articulation({ type: 'a.', position: 'below' }), 0);
    id('m10c').addModifier(f.Articulation({ type: 'a.', position: 'below' }), 0);
    id('m10d').addModifier(f.Fingering({ number: '4' }), 0);
    f.Curve({
        from: id('m9a'),
        to: id('m10a'),
        options: {
            cps: [
                { x: 0, y: 40 },
                { x: 0, y: 40 },
            ],
        },
    });
    /*  Measure 11 */
    system = appendSystem(150);
    system.addStave({
        voices: [voice([notes('E5/q[id="m11a"]'), beam(notes('C5/8, D5, E5, F5', { stem: 'down' }))].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat))],
    });
    id('m11a').addModifier(f.Fingering({ number: '3', position: 'above' }), 0);
    system.addStave({ voices: [voice(notes('C4/h.', { clef: 'bass' }))] });
    system.addConnector('singleRight');
    /*  Measure 12 */
    system = appendSystem(170);
    system.addStave({ voices: [voice(notes('G5/q[id="m12a"], G4[id="m12b"], G4[id="m12c"]'))] });
    system.addStave({
        voices: [
            score
                .set({ clef: 'bass' })
                .voice([notes('B3/q[id="m12d"]'), beam(notes('C4/8, B3, A3, G3[id="m12e"]', { stem: 'down' }))].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat)),
        ],
    });
    system.addConnector('singleRight');
    id('m12a').addModifier(f.Articulation({ type: 'a.', position: 'above' }), 0);
    id('m12b').addModifier(f.Articulation({ type: 'a.', position: 'below' }), 0);
    id('m12c').addModifier(f.Articulation({ type: 'a.', position: 'below' }), 0);
    id('m12d').addModifier(f.Fingering({ number: '2', position: 'above' }), 0);
    id('m12e').addModifier(f.Fingering({ number: '4', position: 'above' }), 0);
    f.Curve({
        from: id('m11a'),
        to: id('m12a'),
        options: {
            cps: [
                { x: 0, y: 20 },
                { x: 0, y: 20 },
            ],
        },
    });
    /*  Measure 13 (New system) */
    x = 20;
    y += 230;
    system = appendSystem(220);
    system
        .addStave({
        voices: [
            score
                .set({ clef: 'treble' })
                .voice([notes('c5/q[id="m13a"]'), beam(notes('d5/8, c5, b4, a4', { stem: 'down' }))].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat)),
        ],
    })
        .addClef('treble')
        .addKeySignature('G');
    system
        .addStave({ voices: [voice(notes('a3/h[id="m13b"], f3/q[id="m13c"]', { clef: 'bass' }))] })
        .addClef('bass')
        .addKeySignature('G');
    system.addConnector('brace');
    system.addConnector('singleRight');
    system.addConnector('singleLeft');
    id('m13a').addModifier(f.Fingering({ number: '4', position: 'above' }), 0);
    id('m13b').addModifier(f.Fingering({ number: '1' }), 0);
    id('m13c').addModifier(f.Fingering({ number: '3', position: 'above' }), 0);
    /*  Measure 14 */
    system = appendSystem(180);
    system.addStave({
        voices: [
            score
                .set({ clef: 'treble' })
                .voice([notes('B4/q'), beam(notes('C5/8, b4, a4, g4', { stem: 'up' }))].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat)),
        ],
    });
    system.addStave({ voices: [voice(notes('g3/h[id="m14a"], b3/q[id="m14b"]', { clef: 'bass' }))] });
    system.addConnector('singleRight');
    id('m14a').addModifier(f.Fingering({ number: '2' }), 0);
    id('m14b').addModifier(f.Fingering({ number: '1' }), 0);
    /*  Measure 15 */
    system = appendSystem(180);
    system.addStave({
        voices: [
            score
                .set({ clef: 'treble' })
                .voice([notes('a4/q'), beam(notes('b4/8, a4, g4, f4[id="m15a"]', { stem: 'up' }))].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat)),
        ],
    });
    system.addStave({ voices: [voice(notes('c4/q[id="m15b"], d4, d3', { clef: 'bass' }))] });
    system.addConnector('singleRight');
    id('m15a').addModifier(f.Fingering({ number: '2' }), 0);
    id('m15b').addModifier(f.Fingering({ number: '2' }), 0);
    /*  Measure 16 */
    system = appendSystem(130);
    system
        .addStave({
        voices: [score.set({ clef: 'treble' }).voice([notes('g4/h.[id="m16a"]')].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat))],
    })
        .setEndBarType(_src_index__WEBPACK_IMPORTED_MODULE_1__.BarlineType.REPEAT_END);
    system
        .addStave({ voices: [voice(notes('g3/h[id="m16b"], g2/q', { clef: 'bass' }))] })
        .setEndBarType(_src_index__WEBPACK_IMPORTED_MODULE_1__.BarlineType.REPEAT_END);
    system.addConnector('boldDoubleRight');
    id('m16a').addModifier(f.Fingering({ number: '1' }), 0);
    id('m16b').addModifier(f.Fingering({ number: '1' }), 0);
    f.Curve({
        from: id('m13a'),
        to: id('m16a'),
        options: {
            cps: [
                { x: 0, y: 50 },
                { x: 0, y: 20 },
            ],
            invert: true,
            positionEnd: 'nearTop',
        },
    });
    /* Measure 17 */
    system = appendSystem(180);
    system
        .addStave({
        voices: [
            score
                .set({ clef: 'treble' })
                .voice([notes('b5/q[id="m17a"]'), beam(notes('g5/8, a5, b5, g5', { stem: 'down' }))].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat)),
            voice([f.TextDynamics({ text: 'mf', duration: 'h', dots: 1, line: 10 })]),
        ],
    })
        .setBegBarType(_src_index__WEBPACK_IMPORTED_MODULE_1__.BarlineType.REPEAT_BEGIN);
    system.addStave({ voices: [voice(notes('g3/h.', { clef: 'bass' }))] }).setBegBarType(_src_index__WEBPACK_IMPORTED_MODULE_1__.BarlineType.REPEAT_BEGIN);
    system.addConnector('boldDoubleLeft');
    system.addConnector('singleRight');
    id('m17a').addModifier(f.Fingering({ number: '5', position: 'above' }), 0);
    /* Measure 18 */
    system = appendSystem(180);
    system.addStave({
        voices: [
            score
                .set({ clef: 'treble' })
                .voice([notes('a5/q[id="m18a"]'), beam(notes('d5/8, e5, f5, d5[id="m18b"]', { stem: 'down' }))].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat)),
        ],
    });
    system.addStave({ voices: [voice(notes('f3/h.', { clef: 'bass' }))] });
    system.addConnector('singleRight');
    id('m18a').addModifier(f.Fingering({ number: '4', position: 'above' }), 0);
    f.Curve({
        from: id('m17a'),
        to: id('m18b'),
        options: {
            cps: [
                { x: 0, y: 20 },
                { x: 0, y: 30 },
            ],
        },
    });
    /* Done */
    f.draw();
    _src_index__WEBPACK_IMPORTED_MODULE_1__.Registry.disableDefaultRegistry();
    options.assert.ok(true, 'Bach Minuet 1');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(BachDemoTests);



/***/ }),

/***/ "./tests/barline_tests.ts":
/*!********************************!*\
  !*** ./tests/barline_tests.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BarlineTests: () => (/* binding */ BarlineTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_stavebarline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/stavebarline */ "./src/stavebarline.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Barline Tests


const BarlineTests = {
    Start() {
        QUnit.module('Barline');
        QUnit.test('Enums', enums);
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Simple BarNotes', simple);
        run('Style BarNotes', style);
    },
};
function enums(assert) {
    // VexFlow 4.0 renamed Barline.type => BarlineType.
    // The old way still works, for backwards compatibility.
    assert.equal(_src_stavebarline__WEBPACK_IMPORTED_MODULE_1__.Barline.type, _src_stavebarline__WEBPACK_IMPORTED_MODULE_1__.BarlineType);
    const a = _src_stavebarline__WEBPACK_IMPORTED_MODULE_1__.BarlineType['DOUBLE'];
    const b = _src_stavebarline__WEBPACK_IMPORTED_MODULE_1__.BarlineType.DOUBLE;
    assert.equal(a, b);
}
function simple(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 380, 160);
    const stave = f.Stave();
    const notes = [
        f.StaveNote({ keys: ['d/4', 'e/4', 'f/4'], stemDirection: -1, duration: '2' }),
        f.BarNote({ type: 'single' }),
        f
            .StaveNote({ keys: ['c/4', 'f/4', 'a/4'], stemDirection: -1, duration: '2' })
            .addModifier(f.Accidental({ type: 'n' }), 0)
            .addModifier(f.Accidental({ type: '#' }), 1),
    ];
    const voice = f.Voice().addTickables(notes);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'Simple Test');
}
function style(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 380, 160);
    const stave = f.Stave();
    const notes = [
        f.StaveNote({ keys: ['d/4', 'e/4', 'f/4'], stemDirection: -1, duration: '2' }),
        f.BarNote({ type: 'single' }),
        f
            .StaveNote({ keys: ['c/4', 'f/4', 'a/4'], stemDirection: -1, duration: '2' })
            .addModifier(f.Accidental({ type: 'n' }), 0)
            .addModifier(f.Accidental({ type: '#' }), 1),
    ];
    notes[1].setStyle({ shadowBlur: 15, shadowColor: 'blue', fillStyle: 'blue', strokeStyle: 'blue' });
    const voice = f.Voice().addTickables(notes);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'Style');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(BarlineTests);



/***/ }),

/***/ "./tests/beam_tests.ts":
/*!*****************************!*\
  !*** ./tests/beam_tests.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BeamTests: () => (/* binding */ BeamTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/index */ "./src/index.ts");
/* harmony import */ var _src_metrics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/metrics */ "./src/metrics.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Beam Tests
// TODO: Factory.Beam()'s 'notes' argument is a StemmableNote[], but we only have access to Tickable[].



const BeamTests = {
    Start() {
        QUnit.module('Beam');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Simple Beam', simple);
        run('Multi Beam', multi);
        run('Sixteenth Beam', sixteenth);
        run('Slopey Beam', slopey);
        run('Auto-stemmed Beam', autoStem);
        run('Mixed Beam 1', mixed);
        run('Mixed Beam 2', mixed2);
        run('Dotted Beam', dotted);
        run('Partial Beam', partial);
        run('Close Trade-offs Beam', tradeoffs);
        run('Insane Beam', insane);
        run('Lengthy Beam', lenghty);
        run('Outlier Beam', outlier);
        run('Break Secondary Beams', breakSecondaryBeams);
        run('Partial Beam Direction', partialBeamDirection);
        run('TabNote Beams Up', tabBeamsUp);
        run('TabNote Beams Down', tabBeamsDown);
        run('TabNote Auto Create Beams', autoTabBeams);
        run('TabNote Beams Auto Stem', tabBeamsAutoStem);
        run('Complex Beams with Annotations', complexWithAnnotation);
        run('Complex Beams with Articulations', complexWithArticulation);
        run('Complex Beams with Articulations two Staves', complexWithArticulation2);
    },
};
function simple(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const beam = score.beam.bind(score);
    const notes = score.notes.bind(score);
    const voice = score.voice([
        notes('(cb4 e#4 a4)/2'),
        beam(notes('(cb4 e#4 a4)/8, (d4 f4 a4), (ebb4 g##4 b4), (f4 a4 c5)', { stem: 'up' })),
    ].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat), { time: '2/2' });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'Simple Test');
}
function multi(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const voice = score.voice.bind(score);
    const beam = score.beam.bind(score);
    const notes = score.notes.bind(score);
    const voices = [
        voice([beam(notes('f5/8, e5, d5, c5', { stem: 'up' })), beam(notes('c5, d5, e5, f5', { stem: 'up' }))].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat)),
        voice([beam(notes('f4/8, e4, d4, c4', { stem: 'down' })), beam(notes('c4/8, d4, e4, f4', { stem: 'down' }))].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat)),
    ];
    f.Formatter().joinVoices(voices).formatToStave(voices, stave);
    f.draw();
    options.assert.ok(true, 'Multi Test');
}
function sixteenth(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const voice = score.voice.bind(score);
    const beam = score.beam.bind(score);
    const notes = score.notes.bind(score);
    const voices = [
        voice([
            beam(notes('f5/16, f5, d5, c5', { stem: 'up' })),
            beam(notes('c5/16, d5, f5, e5', { stem: 'up' })),
            notes('f5/2', { stem: 'up' }),
        ].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat)),
        voice([
            beam(notes('f4/16, e4/16, d4/16, c4/16', { stem: 'down' })),
            beam(notes('c4/16, d4/16, f4/16, e4/16', { stem: 'down' })),
            notes('f4/2', { stem: 'down' }),
        ].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat)),
    ];
    f.Formatter().joinVoices(voices).formatToStave(voices, stave);
    f.draw();
    options.assert.ok(true, 'Sixteenth Test');
}
function breakSecondaryBeams(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 200);
    const stave = f.Stave({ y: 20 });
    const score = f.EasyScore();
    const voice = score.voice.bind(score);
    const beam = score.beam.bind(score);
    const notes = score.notes.bind(score);
    const voices = [
        voice([
            beam(notes('f5/16., f5/32, c5/16., d5/32, c5/16., d5/32', { stem: 'up' }), { secondaryBeamBreaks: [1, 3] }),
            beam(notes('f5/16, e5, e5, e5, e5, e5', { stem: 'up' }), { secondaryBeamBreaks: [2] }),
        ].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat), { time: '3/4' }),
        voice([
            beam(notes('f4/32, d4, e4, c4, d4, c4, f4, d4, e4, c4, c4, d4', { stem: 'down' }), {
                secondaryBeamBreaks: [3, 7],
            }),
            beam(notes('d4/16, f4, d4, e4, e4, e4', { stem: 'down' }), { secondaryBeamBreaks: [3] }),
        ].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat), { time: '3/4' }),
    ];
    f.Formatter().joinVoices(voices).formatToStave(voices, stave);
    f.draw();
    options.assert.ok(true, 'Breaking Secondary Beams Test');
}
function partialBeamDirection(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 200);
    const stave = f.Stave({ y: 20 });
    const score = f.EasyScore();
    const voice = score.voice.bind(score);
    const beam = score.beam.bind(score);
    const notes = score.notes.bind(score);
    const voices = [
        voice([
            // Default beaming:
            beam(notes('f4/8, f4/16, f4/8, f4/16', { stem: 'up' })),
            // Force first 16th beam right
            beam(notes('f4/8, f4/16, f4/8, f4/16', { stem: 'up' }), { partialBeamDirections: { '1': 'R' } }),
            // Force first 16th beam left
            beam(notes('f4/8, f4/16, f4/8, f4/16', { stem: 'up' }), { partialBeamDirections: { '1': 'L' } }),
        ].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat), { time: '9/8' }),
    ];
    f.Formatter().joinVoices(voices).formatToStave(voices, stave);
    f.draw();
    options.assert.ok(true, 'Partial beam direction test');
}
function slopey(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 350, 140);
    const stave = f.Stave({ y: 20 });
    const score = f.EasyScore();
    const beam = score.beam.bind(score);
    const notes = score.notes.bind(score);
    const voice = score.voice([
        beam(notes('c4/8, f4/8, d5/8, g5/8', { stem: 'up' })),
        beam(notes('d6/8, f5/8, d4/8, g3/8', { stem: 'up' })),
    ].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat));
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'Slopey Test');
}
function autoStem(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 350, 140);
    const stave = f.Stave({ y: 20 });
    const score = f.EasyScore();
    const voice = score.voice(score.notes('a4/8, b4/8, g4/8, c5/8, f4/8, d5/8, e4/8, e5/8, b4/8, b4/8, g4/8, d5/8'), {
        time: '6/4',
    });
    const notes = voice.getTickables();
    const beams = [
        f.Beam({ notes: notes.slice(0, 2), options: { autoStem: true } }),
        f.Beam({ notes: notes.slice(2, 4), options: { autoStem: true } }),
        f.Beam({ notes: notes.slice(4, 6), options: { autoStem: true } }),
        f.Beam({ notes: notes.slice(6, 8), options: { autoStem: true } }),
        f.Beam({ notes: notes.slice(8, 10), options: { autoStem: true } }),
        f.Beam({ notes: notes.slice(10, 12), options: { autoStem: true } }),
    ];
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    const UP = _src_index__WEBPACK_IMPORTED_MODULE_1__.Stem.UP;
    const DOWN = _src_index__WEBPACK_IMPORTED_MODULE_1__.Stem.DOWN;
    options.assert.equal(beams[0].getStemDirection(), UP);
    options.assert.equal(beams[1].getStemDirection(), UP);
    options.assert.equal(beams[2].getStemDirection(), UP);
    options.assert.equal(beams[3].getStemDirection(), UP);
    options.assert.equal(beams[4].getStemDirection(), DOWN);
    options.assert.equal(beams[5].getStemDirection(), DOWN);
    f.draw();
    options.assert.ok(true, 'AutoStem Beam Test');
}
function mixed(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 350, 140);
    const stave = f.Stave({ y: 20 });
    const score = f.EasyScore();
    const voice1 = score.voice(score.notes('f5/8, d5/16, c5/16, c5/16, d5/16, e5/8, f5/8, d5/16, c5/16, c5/16, d5/16, e5/8', { stem: 'up' }));
    const voice2 = score.voice(score.notes('f4/16, e4/8, d4/16, c4/16, d4/8, f4/16, f4/16, e4/8, d4/16, c4/16, d4/8, f4/16', { stem: 'down' }));
    [
        [0, 4],
        [4, 8],
        [8, 12],
    ].forEach((range) => f.Beam({ notes: voice1.getTickables().slice(range[0], range[1]) }));
    [
        [0, 4],
        [4, 8],
        [8, 12],
    ].forEach((range) => f.Beam({ notes: voice2.getTickables().slice(range[0], range[1]) }));
    f.Formatter().joinVoices([voice1, voice2]).formatToStave([voice1, voice2], stave);
    f.draw();
    options.assert.ok(true, 'Multi Test');
}
function mixed2(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 450, 180);
    const stave = f.Stave({ y: 20 });
    const score = f.EasyScore();
    const voice = score.voice(score.notes('f5/32, d5/16, c5/32, c5/64, d5/128, e5/8, f5/16, d5/32, c5/64, c5/32, d5/16, e5/128', {
        stem: 'up',
    }), { time: '31/64' });
    const voice2 = score.voice(score.notes('f4/32, d4/16, c4/32, c4/64, d4/128, e4/8, f4/16, d4/32, c4/64, c4/32, d4/16, e4/128', {
        stem: 'down',
    }), { time: '31/64' });
    f.Beam({ notes: voice.getTickables().slice(0, 12) });
    f.Beam({ notes: voice2.getTickables().slice(0, 12) });
    f.Formatter().joinVoices([voice, voice2]).formatToStave([voice, voice2], stave);
    f.draw();
    options.assert.ok(true, 'Multi Test');
}
function dotted(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const voice = score.voice(score.notes('d4/8, b3/8., a3/16, a3/8, b3/8., c4/16, d4/8, b3/8, a3/8., a3/16, b3/8., c4/16', { stem: 'up' }), { time: '6/4' });
    const notes = voice.getTickables();
    f.Beam({ notes: notes.slice(0, 4) });
    f.Beam({ notes: notes.slice(4, 8) });
    f.Beam({ notes: notes.slice(8, 12) });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'Dotted Test');
}
function partial(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const voice = score.voice(score.notes('d4/8, b3/32, c4/16., d4/16., e4/8, c4/64, c4/32, a3/8., b3/32., c4/8, e4/64, b3/16., b3/64, f4/8, e4/8, g4/64, e4/8'), { time: '89/64' });
    const notes = voice.getTickables();
    f.Beam({ notes: notes.slice(0, 3) });
    f.Beam({ notes: notes.slice(3, 9) });
    f.Beam({ notes: notes.slice(9, 13) });
    f.Beam({ notes: notes.slice(13, 17) });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'Partial Test');
}
function tradeoffs(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave();
    const score = f.EasyScore();
    const voice = score.voice(score.notes('a4/8, b4/8, c4/8, d4/8, g4/8, a4/8, b4/8, c4/8', { stem: 'up' }));
    const notes = voice.getTickables();
    f.Beam({ notes: notes.slice(0, 4) });
    f.Beam({ notes: notes.slice(4, 8) });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'Close Trade-offs Test');
}
function insane(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 450, 180);
    const stave = f.Stave({ y: 20 });
    const score = f.EasyScore();
    const voice = score.voice(score.notes('g4/8, g5/8, c4/8, b5/8, g4/8[stem="down"], a5[stem="down"], b4[stem="down"], c4/8', { stem: 'up' }));
    const notes = voice.getTickables();
    f.Beam({ notes: notes.slice(0, 4) });
    f.Beam({ notes: notes.slice(4, 7) });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'Insane Test');
}
function lenghty(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 450, 180);
    const stave = f.Stave({ y: 20 });
    const score = f.EasyScore();
    const voice = score.voice(score.beam(score.notes('g4/8, g4, g4, a4', { stem: 'up' })), { time: '2/4' });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'Lengthy Test');
}
function outlier(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 450, 180);
    const stave = f.Stave({ y: 20 });
    const score = f.EasyScore();
    const voice = score.voice(score.notes([
        'g4/8[stem="up"],   f4[stem="up"],   d5[stem="up"],   e4[stem="up"]',
        'd5/8[stem="down"], d5[stem="down"], c5[stem="down"], d5[stem="down"]',
    ].join()));
    const notes = voice.getTickables();
    f.Beam({ notes: notes.slice(0, 4) });
    f.Beam({ notes: notes.slice(4, 8) });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave, { stave: stave });
    f.draw();
    options.assert.ok(true, 'Outlier Test');
}
function tabBeamsUp(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 200);
    const stave = f.TabStave({ y: 20 });
    const specs = [
        {
            positions: [
                { str: 3, fret: 6 },
                { str: 4, fret: 25 },
            ],
            duration: '4',
        },
        {
            positions: [
                { str: 2, fret: 10 },
                { str: 5, fret: 12 },
            ],
            duration: '8',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '8',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '16',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '32',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '64',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '128',
        },
        { positions: [{ str: 3, fret: 6 }], duration: '8' },
        { positions: [{ str: 3, fret: 6 }], duration: '8' },
        { positions: [{ str: 3, fret: 6 }], duration: '8' },
        { positions: [{ str: 3, fret: 6 }], duration: '8' },
    ];
    const notes = specs.map((struct) => {
        const tabNote = f.TabNote(struct);
        tabNote.renderOptions.drawStem = true;
        return tabNote;
    });
    f.Beam({ notes: notes.slice(1, 7) });
    f.Beam({ notes: notes.slice(8, 11) });
    f.Tuplet({ notes: notes.slice(8, 11), options: { ratioed: true } });
    const voice = f.Voice().setMode(_src_index__WEBPACK_IMPORTED_MODULE_1__.Voice.Mode.SOFT).addTickables(notes);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'All objects have been drawn');
}
function tabBeamsDown(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 250);
    const stave = f.TabStave({ options: { numLines: 10 } });
    const specs = [
        {
            stemDirection: -1,
            positions: [
                { str: 3, fret: 6 },
                { str: 4, fret: 25 },
            ],
            duration: '4',
        },
        {
            stemDirection: -1,
            positions: [
                { str: 2, fret: 10 },
                { str: 5, fret: 12 },
            ],
            duration: '8dd',
        },
        {
            stemDirection: -1,
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '8',
        },
        {
            stemDirection: -1,
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '16',
        },
        {
            stemDirection: -1,
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '32',
        },
        {
            stemDirection: -1,
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '64',
        },
        {
            stemDirection: -1,
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '128',
        },
        { stemDirection: -1, positions: [{ str: 1, fret: 6 }], duration: '8' },
        { stemDirection: -1, positions: [{ str: 1, fret: 6 }], duration: '8' },
        { stemDirection: -1, positions: [{ str: 1, fret: 6 }], duration: '8' },
        { stemDirection: -1, positions: [{ str: 7, fret: 6 }], duration: '8' },
        { stemDirection: -1, positions: [{ str: 7, fret: 6 }], duration: '8' },
        { stemDirection: -1, positions: [{ str: 10, fret: 6 }], duration: '8' },
        { stemDirection: -1, positions: [{ str: 10, fret: 6 }], duration: '8' },
    ];
    const notes = specs.map((struct) => {
        const tabNote = f.TabNote(struct);
        tabNote.renderOptions.drawStem = true;
        tabNote.renderOptions.drawDots = true;
        return tabNote;
    });
    _src_index__WEBPACK_IMPORTED_MODULE_1__.Dot.buildAndAttach([notes[1], notes[1]]);
    f.Beam({ notes: notes.slice(1, 7) });
    f.Beam({ notes: notes.slice(8, 11) });
    f.Tuplet({ notes: notes.slice(8, 11), options: { location: -1 } });
    f.Tuplet({ notes: notes.slice(11, 14), options: { location: -1 } });
    const voice = f.Voice().setMode(_src_index__WEBPACK_IMPORTED_MODULE_1__.Voice.Mode.SOFT).addTickables(notes);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'All objects have been drawn');
}
function autoTabBeams(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 200);
    const stave = f.TabStave();
    const specs = [
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '8',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '8',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '16',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '16',
        },
        { positions: [{ str: 1, fret: 6 }], duration: '32' },
        { positions: [{ str: 1, fret: 6 }], duration: '32' },
        { positions: [{ str: 1, fret: 6 }], duration: '32' },
        { positions: [{ str: 6, fret: 6 }], duration: '32' },
        { positions: [{ str: 6, fret: 6 }], duration: '16' },
        { positions: [{ str: 6, fret: 6 }], duration: '16' },
        { positions: [{ str: 6, fret: 6 }], duration: '16' },
        { positions: [{ str: 6, fret: 6 }], duration: '16' },
    ];
    const notes = specs.map((struct) => {
        const tabNote = f.TabNote(struct);
        tabNote.renderOptions.drawStem = true;
        tabNote.renderOptions.drawDots = true;
        return tabNote;
    });
    const voice = f.Voice().setMode(_src_index__WEBPACK_IMPORTED_MODULE_1__.Voice.Mode.SOFT).addTickables(notes);
    const beams = _src_index__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voice, -1);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    beams.forEach((beam) => beam.setContext(f.getContext()).draw());
    options.assert.ok(true, 'All objects have been drawn');
}
// This tests makes sure the autoStem functionality is works.
// TabNote stems within a beam group should end up normalized
function tabBeamsAutoStem(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 300);
    const stave = f.TabStave();
    const specs = [
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '8',
            stemDirection: -1,
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '8',
            stemDirection: 1,
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '16',
            stemDirection: -1,
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '16',
            stemDirection: 1,
        },
        { positions: [{ str: 1, fret: 6 }], duration: '32', stemDirection: 1 },
        { positions: [{ str: 1, fret: 6 }], duration: '32', stemDirection: -1 },
        { positions: [{ str: 1, fret: 6 }], duration: '32', stemDirection: -1 },
        { positions: [{ str: 6, fret: 6 }], duration: '32', stemDirection: -1 },
        { positions: [{ str: 6, fret: 6 }], duration: '16', stemDirection: 1 },
        { positions: [{ str: 6, fret: 6 }], duration: '16', stemDirection: 1 },
        { positions: [{ str: 6, fret: 6 }], duration: '16', stemDirection: 1 },
        { positions: [{ str: 6, fret: 6 }], duration: '16', stemDirection: -1 },
    ];
    const notes = specs.map((struct) => {
        const tabNote = f.TabNote(struct);
        tabNote.renderOptions.drawStem = true;
        tabNote.renderOptions.drawDots = true;
        return tabNote;
    });
    // Stems should format down
    f.Beam({ notes: notes.slice(0, 8), options: { autoStem: true } });
    // Stems should format up
    f.Beam({ notes: notes.slice(8, 12), options: { autoStem: true } });
    const voice = f.Voice().setMode(_src_index__WEBPACK_IMPORTED_MODULE_1__.Voice.Mode.SOFT).addTickables(notes);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'All objects have been drawn');
}
function complexWithAnnotation(options) {
    const factory = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 500, 200);
    const stave = factory.Stave({ y: 40 });
    const s1 = [
        { keys: ['e/4'], duration: '128', stemDirection: 1 },
        { keys: ['d/4'], duration: '16', stemDirection: 1 },
        { keys: ['e/4'], duration: '8', stemDirection: 1 },
        { keys: ['c/4', 'g/4'], duration: '32', stemDirection: 1 },
        { keys: ['c/4'], duration: '32', stemDirection: 1 },
        { keys: ['c/4'], duration: '32', stemDirection: 1 },
        { keys: ['c/4'], duration: '32', stemDirection: 1 },
    ];
    const s2 = [
        { keys: ['e/5'], duration: '128', stemDirection: -1 },
        { keys: ['d/5'], duration: '16', stemDirection: -1 },
        { keys: ['e/5'], duration: '8', stemDirection: -1 },
        { keys: ['c/5', 'g/5'], duration: '32', stemDirection: -1 },
        { keys: ['c/5'], duration: '32', stemDirection: -1 },
        { keys: ['c/5'], duration: '32', stemDirection: -1 },
        { keys: ['c/5'], duration: '32', stemDirection: -1 },
    ];
    const font = {
        family: _src_metrics__WEBPACK_IMPORTED_MODULE_2__.Metrics.get('Annotation.fontFamily'),
        size: 14,
        weight: _src_index__WEBPACK_IMPORTED_MODULE_1__.FontWeight.BOLD,
        style: _src_index__WEBPACK_IMPORTED_MODULE_1__.FontStyle.ITALIC,
    };
    const notes1 = s1.map((struct) => factory
        .StaveNote(struct) //
        .addModifier(factory.Annotation({ text: '1', vJustify: _src_index__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.TOP, font }), 0));
    const notes2 = s2.map((struct) => factory
        .StaveNote(struct) //
        .addModifier(factory.Annotation({ text: '3', vJustify: _src_index__WEBPACK_IMPORTED_MODULE_1__.AnnotationVerticalJustify.BOTTOM, font }), 0));
    factory.Beam({ notes: notes1 });
    factory.Beam({ notes: notes2 });
    const voice = factory.Voice().setMode(_src_index__WEBPACK_IMPORTED_MODULE_1__.Voice.Mode.SOFT).addTickables(notes1).addTickables(notes2);
    factory.Formatter().joinVoices([voice]).formatToStave([voice], stave, { stave: stave });
    factory.draw();
    options.assert.ok(true, 'Complex beam annotations');
}
function complexWithArticulation(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 500, 200);
    const stave = f.Stave({ y: 40 });
    const s1 = [
        { keys: ['e/4'], duration: '128', stemDirection: 1 },
        { keys: ['d/4'], duration: '16', stemDirection: 1 },
        { keys: ['e/4'], duration: '8', stemDirection: 1 },
        { keys: ['c/4', 'g/4'], duration: '32', stemDirection: 1 },
        { keys: ['c/4'], duration: '32', stemDirection: 1 },
        { keys: ['c/4'], duration: '32', stemDirection: 1 },
        { keys: ['c/4'], duration: '32', stemDirection: 1 },
    ];
    const s2 = [
        { keys: ['e/5'], duration: '128', stemDirection: -1 },
        { keys: ['d/5'], duration: '16', stemDirection: -1 },
        { keys: ['e/5'], duration: '8', stemDirection: -1 },
        { keys: ['c/5', 'g/5'], duration: '32', stemDirection: -1 },
        { keys: ['c/5'], duration: '32', stemDirection: -1 },
        { keys: ['c/5'], duration: '32', stemDirection: -1 },
        { keys: ['c/5'], duration: '32', stemDirection: -1 },
    ];
    const notes1 = s1.map((struct) => f.StaveNote(struct).addModifier(f.Articulation({ type: 'am', position: 'above' }), 0));
    const notes2 = s2.map((struct) => f.StaveNote(struct).addModifier(f.Articulation({ type: 'a>', position: 'below' }), 0));
    f.Beam({ notes: notes1 });
    f.Beam({ notes: notes2 });
    const voice = f.Voice().setMode(_src_index__WEBPACK_IMPORTED_MODULE_1__.Voice.Mode.SOFT).addTickables(notes1).addTickables(notes2);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave, { stave: stave });
    f.draw();
    options.assert.ok(true, 'Complex beam articulations');
}
function complexWithArticulation2(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 500, 300);
    const system = f.System();
    const s1 = [
        { keys: ['e/4'], duration: '128', stemDirection: 1 },
        { keys: ['d/4'], duration: '16', stemDirection: 1 },
        { keys: ['e/4'], duration: '8', stemDirection: 1 },
        { keys: ['c/4', 'g/4'], duration: '32', stemDirection: 1 },
        { keys: ['c/4'], duration: '32', stemDirection: 1 },
        { keys: ['c/4'], duration: '32', stemDirection: 1 },
        { keys: ['c/4'], duration: '32', stemDirection: 1 },
    ];
    const s2 = [
        { keys: ['e/5'], duration: '128', stemDirection: -1 },
        { keys: ['d/5'], duration: '16', stemDirection: -1 },
        { keys: ['e/5'], duration: '8', stemDirection: -1 },
        { keys: ['c/5', 'g/5'], duration: '32', stemDirection: -1 },
        { keys: ['c/5'], duration: '32', stemDirection: -1 },
        { keys: ['c/5'], duration: '32', stemDirection: -1 },
        { keys: ['c/5'], duration: '32', stemDirection: -1 },
    ];
    const notes1 = s1.map((struct) => f.StaveNote(struct).addModifier(f.Articulation({ type: 'am', position: 'above' }), 0));
    const notes2 = s2.map((struct) => f.StaveNote(struct).addModifier(f.Articulation({ type: 'a>', position: 'below' }), 0));
    const notes3 = s1.map((struct) => f.StaveNote(struct).addModifier(f.Articulation({ type: 'am', position: 'above' }), 0));
    const notes4 = s2.map((struct) => f.StaveNote(struct).addModifier(f.Articulation({ type: 'a>', position: 'below' }), 0));
    f.Beam({ notes: notes1 });
    f.Beam({ notes: notes2 });
    f.Beam({ notes: notes3 });
    f.Beam({ notes: notes4 });
    const voice1 = f.Voice().setMode(_src_index__WEBPACK_IMPORTED_MODULE_1__.Voice.Mode.SOFT).addTickables(notes1).addTickables(notes2);
    const voice2 = f.Voice().setMode(_src_index__WEBPACK_IMPORTED_MODULE_1__.Voice.Mode.SOFT).addTickables(notes3).addTickables(notes4);
    system.addStave({ voices: [voice1] });
    system.addStave({ voices: [voice2] });
    f.draw();
    options.assert.ok(true, 'Complex beam articulations two staves');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(BeamTests);



/***/ }),

/***/ "./tests/bend_tests.ts":
/*!*****************************!*\
  !*** ./tests/bend_tests.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BendTests: () => (/* binding */ BendTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_bend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/bend */ "./src/bend.ts");
/* harmony import */ var _src_formatter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/formatter */ "./src/formatter.ts");
/* harmony import */ var _src_metrics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/metrics */ "./src/metrics.ts");
/* harmony import */ var _src_modifiercontext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/modifiercontext */ "./src/modifiercontext.ts");
/* harmony import */ var _src_note__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/note */ "./src/note.ts");
/* harmony import */ var _src_tabnote__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/tabnote */ "./src/tabnote.ts");
/* harmony import */ var _src_tabstave__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/tabstave */ "./src/tabstave.ts");
/* harmony import */ var _src_tickcontext__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/tickcontext */ "./src/tickcontext.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Bend Tests









const BendTests = {
    Start() {
        QUnit.module('Bend');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Double Bends', doubleBends);
        run('Reverse Bends', reverseBends);
        run('Bend Phrase', bendPhrase);
        run('Double Bends With Release', doubleBendsWithRelease);
        run('Whako Bend', whackoBends);
        // TODO: Rename 'Whako Bend' => 'Whacko'
    },
};
// Helper functions for creating TabNote and Bend objects.
const note = (noteStruct) => new _src_tabnote__WEBPACK_IMPORTED_MODULE_6__.TabNote(noteStruct);
const bendWithPhrase = (phrase) => new _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend(phrase);
/**
 * Bend two strings at a time.
 */
function doubleBends(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 500, 240);
    ctx.scale(1.5, 1.5);
    ctx.font = '10pt Arial';
    const stave = new _src_tabstave__WEBPACK_IMPORTED_MODULE_7__.TabStave(10, 10, 450).addClef('tab').setContext(ctx).draw();
    const notes = [
        note({
            positions: [
                { str: 2, fret: 10 },
                { str: 4, fret: 9 },
            ],
            duration: 'q',
        })
            .addModifier(bendWithPhrase([{ type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: 'Full' }]), 0)
            .addModifier(bendWithPhrase([{ type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: '1/2' }]), 1),
        note({
            positions: [
                { str: 2, fret: 5 },
                { str: 3, fret: 5 },
            ],
            duration: 'q',
        })
            .addModifier(bendWithPhrase([{ type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: '1/4' }]), 0)
            .addModifier(bendWithPhrase([{ type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: '1/4' }]), 1),
        // This note is not visible because it is pushed off to the right by the ctx.scale(1.5, 1.5) at the top.
        note({
            positions: [{ str: 4, fret: 7 }],
            duration: 'h',
        }),
    ];
    _src_formatter__WEBPACK_IMPORTED_MODULE_2__.Formatter.FormatAndDraw(ctx, stave, notes);
    notes.forEach((note) => _src_note__WEBPACK_IMPORTED_MODULE_5__.Note.plotMetrics(ctx, note, 140));
    options.assert.ok(true, 'Double Bends');
}
function doubleBendsWithRelease(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 550, 240);
    ctx.scale(1.0, 1.0);
    ctx.setBackgroundFillStyle('#FFF');
    ctx.setFont('Arial', _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.Font.size);
    const stave = new _src_tabstave__WEBPACK_IMPORTED_MODULE_7__.TabStave(10, 10, 550).addClef('tab').setContext(ctx).draw();
    const notes = [
        note({
            positions: [
                { str: 1, fret: 10 },
                { str: 4, fret: 9 },
            ],
            duration: 'q',
        })
            .addModifier(bendWithPhrase([
            { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: '1/2' },
            { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.DOWN, text: '' },
        ]), 0)
            .addModifier(bendWithPhrase([
            { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: 'Full' },
            { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.DOWN, text: '' },
        ]), 1),
        note({
            positions: [
                { str: 2, fret: 5 },
                { str: 3, fret: 5 },
                { str: 4, fret: 5 },
            ],
            duration: 'q',
        })
            .addModifier(bendWithPhrase([
            { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: '1/4' },
            { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.DOWN, text: '' },
        ]), 0)
            .addModifier(bendWithPhrase([
            { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: 'Monstrous' },
            { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.DOWN, text: '' },
        ]), 1)
            .addModifier(bendWithPhrase([
            { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: '1/4' },
            { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.DOWN, text: '' },
        ]), 2),
        note({
            positions: [{ str: 4, fret: 7 }],
            duration: 'q',
        }),
        note({
            positions: [{ str: 4, fret: 7 }],
            duration: 'q',
        }),
    ];
    _src_formatter__WEBPACK_IMPORTED_MODULE_2__.Formatter.FormatAndDraw(ctx, stave, notes);
    notes.forEach((note) => _src_note__WEBPACK_IMPORTED_MODULE_5__.Note.plotMetrics(ctx, note, 140));
    options.assert.ok(true, 'Bend Release');
}
/**
 * Add the bend for note 1 before adding the bend for note 0,
 * by swapping the two indexes in .addModifier(modifier, index).
 * As a result, the bend curves intersect.
 */
function reverseBends(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 500, 240);
    ctx.scale(1.5, 1.5);
    ctx.setFont('10pt Arial');
    const stave = new _src_tabstave__WEBPACK_IMPORTED_MODULE_7__.TabStave(10, 10, 450).addClef('tab').setContext(ctx).draw();
    const notes = [
        note({
            positions: [
                { str: 2, fret: 10 },
                { str: 4, fret: 9 },
            ],
            duration: 'w',
        })
            .addModifier(bendWithPhrase([{ type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: 'Full' }]), 1)
            .addModifier(bendWithPhrase([{ type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: '1/2' }]), 0),
        note({
            positions: [
                { str: 2, fret: 5 },
                { str: 3, fret: 5 },
            ],
            duration: 'w',
        })
            .addModifier(bendWithPhrase([{ type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: '1/4' }]), 1)
            .addModifier(bendWithPhrase([{ type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: '1/4' }]), 0),
        note({
            positions: [{ str: 4, fret: 7 }],
            duration: 'w',
        }),
    ];
    for (let i = 0; i < notes.length; ++i) {
        const note = notes[i];
        const mc = new _src_modifiercontext__WEBPACK_IMPORTED_MODULE_4__.ModifierContext();
        note.addToModifierContext(mc);
        const tickContext = new _src_tickcontext__WEBPACK_IMPORTED_MODULE_8__.TickContext();
        tickContext
            .addTickable(note)
            .preFormat()
            .setX(75 * i);
        note.setStave(stave).setContext(ctx).draw();
        _src_note__WEBPACK_IMPORTED_MODULE_5__.Note.plotMetrics(ctx, note, 140);
        options.assert.ok(true, 'Bend ' + i);
    }
}
function bendPhrase(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 500, 240);
    ctx.scale(1.5, 1.5);
    ctx.font = _src_metrics__WEBPACK_IMPORTED_MODULE_3__.Metrics.get('Bend.fontSize') + _src_metrics__WEBPACK_IMPORTED_MODULE_3__.Metrics.get('Bend.fontFamily'); // Optionally use constants defined in Font.
    const stave = new _src_tabstave__WEBPACK_IMPORTED_MODULE_7__.TabStave(10, 10, 450).addClef('tab').setContext(ctx).draw();
    const phrase1 = [
        { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: 'Full' },
        { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.DOWN, text: 'Monstrous' },
        { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: '1/2' },
        { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.DOWN, text: '' },
    ];
    const bend1 = bendWithPhrase(phrase1).setContext(ctx);
    const notes = [
        note({
            positions: [{ str: 2, fret: 10 }],
            duration: 'w',
        }).addModifier(bend1, 0),
    ];
    for (let i = 0; i < notes.length; ++i) {
        const note = notes[i];
        note.addToModifierContext(new _src_modifiercontext__WEBPACK_IMPORTED_MODULE_4__.ModifierContext());
        const tickContext = new _src_tickcontext__WEBPACK_IMPORTED_MODULE_8__.TickContext();
        tickContext
            .addTickable(note)
            .preFormat()
            .setX(75 * i);
        note.setStave(stave).setContext(ctx).draw();
        _src_note__WEBPACK_IMPORTED_MODULE_5__.Note.plotMetrics(ctx, note, 140);
        options.assert.ok(true, 'Bend ' + i);
    }
}
function whackoBends(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 240);
    ctx.scale(1.0, 1.0);
    ctx.setBackgroundFillStyle('#FFF');
    ctx.setFont('Arial', _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.Font.size);
    const stave = new _src_tabstave__WEBPACK_IMPORTED_MODULE_7__.TabStave(10, 10, 350).addClef('tab').setContext(ctx).draw();
    const phrase1 = [
        { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: 'Full' },
        { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.DOWN, text: '' },
        { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: '1/2' },
        { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.DOWN, text: '' },
    ];
    const phrase2 = [
        { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: 'Full' },
        { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: 'Full' },
        { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: '1/2' },
        { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.DOWN, text: '' },
        { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.DOWN, text: 'Full' },
        { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.DOWN, text: 'Full' },
        { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: '1/2' },
        { type: _src_bend__WEBPACK_IMPORTED_MODULE_1__.Bend.DOWN, text: '' },
    ];
    const notes = [
        note({
            positions: [
                { str: 2, fret: 10 },
                { str: 3, fret: 9 },
            ],
            duration: 'q',
        })
            .addModifier(bendWithPhrase(phrase1), 0)
            .addModifier(bendWithPhrase(phrase2), 1),
    ];
    _src_formatter__WEBPACK_IMPORTED_MODULE_2__.Formatter.FormatAndDraw(ctx, stave, notes);
    _src_note__WEBPACK_IMPORTED_MODULE_5__.Note.plotMetrics(ctx, notes[0], 140);
    options.assert.ok(true, 'Whacko Bend & Release');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(BendTests);



/***/ }),

/***/ "./tests/boundingbox_tests.ts":
/*!************************************!*\
  !*** ./tests/boundingbox_tests.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BoundingBoxTests: () => (/* binding */ BoundingBoxTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/index */ "./src/index.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Bounding Box Tests


const BoundingBoxTests = {
    Start() {
        QUnit.module('BoundingBox');
        QUnit.test('Initialization Test', initialization);
        QUnit.test('Merging Text', merging);
    },
};
function initialization(assert) {
    const bb = new _src_index__WEBPACK_IMPORTED_MODULE_1__.BoundingBox(4, 5, 6, 7);
    assert.equal(bb.getX(), 4, 'Bad X');
    assert.equal(bb.getY(), 5, 'Bad Y');
    assert.equal(bb.getW(), 6, 'Bad W');
    assert.equal(bb.getH(), 7, 'Bad H');
    bb.setX(5);
    assert.equal(bb.getX(), 5, 'Bad X');
}
function merging(assert) {
    const tests = [
        {
            type: 'Intersection',
            bb1: new _src_index__WEBPACK_IMPORTED_MODULE_1__.BoundingBox(10, 10, 10, 10),
            bb2: new _src_index__WEBPACK_IMPORTED_MODULE_1__.BoundingBox(15, 20, 10, 10),
            merged: new _src_index__WEBPACK_IMPORTED_MODULE_1__.BoundingBox(10, 10, 15, 20),
        },
        {
            type: '1 contains 2',
            bb1: new _src_index__WEBPACK_IMPORTED_MODULE_1__.BoundingBox(10, 10, 30, 30),
            bb2: new _src_index__WEBPACK_IMPORTED_MODULE_1__.BoundingBox(15, 15, 10, 10),
            merged: new _src_index__WEBPACK_IMPORTED_MODULE_1__.BoundingBox(10, 10, 30, 30),
        },
        {
            type: '2 contains 1',
            bb1: new _src_index__WEBPACK_IMPORTED_MODULE_1__.BoundingBox(15, 15, 10, 10),
            bb2: new _src_index__WEBPACK_IMPORTED_MODULE_1__.BoundingBox(10, 10, 30, 30),
            merged: new _src_index__WEBPACK_IMPORTED_MODULE_1__.BoundingBox(10, 10, 30, 30),
        },
    ];
    tests.forEach((test) => {
        const type = test.type;
        const bb1 = test.bb1;
        const bb2 = test.bb2;
        const merged = test.merged;
        bb1.mergeWith(bb2);
        assert.equal(bb1.getX(), merged.getX(), type + ' - Bad X');
        assert.equal(bb1.getY(), merged.getY(), type + ' - Bad Y');
        assert.equal(bb1.getW(), merged.getW(), type + ' - Bad W');
        assert.equal(bb1.getH(), merged.getH(), type + ' - Bad H');
    });
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(BoundingBoxTests);



/***/ }),

/***/ "./tests/chordsymbol_tests.ts":
/*!************************************!*\
  !*** ./tests/chordsymbol_tests.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ChordSymbolTests: () => (/* binding */ ChordSymbolTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_accidental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/accidental */ "./src/accidental.ts");
/* harmony import */ var _src_chordsymbol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/chordsymbol */ "./src/chordsymbol.ts");
/* harmony import */ var _src_element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/element */ "./src/element.ts");
/* harmony import */ var _src_formatter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/formatter */ "./src/formatter.ts");
/* harmony import */ var _src_ornament__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/ornament */ "./src/ornament.ts");
/* harmony import */ var _src_stave__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/stave */ "./src/stave.ts");
/* harmony import */ var _src_stavenote__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/stavenote */ "./src/stavenote.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// ChordSymbol Tests








const ChordSymbolTests = {
    Start() {
        QUnit.module('ChordSymbol');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Chord Symbol With Modifiers', withModifiers);
        run('Chord Symbol Font Size Tests', fontSize);
        run('Chord Symbol Kerning Tests', kern);
        run('Top Chord Symbols', top);
        run('Top Chord Symbols Justified', topJustify);
        run('Bottom Chord Symbols', bottom);
        run('Bottom Stem Down Chord Symbols', bottomStemDown);
        run('Double Bottom Chord Symbols', doubleBottom);
    },
};
// Options for customizing addGlyphOrText() or addGlyph().
const superscript = { symbolModifier: _src_chordsymbol__WEBPACK_IMPORTED_MODULE_2__.ChordSymbol.symbolModifiers.SUPERSCRIPT };
const subscript = { symbolModifier: _src_chordsymbol__WEBPACK_IMPORTED_MODULE_2__.ChordSymbol.symbolModifiers.SUBSCRIPT };
// Helper function for creating StaveNotes.
const note = (factory, keys, duration, chordSymbol) => factory.StaveNote({ keys, duration }).addModifier(chordSymbol, 0);
/** Calculate the glyph's width in the current music font. */
function getGlyphWidth(charCode) {
    const el = new _src_element__WEBPACK_IMPORTED_MODULE_3__.Element();
    el.setText(String.fromCharCode(charCode));
    return el.getWidth();
}
function withModifiers(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 750, 580);
    const ctx = f.getContext();
    ctx.scale(1.5, 1.5);
    function draw(chords, y) {
        const notes = [
            note(f, ['c/4'], 'q', chords[0]).addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_5__.Ornament('doit')),
            note(f, ['c/4'], 'q', chords[1]),
            note(f, ['c/4'], 'q', chords[2]).addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_5__.Ornament('fall')),
            note(f, ['c/4'], 'q', chords[3]),
        ];
        const score = f.EasyScore();
        const voice = score.voice(notes, { time: '4/4' });
        const formatter = f.Formatter();
        formatter.joinVoices([voice]);
        const voiceW = formatter.preCalculateMinTotalWidth([voice]);
        const staffW = voiceW + _src_stave__WEBPACK_IMPORTED_MODULE_6__.Stave.defaultPadding + getGlyphWidth(0xe050 /*gClef*/);
        formatter.format([voice], voiceW);
        const staff = f.Stave({ x: 10, y, width: staffW }).addClef('treble').draw();
        voice.draw(ctx, staff);
    }
    let chords = [];
    chords.push(f
        .ChordSymbol({ fontSize: 10 })
        .addText('F7')
        .addGlyph('leftParenTall')
        .addGlyphOrText('b9', superscript)
        .addGlyphOrText('#11', subscript)
        .addGlyph('rightParenTall'));
    chords.push(f.ChordSymbol({ fontSize: 12 }).addText('F7').addGlyphOrText('b9', superscript).addGlyphOrText('#11', subscript));
    chords.push(f
        .ChordSymbol({ fontSize: 14 })
        .addText('F7')
        .addGlyph('leftParenTall')
        .addGlyphOrText('add 3', superscript)
        .addGlyphOrText('omit 9', subscript)
        .addGlyph('rightParenTall'));
    chords.push(f
        .ChordSymbol({ fontSize: 16 })
        .addText('F7')
        .addGlyph('leftParenTall')
        .addGlyphOrText('b9', superscript)
        .addGlyphOrText('#11', subscript)
        .addGlyph('rightParenTall'));
    draw(chords, 40);
    chords = [];
    chords.push(f
        .ChordSymbol({ fontSize: 10 })
        .setFontSize(10)
        .addText('F7')
        .addGlyphOrText('#11', superscript)
        .addGlyphOrText('b9', subscript));
    chords.push(f.ChordSymbol({ fontSize: 12 }).addText('F7').addGlyphOrText('#11', superscript).addGlyphOrText('b9', subscript));
    chords.push(f.ChordSymbol({ fontSize: 14 }).addText('F7').addGlyphOrText('#11', superscript).addGlyphOrText('b9', subscript));
    chords.push(f
        .ChordSymbol({ fontSize: 16 })
        .setFontSize(16)
        .addText('F7')
        .addGlyphOrText('#11', superscript)
        .addGlyphOrText('b9', subscript));
    draw(chords, 140);
    chords = [
        f.ChordSymbol({ fontSize: 10 }).addGlyphOrText('Ab').addGlyphOrText('7(#11b9)', superscript),
        f.ChordSymbol({ fontSize: 14 }).addGlyphOrText('C#').addGlyphOrText('7(#11b9)', superscript),
        f.ChordSymbol({ fontSize: 16 }).addGlyphOrText('Ab').addGlyphOrText('7(#11b9)', superscript),
        f.ChordSymbol({ fontSize: 18 }).addGlyphOrText('C#').addGlyphOrText('7(#11b9)', superscript),
    ];
    draw(chords, 240);
    options.assert.ok(true, 'Font Size Chord Symbol');
}
function fontSize(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 750, 580);
    const ctx = f.getContext();
    ctx.scale(1.5, 1.5);
    function draw(chords, y) {
        const stave = f.Stave({ x: 10, y, width: 450 }).addClef('treble');
        const notes = [
            note(f, ['c/4'], 'q', chords[0]),
            note(f, ['c/4'], 'q', chords[1]),
            note(f, ['c/4'], 'q', chords[2]),
            note(f, ['c/4'], 'q', chords[3]),
        ];
        const score = f.EasyScore();
        const voice = score.voice(notes, { time: '4/4' });
        f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
        f.draw();
    }
    let chords = [];
    chords.push(f
        .ChordSymbol({ fontSize: 10 })
        .addText('F7')
        .addGlyph('leftParenTall')
        .addGlyphOrText('b9', superscript)
        .addGlyphOrText('#11', subscript)
        .addGlyph('rightParenTall'));
    chords.push(f.ChordSymbol({ fontSize: 12 }).addText('F7').addGlyphOrText('b9', superscript).addGlyphOrText('#11', subscript));
    chords.push(f
        .ChordSymbol({ fontSize: 14 })
        .addText('F7')
        .addGlyph('leftParenTall')
        .addGlyphOrText('add 3', superscript)
        .addGlyphOrText('omit 9', subscript)
        .addGlyph('rightParenTall'));
    chords.push(f
        .ChordSymbol({ fontSize: 16 })
        .addText('F7')
        .addGlyph('leftParenTall')
        .addGlyphOrText('b9', superscript)
        .addGlyphOrText('#11', subscript)
        .addGlyph('rightParenTall'));
    draw(chords, 40);
    chords = [];
    chords.push(f
        .ChordSymbol({ fontSize: 10 })
        .setFontSize(10)
        .addText('F7')
        .addGlyphOrText('#11', superscript)
        .addGlyphOrText('b9', subscript));
    chords.push(f.ChordSymbol({ fontSize: 12 }).addText('F7').addGlyphOrText('#11', superscript).addGlyphOrText('b9', subscript));
    chords.push(f.ChordSymbol({ fontSize: 14 }).addText('F7').addGlyphOrText('#11', superscript).addGlyphOrText('b9', subscript));
    chords.push(f
        .ChordSymbol({ fontSize: 16 })
        .setFontSize(16)
        .addText('F7')
        .addGlyphOrText('#11', superscript)
        .addGlyphOrText('b9', subscript));
    draw(chords, 140);
    chords = [
        f.ChordSymbol({ fontSize: 10 }).addGlyphOrText('Ab').addGlyphOrText('7(#11b9)', superscript),
        f.ChordSymbol({ fontSize: 14 }).addGlyphOrText('C#').addGlyphOrText('7(#11b9)', superscript),
        f.ChordSymbol({ fontSize: 16 }).addGlyphOrText('Ab').addGlyphOrText('7(#11b9)', superscript),
        f.ChordSymbol({ fontSize: 18 }).addGlyphOrText('C#').addGlyphOrText('7(#11b9)', superscript),
    ];
    draw(chords, 240);
    options.assert.ok(true, 'Font Size Chord Symbol');
}
function kern(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 650 * 1.5, 650);
    const ctx = f.getContext();
    ctx.scale(1.5, 1.5);
    function draw(chords, y) {
        const stave = f.Stave({ x: 10, y, width: 450 }).addClef('treble').setContext(ctx).draw();
        const notes = [
            note(f, ['C/4'], 'q', chords[0]),
            note(f, ['C/4'], 'q', chords[1]),
            note(f, ['C/4'], 'q', chords[2]),
            note(f, ['C/4'], 'q', chords[3]),
        ];
        const score = f.EasyScore();
        const voice = score.voice(notes, { time: '4/4' });
        f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
        f.draw();
    }
    let chords = [
        f.ChordSymbol().addText('A').addGlyphSuperscript('dim'),
        f.ChordSymbol().addText('A').addGlyphSuperscript('dim'),
        f.ChordSymbol({ hJustify: 'left' }).addText('C').addGlyph('halfDiminished', superscript),
        f.ChordSymbol().addText('D').addGlyph('halfDiminished', superscript),
    ];
    draw(chords, 10);
    chords = [
        f.ChordSymbol().addText('A').addGlyphSuperscript('dim'),
        f.ChordSymbol().addText('A').addGlyphSuperscript('dim'),
        f.ChordSymbol().addText('A').addGlyphSuperscript('+').addTextSuperscript('5'),
        f.ChordSymbol().addText('G').addGlyphSuperscript('+').addTextSuperscript('5'),
    ];
    draw(chords, 110);
    chords = [
        f.ChordSymbol().addText('A').addGlyph('-'),
        f.ChordSymbol().addText('E').addGlyph('-'),
        f.ChordSymbol().addText('A').addGlyphOrText('(#11)', superscript),
        f.ChordSymbol().addText('E').addGlyphOrText('(#9)', superscript),
    ];
    draw(chords, 210);
    chords = [
        f.ChordSymbol().addGlyphOrText('F/B').addGlyphOrText('b', superscript),
        f.ChordSymbol().addText('E').addGlyphOrText('V/V'),
        f.ChordSymbol().addText('A').addGlyphOrText('(#11)', superscript),
        f.ChordSymbol().addText('E').addGlyphOrText('(#9)', superscript),
    ];
    draw(chords, 310);
    options.assert.ok(true, 'Chord Symbol Kerning Tests');
}
function top(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 650 * 1.5, 650);
    const ctx = f.getContext();
    ctx.scale(1.5, 1.5);
    // Helper function for creating StaveNotes.
    const note = (factory, keys, duration, chordSymbol, direction) => factory.StaveNote({ keys, duration, stemDirection: direction }).addModifier(chordSymbol, 0);
    function draw(c1, c2, y) {
        const stave = f.Stave({ x: 10, y, width: 450 }).addClef('treble').setContext(ctx).draw();
        const notes = [
            note(f, ['e/4', 'a/4', 'd/5'], 'h', c1, 1).addModifier(new _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental('b'), 0),
            note(f, ['c/5', 'e/5', 'c/6'], 'h', c2, -1),
        ];
        const score = f.EasyScore();
        const voice = score.voice(notes, { time: '4/4' });
        f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
        f.draw();
    }
    let chord1 = f.ChordSymbol().addText('F7').setHorizontal('left').addGlyphOrText('(#11b9)', superscript);
    let chord2 = f.ChordSymbol().addText('C').setHorizontal('left').addGlyphSuperscript('majorSeventh');
    draw(chord1, chord2, 40);
    chord1 = f
        .ChordSymbol()
        .addText('F7')
        .addTextSuperscript('(')
        .addGlyphOrText('#11b9', superscript)
        .addTextSuperscript(')');
    chord2 = f.ChordSymbol().addText('C').setHorizontal('left').addTextSuperscript('Maj.');
    draw(chord1, chord2, 140);
    chord1 = f
        .ChordSymbol()
        .addText('F7')
        .setHorizontal('left')
        .addGlyphOrText('#11', superscript)
        .addGlyphOrText('b9', subscript);
    chord2 = f.ChordSymbol().addText('C').addTextSuperscript('sus4');
    draw(chord1, chord2, 240);
    options.assert.ok(true, 'Top Chord Symbol');
}
function topJustify(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 500 * 1.5, 680);
    const ctx = f.getContext();
    ctx.scale(1.5, 1.5);
    function draw(chord1, chord2, y) {
        const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_6__.Stave(10, y, 450).addClef('treble').setContext(ctx).draw();
        const notes = [
            note(f, ['e/4', 'a/4', 'd/5'], 'h', chord1).addModifier(new _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental('b'), 0),
            note(f, ['c/4', 'e/4', 'B/4'], 'h', chord2),
        ];
        _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, stave, notes);
    }
    let chord1 = f.ChordSymbol().addText('F7').setHorizontal('left').addGlyphOrText('(#11b9)', superscript);
    let chord2 = f.ChordSymbol({ hJustify: 'left' }).addText('C').addGlyphSuperscript('majorSeventh');
    draw(chord1, chord2, 40);
    chord1 = f
        .ChordSymbol({ hJustify: 'center' })
        .addText('F7')
        .setHorizontal('left')
        .addGlyphOrText('(#11b9)', superscript);
    chord2 = f.ChordSymbol({ hJustify: 'center' }).addText('C').addTextSuperscript('Maj.');
    draw(chord1, chord2, 140);
    chord1 = f
        .ChordSymbol({ hJustify: 'right' })
        .addText('F7')
        .setHorizontal('left')
        .addGlyphOrText('#11', superscript)
        .addGlyphOrText('b9', subscript);
    chord2 = f.ChordSymbol({ hJustify: 'right' }).addText('C').addTextSuperscript('Maj.');
    draw(chord1, chord2, 240);
    chord1 = f
        .ChordSymbol({ hJustify: 'left' })
        .addText('F7')
        .setHorizontal('left')
        .addGlyphOrText('#11', superscript)
        .addGlyphOrText('b9', subscript);
    chord2 = f.ChordSymbol({ hJustify: 'centerStem' }).addText('C').addTextSuperscript('Maj.');
    draw(chord1, chord2, 340);
    options.assert.ok(true, 'Top Chord Justified');
}
function bottom(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600 * 1.5, 230);
    const ctx = f.getContext();
    ctx.scale(1.5, 1.5);
    function draw(chords, y) {
        const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_6__.Stave(10, y, 400).addClef('treble').setContext(ctx).draw();
        const notes = [
            note(f, ['c/4', 'f/4', 'a/4'], 'q', chords[0]),
            note(f, ['c/4', 'e/4', 'b/4'], 'q', chords[1]).addModifier(new _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental('b'), 2),
            note(f, ['c/4', 'e/4', 'g/4'], 'q', chords[2]),
            note(f, ['c/4', 'f/4', 'a/4'], 'q', chords[3]).addModifier(new _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental('#'), 1),
        ];
        _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, stave, notes);
    }
    const chords = [
        f.ChordSymbol({ vJustify: 'bottom' }).addText('I').addTextSuperscript('6').addTextSubscript('4'),
        f.ChordSymbol({ vJustify: 'bottom' }).addGlyphOrText('V'),
        f.ChordSymbol({ vJustify: 'bottom' }).addLine(),
        f.ChordSymbol({ vJustify: 'bottom' }).addGlyphOrText('V/V'),
    ];
    draw(chords, 10);
    options.assert.ok(true, 'Bottom Chord Symbol');
}
function bottomStemDown(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600 * 1.5, 330);
    const ctx = f.getContext();
    ctx.scale(1.5, 1.5);
    function draw(chords, y) {
        // Helper function to create a StaveNote with a ChordSymbol and the stem pointing down.
        const note = (keys, duration, chordSymbol) => new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({ keys, duration, stemDirection: -1 }).addModifier(chordSymbol, 0);
        const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_6__.Stave(10, y, 400).addClef('treble').setContext(ctx).draw();
        const notes = [
            note(['c/4', 'f/4', 'a/4'], 'q', chords[0]),
            note(['c/4', 'e/4', 'b/4'], 'q', chords[1]).addModifier(new _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental('b'), 2),
            note(['c/4', 'e/4', 'g/4'], 'q', chords[2]),
            note(['c/4', 'f/4', 'a/4'], 'q', chords[3]).addModifier(new _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental('#'), 1),
        ];
        _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, stave, notes);
    }
    const chords = [
        f.ChordSymbol({ vJustify: 'bottom' }).addGlyphOrText('F'),
        f.ChordSymbol({ vJustify: 'bottom' }).addGlyphOrText('C7'),
        f.ChordSymbol({ vJustify: 'bottom' }).addLine(),
        f.ChordSymbol({ vJustify: 'bottom' }).addText('A').addGlyphSuperscript('dim'),
    ];
    draw(chords, 10);
    options.assert.ok(true, 'Bottom Stem Down Chord Symbol');
}
function doubleBottom(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600 * 1.5, 260);
    const ctx = f.getContext();
    ctx.scale(1.5, 1.5);
    function draw(chords, chords2, y) {
        // Helper function to create a StaveNote with two ChordSymbols attached.
        const note = (keys, duration, chordSymbol1, chordSymbol2) => new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({ keys, duration }).addModifier(chordSymbol1, 0).addModifier(chordSymbol2, 0);
        const stave = f.Stave({ x: 10, y, width: 450 }).addClef('treble').setContext(ctx).draw();
        const notes = [
            note(['c/4', 'f/4', 'a/4'], 'q', chords[0], chords2[0]),
            note(['c/4', 'e/4', 'b/4'], 'q', chords[1], chords2[1]).addModifier(f.Accidental({ type: 'b' }), 2),
            note(['c/4', 'e/4', 'g/4'], 'q', chords[2], chords2[2]),
            note(['c/4', 'f/4', 'a/4'], 'q', chords[3], chords2[3]).addModifier(f.Accidental({ type: '#' }), 1),
        ];
        _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, stave, notes);
    }
    const chords1 = [
        f.ChordSymbol({ vJustify: 'bottom' }).addText('I').addTextSuperscript('6').addTextSubscript('4'),
        f.ChordSymbol({ vJustify: 'bottom' }).addGlyphOrText('V'),
        f.ChordSymbol({ vJustify: 'bottom' }).addLine(),
        f.ChordSymbol({ vJustify: 'bottom' }).addGlyphOrText('V/V'),
    ];
    const chords2 = [
        f.ChordSymbol({ vJustify: 'bottom' }).addText('T'),
        f.ChordSymbol({ vJustify: 'bottom' }).addText('D'),
        f.ChordSymbol({ vJustify: 'bottom' }).addText('D'),
        f.ChordSymbol({ vJustify: 'bottom' }).addText('SD'),
    ];
    draw(chords1, chords2, 10);
    options.assert.ok(true, '2 Bottom Chord Symbol');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(ChordSymbolTests);



/***/ }),

/***/ "./tests/clef_tests.ts":
/*!*****************************!*\
  !*** ./tests/clef_tests.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ClefTests: () => (/* binding */ ClefTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Clef Tests

const ClefTests = {
    Start() {
        QUnit.module('Clef');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Clef Test', draw);
        run('Clef End Test', drawEnd);
        run('Small Clef Test', drawSmall);
        run('Small Clef End Test', drawSmallEnd);
        run('Clef Change Test', drawClefChange);
    },
};
function draw(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 800, 120);
    f.Stave()
        .addClef('treble')
        .addClef('treble', 'default', '8va')
        .addClef('treble', 'default', '8vb')
        .addClef('alto')
        .addClef('tenor')
        .addClef('soprano')
        .addClef('bass')
        .addClef('bass', 'default', '8vb')
        .addClef('mezzo-soprano')
        .addClef('baritone-c')
        .addClef('baritone-f')
        .addClef('subbass')
        .addClef('percussion')
        .addClef('french')
        .addEndClef('treble');
    f.draw();
    options.assert.ok(true, 'all pass');
}
function drawEnd(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 800, 120);
    f.Stave()
        .addClef('bass')
        .addEndClef('treble')
        .addEndClef('treble', 'default', '8va')
        .addEndClef('treble', 'default', '8vb')
        .addEndClef('alto')
        .addEndClef('tenor')
        .addEndClef('soprano')
        .addEndClef('bass')
        .addEndClef('bass', 'default', '8vb')
        .addEndClef('mezzo-soprano')
        .addEndClef('baritone-c')
        .addEndClef('baritone-f')
        .addEndClef('subbass')
        .addEndClef('percussion')
        .addEndClef('french');
    f.draw();
    options.assert.ok(true, 'all pass');
}
function drawSmall(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 800, 120);
    f.Stave()
        .addClef('treble', 'small')
        .addClef('treble', 'small', '8va')
        .addClef('treble', 'small', '8vb')
        .addClef('alto', 'small')
        .addClef('tenor', 'small')
        .addClef('soprano', 'small')
        .addClef('bass', 'small')
        .addClef('bass', 'small', '8vb')
        .addClef('mezzo-soprano', 'small')
        .addClef('baritone-c', 'small')
        .addClef('baritone-f', 'small')
        .addClef('subbass', 'small')
        .addClef('percussion', 'small')
        .addClef('french', 'small')
        .addEndClef('treble', 'small');
    f.draw();
    options.assert.ok(true, 'all pass');
}
function drawSmallEnd(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 800, 120);
    f.Stave()
        .addClef('bass', 'small')
        .addEndClef('treble', 'small')
        .addEndClef('treble', 'small', '8va')
        .addEndClef('treble', 'small', '8vb')
        .addEndClef('alto', 'small')
        .addEndClef('tenor', 'small')
        .addEndClef('soprano', 'small')
        .addEndClef('bass', 'small')
        .addEndClef('bass', 'small', '8vb')
        .addEndClef('mezzo-soprano', 'small')
        .addEndClef('baritone-c', 'small')
        .addEndClef('baritone-f', 'small')
        .addEndClef('subbass', 'small')
        .addEndClef('percussion', 'small')
        .addEndClef('french', 'small');
    f.draw();
    options.assert.ok(true, 'all pass');
}
function drawClefChange(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 800, 180);
    const stave = f.Stave().addClef('treble');
    const notes = [
        f.StaveNote({ keys: ['c/4'], duration: '4', clef: 'treble' }),
        f.ClefNote({ type: 'alto', options: { size: 'small' } }),
        f.StaveNote({ keys: ['c/4'], duration: '4', clef: 'alto' }),
        f.ClefNote({ type: 'tenor', options: { size: 'small' } }),
        f.StaveNote({ keys: ['c/4'], duration: '4', clef: 'tenor' }),
        f.ClefNote({ type: 'soprano', options: { size: 'small' } }),
        f.StaveNote({ keys: ['c/4'], duration: '4', clef: 'soprano' }),
        f.ClefNote({ type: 'bass', options: { size: 'small' } }),
        f.StaveNote({ keys: ['c/4'], duration: '4', clef: 'bass' }),
        f.ClefNote({ type: 'mezzo-soprano', options: { size: 'small' } }),
        f.StaveNote({ keys: ['c/4'], duration: '4', clef: 'mezzo-soprano' }),
        f.ClefNote({ type: 'baritone-c', options: { size: 'small' } }),
        f.StaveNote({ keys: ['c/4'], duration: '4', clef: 'baritone-c' }),
        f.ClefNote({ type: 'baritone-f', options: { size: 'small' } }),
        f.StaveNote({ keys: ['c/4'], duration: '4', clef: 'baritone-f' }),
        f.ClefNote({ type: 'subbass', options: { size: 'small' } }),
        f.StaveNote({ keys: ['c/4'], duration: '4', clef: 'subbass' }),
        f.ClefNote({ type: 'french', options: { size: 'small' } }),
        f.StaveNote({ keys: ['c/4'], duration: '4', clef: 'french' }),
        f.ClefNote({ type: 'treble', options: { size: 'small', annotation: '8vb' } }),
        f.StaveNote({ keys: ['c/4'], duration: '4', clef: 'treble', octaveShift: -1 }),
        f.ClefNote({ type: 'treble', options: { size: 'small', annotation: '8va' } }),
        f.StaveNote({ keys: ['c/4'], duration: '4', clef: 'treble', octaveShift: 1 }),
    ];
    const voice = f.Voice({ time: '12/4' }).addTickables(notes);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'all pass');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(ClefTests);



/***/ }),

/***/ "./tests/crossbeam_tests.ts":
/*!**********************************!*\
  !*** ./tests/crossbeam_tests.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CrossBeamTests: () => (/* binding */ CrossBeamTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_stave__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/stave */ "./src/stave.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Formatter Tests


const CrossBeamTests = {
    Start() {
        QUnit.module('CrossBeam');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        const crossStaveTests = [];
        crossStaveTests.push({
            title: 'Single clef mixed 1',
            time: '3/4',
            voices: [
                {
                    notes: [{ notestring: 'g4/16, f4/16, a6/16, g6/16, b4/4/r, g6/8, g4/8 ', clef: 'treble' }],
                    stavemask: [0, 0, 0, 0, 0, 0, 0],
                    beammask: [1, 1, -1, -1, 0, -1, 1],
                    clef: 'treble',
                },
            ],
        });
        crossStaveTests.push({
            title: 'Single clef mixed 2',
            time: '3/4',
            voices: [
                {
                    notes: [{ notestring: 'g4/16, f6/16, a4/16, g6/16, b4/4/r, g6/8, g4/8 ', clef: 'treble' }],
                    stavemask: [0, 0, 0, 0, 0, 0, 0],
                    beammask: [1, -1, 1, -1, 0, -1, 1],
                    clef: 'treble',
                },
            ],
        });
        crossStaveTests.push({
            title: 'Mixed clef voice middle',
            time: '2/4',
            voices: [
                {
                    notes: [{ notestring: 'e#5/4, b4/16/r, b4/16, d5/16., c5/32 ', clef: 'treble' }],
                    stavemask: [0, 0, 0, 0, 0],
                    beammask: [0, 0, 1, 1, 1],
                    clef: 'treble',
                },
                {
                    notes: [
                        { notestring: 'C3/16, B3/16, C4/16', clef: 'bass' },
                        { notestring: 'E#4/16', clef: 'treble' },
                        { notestring: 'C4/4', clef: 'bass' },
                    ],
                    stavemask: [1, 1, 1, 0, 1],
                    beammask: [1, 1, 1, -1, 0],
                    clef: 'bass',
                },
            ],
        });
        crossStaveTests.push({
            title: 'Vertical alignment - cross stave (beam up1)',
            time: '4/4',
            voices: [
                {
                    notes: [
                        { notestring: 'C#5/q, B4/q, A4/8, E4/8', clef: 'treble' },
                        { notestring: 'C4/8, D4/8', clef: 'bass' },
                    ],
                    beammask: [0, 0, 1, 1, 1, 1],
                    stavemask: [0, 0, 0, 0, 1, 1],
                    clef: 'treble',
                },
                { notes: [{ notestring: '', clef: 'bass' }], beammask: [], stavemask: [], clef: 'bass' },
            ],
        });
        crossStaveTests.push({
            title: 'Vertical alignment - cross stave (beam up2)',
            time: '4/4',
            voices: [
                {
                    notes: [
                        { notestring: 'C#5/q, C5/16, B4/q, A4/8, E4/16', clef: 'treble' },
                        { notestring: 'C4/8, D4/8', clef: 'bass' },
                    ],
                    beammask: [0, 0, 0, 1, 1, 1, 1],
                    stavemask: [0, 0, 0, 0, 0, 1, 1],
                    clef: 'treble',
                },
                { notes: [{ notestring: '', clef: 'bass' }], beammask: [], stavemask: [], clef: 'bass' },
            ],
        });
        crossStaveTests.push({
            title: 'Vertical alignment - cross stave (beam up3)',
            time: '4/4',
            voices: [
                {
                    notes: [
                        { notestring: 'C#5/q, C5/16, B4/q, A4/8, E4/8', clef: 'treble' },
                        { notestring: 'C4/16, D4/8', clef: 'bass' },
                    ],
                    beammask: [0, 0, 0, 1, 1, 1, 1],
                    stavemask: [0, 0, 0, 0, 0, 1, 1],
                    clef: 'treble',
                },
                { notes: [{ notestring: '', clef: 'bass' }], beammask: [], stavemask: [], clef: 'bass' },
            ],
        });
        crossStaveTests.push({
            title: 'Vertical alignment - cross stave (beam up4)',
            time: '4/4',
            voices: [
                {
                    notes: [
                        { notestring: 'C#5/q, C5/8, B4/q, A4/8, E4/16', clef: 'treble' },
                        { notestring: 'C4/16, D4/8', clef: 'bass' },
                    ],
                    beammask: [0, 0, 0, 1, 1, 1, 1],
                    stavemask: [0, 0, 0, 0, 0, 1, 1],
                    clef: 'treble',
                },
                { notes: [{ notestring: '', clef: 'bass' }], beammask: [], stavemask: [], clef: 'bass' },
            ],
        });
        crossStaveTests.push({
            title: 'Vertical alignment - cross stave (beam down1)',
            time: '4/4',
            voices: [
                {
                    notes: [
                        { notestring: 'C#5/q, B4/q, A4/8, E4/8', clef: 'treble' },
                        { notestring: 'C4/8, D4/8', clef: 'bass' },
                    ],
                    beammask: [0, 0, -1, -1, -1, -1],
                    stavemask: [0, 0, 0, 0, 1, 1],
                    clef: 'treble',
                },
                { notes: [{ notestring: '', clef: 'bass' }], beammask: [], stavemask: [], clef: 'bass' },
            ],
        });
        crossStaveTests.push({
            title: 'Vertical alignment - cross stave (beam down2)',
            time: '4/4',
            voices: [
                {
                    notes: [
                        { notestring: 'C#5/q, C5/16, B4/q, A4/8, E4/16', clef: 'treble' },
                        { notestring: 'C4/8, D4/8', clef: 'bass' },
                    ],
                    beammask: [0, 0, 0, -1, -1, -1, -1],
                    stavemask: [0, 0, 0, 0, 0, 1, 1],
                    clef: 'treble',
                },
                { notes: [{ notestring: '', clef: 'bass' }], beammask: [], stavemask: [], clef: 'bass' },
            ],
        });
        crossStaveTests.push({
            title: 'Vertical alignment - cross stave (beam down3)',
            time: '4/4',
            voices: [
                {
                    notes: [
                        { notestring: 'C#5/q, C5/16, B4/q, A4/8, E4/8', clef: 'treble' },
                        { notestring: 'C4/16, D4/8', clef: 'bass' },
                    ],
                    beammask: [0, 0, 0, -1, -1, -1, -1],
                    stavemask: [0, 0, 0, 0, 0, 1, 1],
                    clef: 'treble',
                },
                { notes: [{ notestring: '', clef: 'bass' }], beammask: [], stavemask: [], clef: 'bass' },
            ],
        });
        crossStaveTests.push({
            title: 'Vertical alignment - cross stave (beam down4)',
            time: '4/4',
            voices: [
                {
                    notes: [
                        { notestring: 'C#5/q, C5/8, B4/q, A4/8, E4/16', clef: 'treble' },
                        { notestring: 'C4/16, D4/8', clef: 'bass' },
                    ],
                    beammask: [0, 0, 0, -1, -1, -1, -1],
                    stavemask: [0, 0, 0, 0, 0, 1, 1],
                    clef: 'treble',
                },
                { notes: [{ notestring: '', clef: 'bass' }], beammask: [], stavemask: [], clef: 'bass' },
            ],
        });
        crossStaveTests.push({
            title: 'Vertical alignment - cross stave (beam middle1)',
            time: '4/4',
            voices: [
                {
                    notes: [
                        { notestring: 'C#5/q, B4/q, A4/8, E4/8', clef: 'treble' },
                        { notestring: 'C4/8, D4/8', clef: 'bass' },
                    ],
                    beammask: [0, 0, -1, -1, 1, 1],
                    stavemask: [0, 0, 0, 0, 1, 1],
                    clef: 'treble',
                },
                { notes: [{ notestring: '', clef: 'bass' }], beammask: [], stavemask: [], clef: 'bass' },
            ],
        });
        crossStaveTests.push({
            title: 'Vertical alignment - cross stave (beam middle2)',
            time: '4/4',
            voices: [
                {
                    notes: [
                        { notestring: 'C#5/q, C5/16, B4/q, A4/8, E4/16', clef: 'treble' },
                        { notestring: 'C4/8, D4/8', clef: 'bass' },
                    ],
                    beammask: [0, 0, 0, -1, -1, 1, 1],
                    stavemask: [0, 0, 0, 0, 0, 1, 1],
                    clef: 'treble',
                },
                { notes: [{ notestring: '', clef: 'bass' }], beammask: [], stavemask: [], clef: 'bass' },
            ],
        });
        crossStaveTests.push({
            title: 'Vertical alignment - cross stave (beam middle3)',
            time: '4/4',
            voices: [
                {
                    notes: [
                        { notestring: 'C#5/q, C5/16, B4/q, A4/8, E4/8', clef: 'treble' },
                        { notestring: 'C4/16, D4/8', clef: 'bass' },
                    ],
                    beammask: [0, 0, 0, -1, -1, 1, 1],
                    stavemask: [0, 0, 0, 0, 0, 1, 1],
                    clef: 'treble',
                },
                { notes: [{ notestring: '', clef: 'bass' }], beammask: [], stavemask: [], clef: 'bass' },
            ],
        });
        crossStaveTests.push({
            title: 'Vertical alignment - cross stave (beam middle4)',
            time: '4/4',
            voices: [
                {
                    notes: [
                        { notestring: 'C#5/q, C5/8, B4/q, A4/8, E4/16', clef: 'treble' },
                        { notestring: 'C4/16, D4/8', clef: 'bass' },
                    ],
                    beammask: [0, 0, 0, -1, -1, 1, 1],
                    stavemask: [0, 0, 0, 0, 0, 1, 1],
                    clef: 'treble',
                },
                { notes: [{ notestring: '', clef: 'bass' }], beammask: [], stavemask: [], clef: 'bass' },
            ],
        });
        crossStaveTests.forEach((cst) => {
            run(cst.title, crossClef, cst);
        });
    },
};
function crossClef(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 400 + _src_stave__WEBPACK_IMPORTED_MODULE_1__.Stave.defaultPadding, 250);
    f.getContext().scale(0.8, 0.8);
    const score = f.EasyScore();
    const system = f.System({
        details: { softmaxFactor: 100 },
        autoWidth: true,
        debugFormatter: false,
    });
    const testdata = options.params;
    const voicedata = testdata.voices;
    const stavemap = [];
    for (let i = 0; i < voicedata.length; ++i) {
        const clef = voicedata[i].clef;
        stavemap.push(system.addStave({ voices: [] }).addClef(clef).addTimeSignature(testdata.time));
    }
    for (let i = 0; i < voicedata.length; ++i) {
        const stavemask = voicedata[i].stavemask;
        let scoreNotes = [];
        const voicenotes = voicedata[i].notes;
        for (let k = 0; k < voicenotes.length; ++k) {
            scoreNotes = scoreNotes.concat(score.notes(voicenotes[k].notestring, { clef: voicenotes[k].clef }));
        }
        const beammask = voicedata[i].beammask;
        let curGroup = [];
        const beamGroups = [];
        for (let j = 0; j < scoreNotes.length; ++j) {
            const note = scoreNotes[j];
            note.setStave(stavemap[stavemask[j]]);
            if (beammask[j] !== 0) {
                note.setStemDirection(beammask[j]);
                curGroup.push(note);
            }
            else {
                if (curGroup.length) {
                    beamGroups.push(curGroup);
                    curGroup = [];
                }
            }
        }
        if (curGroup.length) {
            beamGroups.push(curGroup);
        }
        beamGroups.forEach((bg) => {
            score.beam(bg);
        });
        if (scoreNotes.length > 0) {
            const voice = score.voice(scoreNotes, { time: testdata.time });
            system.addVoices([voice]);
        }
    }
    f.draw();
    options.assert.ok(true);
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(CrossBeamTests);



/***/ }),

/***/ "./tests/curve_tests.ts":
/*!******************************!*\
  !*** ./tests/curve_tests.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CurveTests: () => (/* binding */ CurveTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/curve */ "./src/curve.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Curve Tests


const CurveTests = {
    Start() {
        QUnit.module('Curve');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Simple Curve', simple);
        run('Rounded Curve', rounded);
        run('Thick Thin Curves', thickThin);
        run('Top Curve', top);
    },
};
/**
 * Helper function. Each test case passes in a set of notes and
 * a setupCurves() callback which uses Factory.Curve(...) to build the curves.
 * Curves can be used to indicate slurs (legato articulation).
 */
function createTest(noteGroup1, noteGroup2, setupCurves) {
    return (options) => {
        const factory = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 350, 200);
        const stave = factory.Stave({ y: 50 });
        const score = factory.EasyScore();
        // Use .reduce(concat) to flatten the two StaveNote[] into a single StaveNote[].
        const staveNotes = [
            score.beam(score.notes(...noteGroup1)),
            score.beam(score.notes(...noteGroup2)), // group 2
        ].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat);
        setupCurves(factory, staveNotes);
        const voices = [score.voice(staveNotes, { time: '4/4' })];
        factory.Formatter().joinVoices(voices).formatToStave(voices, stave);
        factory.draw();
        options.assert.ok('Simple Curve');
    };
}
const simple = createTest(['c4/8, f5, d5, g5', { stem: 'up' }], // beamGroup1
['d6/8, f5, d5, g5', { stem: 'down' }], // beamGroup2
(f, notes) => {
    f.Curve({
        from: notes[0],
        to: notes[3],
        options: {
            cps: [
                { x: 0, y: 10 },
                { x: 0, y: 50 },
            ],
        },
    });
    f.Curve({
        from: notes[4],
        to: notes[7],
        options: {
            cps: [
                { x: 0, y: 10 },
                { x: 0, y: 20 },
            ],
        },
    });
});
const rounded = createTest(['c5/8, f4, d4, g5', { stem: 'up' }], // beamGroup1
['d5/8, d6, d6, g5', { stem: 'down' }], // beamGroup2
(f, notes) => {
    f.Curve({
        from: notes[0],
        to: notes[3],
        options: {
            xShift: -10,
            yShift: 30,
            cps: [
                { x: 0, y: 20 },
                { x: 0, y: 50 },
            ],
        },
    });
    f.Curve({
        from: notes[4],
        to: notes[7],
        options: {
            cps: [
                { x: 0, y: 50 },
                { x: 0, y: 50 },
            ],
        },
    });
});
const thickThin = createTest(['c5/8, f4, d4, g5', { stem: 'up' }], // beamGroup1
['d5/8, d6, d6, g5', { stem: 'down' }], // beamGroup2
(f, notes) => {
    f.Curve({
        from: notes[0],
        to: notes[3],
        options: {
            thickness: 10,
            xShift: -10,
            yShift: 30,
            cps: [
                { x: 0, y: 20 },
                { x: 0, y: 50 },
            ],
        },
    });
    f.Curve({
        from: notes[4],
        to: notes[7],
        options: {
            thickness: 0,
            cps: [
                { x: 0, y: 50 },
                { x: 0, y: 50 },
            ],
        },
    });
});
const top = createTest(['c5/8, f4, d4, g5', { stem: 'up' }], // beamGroup1
['d5/8, d6, d6, g5', { stem: 'down' }], // beamGroup2
(f, notes) => {
    f.Curve({
        from: notes[0],
        to: notes[7],
        options: {
            xShift: -3,
            yShift: 10,
            position: _src_curve__WEBPACK_IMPORTED_MODULE_1__.CurvePosition.NEAR_TOP,
            positionEnd: _src_curve__WEBPACK_IMPORTED_MODULE_1__.CurvePosition.NEAR_HEAD,
            cps: [
                { x: 0, y: 20 },
                { x: 40, y: 80 },
            ],
        },
    });
});
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(CurveTests);



/***/ }),

/***/ "./tests/dot_tests.ts":
/*!****************************!*\
  !*** ./tests/dot_tests.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DotTests: () => (/* binding */ DotTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_beam__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/beam */ "./src/beam.ts");
/* harmony import */ var _src_dot__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/dot */ "./src/dot.ts");
/* harmony import */ var _src_formatter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/formatter */ "./src/formatter.ts");
/* harmony import */ var _src_modifiercontext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/modifiercontext */ "./src/modifiercontext.ts");
/* harmony import */ var _src_note__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/note */ "./src/note.ts");
/* harmony import */ var _src_stave__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/stave */ "./src/stave.ts");
/* harmony import */ var _src_stavenote__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/stavenote */ "./src/stavenote.ts");
/* harmony import */ var _src_tickcontext__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/tickcontext */ "./src/tickcontext.ts");
/* harmony import */ var _src_voice__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/voice */ "./src/voice.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Dot Tests










const DotTests = {
    Start() {
        QUnit.module('Dot');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Basic', basic);
        run('Multi Voice', multiVoice);
    },
};
/**
 * Helper function for the basic test case below.
 */
function showOneNote(note1, stave, ctx, x) {
    const modifierContext = new _src_modifiercontext__WEBPACK_IMPORTED_MODULE_4__.ModifierContext();
    note1.setStave(stave).addToModifierContext(modifierContext);
    new _src_tickcontext__WEBPACK_IMPORTED_MODULE_8__.TickContext().addTickable(note1).preFormat().setX(x);
    note1.setContext(ctx).draw();
    _src_note__WEBPACK_IMPORTED_MODULE_5__.Note.plotMetrics(ctx, note1, 140);
}
function basic(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 1000, 240);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_6__.Stave(10, 10, 975);
    stave.setContext(ctx);
    stave.draw();
    const notes = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({ keys: ['c/4', 'e/4', 'a/4', 'b/4'], duration: 'w' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({ keys: ['a/4', 'b/4', 'c/5'], duration: '4', stemDirection: 1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({ keys: ['g/4', 'a/4', 'b/4'], duration: '4', stemDirection: -1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({ keys: ['e/4', 'f/4', 'b/4', 'c/5'], duration: '4' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({
            keys: ['g/4', 'a/4', 'd/5', 'e/5', 'g/5'],
            duration: '4',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({ keys: ['g/4', 'b/4', 'd/5', 'e/5'], duration: '4', stemDirection: -1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({ keys: ['e/4', 'g/4', 'b/4', 'c/5'], duration: '4', stemDirection: 1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({ keys: ['d/4', 'e/4', 'f/4', 'a/4', 'c/5', 'e/5', 'g/5'], duration: '2' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({
            keys: ['f/4', 'g/4', 'a/4', 'b/4', 'c/5', 'e/5', 'g/5'],
            duration: '16',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({ keys: ['f/4', 'g/4', 'a/4', 'b/4', 'c/5', 'e/5', 'g/5'], duration: '16', stemDirection: 1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({
            keys: ['e/4', 'g/4', 'a/4', 'b/4', 'c/5', 'e/5', 'f/5'],
            duration: '16',
            stemDirection: 1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({
            keys: ['e/4', 'g/4', 'a/4', 'b/4', 'c/5'],
            duration: '16',
            stemDirection: 1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({ keys: ['e/4', 'a/4', 'b/4', 'c/5'], duration: '16', stemDirection: 1 }),
    ];
    _src_dot__WEBPACK_IMPORTED_MODULE_2__.Dot.buildAndAttach(notes, { all: true });
    _src_dot__WEBPACK_IMPORTED_MODULE_2__.Dot.buildAndAttach([notes[7], notes[8], notes[9]], { all: true });
    _src_dot__WEBPACK_IMPORTED_MODULE_2__.Dot.buildAndAttach([notes[8], notes[9]], { all: true });
    const beam = new _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam(notes.slice(notes.length - 2));
    for (let i = 0; i < notes.length; i++) {
        showOneNote(notes[i], stave, ctx, 30 + i * 65);
        const dots = notes[i].getModifiersByType('Dot');
        options.assert.ok(dots.length > 0, 'Note ' + i + ' has dots');
        for (let j = 0; j < dots.length; ++j) {
            options.assert.ok(dots[j].getWidth() > 0, 'Dot ' + j + ' has width set');
        }
    }
    beam.setContext(ctx).draw();
    _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.plotLegendForNoteWidth(ctx, 890, 140);
    options.assert.ok(true, 'Full Dot');
}
function multiVoice(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 750, 300);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_6__.Stave(30, 45, 700).setContext(ctx).draw();
    const notes1 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({ keys: ['c/4', 'e/4', 'a/4'], duration: '2', stemDirection: -1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({ keys: ['c/4', 'e/4', 'c/5'], duration: '2', stemDirection: -1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({ keys: ['d/4', 'c/5', 'd/5'], duration: '2', stemDirection: -1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({ keys: ['d/4', 'c/5', 'd/5'], duration: '8', stemDirection: -1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({ keys: ['d/4', 'c/5', 'd/5'], duration: '8', stemDirection: -1 }),
    ];
    _src_dot__WEBPACK_IMPORTED_MODULE_2__.Dot.buildAndAttach([notes1[0], notes1[2], notes1[3], notes1[4]], { all: true });
    _src_dot__WEBPACK_IMPORTED_MODULE_2__.Dot.buildAndAttach([notes1[0], notes1[2], notes1[3], notes1[4]], { all: true });
    _src_dot__WEBPACK_IMPORTED_MODULE_2__.Dot.buildAndAttach([notes1[1]], { index: 0 });
    _src_dot__WEBPACK_IMPORTED_MODULE_2__.Dot.buildAndAttach([notes1[1]], { index: 0 });
    _src_dot__WEBPACK_IMPORTED_MODULE_2__.Dot.buildAndAttach([notes1[1]], { index: 1 });
    _src_dot__WEBPACK_IMPORTED_MODULE_2__.Dot.buildAndAttach([notes1[1]], { index: 1 });
    _src_dot__WEBPACK_IMPORTED_MODULE_2__.Dot.buildAndAttach([notes1[1]], { index: 2 });
    _src_dot__WEBPACK_IMPORTED_MODULE_2__.Dot.buildAndAttach([notes1[1]], { index: 2 });
    _src_dot__WEBPACK_IMPORTED_MODULE_2__.Dot.buildAndAttach([notes1[1]], { index: 2 });
    _src_dot__WEBPACK_IMPORTED_MODULE_2__.Dot.buildAndAttach([notes1[2], notes1[3], notes1[4]]);
    const notes2 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({ keys: ['d/5', 'a/5', 'b/5'], duration: '2', stemDirection: 1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({ keys: ['d/5', 'a/5', 'b/5'], duration: '4', stemDirection: 1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({ keys: ['d/5', 'a/5', 'b/5'], duration: '4', stemDirection: 1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({ keys: ['d/5', 'g/5', 'a/5', 'b/5'], duration: '8', stemDirection: 1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({ keys: ['d/5', 'a/5', 'b/5'], duration: '8', stemDirection: 1 }),
    ];
    _src_dot__WEBPACK_IMPORTED_MODULE_2__.Dot.buildAndAttach(notes2, { all: true });
    _src_dot__WEBPACK_IMPORTED_MODULE_2__.Dot.buildAndAttach([notes2[1]], { all: true });
    const voice1 = new _src_voice__WEBPACK_IMPORTED_MODULE_9__.Voice().setMode(_src_voice__WEBPACK_IMPORTED_MODULE_9__.Voice.Mode.SOFT).addTickables(notes1);
    const voice2 = new _src_voice__WEBPACK_IMPORTED_MODULE_9__.Voice().setMode(_src_voice__WEBPACK_IMPORTED_MODULE_9__.Voice.Mode.SOFT).addTickables(notes2);
    const formatter = new _src_formatter__WEBPACK_IMPORTED_MODULE_3__.Formatter().joinVoices([voice1, voice2]);
    formatter.format([voice1, voice2], 700);
    voice1.draw(ctx, stave);
    voice2.draw(ctx, stave);
    notes1.forEach((note) => _src_note__WEBPACK_IMPORTED_MODULE_5__.Note.plotMetrics(ctx, note, 190));
    notes2.forEach((note) => _src_note__WEBPACK_IMPORTED_MODULE_5__.Note.plotMetrics(ctx, note, 20));
    _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.plotLegendForNoteWidth(ctx, 620, 220);
    options.assert.ok(true, 'Full Dot');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(DotTests);



/***/ }),

/***/ "./tests/easyscore_tests.ts":
/*!**********************************!*\
  !*** ./tests/easyscore_tests.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EasyScoreTests: () => (/* binding */ EasyScoreTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_articulation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/articulation */ "./src/articulation.ts");
/* harmony import */ var _src_easyscore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/easyscore */ "./src/easyscore.ts");
/* harmony import */ var _src_frethandfinger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/frethandfinger */ "./src/frethandfinger.ts");
/* harmony import */ var _src_modifier__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/modifier */ "./src/modifier.ts");
/* harmony import */ var _src_parenthesis__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/parenthesis */ "./src/parenthesis.ts");
/* harmony import */ var _src_staveconnector__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/staveconnector */ "./src/staveconnector.ts");
/* harmony import */ var _src_stem__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/stem */ "./src/stem.ts");
/* harmony import */ var _src_tuplet__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/tuplet */ "./src/tuplet.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// EasyScore Tests









const EasyScoreTests = {
    Start() {
        QUnit.module('EasyScore');
        QUnit.test('Basic', basic);
        QUnit.test('Accidentals', accidentals);
        QUnit.test('Durations', durations);
        QUnit.test('Chords', chords);
        QUnit.test('Dots', dots);
        QUnit.test('Types', types);
        QUnit.test('Options', options);
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Draw Basic', drawBasicTest);
        run('Draw Different KeySignature', drawDiffKeysig);
        run('Draw Basic Muted', drawBasicMutedTest);
        run('Draw Basic Harmonic', drawBasicHarmonicTest);
        run('Draw Basic Slash', drawBasicSlashTest);
        run('Draw Ghostnote Basic', drawGhostBasicTest);
        run('Draw Ghostnote Dotted', drawGhostDottedTest);
        run('Draw Parenthesised', drawParenthesisedTest);
        run('Draw Accidentals', drawAccidentalsTest);
        run('Draw Beams', drawBeamsTest);
        run('Draw Tuplets', drawTupletsTest);
        run('Draw Dots', drawDotsTest);
        run('Draw Options', drawOptionsTest);
        run('Draw Fingerings', drawFingeringsTest);
        run('Keys', keys);
    },
};
/**
 * Use Function.prototype.bind() to create shortcut methods.
 * This can improve the readability of your EasyScore code.
 */
function createShortcuts(score) {
    return {
        voice: score.voice.bind(score),
        notes: score.notes.bind(score),
        beam: score.beam.bind(score),
        tuplet: score.tuplet.bind(score),
    };
}
/**
 * Test case verifies:
 * - all strings in `mustPass` parse correctly
 * - all strings in `mustFail` fail to parse (i.e., Result.success is `false`).
 */
function basic(assert) {
    const score = new _src_easyscore__WEBPACK_IMPORTED_MODULE_2__.EasyScore();
    const mustPass = ['c4', 'c#4', 'c4/r', 'c#5', 'c3/m', 'c3//m', 'c3//h', 'c3/s', 'c3//s', 'c3/g', 'c3//g'];
    const mustFail = ['', '()', '7', '(c#4 e5 g6'];
    mustPass.forEach((line) => assert.equal(score.parse(line).success, true, line));
    mustFail.forEach((line) => assert.equal(score.parse(line).success, false, line));
}
function accidentals(assert) {
    const score = new _src_easyscore__WEBPACK_IMPORTED_MODULE_2__.EasyScore();
    const mustPass = [
        'c3',
        'c##3, cb3',
        'Cn3',
        'f3//m',
        '(c##3 cbb3 cn3), cb3',
        'cbbs7',
        'cbb7',
        'cbss7',
        'cbs7',
        'cb7',
        'cdb7',
        'cd7',
        'c##7',
        'c#7',
        'cn7',
        'c++-7',
        'c++7',
        'c+-7',
        'c+7',
        '(cbs3 bbs3 dbs3), ebs3',
        '(cd7 cbb3 cn3), cb3',
        'co7',
        'ck7',
    ];
    const mustFail = [
        'ct3',
        'cdbb7',
        '(cq cbb3 cn3), cb3',
        '(cdd7 cbb3 cn3), cb3',
        'cbbbs7',
        'cbbss7',
        'cbsss7',
        'csbs7',
        'cddb7',
        'cddbb7',
        'cdd7',
        'c##b7',
        'c#bs7',
        'cnb#7',
        'c+#+b-d7',
        'c+--7',
        'c++--7',
        'c+++7',
        'cbk7',
        'cok7',
        'cko7',
        'c#s7',
    ];
    mustPass.forEach((line) => assert.equal(score.parse(line).success, true, line));
    mustFail.forEach((line) => assert.equal(score.parse(line).success, false, line));
}
function durations(assert) {
    const score = new _src_easyscore__WEBPACK_IMPORTED_MODULE_2__.EasyScore();
    const mustPass = ['c3/4', 'c##3/w, cb3', 'c##3/w, cb3/q', 'c##3/q, cb3/32', '(c##3 cbb3 cn3), cb3'];
    const mustFail = ['Cn3/]', '/', '(cq cbb3 cn3), cb3', '(cdd7 cbb3 cn3), cb3'];
    mustPass.forEach((line) => assert.equal(score.parse(line).success, true, line));
    mustFail.forEach((line) => assert.equal(score.parse(line).success, false, line));
}
function chords(assert) {
    const score = new _src_easyscore__WEBPACK_IMPORTED_MODULE_2__.EasyScore();
    const mustPass = [
        '(c5)',
        '(c3 e0 g9)',
        '(c##4 cbb4 cn4)/w, (c#5 cb2 a3)/32',
        '(d##4 cbb4 cn4)/w/r, (c#5 cb2 a3)',
        '(c##4 cbb4 cn4)/4, (c#5 cb2 a3)',
        '(c##4 cbb4 cn4)/m, (c#5 cb2 a3)',
    ];
    const mustFail = ['(c)'];
    mustPass.forEach((line) => assert.equal(score.parse(line).success, true, line));
    mustFail.forEach((line) => assert.equal(score.parse(line).success, false, line));
}
function dots(assert) {
    const score = new _src_easyscore__WEBPACK_IMPORTED_MODULE_2__.EasyScore();
    const mustPass = [
        'c3/4.',
        'c##3/w.., cb3',
        'f##3/s, cb3/q...',
        'c##3/q, cb3/32',
        '(c##3 cbb3 cn3)., cb3',
        '(c5).',
        '(c##4 cbb4 cn4)/w.., (c#5 cb2 a3)/32',
    ];
    const mustFail = ['.', 'c.#', 'c#4./4'];
    mustPass.forEach((line) => assert.equal(score.parse(line).success, true, line));
    mustFail.forEach((line) => assert.equal(score.parse(line).success, false, line));
}
function types(assert) {
    const score = new _src_easyscore__WEBPACK_IMPORTED_MODULE_2__.EasyScore();
    const mustPass = ['c3/4/m.', 'c##3//r.., cb3', 'c##3/m.., cb3', 'c##3/r.., cb3', 'd##3/w/s, cb3/q...', 'Fb4'];
    const mustFail = ['c4/q/U', '(c##4, cbb4 cn4)/w.., (c#5 cb2 a3)/32', 'z#3'];
    mustPass.forEach((line) => assert.equal(score.parse(line).success, true, line));
    mustFail.forEach((line) => assert.equal(score.parse(line).success, false, line));
}
function options(assert) {
    const score = new _src_easyscore__WEBPACK_IMPORTED_MODULE_2__.EasyScore();
    const mustPass = [
        'c3/4.[foo="bar"]',
        'c##3/w.., cb3[id="blah"]',
        'c##3/q, cb3/32',
        '(c##3 cbb3 cn3).[blah="bod4o"], cb3',
        '(c5)[fooooo="booo"]',
        'c#5[id="foobar"]',
    ];
    const mustFail = ['.[', 'f##3/w[], cb3/q...'];
    mustPass.forEach((line) => assert.equal(score.parse(line).success, true, line));
    mustFail.forEach((line) => assert.equal(score.parse(line).success, false, line));
}
function drawBasicTest(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 350);
    const score = f.EasyScore();
    const system = f.System();
    const { voice, notes } = createShortcuts(score);
    system
        .addStave({
        voices: [
            voice(notes('(d4 e4 g4)/q, c4/q, c4/q/r, c4/q', { stem: 'down' })),
            voice(notes('c#5/h., c5/q', { stem: 'up' })),
        ],
    })
        .addClef('treble');
    system
        .addStave({
        voices: [voice(notes('c#3/q, cn3/q, bb3/q, d##3/q', { clef: 'bass' }))],
    })
        .addClef('bass');
    system.addConnector().setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_6__.StaveConnector.type.BRACKET);
    f.draw();
    options.assert.expect(0);
}
function drawDiffKeysig(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 350);
    const score = f.EasyScore();
    const system = f.System();
    const { voice, notes } = createShortcuts(score);
    system
        .addStave({
        voices: [
            voice(notes('(d4 e4 g4)/q, c4/q, c4/q/r, c4/q', { stem: 'down' })),
            voice(notes('c5/h., c5/q', { stem: 'up' })),
        ],
    })
        .addClef('treble')
        .addTimeSignature('4/4')
        .addKeySignature('D');
    system
        .addStave({
        voices: [voice(notes('c#3/q, cn3/q, bb3/q, d##3/q', { clef: 'bass' }))],
    })
        .addClef('bass')
        .addTimeSignature('4/4');
    system.addConnector().setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_6__.StaveConnector.type.BRACKET);
    f.draw();
    options.assert.expect(0);
}
function drawBasicMutedTest(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 350);
    const score = f.EasyScore();
    const system = f.System();
    const { voice, notes } = createShortcuts(score);
    system
        .addStave({
        voices: [
            voice(notes('(d4 e4 g4)/q/m, c4/q/m, c4/q/r, c4/q/m', { stem: 'down' })),
            voice(notes('c#5/h/m., c5/q/m', { stem: 'up' })),
        ],
    })
        .addClef('treble');
    system
        .addStave({
        voices: [voice(notes('c#3/q/m, cn3/q/m, bb3/q/m, d##3/q/m', { clef: 'bass' }))],
    })
        .addClef('bass');
    system.addConnector().setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_6__.StaveConnector.type.BRACKET);
    f.draw();
    options.assert.expect(0);
}
function drawBasicHarmonicTest(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 350);
    const score = f.EasyScore();
    const system = f.System();
    const { voice, notes } = createShortcuts(score);
    system
        .addStave({
        voices: [
            voice(notes('(d4 e4 g4)/q/h, c4/q/h, c4/q/r, c4/q/h', { stem: 'down' })),
            voice(notes('c#5/h/h., c5/q/h', { stem: 'up' })),
        ],
    })
        .addClef('treble');
    system
        .addStave({
        voices: [voice(notes('c#3/q/h, cn3/q/h, bb3/q/h, d##3/q/h', { clef: 'bass' }))],
    })
        .addClef('bass');
    system.addConnector().setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_6__.StaveConnector.type.BRACKET);
    f.draw();
    options.assert.expect(0);
}
function drawBasicSlashTest(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 350);
    const score = f.EasyScore();
    const system = f.System();
    const { voice, notes } = createShortcuts(score);
    system
        .addStave({
        voices: [
            voice(notes('(d4 e4 g4)/q/s, c4/q/s, c4/q/r, c4/q/s', { stem: 'down' })),
            voice(notes('c#5/h/s., c5/q/s', { stem: 'up' })),
        ],
    })
        .addClef('treble');
    system
        .addStave({
        voices: [voice(notes('c#3/q/s, cn3/q/s, bb3/q/s, d##3/q/s', { clef: 'bass' }))],
    })
        .addClef('bass');
    system.addConnector().setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_6__.StaveConnector.type.BRACKET);
    f.draw();
    options.assert.expect(0);
}
function drawGhostBasicTest(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 550);
    const score = f.EasyScore();
    const system = f.System();
    system.addStave({
        voices: [
            score.voice([
                ...score.notes('f#5/4, f5, db5, c5', { stem: 'up' }),
                ...score.beam(score.notes('c5/8, d5, fn5, e5', { stem: 'up' })),
                ...score.beam(score.notes('d5, c5', { stem: 'up' })),
            ], { time: '7/4' }),
            score.voice(score.notes('c4/h/g, f4/4, c4/4/g, e4/4, c4/8/g, d##4/8, c4/8, c4/8', { stem: 'down' }), {
                time: '7/4',
            }),
        ],
    });
    f.draw();
    options.assert.expect(0);
}
function drawGhostDottedTest(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 550);
    const score = f.EasyScore();
    const system = f.System();
    system.addStave({
        voices: [
            score.voice([
                ...score.notes('c4/4/g., fbb5/8, d5/4', { stem: 'up' }),
                ...score.beam(score.notes('c5/8, c#5/16, d5/16', { stem: 'up' })),
                ...score.notes('c4/2/g.., fn5/8', { stem: 'up' }),
            ], { time: '8/4' }),
            score.voice([
                ...score.notes('f#4/4', { stem: 'down' }),
                ...score.beam(score.notes('e4/8, d4/8', { stem: 'down' })),
                ...score.notes('c4/4/g.., cb4/16, c#4/h, d4/4', { stem: 'down' }),
                ...score.beam(score.notes('fn4/8, e4/8', { stem: 'down' })),
            ], { time: '8/4' }),
        ],
    });
    f.draw();
    options.assert.expect(0);
}
function drawParenthesisedTest(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 350);
    const score = f.EasyScore();
    const system = f.System();
    const { voice, notes } = createShortcuts(score);
    const notes1 = notes('(d4 e4 g4)/q, c4/q, c4/q/r, c4/q', { stem: 'down' });
    _src_parenthesis__WEBPACK_IMPORTED_MODULE_5__.Parenthesis.buildAndAttach([notes1[0], notes1[3]]);
    const notes2 = notes('c#5/h., c5/q', { stem: 'down' });
    _src_parenthesis__WEBPACK_IMPORTED_MODULE_5__.Parenthesis.buildAndAttach([notes2[0], notes2[1]]);
    system
        .addStave({
        voices: [voice(notes1), voice(notes2)],
    })
        .addClef('treble');
    const notes3 = notes('c#3/q, cn3/q, bb3/q, d##3/q', { stem: 'down' });
    _src_parenthesis__WEBPACK_IMPORTED_MODULE_5__.Parenthesis.buildAndAttach(notes3);
    system
        .addStave({
        voices: [voice(notes3)],
    })
        .addClef('bass');
    system.addConnector().setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_6__.StaveConnector.type.BRACKET);
    f.draw();
    options.assert.expect(0);
}
function drawAccidentalsTest(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 350);
    const score = f.EasyScore();
    const system = f.System();
    const { voice, notes } = createShortcuts(score);
    system
        .addStave({
        voices: [
            voice(notes('(cbbs4 ebb4 gbss4)/q, cbs4/q, cdb4/q/r, cd4/q', { stem: 'down' })),
            voice(notes('c++-5/h., c++5/q', { stem: 'up' })),
        ],
    })
        .addClef('treble');
    system
        .addStave({
        voices: [voice(notes('c+-3/q, c+3/q, bb3/q, d##3/q', { clef: 'bass' }))],
    })
        .addClef('bass');
    system.addConnector().setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_6__.StaveConnector.type.BRACKET);
    f.draw();
    options.assert.expect(0);
}
function drawBeamsTest(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 250);
    const score = f.EasyScore();
    const system = f.System();
    const { voice, notes, beam } = createShortcuts(score);
    system
        .addStave({
        voices: [
            voice(notes('(c4 e4 g4)/q, c4/q, c4/q/r, c4/q', { stem: 'down' })),
            voice([...notes('c#5/h.', { stem: 'up' }), ...beam(notes('c5/8, c5/8', { stem: 'up' }))]),
        ],
    })
        .addClef('treble');
    f.draw();
    options.assert.expect(0);
}
function drawTupletsTest(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 250);
    const score = f.EasyScore();
    const system = f.System();
    const { voice, notes, tuplet, beam } = createShortcuts(score);
    // Voice 1, with stems pointed down.
    const v1Tuplet = tuplet(notes('(c4 e4 g4)/q, cbb4/q, c4/q', { stem: 'down' }), {
        location: _src_tuplet__WEBPACK_IMPORTED_MODULE_8__.Tuplet.LOCATION_BOTTOM,
    });
    const v1HalfNote = notes('c4/h', { stem: 'down' });
    const v1 = voice([...v1Tuplet, ...v1HalfNote]);
    // Voice 2, with stems pointed up.
    const v2HalfNote = notes('c#5/h.', { stem: 'up' });
    const v2Tuplet = tuplet(beam(notes('cb5/8, cn5/8, c5/8', { stem: 'up' })));
    const v2 = voice([...v2HalfNote, ...v2Tuplet]);
    system.addStave({ voices: [v1, v2] }).addClef('treble');
    f.draw();
    options.assert.expect(0);
}
function drawDotsTest(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 250);
    const score = f.EasyScore();
    const system = f.System();
    const { voice, notes } = createShortcuts(score);
    system
        .addStave({
        voices: [voice(notes('(c4 e4 g4)/8., (c4 e4 g4)/8.., (c4 e4 g4)/8..., (c4 e4 g4)/8...., (c4 e4 g4)/16...'))],
    })
        .addClef('treble');
    f.draw();
    options.assert.expect(0);
}
function drawOptionsTest(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 500, 200);
    const score = f.EasyScore();
    const system = f.System();
    const notes = score.notes('B4/h[id="foobar", class="red,bold", stem="up", articulations="staccato.below,tenuto"], B4/q[articulations="accent.above"], B4/q[stem="down"]');
    system.addStave({ voices: [score.voice(notes)] });
    f.draw();
    const note0 = notes[0];
    const note1 = notes[1];
    const note0Modifier0 = note0.getModifiers()[0];
    const note0Modifier1 = note0.getModifiers()[1];
    const note1Modifier0 = note1.getModifiers()[0];
    options.assert.equal(note0.getAttribute('id'), 'foobar');
    options.assert.ok(note0.hasClass('red'));
    options.assert.ok(note0.hasClass('bold'));
    options.assert.equal(note0Modifier0.getCategory(), _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation.CATEGORY);
    options.assert.equal(note0Modifier0.type, 'a.');
    options.assert.equal(note0Modifier0.getPosition(), _src_modifier__WEBPACK_IMPORTED_MODULE_4__.Modifier.Position.BELOW);
    options.assert.equal(note0Modifier1.getCategory(), _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation.CATEGORY);
    options.assert.equal(note0Modifier1.type, 'a-');
    options.assert.equal(note0Modifier1.getPosition(), _src_modifier__WEBPACK_IMPORTED_MODULE_4__.Modifier.Position.ABOVE);
    options.assert.equal(note0.getStemDirection(), _src_stem__WEBPACK_IMPORTED_MODULE_7__.Stem.UP);
    options.assert.equal(note1Modifier0.getCategory(), _src_articulation__WEBPACK_IMPORTED_MODULE_1__.Articulation.CATEGORY);
    options.assert.equal(note1Modifier0.type, 'a>');
    options.assert.equal(note1Modifier0.getPosition(), _src_modifier__WEBPACK_IMPORTED_MODULE_4__.Modifier.Position.ABOVE);
    options.assert.equal(notes[2].getStemDirection(), _src_stem__WEBPACK_IMPORTED_MODULE_7__.Stem.DOWN);
}
function drawFingeringsTest(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 500, 200);
    const score = f.EasyScore();
    const system = f.System();
    const notes = score.notes('C4/q[fingerings="1"], E4[fingerings="3.above"], G4[fingerings="5.below"], (C4 E4 G4)[fingerings="1,3,5"]');
    system.addStave({ voices: [score.voice(notes)] });
    f.draw();
    const note0Modifier0 = notes[0].getModifiers()[0];
    options.assert.equal(note0Modifier0.getCategory(), _src_frethandfinger__WEBPACK_IMPORTED_MODULE_3__.FretHandFinger.CATEGORY);
    options.assert.equal(note0Modifier0.getFretHandFinger(), '1');
    options.assert.equal(note0Modifier0.getPosition(), _src_modifier__WEBPACK_IMPORTED_MODULE_4__.Modifier.Position.LEFT);
    const note1Modifier0 = notes[1].getModifiers()[0];
    options.assert.equal(note1Modifier0.getCategory(), _src_frethandfinger__WEBPACK_IMPORTED_MODULE_3__.FretHandFinger.CATEGORY);
    options.assert.equal(note1Modifier0.getFretHandFinger(), '3');
    options.assert.equal(note1Modifier0.getPosition(), _src_modifier__WEBPACK_IMPORTED_MODULE_4__.Modifier.Position.ABOVE);
    const note2Modifier0 = notes[2].getModifiers()[0];
    options.assert.equal(note2Modifier0.getCategory(), _src_frethandfinger__WEBPACK_IMPORTED_MODULE_3__.FretHandFinger.CATEGORY);
    options.assert.equal(note2Modifier0.getFretHandFinger(), '5');
    options.assert.equal(note2Modifier0.getPosition(), _src_modifier__WEBPACK_IMPORTED_MODULE_4__.Modifier.Position.BELOW);
    const note3Modifiers = notes[3].getModifiers();
    const note3Modifier0 = note3Modifiers[0];
    const note3Modifier1 = note3Modifiers[1];
    const note3Modifier2 = note3Modifiers[2];
    options.assert.equal(note3Modifier0.getCategory(), _src_frethandfinger__WEBPACK_IMPORTED_MODULE_3__.FretHandFinger.CATEGORY);
    options.assert.equal(note3Modifier0.getFretHandFinger(), '1');
    options.assert.equal(note3Modifier0.getPosition(), _src_modifier__WEBPACK_IMPORTED_MODULE_4__.Modifier.Position.LEFT);
    options.assert.equal(note3Modifier1.getCategory(), _src_frethandfinger__WEBPACK_IMPORTED_MODULE_3__.FretHandFinger.CATEGORY);
    options.assert.equal(note3Modifier1.getFretHandFinger(), '3');
    options.assert.equal(note3Modifier1.getPosition(), _src_modifier__WEBPACK_IMPORTED_MODULE_4__.Modifier.Position.LEFT);
    options.assert.equal(note3Modifier2.getCategory(), _src_frethandfinger__WEBPACK_IMPORTED_MODULE_3__.FretHandFinger.CATEGORY);
    options.assert.equal(note3Modifier2.getFretHandFinger(), '5');
    options.assert.equal(note3Modifier2.getPosition(), _src_modifier__WEBPACK_IMPORTED_MODULE_4__.Modifier.Position.LEFT);
}
function keys(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 200);
    const score = f.EasyScore();
    const system = f.System();
    const notes = score.notes('c#3/q, c##3, cb3, cbb3, cn3, c3, cbbs3, cbss3, cbs3, cdb3, cd3, c++-3, c++3, c+-3, c+3, co3, ck3', { clef: 'bass' });
    system.addStave({ voices: [f.Voice().setStrict(false).addTickables(notes)] }).addClef('bass');
    f.draw();
    options.assert.equal(notes[0].keys, 'c#/3');
    options.assert.equal(notes[1].keys, 'c##/3');
    options.assert.equal(notes[2].keys, 'cb/3');
    options.assert.equal(notes[3].keys, 'cbb/3');
    options.assert.equal(notes[4].keys, 'cn/3');
    for (let i = 5; i < notes.length; i++) {
        options.assert.equal(notes[i].keys, 'c/3');
    }
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(EasyScoreTests);



/***/ }),

/***/ "./tests/factory_tests.ts":
/*!********************************!*\
  !*** ./tests/factory_tests.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FactoryTests: () => (/* binding */ FactoryTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_factory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/factory */ "./src/factory.ts");
/* harmony import */ var _src_stavebarline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/stavebarline */ "./src/stavebarline.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Factory Tests



const FactoryTests = {
    Start() {
        QUnit.module('Factory');
        QUnit.test('Defaults', defaults);
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Draw', draw);
        run('Draw Tab (repeat barlines must be aligned)', drawTab);
    },
};
function defaults(assert) {
    // Throws RuntimeError: 'HTML DOM element not set in Factory'
    assert.throws(() => new _src_factory__WEBPACK_IMPORTED_MODULE_1__.Factory({ renderer: { elementId: '', width: 700, height: 500 } }), 'Empty string for elementId throws an exception.');
    const factory = new _src_factory__WEBPACK_IMPORTED_MODULE_1__.Factory({
        renderer: { elementId: null, width: 700, height: 500 },
    });
    // eslint-disable-next-line
    // @ts-ignore access a protected member for testing purposes.
    const options = factory.options;
    assert.equal(options.renderer.width, 700);
    assert.equal(options.renderer.height, 500);
    assert.equal(options.renderer.elementId, null);
    assert.equal(options.stave.space, 10);
}
function draw(options) {
    const f = _src_factory__WEBPACK_IMPORTED_MODULE_1__.Factory.newFromElementId(options.elementId);
    f.Stave().setClef('treble');
    f.draw();
    options.assert.expect(0);
}
function drawTab(options) {
    const factory = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 500, 400);
    const system = factory.System({ width: 500 });
    const stave = factory.Stave().setClef('treble').setKeySignature('C#').setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_2__.Barline.type.REPEAT_BEGIN);
    const voices = [factory.Voice().addTickables([factory.GhostNote({ duration: 'w' })])];
    system.addStave({ stave, voices });
    const tabStave = factory.TabStave().setClef('tab').setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_2__.Barline.type.REPEAT_BEGIN);
    const tabVoices = [factory.Voice().addTickables([factory.GhostNote({ duration: 'w' })])];
    system.addStave({ stave: tabStave, voices: tabVoices });
    factory.draw();
    options.assert.equal(stave.getModifiers()[0].getX(), tabStave.getModifiers()[0].getX());
    options.assert.expect(1);
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(FactoryTests);



/***/ }),

/***/ "./tests/font_tests.ts":
/*!*****************************!*\
  !*** ./tests/font_tests.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FontTests: () => (/* binding */ FontTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_accidental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/accidental */ "./src/accidental.ts");
/* harmony import */ var _src_bend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/bend */ "./src/bend.ts");
/* harmony import */ var _src_canvascontext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/canvascontext */ "./src/canvascontext.ts");
/* harmony import */ var _src_flow__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/flow */ "./src/flow.ts");
/* harmony import */ var _src_font__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/font */ "./src/font.ts");
/* harmony import */ var _src_pedalmarking__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/pedalmarking */ "./src/pedalmarking.ts");
/* harmony import */ var _src_stavenote__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/stavenote */ "./src/stavenote.ts");
/* harmony import */ var _src_textbracket__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/textbracket */ "./src/textbracket.ts");
/* harmony import */ var _src_textnote__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/textnote */ "./src/textnote.ts");
/* harmony import */ var _src_voice__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../src/voice */ "./src/voice.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Font Tests











const FontTests = {
    Start() {
        QUnit.module('Font');
        QUnit.test('setFont', setFont);
        QUnit.test('Parsing', fontParsing);
        QUnit.test('Sizes', fontSizes);
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Set Text Font to Georgia', setTextFontToGeorgia);
        run('Set Music Font to Petaluma', setMusicFontToPetaluma);
    },
};
/**
 * Test out the setFont method in various classes.
 */
function setFont(assert) {
    // Create a CanvasCntext and call setFont on it.
    const canvas = document.createElement('canvas');
    canvas.width = 800;
    canvas.height = 400;
    // Set the font and get the font to verify that it matches.
    // NOTE: Safari has a bug where it does not return the font-weight!
    // https://github.com/0xfe/vexflow/issues/1240#issuecomment-986504088
    const ctx = new _src_canvascontext__WEBPACK_IMPORTED_MODULE_3__.CanvasContext(canvas.getContext('2d'));
    ctx.setFont('PetalumaScript', '100px', 'normal', 'italic');
    assert.equal(ctx.font, 'italic 100px PetalumaScript');
    const voice = new _src_voice__WEBPACK_IMPORTED_MODULE_10__.Voice();
    voice.setFont('bold 32pt Arial');
    const fontInfo = voice.fontInfo;
    assert.equal(fontInfo === null || fontInfo === void 0 ? void 0 : fontInfo.size, '32pt');
    const flat = new _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental('b');
    // Add italic to the default font as defined in Element.TEXT_FONT (since Accidental does not override TEXT_FONT).
    flat.setFont(undefined, undefined, undefined, 'italic');
    assert.equal(flat.getFont(), 'italic 30pt Bravura,Roboto Slab');
    // Anything that is not set will be reset to the defaults.
    flat.setFont(undefined, undefined, 'bold', undefined);
    assert.equal(flat.getFont(), 'bold 30pt Bravura,Roboto Slab');
    flat.setFont(undefined, undefined, 'bold', 'italic');
    assert.equal(flat.getFont(), 'italic bold 30pt Bravura,Roboto Slab');
    flat.setFont(undefined, undefined, 'bold', 'oblique');
    assert.equal(flat.getFont(), 'oblique bold 30pt Bravura,Roboto Slab');
    // '' is equivalent to 'normal'. Neither will be included in the CSS font string.
    flat.setFont(undefined, undefined, 'normal', '');
    assert.equal(flat.getFont(), '30pt Bravura,Roboto Slab');
}
function fontParsing(assert) {
    const b = new _src_bend__WEBPACK_IMPORTED_MODULE_2__.Bend([
        { type: _src_bend__WEBPACK_IMPORTED_MODULE_2__.Bend.UP, text: '1/2' },
        { type: _src_bend__WEBPACK_IMPORTED_MODULE_2__.Bend.DOWN, text: '' },
    ]);
    const bFont = b.fontInfo;
    // Check the default font.
    assert.equal(bFont === null || bFont === void 0 ? void 0 : bFont.family, 'Bravura,Roboto Slab');
    assert.equal(bFont === null || bFont === void 0 ? void 0 : bFont.size, 10);
    assert.equal(bFont === null || bFont === void 0 ? void 0 : bFont.weight, _src_font__WEBPACK_IMPORTED_MODULE_5__.FontWeight.NORMAL);
    assert.equal(bFont === null || bFont === void 0 ? void 0 : bFont.style, _src_font__WEBPACK_IMPORTED_MODULE_5__.FontStyle.NORMAL);
    const f1 = 'Roboto Slab, serif';
    const t = new _src_textnote__WEBPACK_IMPORTED_MODULE_9__.TextNote({ duration: '4', font: { family: f1 } });
    assert.equal(f1, t.fontInfo.family);
    const n1 = new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({ keys: ['e/5'], duration: '4' });
    const n2 = new _src_stavenote__WEBPACK_IMPORTED_MODULE_7__.StaveNote({ keys: ['c/5'], duration: '4' });
    const tb = new _src_textbracket__WEBPACK_IMPORTED_MODULE_8__.TextBracket({ start: n1, stop: n2 });
    const f2 = tb.fontInfo;
    assert.equal(f2 === null || f2 === void 0 ? void 0 : f2.size, 15);
    assert.equal(f2 === null || f2 === void 0 ? void 0 : f2.style, _src_font__WEBPACK_IMPORTED_MODULE_5__.FontStyle.ITALIC);
    // The line-height /3 is currently ignored.
    const f3 = _src_font__WEBPACK_IMPORTED_MODULE_5__.Font.fromCSSString(`bold 1.5em/3 "Lucida Sans Typewriter", "Lucida Console", Consolas, monospace`);
    const f3SizeInPx = _src_font__WEBPACK_IMPORTED_MODULE_5__.Font.convertSizeToPixelValue(f3.size);
    assert.equal(f3SizeInPx, 24);
}
function fontSizes(assert) {
    {
        const size = '17px';
        const sizeInEm = _src_font__WEBPACK_IMPORTED_MODULE_5__.Font.convertSizeToPixelValue(size) / _src_font__WEBPACK_IMPORTED_MODULE_5__.Font.scaleToPxFrom.em;
        assert.equal(sizeInEm, 1.0625);
    }
    {
        const size = '2em';
        const sizeInPx = _src_font__WEBPACK_IMPORTED_MODULE_5__.Font.convertSizeToPixelValue(size);
        assert.equal(sizeInPx, 32);
    }
    {
        const pedal = new _src_pedalmarking__WEBPACK_IMPORTED_MODULE_6__.PedalMarking([]);
        assert.equal(pedal.getFont(), '30pt Bravura,Roboto Slab');
        assert.equal(pedal.fontSizeInPoints, 30);
        assert.equal(pedal.fontSizeInPixels, 40);
        const doubledSizePx = pedal.fontSizeInPixels * 2; // Double the font size.
        assert.equal(doubledSizePx, 80);
        const doubledSizePt = _src_font__WEBPACK_IMPORTED_MODULE_5__.Font.scaleSize(pedal.fontSizeInPoints, 2); // Double the font size.
        assert.equal(doubledSizePt, 60);
        assert.equal(_src_font__WEBPACK_IMPORTED_MODULE_5__.Font.scaleSize('1.5em', 3), '4.5em');
    }
}
function setTextFontToGeorgia(options) {
    const factory = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 400, 200);
    const stave = factory.Stave({ y: 40 });
    const score = factory.EasyScore();
    const voice1 = score.voice([
        factory.StaveNote({ keys: ['c/4', 'e/4', 'a/4'], stemDirection: -1, duration: 'h' }),
        factory.StaveNote({ keys: ['d/4', 'f/4'], stemDirection: -1, duration: 'q' }),
        factory.StaveNote({ keys: ['c/4', 'f/4', 'a/4'], stemDirection: -1, duration: 'q' }),
    ]);
    const georgiaFont = {
        family: 'Georgia, Courier New, serif',
        size: 14,
        weight: 'bold',
        style: 'italic',
    };
    const voice2 = score.voice([
        factory
            .TextNote({ text: 'Here are some fun lyrics...', duration: 'w' })
            .setJustification(_src_textnote__WEBPACK_IMPORTED_MODULE_9__.TextNote.Justification.LEFT)
            .setFont(georgiaFont),
    ]);
    const formatter = factory.Formatter();
    formatter.joinVoices([voice1, voice2]).formatToStave([voice1, voice2], stave);
    factory.draw();
    options.assert.ok(true);
}
function setMusicFontToPetaluma(options) {
    _src_flow__WEBPACK_IMPORTED_MODULE_4__.Flow.setMusicFont('Petaluma');
    const factory = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 400, 200);
    const stave = factory.Stave({ y: 40 });
    const score = factory.EasyScore();
    const voice = score.voice([
        factory.StaveNote({ keys: ['c/4', 'e/4', 'a/4'], stemDirection: -1, duration: 'h' }),
        factory.StaveNote({ keys: ['d/4', 'f/4'], stemDirection: -1, duration: 'q' }),
        factory.StaveNote({ keys: ['c/4', 'f/4', 'a/4'], stemDirection: -1, duration: 'q' }),
    ]);
    const formatter = factory.Formatter();
    formatter.joinVoices([voice]).formatToStave([voice], stave);
    factory.draw();
    options.assert.ok(true);
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(FontTests);



/***/ }),

/***/ "./tests/formatter_tests.ts":
/*!**********************************!*\
  !*** ./tests/formatter_tests.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FormatterTests: () => (/* binding */ FormatterTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_accidental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/accidental */ "./src/accidental.ts");
/* harmony import */ var _src_annotation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/annotation */ "./src/annotation.ts");
/* harmony import */ var _src_articulation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/articulation */ "./src/articulation.ts");
/* harmony import */ var _src_beam__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/beam */ "./src/beam.ts");
/* harmony import */ var _src_bend__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/bend */ "./src/bend.ts");
/* harmony import */ var _src_dot__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/dot */ "./src/dot.ts");
/* harmony import */ var _src_element__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/element */ "./src/element.ts");
/* harmony import */ var _src_flow__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/flow */ "./src/flow.ts");
/* harmony import */ var _src_font__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/font */ "./src/font.ts");
/* harmony import */ var _src_formatter__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../src/formatter */ "./src/formatter.ts");
/* harmony import */ var _src_frethandfinger__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../src/frethandfinger */ "./src/frethandfinger.ts");
/* harmony import */ var _src_metrics__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../src/metrics */ "./src/metrics.ts");
/* harmony import */ var _src_modifier__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../src/modifier */ "./src/modifier.ts");
/* harmony import */ var _src_note__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../src/note */ "./src/note.ts");
/* harmony import */ var _src_registry__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../src/registry */ "./src/registry.ts");
/* harmony import */ var _src_stave__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../src/stave */ "./src/stave.ts");
/* harmony import */ var _src_staveconnector__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../src/staveconnector */ "./src/staveconnector.ts");
/* harmony import */ var _src_stavenote__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../src/stavenote */ "./src/stavenote.ts");
/* harmony import */ var _src_stem__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../src/stem */ "./src/stem.ts");
/* harmony import */ var _src_stringnumber__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../src/stringnumber */ "./src/stringnumber.ts");
/* harmony import */ var _src_tuplet__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../src/tuplet */ "./src/tuplet.ts");
/* harmony import */ var _src_voice__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../src/voice */ "./src/voice.ts");
/* harmony import */ var _mocks__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./mocks */ "./tests/mocks.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Formatter Tests
























const FormatterTests = {
    Start() {
        QUnit.module('Formatter');
        QUnit.test('TickContext Building', buildTickContexts);
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Penultimate Note Padding', penultimateNote);
        run('Whitespace and justify', rightJustify);
        run('Notehead padding', noteHeadPadding);
        run('Justification and alignment with accidentals', accidentalJustification);
        run('Long measure taking full space', longMeasureProblems);
        run('Vertical alignment - few unaligned beats', unalignedNoteDurations1);
        run('Vertical alignment - many unaligned beats', unalignedNoteDurations2, { globalSoftmax: false });
        run('Vertical alignment - many unaligned beats (global softmax)', unalignedNoteDurations2, { globalSoftmax: true });
        run('Vertical alignment - many mixed elements', alignedMixedElements, { globalSoftmax: true });
        run('StaveNote - Justification', justifyStaveNotes);
        run('Notes with Tab', notesWithTab);
        run('Multiple Staves - Justified', multiStaves, { debug: true });
        run('Softmax', softMax);
        run('Mixtime', mixTime);
        run('Tight', tightNotes1);
        run('Tight 2', tightNotes2);
        run('Annotations', annotations);
        run('Proportional Formatting - No Tuning', proportional, { debug: true, iterations: 0 });
        run('Proportional Formatting - No Justification', proportional, { justify: false, debug: true, iterations: 0 });
        run('Proportional Formatting (20 iterations)', proportional, { debug: true, iterations: 20, alpha: 0.5 });
    },
};
/** Calculate the glyph's width in the current music font. */
function getGlyphWidth(glyph) {
    const el = new _src_element__WEBPACK_IMPORTED_MODULE_7__.Element();
    el.setText(glyph);
    return el.getWidth();
}
function buildTickContexts(assert) {
    function createTickable(beat) {
        return new _mocks__WEBPACK_IMPORTED_MODULE_23__.MockTickable().setTicks(beat);
    }
    const BEAT = (1 * _src_flow__WEBPACK_IMPORTED_MODULE_8__.Flow.RESOLUTION) / 4;
    const tickables1 = [
        createTickable(BEAT).setWidth(10),
        createTickable(BEAT * 2).setWidth(20),
        createTickable(BEAT).setWidth(30),
    ];
    const tickables2 = [
        createTickable(BEAT * 2).setWidth(10),
        createTickable(BEAT).setWidth(20),
        createTickable(BEAT).setWidth(30),
    ];
    const voice1 = new _src_voice__WEBPACK_IMPORTED_MODULE_22__.Voice(_src_flow__WEBPACK_IMPORTED_MODULE_8__.Flow.TIME4_4);
    const voice2 = new _src_voice__WEBPACK_IMPORTED_MODULE_22__.Voice(_src_flow__WEBPACK_IMPORTED_MODULE_8__.Flow.TIME4_4);
    voice1.addTickables(tickables1);
    voice2.addTickables(tickables2);
    const formatter = new _src_formatter__WEBPACK_IMPORTED_MODULE_10__.Formatter();
    const tContexts = formatter.createTickContexts([voice1, voice2]);
    assert.equal(tContexts.list.length, 4, 'Voices should have four tick contexts');
    assert.throws(() => formatter.getMinTotalWidth(), /NoMinTotalWidth/, 'Expected to throw exception');
    assert.ok(formatter.preCalculateMinTotalWidth([voice1, voice2]), 'Successfully runs preCalculateMinTotalWidth');
    assert.equal(formatter.getMinTotalWidth(), 88, 'Get minimum total width without passing voices');
    formatter.preFormat();
    assert.equal(formatter.getMinTotalWidth(), 88, 'Minimum total width');
    assert.equal(tickables1[0].getX(), tickables2[0].getX(), 'First notes of both voices have the same X');
    assert.equal(tickables1[2].getX(), tickables2[2].getX(), 'Last notes of both voices have the same X');
    assert.ok(tickables1[1].getX() < tickables2[1].getX(), 'Second note of voice 2 is to the right of the second note of voice 1');
}
function rightJustify(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 1200, 150);
    const getTickables = (time, n, duration, duration2) => {
        const tickar = [];
        let i = 0;
        for (i = 0; i < n; ++i) {
            const dd = i === n - 1 ? duration2 : duration;
            tickar.push(new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['f/4'], duration: dd }));
        }
        return new _src_voice__WEBPACK_IMPORTED_MODULE_22__.Voice(time).addTickables(tickar);
    };
    const renderTest = (time, n, duration, duration2, x, width) => {
        const formatter = f.Formatter();
        const stave = f.Stave({ x, y: 20, width });
        // stave.addClef('treble').addTimeSignature('4/4');
        const voice = getTickables(time, n, duration, duration2);
        formatter.joinVoices([voice]).formatToStave([voice], stave);
        stave.draw();
        voice.draw(f.getContext(), stave);
    };
    renderTest({ numBeats: 4, beatValue: 4, resolution: 4 * 4096 }, 3, '4', '2', 10, 300);
    renderTest({ numBeats: 4, beatValue: 4, resolution: 4 * 4096 }, 1, 'w', 'w', 310, 300);
    renderTest({ numBeats: 3, beatValue: 4, resolution: 4 * 4096 }, 3, '4', '4', 610, 300);
    renderTest({ numBeats: 3, beatValue: 4, resolution: 4 * 4096 }, 6, '8', '8', 910, 300);
    options.assert.ok(true);
}
function penultimateNote(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 500, 550);
    const score = f.EasyScore();
    const staffWidth = 310;
    let system = undefined;
    let voices = [];
    let notes = [];
    let note = undefined;
    let stave = undefined;
    let y = 10;
    const draw = (softmax) => {
        system = f.System({
            width: staffWidth,
            y,
            formatOptions: { alignRests: true },
            details: { softmaxFactor: softmax },
        });
        notes = [];
        voices = [];
        note = score.notes('C4/8/r', { clef: 'bass' })[0];
        notes.push(note);
        note = score.notes('A3/8', { stem: 'up', clef: 'bass' })[0];
        notes.push(note);
        note = score.notes('C4/4', { stem: 'up', clef: 'bass' })[0];
        notes.push(note);
        voices.push(score.voice(notes).setMode(2));
        notes = [];
        note = score.notes('( F3 A3 )/4', { stem: 'down', clef: 'bass' })[0];
        notes.push(note);
        note = score.notes('B4/4/r', {})[0];
        notes.push(note);
        voices.push(score.voice(notes).setMode(2));
        notes = [];
        stave = system.addStave({ voices: voices });
        stave.addClef('bass');
        stave.addTimeSignature('2/4');
        voices = [];
        f.draw();
        f.getContext().fillText(`softmax: ${softmax.toString()}`, staffWidth + 20, y + 50);
        y += 100;
    };
    draw(15);
    draw(10);
    draw(5);
    draw(2);
    draw(1);
    options.assert.ok(true);
}
function noteHeadPadding(options) {
    const registry = new _src_registry__WEBPACK_IMPORTED_MODULE_15__.Registry();
    _src_registry__WEBPACK_IMPORTED_MODULE_15__.Registry.enableDefaultRegistry(registry);
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 300);
    const score = f.EasyScore();
    score.set({ time: '9/8' });
    const notes1 = score.notes('(d5 f5)/8,(c5 e5)/8,(d5 f5)/8,(c5 e5)/2.');
    const beams = [new _src_beam__WEBPACK_IMPORTED_MODULE_4__.Beam(notes1.slice(0, 3), true)];
    const voice1 = new _src_voice__WEBPACK_IMPORTED_MODULE_22__.Voice().setMode(_src_voice__WEBPACK_IMPORTED_MODULE_22__.Voice.Mode.SOFT);
    const notes2 = score.notes('(g4 an4)/2.,(g4 a4)/4.', { clef: 'treble' });
    const voice2 = new _src_voice__WEBPACK_IMPORTED_MODULE_22__.Voice().setMode(_src_voice__WEBPACK_IMPORTED_MODULE_22__.Voice.Mode.SOFT);
    voice2.addTickables(notes2);
    voice1.addTickables(notes1);
    const formatter = f.Formatter().joinVoices([voice1]).joinVoices([voice2]);
    const width = formatter.preCalculateMinTotalWidth([voice1, voice2]);
    formatter.format([voice1, voice2], width);
    const staveWidth = width + _src_stave__WEBPACK_IMPORTED_MODULE_16__.Stave.defaultPadding;
    const stave1 = f.Stave({ y: 50, width: staveWidth });
    const stave2 = f.Stave({ y: 150, width: staveWidth });
    stave1.draw();
    stave2.draw();
    voice1.draw(f.getContext(), stave1);
    voice2.draw(f.getContext(), stave2);
    beams.forEach((b) => b.setContext(f.getContext()).draw());
    options.assert.ok(true);
}
function longMeasureProblems(options) {
    const registry = new _src_registry__WEBPACK_IMPORTED_MODULE_15__.Registry();
    _src_registry__WEBPACK_IMPORTED_MODULE_15__.Registry.enableDefaultRegistry(registry);
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 1500, 300);
    const score = f.EasyScore();
    score.set({ time: '4/4' });
    const notes1 = score.notes('b4/4,b4/8,b4/8,b4/4,b4/4,b4/2,b4/2,b4/4,b4/8,b4/8,b4/4,b4/4,b4/2,b4/2,b4/4,b4/8,b4/8,b4/4,b4/4,b4/2,b4/2,b4/4,b4/2,b4/8,b4/8');
    const voice1 = new _src_voice__WEBPACK_IMPORTED_MODULE_22__.Voice().setMode(_src_voice__WEBPACK_IMPORTED_MODULE_22__.Voice.Mode.SOFT);
    const notes2 = score.notes('d3/4,(ab3 f4)/2,d3/4,ab3/4,d3/2,ab3/4,d3/4,ab3/2,d3/4,ab3/4,d3/2,ab3/4,d3/4,ab3/2,d3/4,ab3/4,d3/2,ab3/4,d4/4,d4/2,d4/4', { clef: 'bass' });
    const voice2 = new _src_voice__WEBPACK_IMPORTED_MODULE_22__.Voice().setMode(_src_voice__WEBPACK_IMPORTED_MODULE_22__.Voice.Mode.SOFT);
    voice2.addTickables(notes2);
    voice1.addTickables(notes1);
    const formatter = f.Formatter().joinVoices([voice1]).joinVoices([voice2]);
    const width = formatter.preCalculateMinTotalWidth([voice1, voice2]);
    formatter.format([voice1, voice2], width);
    const stave1 = f.Stave({ y: 50, width: width + _src_stave__WEBPACK_IMPORTED_MODULE_16__.Stave.defaultPadding });
    const stave2 = f.Stave({ y: 200, width: width + _src_stave__WEBPACK_IMPORTED_MODULE_16__.Stave.defaultPadding });
    stave1.draw();
    stave2.draw();
    voice1.draw(f.getContext(), stave1);
    voice2.draw(f.getContext(), stave2);
    options.assert.ok(true);
}
function accidentalJustification(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 300);
    const score = f.EasyScore();
    const notes11 = score.notes('a4/2, a4/4, a4/8, ab4/16, an4/16');
    const voice11 = score.voice(notes11, { time: '4/4' });
    const notes21 = score.notes('c4/2, d4/8, d4/8, e4/8, e4/8');
    const voice21 = score.voice(notes21, { time: '4/4' });
    let beams = _src_beam__WEBPACK_IMPORTED_MODULE_4__.Beam.generateBeams(notes11.slice(2));
    beams = beams.concat(beams, _src_beam__WEBPACK_IMPORTED_MODULE_4__.Beam.generateBeams(notes21.slice(1, 3)));
    beams = beams.concat(_src_beam__WEBPACK_IMPORTED_MODULE_4__.Beam.generateBeams(notes21.slice(3)));
    const formatter = f.Formatter({}).joinVoices([voice11]).joinVoices([voice21]);
    const width = formatter.preCalculateMinTotalWidth([voice11, voice21]);
    const stave11 = f.Stave({ y: 20, width: width + _src_stave__WEBPACK_IMPORTED_MODULE_16__.Stave.defaultPadding });
    const stave21 = f.Stave({ y: 130, width: width + _src_stave__WEBPACK_IMPORTED_MODULE_16__.Stave.defaultPadding });
    formatter.format([voice11, voice21], width);
    const ctx = f.getContext();
    stave11.setContext(ctx).draw();
    stave21.setContext(ctx).draw();
    voice11.draw(ctx, stave11);
    voice21.draw(ctx, stave21);
    beams.forEach((b) => b.setContext(ctx).draw());
    options.assert.ok(true);
}
function unalignedNoteDurations1(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 250);
    const score = f.EasyScore();
    const notes11 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['a/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['b/4'], duration: '4' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['b/4'], duration: '8' }),
    ];
    const notes21 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['a/4'], duration: '16' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['b/4.'], duration: '4' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['a/4'], duration: '8d' }),
    ];
    _src_dot__WEBPACK_IMPORTED_MODULE_6__.Dot.buildAndAttach([notes21[2]], { all: true });
    const ctx = f.getContext();
    const voice11 = score.voice(notes11, { time: '2/4' }).setMode(_src_voice__WEBPACK_IMPORTED_MODULE_22__.Voice.Mode.SOFT);
    const voice21 = score.voice(notes21, { time: '2/4' }).setMode(_src_voice__WEBPACK_IMPORTED_MODULE_22__.Voice.Mode.SOFT);
    const beams21 = _src_beam__WEBPACK_IMPORTED_MODULE_4__.Beam.generateBeams(notes21);
    const beams11 = _src_beam__WEBPACK_IMPORTED_MODULE_4__.Beam.generateBeams(notes11);
    const formatter = new _src_formatter__WEBPACK_IMPORTED_MODULE_10__.Formatter();
    formatter.joinVoices([voice11]);
    formatter.joinVoices([voice21]);
    const width = formatter.preCalculateMinTotalWidth([voice11, voice21]);
    const stave11 = f.Stave({ y: 20, width: width + _src_stave__WEBPACK_IMPORTED_MODULE_16__.Stave.defaultPadding });
    const stave21 = f.Stave({ y: 130, width: width + _src_stave__WEBPACK_IMPORTED_MODULE_16__.Stave.defaultPadding });
    formatter.format([voice11, voice21], width);
    stave11.setContext(ctx).draw();
    stave21.setContext(ctx).draw();
    voice11.draw(ctx, stave11);
    voice21.draw(ctx, stave21);
    beams21.forEach((b) => b.setContext(ctx).draw());
    beams11.forEach((b) => b.setContext(ctx).draw());
    options.assert.ok(voice11.getTickables()[1].getX() > voice21.getTickables()[1].getX());
}
function unalignedNoteDurations2(options) {
    const notes1 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['b/4'], duration: '8r' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['g/4'], duration: '16' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['c/5'], duration: '16' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['e/5'], duration: '16' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['g/4'], duration: '16' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['c/5'], duration: '16' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['e/5'], duration: '16' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['b/4'], duration: '8r' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['g/4'], duration: '16' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['c/5'], duration: '16' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['e/5'], duration: '16' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['g/4'], duration: '16' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['c/5'], duration: '16' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['e/5'], duration: '16' }),
    ];
    const notes2 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['a/4'], duration: '16r' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['e/4.'], duration: '8d' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['e/4'], duration: '4' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['a/4'], duration: '16r' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['e/4.'], duration: '8d' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['e/4'], duration: '4' }),
    ];
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 750, 280);
    const context = f.getContext();
    const voice1 = new _src_voice__WEBPACK_IMPORTED_MODULE_22__.Voice({ numBeats: 4, beatValue: 4 });
    voice1.addTickables(notes1);
    const voice2 = new _src_voice__WEBPACK_IMPORTED_MODULE_22__.Voice({ numBeats: 4, beatValue: 4 });
    voice2.addTickables(notes2);
    const formatter = new _src_formatter__WEBPACK_IMPORTED_MODULE_10__.Formatter({ globalSoftmax: options.params.globalSoftmax });
    formatter.joinVoices([voice1]);
    formatter.joinVoices([voice2]);
    const width = formatter.preCalculateMinTotalWidth([voice1, voice2]);
    formatter.format([voice1, voice2], width);
    const stave1 = new _src_stave__WEBPACK_IMPORTED_MODULE_16__.Stave(10, 40, width + _src_stave__WEBPACK_IMPORTED_MODULE_16__.Stave.defaultPadding);
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_16__.Stave(10, 100, width + _src_stave__WEBPACK_IMPORTED_MODULE_16__.Stave.defaultPadding);
    stave1.setContext(context).draw();
    stave2.setContext(context).draw();
    voice1.draw(context, stave1);
    voice2.draw(context, stave2);
    options.assert.ok(voice1.getTickables()[1].getX() > voice2.getTickables()[1].getX());
}
function alignedMixedElements(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 800, 500);
    const context = f.getContext();
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_16__.Stave(10, 200, 400);
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_16__.Stave(410, 200, 400);
    const notes = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['c/5'], duration: '8' })
            .addModifier(new _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental('##'), 0)
            .addModifier(new _src_frethandfinger__WEBPACK_IMPORTED_MODULE_11__.FretHandFinger('4').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_13__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_stringnumber__WEBPACK_IMPORTED_MODULE_20__.StringNumber('3').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_13__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_3__.Articulation('a.').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_13__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_3__.Articulation('a>').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_13__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_3__.Articulation('a^').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_13__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_3__.Articulation('am').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_13__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_3__.Articulation('a@u').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_13__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_2__.Annotation('yyyy').setVerticalJustification(_src_annotation__WEBPACK_IMPORTED_MODULE_2__.AnnotationVerticalJustify.BOTTOM), 0)
            .addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_2__.Annotation('xxxx').setVerticalJustification(_src_annotation__WEBPACK_IMPORTED_MODULE_2__.AnnotationVerticalJustify.BOTTOM).setFont('sans-serif', 20), 0)
            .addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_2__.Annotation('ttt').setVerticalJustification(_src_annotation__WEBPACK_IMPORTED_MODULE_2__.AnnotationVerticalJustify.BOTTOM).setFont('sans-serif', 20), 0),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['c/5'], duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_19__.Stem.DOWN })
            .addModifier(new _src_stringnumber__WEBPACK_IMPORTED_MODULE_20__.StringNumber('3').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_13__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_3__.Articulation('a.').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_13__.ModifierPosition.BELOW), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_3__.Articulation('a>').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_13__.ModifierPosition.BELOW), 0),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['c/5'], duration: '8' }),
    ];
    const notes2 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['c/5'], duration: '8' })
            .addModifier(new _src_stringnumber__WEBPACK_IMPORTED_MODULE_20__.StringNumber('3').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_13__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_3__.Articulation('a.').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_13__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_2__.Annotation('yyyy').setVerticalJustification(_src_annotation__WEBPACK_IMPORTED_MODULE_2__.AnnotationVerticalJustify.TOP), 0),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['c/5'], duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_19__.Stem.DOWN })
            .addModifier(new _src_frethandfinger__WEBPACK_IMPORTED_MODULE_11__.FretHandFinger('4').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_13__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_stringnumber__WEBPACK_IMPORTED_MODULE_20__.StringNumber('3').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_13__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_3__.Articulation('a.').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_13__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_3__.Articulation('a>').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_13__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_3__.Articulation('a^').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_13__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_3__.Articulation('am').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_13__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_3__.Articulation('a@u').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_13__.ModifierPosition.ABOVE), 0)
            .addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_2__.Annotation('yyyy').setVerticalJustification(_src_annotation__WEBPACK_IMPORTED_MODULE_2__.AnnotationVerticalJustify.TOP), 0)
            .addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_2__.Annotation('xxxx').setVerticalJustification(_src_annotation__WEBPACK_IMPORTED_MODULE_2__.AnnotationVerticalJustify.TOP).setFont('sans-serif', 20), 0)
            .addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_2__.Annotation('ttt').setVerticalJustification(_src_annotation__WEBPACK_IMPORTED_MODULE_2__.AnnotationVerticalJustify.TOP).setFont('sans-serif', 20), 0),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['c/5'], duration: '8' }),
    ];
    const tuplet = new _src_tuplet__WEBPACK_IMPORTED_MODULE_21__.Tuplet(notes).setTupletLocation(-1);
    const tuplet2 = new _src_tuplet__WEBPACK_IMPORTED_MODULE_21__.Tuplet(notes2).setTupletLocation(1);
    _src_formatter__WEBPACK_IMPORTED_MODULE_10__.Formatter.FormatAndDraw(context, stave, notes);
    _src_formatter__WEBPACK_IMPORTED_MODULE_10__.Formatter.FormatAndDraw(context, stave2, notes2);
    stave.setContext(context).draw();
    stave2.setContext(context).draw();
    tuplet.setContext(context).draw();
    tuplet2.setContext(context).draw();
    options.assert.ok(true);
}
function justifyStaveNotes(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 520, 280);
    const ctx = f.getContext();
    const score = f.EasyScore();
    let y = 30;
    function justifyToWidth(width) {
        f.Stave({ y: y }).addClef('treble');
        const voices = [
            score.voice(score.notes('(cbb4 en4 a4)/2, (d4 e4 f4)/8, (d4 f4 a4)/8, (cn4 f#4 a4)/4', { stem: 'down' })),
            score.voice(score.notes('(bb4 e#5 a5)/4, (d5 e5 f5)/2, (c##5 fb5 a5)/4', { stem: 'up' })),
        ];
        f.Formatter()
            .joinVoices(voices)
            .format(voices, width - (_src_stave__WEBPACK_IMPORTED_MODULE_16__.Stave.defaultPadding + getGlyphWidth('\uE050' /*gClef*/)));
        // Show the the width of notes via a horizontal line with red, green, yellow, blue, gray indicators.
        voices[0].getTickables().forEach((note) => _src_note__WEBPACK_IMPORTED_MODULE_14__.Note.plotMetrics(ctx, note, y + 140)); // Bottom line.
        voices[1].getTickables().forEach((note) => _src_note__WEBPACK_IMPORTED_MODULE_14__.Note.plotMetrics(ctx, note, y - 20)); // Top Line
        y += 210;
    }
    justifyToWidth(520);
    f.draw();
    options.assert.ok(true);
}
function notesWithTab(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 420, 580);
    const score = f.EasyScore();
    let y = 10;
    function justifyToWidth(width) {
        const stave = f.Stave({ y: y }).addClef('treble');
        const voice = score.voice(score.notes('d#4/2, (c4 d4)/8, d4/8, (c#4 e4 a4)/4', { stem: 'up' }));
        y += 100;
        f.TabStave({ y: y }).addTabGlyph().setNoteStartX(stave.getNoteStartX());
        const tabVoice = score.voice([
            f
                .TabNote({ positions: [{ str: 3, fret: 6 }], duration: '2' })
                .addModifier(new _src_bend__WEBPACK_IMPORTED_MODULE_5__.Bend([{ type: _src_bend__WEBPACK_IMPORTED_MODULE_5__.Bend.UP, text: 'Full' }]), 0),
            f
                .TabNote({
                positions: [
                    { str: 2, fret: 3 },
                    { str: 3, fret: 5 },
                ],
                duration: '8',
            })
                .addModifier(new _src_bend__WEBPACK_IMPORTED_MODULE_5__.Bend([{ type: _src_bend__WEBPACK_IMPORTED_MODULE_5__.Bend.UP, text: 'Unison' }]), 1),
            f.TabNote({ positions: [{ str: 3, fret: 7 }], duration: '8' }),
            f.TabNote({
                positions: [
                    { str: 3, fret: 6 },
                    { str: 4, fret: 7 },
                    { str: 2, fret: 5 },
                ],
                duration: '4',
            }),
        ]);
        f.Formatter().joinVoices([voice]).joinVoices([tabVoice]).format([voice, tabVoice], width);
        y += 150;
    }
    justifyToWidth(0);
    justifyToWidth(300);
    f.draw();
    options.assert.ok(true);
}
function multiStaves(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 400);
    const ctx = f.getContext();
    const score = f.EasyScore();
    //////////////////////////////////////////////////////////////////////////////////////////////////
    // Draw 3 Staves (one measure each).
    const notes11 = score.notes('f4/4, d4/8, g4/4, eb4/8');
    const notes21 = score.notes('d4/8, d4, d4, d4, e4, eb4');
    const notes31 = score.notes('a5/8, a5, a5, a5, a5, a5', { stem: 'down' });
    let voices = [
        score.voice(notes11, { time: '6/8' }),
        score.voice(notes21, { time: '6/8' }),
        score.voice(notes31, { time: '6/8' }),
    ];
    let formatter = f.Formatter();
    voices.forEach((v) => formatter.joinVoices([v]));
    let width = formatter.preCalculateMinTotalWidth(voices);
    formatter.format(voices, width);
    let beams = [
        new _src_beam__WEBPACK_IMPORTED_MODULE_4__.Beam(notes21.slice(0, 3), true),
        new _src_beam__WEBPACK_IMPORTED_MODULE_4__.Beam(notes21.slice(3, 6), true),
        new _src_beam__WEBPACK_IMPORTED_MODULE_4__.Beam(notes31.slice(0, 3), true),
        new _src_beam__WEBPACK_IMPORTED_MODULE_4__.Beam(notes31.slice(3, 6), true),
    ];
    const staveYs = [20, 130, 250];
    let staveWidth = width + getGlyphWidth('\uE050' /*gClef*/) + getGlyphWidth('\uE088' /*timeSig8*/) + _src_stave__WEBPACK_IMPORTED_MODULE_16__.Stave.defaultPadding;
    let staves = [
        f.Stave({ y: staveYs[0], width: staveWidth }).addClef('treble').addTimeSignature('6/8'),
        f.Stave({ y: staveYs[1], width: staveWidth }).addClef('treble').addTimeSignature('6/8'),
        f.Stave({ y: staveYs[2], width: staveWidth }).addClef('bass').addTimeSignature('6/8'),
    ];
    f.StaveConnector({
        topStave: staves[1],
        bottomStave: staves[2],
        type: 'brace',
    });
    for (let i = 0; i < staves.length; ++i) {
        staves[i].setContext(ctx).draw();
        voices[i].draw(ctx, staves[i]);
    }
    beams.forEach((beam) => beam.setContext(ctx).draw());
    //////////////////////////////////////////////////////////////////////////////////////////////////
    // Draw 3 more staves (one measure each).
    // These are adjacent to the first set of staves, representing the second measure of each stave.
    const notes12 = score.notes('ab4/4, bb4/8, (cb5 eb5)/4[stem="down"], d5/8[stem="down"]');
    const notes22 = score.notes('(eb4 ab4)/4., (c4 eb4 ab4)/4, db5/8', { stem: 'up' });
    const notes32 = score.notes('a5/8, a5, a5, a5, a5, a5', { stem: 'down' });
    voices = [
        score.voice(notes12, { time: '6/8' }),
        score.voice(notes22, { time: '6/8' }),
        score.voice(notes32, { time: '6/8' }),
    ];
    formatter = f.Formatter();
    voices.forEach((v) => formatter.joinVoices([v]));
    width = formatter.preCalculateMinTotalWidth(voices);
    const staveX = staves[0].getX() + staves[0].getWidth();
    staveWidth = width + _src_stave__WEBPACK_IMPORTED_MODULE_16__.Stave.defaultPadding;
    staves = [
        f.Stave({ x: staveX, y: staveYs[0], width: staveWidth }),
        f.Stave({ x: staveX, y: staveYs[1], width: staveWidth }),
        f.Stave({ x: staveX, y: staveYs[2], width: staveWidth }),
    ];
    formatter.format(voices, width);
    beams = [
        // Add beams to each group of 3 notes.
        new _src_beam__WEBPACK_IMPORTED_MODULE_4__.Beam(notes32.slice(0, 3), true),
        new _src_beam__WEBPACK_IMPORTED_MODULE_4__.Beam(notes32.slice(3, 6), true),
    ];
    for (let i = 0; i < staves.length; ++i) {
        staves[i].setContext(ctx).draw();
        voices[i].draw(ctx, staves[i]);
        voices[i].getTickables().forEach((note) => _src_note__WEBPACK_IMPORTED_MODULE_14__.Note.plotMetrics(ctx, note, staveYs[i] - 20));
    }
    beams.forEach((beam) => beam.setContext(ctx).draw());
    options.assert.ok(true);
}
function proportional(options) {
    const debug = options.params.debug;
    _src_registry__WEBPACK_IMPORTED_MODULE_15__.Registry.enableDefaultRegistry(new _src_registry__WEBPACK_IMPORTED_MODULE_15__.Registry());
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 775, 750);
    const system = f.System({
        x: 50,
        autoWidth: true,
        debugFormatter: debug,
        noJustification: !(options.params.justify === undefined && true),
        formatIterations: options.params.iterations,
        details: { alpha: options.params.alpha },
    });
    const score = f.EasyScore();
    const voices = [
        score.notes('c5/8, c5'),
        score.tuplet(score.notes('a4/8, a4, a4'), { notesOccupied: 2 }),
        score.notes('c5/16, c5, c5, c5'),
        score.tuplet(score.notes('a4/16, a4, a4, a4, a4'), { notesOccupied: 4 }),
        score.tuplet(score.notes('a4/32, a4, a4, a4, a4, a4, a4'), { notesOccupied: 8 }),
    ];
    const createVoice = (notes) => score.voice(notes, { time: '1/4' });
    const createStave = (voice) => system
        .addStave({ voices: [voice], debugNoteMetrics: debug })
        .addClef('treble')
        .addTimeSignature('1/4');
    voices.map(createVoice).forEach(createStave);
    system.addConnector().setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_17__.StaveConnector.type.BRACKET);
    f.draw();
    // Debugging: Show how many elements of each type we have added.
    // const typeMap = Registry.getDefaultRegistry().index.type;
    // const table = Object.keys(typeMap).map((typeName) => typeName + ': ' + Object.keys(typeMap[typeName]).length);
    // console.log(table);
    _src_registry__WEBPACK_IMPORTED_MODULE_15__.Registry.disableDefaultRegistry();
    options.assert.ok(true);
}
function softMax(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 550, 500);
    const textX = 450 / 0.8;
    f.getContext().scale(0.8, 0.8);
    function draw(y, factor) {
        const score = f.EasyScore();
        const system = f.System({
            x: 100,
            y,
            details: { softmaxFactor: factor },
            autoWidth: true,
        });
        system
            .addStave({
            voices: [
                score.voice(score
                    .notes('C#5/h, a4/q')
                    .concat(score.beam(score.notes('Abb4/8, A4/8')))
                    .concat(score.beam(score.notes('A4/16, A#4, A4, Ab4/32, A4'))), { time: '5/4' }),
            ],
        })
            .addClef('treble')
            .addTimeSignature('5/4');
        f.draw();
        f.getContext().fillText(`softmax: ${factor.toString()}`, textX, y + 50);
        options.assert.ok(true);
    }
    draw(50, 1);
    draw(150, 2);
    draw(250, 5);
    draw(350, 10);
    draw(450, 15);
}
function mixTime(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 400 + _src_stave__WEBPACK_IMPORTED_MODULE_16__.Stave.defaultPadding, 250);
    f.getContext().scale(0.8, 0.8);
    const score = f.EasyScore();
    const system = f.System({
        details: {},
        autoWidth: true,
        debugFormatter: true,
    });
    system
        .addStave({
        voices: [score.voice(score.notes('C#5/q, B4').concat(score.beam(score.notes('A4/8, E4, C4, D4'))))],
    })
        .addClef('treble')
        .addTimeSignature('4/4');
    system
        .addStave({
        voices: [score.voice(score.notes('C#5/q, B4, B4').concat(score.tuplet(score.beam(score.notes('A4/8, E4, C4')))))],
    })
        .addClef('treble')
        .addTimeSignature('4/4');
    f.draw();
    options.assert.ok(true);
}
function tightNotes1(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 440, 250);
    f.getContext().scale(0.8, 0.8);
    const score = f.EasyScore();
    const system = f.System({
        autoWidth: true,
        debugFormatter: true,
        details: { maxIterations: 10 },
    });
    system
        .addStave({
        voices: [
            score.voice(score.beam(score.notes('B4/16, B4, B4, B4, B4, B4, B4, B4')).concat(score.notes('B4/q, B4'))),
        ],
    })
        .addClef('treble')
        .addTimeSignature('4/4');
    system
        .addStave({
        voices: [
            score.voice(score.notes('B4/q, B4').concat(score.beam(score.notes('B4/16, B4, B4, B4, B4, B4, B4, B4')))),
        ],
    })
        .addClef('treble')
        .addTimeSignature('4/4');
    f.draw();
    options.assert.ok(true);
}
function tightNotes2(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 440, 250);
    f.getContext().scale(0.8, 0.8);
    const score = f.EasyScore();
    const system = f.System({
        autoWidth: true,
        debugFormatter: true,
    });
    system
        .addStave({
        voices: [
            score.voice(score.beam(score.notes('B4/16, B4, B4, B4, B4, B4, B4, B4')).concat(score.notes('B4/q, B4'))),
        ],
    })
        .addClef('treble')
        .addTimeSignature('4/4');
    system
        .addStave({
        voices: [score.voice(score.notes('B4/w'))],
    })
        .addClef('treble')
        .addTimeSignature('4/4');
    f.draw();
    options.assert.ok(true);
}
function annotations(options) {
    const pageWidth = 916;
    const pageHeight = 600;
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, pageWidth, pageHeight);
    const context = f.getContext();
    const lyrics1 = ['ipso', 'ipso-', 'ipso', 'ipso', 'ipsoz', 'ipso-', 'ipso', 'ipso', 'ipso', 'ip', 'ipso'];
    const lyrics2 = ['ipso', 'ipso-', 'ipsoz', 'ipso', 'ipso', 'ipso-', 'ipso', 'ipso', 'ipso', 'ip', 'ipso'];
    const smar = [
        {
            sm: 5,
            width: 550,
            lyrics: lyrics1,
            title: '550px,softMax:5',
        },
        {
            sm: 5,
            width: 550,
            lyrics: lyrics2,
            title: '550px,softmax:5,different word order',
        },
        {
            sm: 10,
            width: 550,
            lyrics: lyrics2,
            title: '550px,softmax:10',
        },
        {
            sm: 15,
            width: 550,
            lyrics: lyrics2,
            title: '550px,softmax:15',
        },
    ];
    const rowSize = 140;
    const beats = 12;
    const beatsPer = 8;
    const beamGroup = 3;
    const durations = ['8d', '16', '8', '8d', '16', '8', '8d', '16', '8', '4', '8'];
    const beams = [];
    let y = 40;
    smar.forEach((sm) => {
        const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_16__.Stave(10, y, sm.width);
        const notes = [];
        let iii = 0;
        context.fillText(sm.title, 100, y);
        y += rowSize;
        durations.forEach((dd) => {
            const note = new _src_stavenote__WEBPACK_IMPORTED_MODULE_18__.StaveNote({ keys: ['b/4'], duration: dd });
            if (dd.indexOf('d') >= 0) {
                _src_dot__WEBPACK_IMPORTED_MODULE_6__.Dot.buildAndAttach([note], { all: true });
            }
            if (sm.lyrics.length > iii) {
                note.addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_2__.Annotation(sm.lyrics[iii])
                    .setVerticalJustification(_src_annotation__WEBPACK_IMPORTED_MODULE_2__.Annotation.VerticalJustify.BOTTOM)
                    .setFont(_src_metrics__WEBPACK_IMPORTED_MODULE_12__.Metrics.get('fontFamily'), 12, _src_font__WEBPACK_IMPORTED_MODULE_9__.FontWeight.NORMAL));
            }
            notes.push(note);
            iii += 1;
        });
        notes.forEach((note) => {
            if (note.getDuration().indexOf('d') >= 0) {
                _src_dot__WEBPACK_IMPORTED_MODULE_6__.Dot.buildAndAttach([note], { all: true });
            }
        });
        // Don't beam the last group
        let notesToBeam = [];
        notes.forEach((note) => {
            if (note.getIntrinsicTicks() < 4096) {
                notesToBeam.push(note);
                if (notesToBeam.length >= beamGroup) {
                    beams.push(new _src_beam__WEBPACK_IMPORTED_MODULE_4__.Beam(notesToBeam));
                    notesToBeam = [];
                }
            }
            else {
                notesToBeam = [];
            }
        });
        const voice1 = new _src_voice__WEBPACK_IMPORTED_MODULE_22__.Voice({ numBeats: beats, beatValue: beatsPer }).setMode(_src_voice__WEBPACK_IMPORTED_MODULE_22__.Voice.Mode.SOFT).addTickables(notes);
        const fmt = new _src_formatter__WEBPACK_IMPORTED_MODULE_10__.Formatter({ softmaxFactor: sm.sm, maxIterations: 2 }).joinVoices([voice1]);
        fmt.format([voice1], sm.width - 11);
        stave.setContext(context).draw();
        voice1.draw(context, stave);
        beams.forEach((b) => b.setContext(context).draw());
    });
    options.assert.ok(true);
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(FormatterTests);



/***/ }),

/***/ "./tests/fraction_tests.ts":
/*!*********************************!*\
  !*** ./tests/fraction_tests.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FractionTests: () => (/* binding */ FractionTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_fraction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/fraction */ "./src/fraction.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Fraction Tests
/* eslint-disable camelcase */
// Allow underscores in this file for representing fractional values inside variable names.


const FractionTests = {
    Start() {
        QUnit.module('Fraction');
        QUnit.test('Basic', basic);
        QUnit.test('With Other Fractions', withOtherFractions);
    },
};
function basic(assert) {
    const f_1_2 = new _src_fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction(1, 2);
    assert.ok(f_1_2.equals(0.5), 'Fraction: 1/2 equals 0.5');
    assert.ok(f_1_2.equals(new _src_fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction(1, 2)), 'Fraction: 1/2 equals 1/2');
    assert.ok(f_1_2.equals(new _src_fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction(2, 4)), 'Fraction: 1/2 equals 2/4');
    assert.notOk(f_1_2.greaterThan(1), 'Fraction: ! 1/2 > 1');
    assert.ok(f_1_2.greaterThan(0.2), 'Fraction: 1/2 > 0.2');
    assert.ok(f_1_2.greaterThanEquals(0.2), 'Fraction: 1/2 >= 0.2');
    assert.ok(f_1_2.greaterThanEquals(0.5), 'Fraction: 1/2 >= 0.5');
    assert.notOk(f_1_2.greaterThanEquals(1), 'Fraction: ! 1/2 >= 1');
    assert.notOk(f_1_2.lessThan(0.5), 'Fraction: ! 1/2 < 0.5');
    assert.ok(f_1_2.lessThan(1), 'Fraction: 1/2 < 1');
    assert.ok(f_1_2.lessThanEquals(0.6), 'Fraction: 1/2 <= 0.6');
    assert.ok(f_1_2.lessThanEquals(0.5), 'Fraction: 1/2 <= 0.5');
    assert.notOk(f_1_2.lessThanEquals(0.4), 'Fraction: ! 1/2 <= 0.4');
    const f_0p5 = f_1_2.copy(0.5);
    assert.strictEqual(f_0p5, f_1_2, 'Fraction: f_0p5 === f_1_2');
    assert.strictEqual(f_0p5.toString(), '0.5/1', 'Fraction: f_0p5.toString() === "0.5/1"');
    assert.strictEqual(f_0p5.toSimplifiedString(), '1/2', 'Fraction: f_0p5.toSimplifiedString() === "1/2"');
    const tempFraction = f_0p5.clone();
    assert.notStrictEqual(tempFraction, f_0p5, 'Fraction: tempFraction !== f_0p5');
    assert.notEqual(tempFraction, f_0p5, 'Fraction: tempFraction != f_0p5');
    assert.deepEqual(tempFraction, f_0p5, 'tempFraction deepEqual f_0p5');
    assert.notDeepEqual(tempFraction, {}, 'tempFraction notDeepEqual {}');
    tempFraction.subtract(-0.5);
    assert.ok(tempFraction.equals(1), 'Fraction: 0.5 -(-0.5) equals 1');
    tempFraction.add(1);
    assert.ok(tempFraction.equals(2), 'Fraction: 1 + 1 equals 2');
    tempFraction.multiply(2);
    assert.ok(tempFraction.equals(4), 'Fraction: 2 * 2 equals 4');
    tempFraction.divide(2);
    assert.ok(tempFraction.equals(2), 'Fraction: 4 / 2 equals 2');
    // Lowest common multiple.
    assert.equal(_src_fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction.LCMM([]), 0);
    assert.equal(_src_fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction.LCMM([17]), 17);
    assert.equal(_src_fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction.LCMM([2, 5]), 10);
    assert.equal(_src_fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction.LCMM([15, 3, 5]), 15);
    assert.equal(_src_fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction.LCMM([2, 4, 6]), 12);
    assert.equal(_src_fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction.LCMM([2, 3, 4, 5]), 60);
    assert.equal(_src_fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction.LCMM([12, 15, 10, 75]), 300);
    // Greatest common divisor.
    assert.equal(_src_fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction.GCD(0, 0), 0);
    assert.equal(_src_fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction.GCD(0, 99), 99);
    assert.equal(_src_fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction.GCD(77, 0), 77);
    assert.equal(_src_fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction.GCD(42, 14), 14);
    assert.equal(_src_fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction.GCD(15, 10), 5);
}
function withOtherFractions(assert) {
    const f_1_2 = new _src_fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction(1, 2);
    const f_1_4 = new _src_fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction(1, 4);
    const f_1_8 = new _src_fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction(1, 8);
    const f_2 = new _src_fraction__WEBPACK_IMPORTED_MODULE_1__.Fraction(2, 1);
    // IMPORTANT NOTE: Fraction methods modify the existing Fraction object.
    // They do not return new objects.
    // Use clone() if you don't want to modify the original object.
    const a = f_1_2.clone().multiply(f_1_2);
    assert.ok(a.equals(f_1_4), '1/2 x 1/2 === 1/4');
    const b = f_1_2.clone().divide(f_1_4);
    assert.ok(b.equals(f_2), '1/2 / 1/4 === 2');
    const c = f_2.clone().subtract(f_1_2).subtract(f_1_2).subtract(f_1_4); // 3/4
    const d = f_1_8.clone().add(f_1_8).add(f_1_8).multiply(f_2);
    assert.ok(c.equals(d), '2-1/2-1/2-1/4 === (1/8+1/8+1/8)*(2/1)');
    assert.equal(c.value(), 0.75, '3/4 === 0.75');
    const e = f_1_8.clone().add(f_1_4).add(f_1_8);
    assert.ok(e.equals(f_1_2), '1/8 + 1/4 + 1/8 === 1/2');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(FractionTests);



/***/ }),

/***/ "./tests/ghostnote_tests.ts":
/*!**********************************!*\
  !*** ./tests/ghostnote_tests.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GhostNoteTests: () => (/* binding */ GhostNoteTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// GhostNote Tests

const GhostNoteTests = {
    Start() {
        QUnit.module('GhostNote');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('GhostNote Basic', basic);
        run('GhostNote Dotted', dotted);
    },
};
/**
 * Helper function to set up the stave, easyscore, voice, and to format & draw.
 */
function createTest(addItems) {
    return (options) => {
        const factory = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 550);
        const stave = factory.Stave();
        const score = factory.EasyScore();
        addItems(factory, score);
        const voices = factory.getVoices();
        factory.Formatter().joinVoices(voices).formatToStave(voices, stave);
        factory.draw();
        options.assert.ok(true, 'all pass');
    };
}
const basic = createTest((f, score) => {
    // Top Voice
    const voiceTop = score.voice(score.notes('f#5/4, f5, db5, c5, c5/8, d5, fn5, e5, d5, c5', { stem: 'up' }), {
        time: '7/4',
    });
    const notesTop = voiceTop.getTickables();
    f.Beam({ notes: notesTop.slice(4, 8) });
    f.Beam({ notes: notesTop.slice(8, 10) });
    // Bottom Voice
    score.voice([
        f.GhostNote({ duration: '2' }),
        f.StaveNote({ keys: ['f/4'], stemDirection: -1, duration: '4' }),
        f.GhostNote({ duration: '4' }),
        f.StaveNote({ keys: ['e/4'], stemDirection: -1, duration: '4' }),
        f.GhostNote({ duration: '8' }),
        f.StaveNote({ keys: ['d/4'], stemDirection: -1, duration: '8' }).addModifier(f.Accidental({ type: '##' }), 0),
        f.StaveNote({ keys: ['c/4'], stemDirection: -1, duration: '8' }),
        f.StaveNote({ keys: ['c/4'], stemDirection: -1, duration: '8' }),
    ], { time: '7/4' });
});
/**
 * A ghost note is invisible, but takes up space on the stave corresponding to its duration.
 * '4d' is a dotted quarter note, equivalent to a quarter + eighth note.
 */
const dotted = createTest((f, score) => {
    const voice1 = score.voice([
        f.GhostNote({ duration: '4d' }),
        f.StaveNote({ duration: '8', keys: ['f/5'], stemDirection: 1 }),
        f.StaveNote({ duration: '4', keys: ['d/5'], stemDirection: 1 }),
        f.StaveNote({ duration: '8', keys: ['c/5'], stemDirection: 1 }),
        f.StaveNote({ duration: '16', keys: ['c/5'], stemDirection: 1 }),
        f.StaveNote({ duration: '16', keys: ['d/5'], stemDirection: 1 }),
        f.GhostNote({ duration: '2dd' }),
        f.StaveNote({ duration: '8', keys: ['f/5'], stemDirection: 1 }),
    ], { time: '8/4' });
    const voice2 = score.voice([
        f.StaveNote({ duration: '4', keys: ['f/4'], stemDirection: -1 }),
        f.StaveNote({ duration: '8', keys: ['e/4'], stemDirection: -1 }),
        f.StaveNote({ duration: '8', keys: ['d/4'], stemDirection: -1 }),
        f.GhostNote({ duration: '4dd' }),
        f.StaveNote({ duration: '16', keys: ['c/4'], stemDirection: -1 }),
        f.StaveNote({ duration: '2', keys: ['c/4'], stemDirection: -1 }),
        f.StaveNote({ duration: '4', keys: ['d/4'], stemDirection: -1 }),
        f.StaveNote({ duration: '8', keys: ['f/4'], stemDirection: -1 }),
        f.StaveNote({ duration: '8', keys: ['e/4'], stemDirection: -1 }),
    ], { time: '8/4' });
    const notes1 = voice1.getTickables();
    const notes2 = voice2.getTickables();
    const addAccidental = (note, type) => note.addModifier(f.Accidental({ type }), 0);
    addAccidental(notes1[1], 'bb');
    addAccidental(notes1[4], '#');
    addAccidental(notes1[7], 'n');
    addAccidental(notes2[0], '#');
    addAccidental(notes2[4], 'b');
    addAccidental(notes2[5], '#');
    addAccidental(notes2[7], 'n');
    f.Beam({ notes: notes1.slice(3, 6) });
    f.Beam({ notes: notes2.slice(1, 3) });
    f.Beam({ notes: notes2.slice(7, 9) });
});
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(GhostNoteTests);



/***/ }),

/***/ "./tests/glyphnote_tests.ts":
/*!**********************************!*\
  !*** ./tests/glyphnote_tests.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlyphNoteTests: () => (/* binding */ GlyphNoteTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_chordsymbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/chordsymbol */ "./src/chordsymbol.ts");
/* harmony import */ var _src_registry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/registry */ "./src/registry.ts");
/* harmony import */ var _src_staveconnector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/staveconnector */ "./src/staveconnector.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// GlyphNote Tests




const GlyphNoteTests = {
    Start() {
        QUnit.module('GlyphNote');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('GlyphNote with ChordSymbols', chordChanges, { debug: false, noPadding: false });
        run('GlyphNote Positioning', basic, { debug: false, noPadding: false });
        run('GlyphNote No Stave Padding', basic, { debug: true, noPadding: true });
        run('GlyphNote RepeatNote', repeatNote, { debug: false, noPadding: true });
    },
};
function chordChanges(options) {
    _src_registry__WEBPACK_IMPORTED_MODULE_2__.Registry.enableDefaultRegistry(new _src_registry__WEBPACK_IMPORTED_MODULE_2__.Registry());
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 300, 200);
    const system = f.System({
        x: 50,
        width: 250,
        debugFormatter: options.params.debug,
        noPadding: options.params.noPadding,
        details: { alpha: options.params.alpha },
    });
    const score = f.EasyScore();
    const notes = [
        f.GlyphNote('\uE504' /*repeatBarSlash*/, { duration: 'q' }),
        f.GlyphNote('\uE504' /*repeatBarSlash*/, { duration: 'q' }),
        f.GlyphNote('\uE504' /*repeatBarSlash*/, { duration: 'q' }),
        f.GlyphNote('\uE504' /*repeatBarSlash*/, { duration: 'q' }),
    ];
    const chord1 = f
        .ChordSymbol()
        .addText('F7')
        .setHorizontal('left')
        .addGlyphOrText('(#11b9)', { symbolModifier: _src_chordsymbol__WEBPACK_IMPORTED_MODULE_1__.ChordSymbol.symbolModifiers.SUPERSCRIPT });
    const chord2 = f
        .ChordSymbol()
        .addText('F7')
        .setHorizontal('left')
        .addGlyphOrText('#11', { symbolModifier: _src_chordsymbol__WEBPACK_IMPORTED_MODULE_1__.ChordSymbol.symbolModifiers.SUPERSCRIPT })
        .addGlyphOrText('b9', { symbolModifier: _src_chordsymbol__WEBPACK_IMPORTED_MODULE_1__.ChordSymbol.symbolModifiers.SUBSCRIPT });
    notes[0].addModifier(chord1, 0);
    notes[2].addModifier(chord2, 0);
    const voice = score.voice(notes);
    system.addStave({ voices: [voice], debugNoteMetrics: options.params.debug });
    system.addConnector().setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_3__.StaveConnector.type.BRACKET);
    f.draw();
    _src_registry__WEBPACK_IMPORTED_MODULE_2__.Registry.disableDefaultRegistry();
    options.assert.ok(true);
}
function basic(options) {
    _src_registry__WEBPACK_IMPORTED_MODULE_2__.Registry.enableDefaultRegistry(new _src_registry__WEBPACK_IMPORTED_MODULE_2__.Registry());
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 300, 400);
    const system = f.System({
        x: 50,
        width: 250,
        debugFormatter: options.params.debug,
        noPadding: options.params.noPadding,
        details: { alpha: options.params.alpha },
    });
    const score = f.EasyScore();
    const newVoice = (notes) => score.voice(notes, { time: '1/4' });
    const newStave = (voice) => system.addStave({ voices: [voice], debugNoteMetrics: options.params.debug });
    const voices = [
        [f.GlyphNote('\uE500' /*repeat1Bar*/, { duration: 'q' }, { line: 4 })],
        [f.GlyphNote('\uE501' /*repeat2Bars*/, { duration: 'q', alignCenter: true })],
        [
            f.GlyphNote('\uE504' /*repeatBarSlash*/, { duration: '16' }),
            f.GlyphNote('\uE504' /*repeatBarSlash*/, { duration: '16' }),
            f.GlyphNote('\uE502' /*repeat4Bars*/, { duration: '16' }),
            f.GlyphNote('\uE504' /*repeatBarSlash*/, { duration: '16' }),
        ],
    ];
    voices.map(newVoice).forEach(newStave);
    system.addConnector().setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_3__.StaveConnector.type.BRACKET);
    f.draw();
    _src_registry__WEBPACK_IMPORTED_MODULE_2__.Registry.disableDefaultRegistry();
    options.assert.ok(true);
}
function repeatNote(options) {
    _src_registry__WEBPACK_IMPORTED_MODULE_2__.Registry.enableDefaultRegistry(new _src_registry__WEBPACK_IMPORTED_MODULE_2__.Registry());
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 300, 500);
    const system = f.System({
        x: 50,
        width: 250,
        debugFormatter: options.params.debug,
        noPadding: options.params.noPadding,
        details: { alpha: options.params.alpha },
    });
    const score = f.EasyScore();
    const createVoice = (notes) => score.voice(notes, { time: '1/4' });
    const addStaveWithVoice = (voice) => system.addStave({ voices: [voice], debugNoteMetrics: options.params.debug });
    const voices = [
        [f.RepeatNote('1')],
        [f.RepeatNote('2')],
        [f.RepeatNote('4')],
        [
            f.RepeatNote('slash', { duration: '16' }),
            f.RepeatNote('slash', { duration: '16' }),
            f.RepeatNote('slash', { duration: '16' }),
            f.RepeatNote('slash', { duration: '16' }),
        ],
    ];
    voices.map(createVoice).forEach(addStaveWithVoice);
    system.addConnector().setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_3__.StaveConnector.type.BRACKET);
    f.draw();
    _src_registry__WEBPACK_IMPORTED_MODULE_2__.Registry.disableDefaultRegistry();
    options.assert.ok(true);
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(GlyphNoteTests);



/***/ }),

/***/ "./tests/gracenote_tests.ts":
/*!**********************************!*\
  !*** ./tests/gracenote_tests.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GraceNoteTests: () => (/* binding */ GraceNoteTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_accidental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/accidental */ "./src/accidental.ts");
/* harmony import */ var _src_annotation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/annotation */ "./src/annotation.ts");
/* harmony import */ var _src_articulation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/articulation */ "./src/articulation.ts");
/* harmony import */ var _src_dot__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/dot */ "./src/dot.ts");
/* harmony import */ var _src_formatter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/formatter */ "./src/formatter.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// GraceNote Tests
// TODO: In the 'stem' test (aka Grace Note Stem  SVG + Petaluma in flow.html), the Petaluma note heads are not scaled down properly.






const GraceNoteTests = {
    Start() {
        QUnit.module('Grace Notes');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Grace Note Basic', basic);
        run('With Articulation and Annotation on Parent Note', graceNoteModifiers);
        run('Grace Note Basic with Slurs', basicSlurred);
        run('Grace Note Stem', stem);
        run('Grace Note Stem with Beams 1', stemWithBeamed, {
            keys1: ['g/4'],
            stemDirection1: 1,
            keys2: ['d/5'],
            stemDirection2: -1,
        });
        run('Grace Note Stem with Beams 2', stemWithBeamed, {
            keys1: ['a/3'],
            stemDirection1: 1,
            keys2: ['a/5'],
            stemDirection2: -1,
        });
        run('Grace Note Stem with Beams 3', stemWithBeamed, {
            keys1: ['c/4'],
            stemDirection1: 1,
            keys2: ['c/6'],
            stemDirection2: -1,
        });
        run('Grace Note Slash', slash);
        run('Grace Note Slash with Beams', slashWithBeams);
        run('Grace Notes Multiple Voices', multipleVoices);
        run('Grace Notes Multiple Voices Multiple Draws', multipleVoicesMultipleDraws);
    },
};
function basic(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 130);
    const stave = f.Stave({ x: 10, y: 10, width: 650 });
    const gracenotes = [
        { keys: ['e/4'], duration: '32' },
        { keys: ['f/4'], duration: '32' },
        { keys: ['g/4'], duration: '32' },
        { keys: ['a/4'], duration: '32' },
    ].map(f.GraceNote.bind(f));
    const gracenotes1 = [{ keys: ['b/4'], duration: '8', slash: false }].map(f.GraceNote.bind(f));
    const gracenotes2 = [{ keys: ['b/4'], duration: '8', slash: true }].map(f.GraceNote.bind(f));
    const gracenotes3 = [
        { keys: ['e/4'], duration: '8' },
        { keys: ['f/4'], duration: '16' },
        { keys: ['e/4', 'g/4'], duration: '8' },
        { keys: ['a/4'], duration: '32' },
        { keys: ['b/4'], duration: '32' },
    ].map(f.GraceNote.bind(f));
    const gracenotes4 = [
        { keys: ['g/4'], duration: '8' },
        { keys: ['g/4'], duration: '16' },
        { keys: ['g/4'], duration: '16' },
    ].map(f.GraceNote.bind(f));
    gracenotes[1].addModifier(f.Accidental({ type: '##' }), 0);
    gracenotes3[3].addModifier(f.Accidental({ type: 'bb' }), 0);
    _src_dot__WEBPACK_IMPORTED_MODULE_4__.Dot.buildAndAttach([gracenotes4[0]], { all: true });
    const notes = [
        f
            .StaveNote({ keys: ['b/4'], duration: '4', autoStem: true })
            .addModifier(f.GraceNoteGroup({ notes: gracenotes }).beamNotes(), 0),
        f
            .StaveNote({ keys: ['c/5'], duration: '4', autoStem: true })
            .addModifier(f.Accidental({ type: '#' }), 0)
            .addModifier(f.GraceNoteGroup({ notes: gracenotes1 }).beamNotes(), 0),
        f
            .StaveNote({ keys: ['c/5', 'd/5'], duration: '4', autoStem: true })
            .addModifier(f.GraceNoteGroup({ notes: gracenotes2 }).beamNotes(), 0),
        f
            .StaveNote({ keys: ['a/4'], duration: '4', autoStem: true })
            .addModifier(f.GraceNoteGroup({ notes: gracenotes3 }).beamNotes(), 0),
        f
            .StaveNote({ keys: ['a/4'], duration: '4', autoStem: true })
            .addModifier(f.GraceNoteGroup({ notes: gracenotes4 }).beamNotes(), 0),
    ];
    const voice = f.Voice().setStrict(false).addTickables(notes);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_5__.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'GraceNoteBasic');
}
function graceNoteModifiers(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 130);
    const stave = f.Stave({ x: 10, y: 10, width: 650 });
    const gracenotes = [{ keys: ['b/4'], duration: '8', slash: false }].map(f.GraceNote.bind(f));
    const notes = [
        f
            .StaveNote({ keys: ['c/5'], duration: '4', autoStem: true })
            .addModifier(f.GraceNoteGroup({ notes: gracenotes }), 0),
        f
            .StaveNote({ keys: ['c/5'], duration: '4', autoStem: true })
            .addModifier(f.GraceNoteGroup({ notes: gracenotes }), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_3__.Articulation('a-').setPosition(3), 0),
        f
            .StaveNote({ keys: ['c/5'], duration: '4', autoStem: true })
            .addModifier(f.GraceNoteGroup({ notes: gracenotes }), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_3__.Articulation('a-').setPosition(3), 0)
            .addModifier(new _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental('#')),
        f
            .StaveNote({ keys: ['c/5'], duration: '4', autoStem: true })
            .addModifier(f.GraceNoteGroup({ notes: gracenotes }), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_3__.Articulation('a-').setPosition(3), 0)
            .addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_2__.Annotation('words')),
        f
            .StaveNote({ keys: ['c/5'], duration: '4', autoStem: true })
            .addModifier(f.GraceNoteGroup({ notes: gracenotes }), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_3__.Articulation('a-').setPosition(3), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_3__.Articulation('a>').setPosition(3), 0),
        f
            .StaveNote({ keys: ['c/5'], duration: '4', autoStem: true })
            .addModifier(f.GraceNoteGroup({ notes: gracenotes }), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_3__.Articulation('a-').setPosition(3), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_3__.Articulation('a>').setPosition(3), 0)
            .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_3__.Articulation('a@a').setPosition(3), 0),
    ];
    const voice = f.Voice().setStrict(false).addTickables(notes);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_5__.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'GraceNoteModifiers');
}
function basicSlurred(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 130);
    const stave = f.Stave({ x: 10, y: 10, width: 650 });
    const gracenotes0 = [
        { keys: ['e/4'], duration: '32' },
        { keys: ['f/4'], duration: '32' },
        { keys: ['g/4'], duration: '32' },
        { keys: ['a/4'], duration: '32' },
    ].map(f.GraceNote.bind(f));
    const gracenotes1 = [{ keys: ['b/4'], duration: '8', slash: false }].map(f.GraceNote.bind(f));
    const gracenotes2 = [{ keys: ['b/4'], duration: '8', slash: true }].map(f.GraceNote.bind(f));
    const gracenotes3 = [
        { keys: ['e/4'], duration: '8' },
        { keys: ['f/4'], duration: '16' },
        { keys: ['e/4', 'g/4'], duration: '8' },
        { keys: ['a/4'], duration: '32' },
        { keys: ['b/4'], duration: '32' },
    ].map(f.GraceNote.bind(f));
    const gracenotes4 = [
        { keys: ['a/4'], duration: '8' },
        { keys: ['a/4'], duration: '16' },
        { keys: ['a/4'], duration: '16' },
    ].map(f.GraceNote.bind(f));
    gracenotes0[1].addModifier(f.Accidental({ type: '#' }), 0);
    gracenotes3[3].addModifier(f.Accidental({ type: 'b' }), 0);
    gracenotes3[2].addModifier(f.Accidental({ type: 'n' }), 0);
    _src_dot__WEBPACK_IMPORTED_MODULE_4__.Dot.buildAndAttach([gracenotes4[0]], { all: true });
    const notes = [
        f
            .StaveNote({ keys: ['b/4'], duration: '4', autoStem: true })
            .addModifier(f.GraceNoteGroup({ notes: gracenotes0, slur: true }).beamNotes(), 0),
        f
            .StaveNote({ keys: ['c/5'], duration: '4', autoStem: true })
            .addModifier(f.Accidental({ type: '#' }), 0)
            .addModifier(f.GraceNoteGroup({ notes: gracenotes1, slur: true }).beamNotes(), 0),
        f
            .StaveNote({ keys: ['c/5', 'd/5'], duration: '4', autoStem: true })
            .addModifier(f.GraceNoteGroup({ notes: gracenotes2, slur: true }).beamNotes(), 0),
        f
            .StaveNote({ keys: ['a/4'], duration: '4', autoStem: true })
            .addModifier(f.GraceNoteGroup({ notes: gracenotes3, slur: true }).beamNotes(), 0),
        f
            .StaveNote({ keys: ['a/4'], duration: '4', autoStem: true })
            .addModifier(f.GraceNoteGroup({ notes: gracenotes4, slur: true }).beamNotes(), 0),
        f.StaveNote({ keys: ['a/4'], duration: '4', autoStem: true }),
    ];
    const voice = f.Voice().setStrict(false).addTickables(notes);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_5__.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'GraceNoteBasic');
}
/**
 * Helper function for three tests below: stem, stemWithBeamed, slash.
 */
const createNoteForStemTest = (duration, noteBuilder, keys, stemDirection, slash = false) => {
    const struct = { duration, slash };
    struct.stemDirection = stemDirection;
    struct.keys = keys;
    return noteBuilder(struct);
};
// Used in three tests below.
const durationsForStemTest = ['8', '16', '32', '64', '128'];
function stem(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 130);
    const stave = f.Stave({ x: 10, y: 10, width: 650 });
    function createNotes(noteBuilder, keys, stemDirection) {
        return durationsForStemTest.map((duration) => createNoteForStemTest(duration, noteBuilder, keys, stemDirection));
    }
    function createNoteBlock(keys, stemDirection) {
        const staveNotes = createNotes(f.StaveNote.bind(f), keys, stemDirection);
        const gracenotes = createNotes(f.GraceNote.bind(f), keys, stemDirection);
        // Add a bunch of GraceNotes in front of the first StaveNote.
        staveNotes[0].addModifier(f.GraceNoteGroup({ notes: gracenotes }), 0);
        return staveNotes;
    }
    const voice = f.Voice().setStrict(false);
    voice.addTickables(createNoteBlock(['g/4'], 1));
    voice.addTickables(createNoteBlock(['d/5'], -1));
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'GraceNoteStem');
}
function stemWithBeamed(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 130);
    const stave = f.Stave({ x: 10, y: 10, width: 650 });
    function createBeamedNotes(noteBuilder, keys, stemDirection, beams, isGrace = false, notesToBeam) {
        const ret = [];
        durationsForStemTest.map((duration) => {
            const n0 = createNoteForStemTest(duration, noteBuilder, keys, stemDirection);
            const n1 = createNoteForStemTest(duration, noteBuilder, keys, stemDirection);
            ret.push(n0);
            ret.push(n1);
            if (notesToBeam) {
                notesToBeam.push([n0, n1]);
            }
            if (!isGrace) {
                beams.push(f.Beam({ notes: [n0, n1] }));
            }
        });
        return ret;
    }
    function createBeamedNoteBlock(keys, stemDirection, beams) {
        const bnotes = createBeamedNotes(f.StaveNote.bind(f), keys, stemDirection, beams);
        const notesToBeam = [];
        const gracenotes = createBeamedNotes(f.GraceNote.bind(f), keys, stemDirection, beams, true, notesToBeam);
        const graceNoteGroup = f.GraceNoteGroup({ notes: gracenotes });
        notesToBeam.map(graceNoteGroup.beamNotes.bind(graceNoteGroup));
        bnotes[0].addModifier(graceNoteGroup, 0);
        return bnotes;
    }
    const beams = [];
    const voice = f.Voice().setStrict(false);
    voice.addTickables(createBeamedNoteBlock(options.params.keys1, options.params.stemDirection1, beams));
    voice.addTickables(createBeamedNoteBlock(options.params.keys2, options.params.stemDirection2, beams));
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'GraceNoteStem');
}
function slash(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 130);
    const stave = f.Stave({ x: 10, y: 10, width: 650 });
    function createNotes(noteT, keys, stemDirection, slash) {
        return durationsForStemTest.map((d) => createNoteForStemTest(d, noteT, keys, stemDirection, slash));
    }
    function createNoteBlock(keys, stemDirection) {
        const notes = [f.StaveNote({ keys: ['f/4'], stemDirection, duration: '16' })];
        let graceNotes = createNotes(f.GraceNote.bind(f), keys, stemDirection, true);
        const duration = '8';
        const gns = [
            { keys: ['d/4', 'a/4'], stemDirection, duration, slash: true },
            { keys: ['d/4', 'a/4'], stemDirection, duration, slash: true },
            { keys: ['d/4', 'a/4'], stemDirection, duration, slash: true },
            { keys: ['e/4', 'a/4'], stemDirection, duration, slash: true },
            { keys: ['e/4', 'a/4'], stemDirection, duration, slash: true },
            { keys: ['b/4', 'f/5'], stemDirection, duration, slash: true },
            { keys: ['b/4', 'f/5'], stemDirection, duration, slash: true },
            { keys: ['b/4', 'f/5'], stemDirection, duration, slash: true },
            { keys: ['e/4', 'a/4'], stemDirection, duration, slash: true },
        ].map(f.GraceNote.bind(f));
        const notesToBeam = [];
        notesToBeam.push([gns[0], gns[1], gns[2]]);
        notesToBeam.push([gns[3], gns[4], gns[5]]);
        notesToBeam.push([gns[6], gns[7], gns[8]]);
        // Merge the two GraceNote[].
        graceNotes = graceNotes.concat(gns);
        const graceNoteGroup = f.GraceNoteGroup({ notes: graceNotes });
        notesToBeam.forEach((notes) => graceNoteGroup.beamNotes(notes));
        notes[0].addModifier(graceNoteGroup, 0);
        return notes;
    }
    const voice = f.Voice().setStrict(false);
    voice.addTickables(createNoteBlock(['d/4', 'a/4'], 1));
    voice.addTickables(createNoteBlock(['d/4', 'a/4'], -1));
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'GraceNoteSlash');
}
function slashWithBeams(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 800, 130);
    const stave = f.Stave({ x: 10, y: 10, width: 750 });
    function createNoteBlock(keys, stemDirection) {
        const notes = [f.StaveNote({ keys: ['f/4'], stemDirection, duration: '16' })];
        let allGraceNotes = [];
        const graceNotesToBeam = [];
        ['8', '16', '32', '64'].forEach(function (duration) {
            const graceNotes = [
                { keys: ['d/4', 'a/4'], stemDirection, duration, slash: true },
                { keys: ['d/4', 'a/4'], stemDirection, duration, slash: false },
                { keys: ['e/4', 'a/4'], stemDirection, duration, slash: true },
                { keys: ['b/4', 'f/5'], stemDirection, duration, slash: false },
                { keys: ['b/4', 'f/5'], stemDirection, duration, slash: true },
                { keys: ['e/4', 'a/4'], stemDirection, duration, slash: false },
            ].map(f.GraceNote.bind(f));
            graceNotesToBeam.push([graceNotes[0], graceNotes[1]]);
            graceNotesToBeam.push([graceNotes[2], graceNotes[3]]);
            graceNotesToBeam.push([graceNotes[4], graceNotes[5]]);
            allGraceNotes = allGraceNotes.concat(graceNotes);
        });
        const graceNoteGroup = f.GraceNoteGroup({ notes: allGraceNotes });
        graceNotesToBeam.forEach((g) => graceNoteGroup.beamNotes(g));
        notes[0].addModifier(graceNoteGroup, 0);
        return notes;
    }
    const voice = f.Voice().setStrict(false);
    voice.addTickables(createNoteBlock(['d/4', 'a/4'], 1));
    voice.addTickables(createNoteBlock(['d/4', 'a/4'], -1));
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'GraceNoteSlashWithBeams');
}
function multipleVoices(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 450, 140);
    const stave = f.Stave({ x: 10, y: 10, width: 450 });
    const notes = [
        { keys: ['f/5'], stemDirection: 1, duration: '16' },
        { keys: ['f/5'], stemDirection: 1, duration: '16' },
        { keys: ['d/5'], stemDirection: 1, duration: '16' },
        { keys: ['c/5'], stemDirection: 1, duration: '16' },
        { keys: ['c/5'], stemDirection: 1, duration: '16' },
        { keys: ['d/5'], stemDirection: 1, duration: '16' },
        { keys: ['f/5'], stemDirection: 1, duration: '16' },
        { keys: ['e/5'], stemDirection: 1, duration: '16' },
    ].map(f.StaveNote.bind(f));
    const notes2 = [
        { keys: ['f/4'], stemDirection: -1, duration: '16' },
        { keys: ['e/4'], stemDirection: -1, duration: '16' },
        { keys: ['d/4'], stemDirection: -1, duration: '16' },
        { keys: ['c/4'], stemDirection: -1, duration: '16' },
        { keys: ['c/4'], stemDirection: -1, duration: '16' },
        { keys: ['d/4'], stemDirection: -1, duration: '16' },
        { keys: ['f/4'], stemDirection: -1, duration: '16' },
        { keys: ['e/4'], stemDirection: -1, duration: '16' },
    ].map(f.StaveNote.bind(f));
    const gracenotes1 = [{ keys: ['b/4'], stemDirection: 1, duration: '8', slash: true }].map(f.GraceNote.bind(f));
    const gracenotes2 = [{ keys: ['f/4'], stemDirection: -1, duration: '8', slash: true }].map(f.GraceNote.bind(f));
    const gracenotes3 = [
        { keys: ['f/4'], duration: '32', stemDirection: -1 },
        { keys: ['e/4'], duration: '32', stemDirection: -1 },
    ].map(f.GraceNote.bind(f));
    const gracenotes4 = [
        { keys: ['f/5'], duration: '32', stemDirection: 1 },
        { keys: ['e/5'], duration: '32', stemDirection: 1 },
        { keys: ['e/5'], duration: '8', stemDirection: 1 },
    ].map(f.GraceNote.bind(f));
    gracenotes2[0].setStemDirection(-1);
    gracenotes2[0].addModifier(f.Accidental({ type: '#' }), 0);
    notes[1].addModifier(f.GraceNoteGroup({ notes: gracenotes4 }).beamNotes(), 0);
    notes[3].addModifier(f.GraceNoteGroup({ notes: gracenotes1 }), 0);
    notes2[1].addModifier(f.GraceNoteGroup({ notes: gracenotes2 }).beamNotes(), 0);
    notes2[5].addModifier(f.GraceNoteGroup({ notes: gracenotes3 }).beamNotes(), 0);
    const voice = f.Voice().setStrict(false).addTickables(notes);
    const voice2 = f.Voice().setStrict(false).addTickables(notes2);
    f.Beam({ notes: notes.slice(0, 4) });
    f.Beam({ notes: notes.slice(4, 8) });
    f.Beam({ notes: notes2.slice(0, 4) });
    f.Beam({ notes: notes2.slice(4, 8) });
    f.Formatter().joinVoices([voice, voice2]).formatToStave([voice, voice2], stave);
    f.draw();
    options.assert.ok(true, 'Sixteenth Test');
}
function multipleVoicesMultipleDraws(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 450, 140);
    const stave = f.Stave({ x: 10, y: 10, width: 450 });
    const notes = [
        { keys: ['f/5'], stemDirection: 1, duration: '16' },
        { keys: ['f/5'], stemDirection: 1, duration: '16' },
        { keys: ['d/5'], stemDirection: 1, duration: '16' },
        { keys: ['c/5'], stemDirection: 1, duration: '16' },
        { keys: ['c/5'], stemDirection: 1, duration: '16' },
        { keys: ['d/5'], stemDirection: 1, duration: '16' },
        { keys: ['f/5'], stemDirection: 1, duration: '16' },
        { keys: ['e/5'], stemDirection: 1, duration: '16' },
    ].map(f.StaveNote.bind(f));
    const notes2 = [
        { keys: ['f/4'], stemDirection: -1, duration: '16' },
        { keys: ['e/4'], stemDirection: -1, duration: '16' },
        { keys: ['d/4'], stemDirection: -1, duration: '16' },
        { keys: ['c/4'], stemDirection: -1, duration: '16' },
        { keys: ['c/4'], stemDirection: -1, duration: '16' },
        { keys: ['d/4'], stemDirection: -1, duration: '16' },
        { keys: ['f/4'], stemDirection: -1, duration: '16' },
        { keys: ['e/4'], stemDirection: -1, duration: '16' },
    ].map(f.StaveNote.bind(f));
    const gracenotes1 = [{ keys: ['b/4'], stemDirection: 1, duration: '8', slash: true }].map(f.GraceNote.bind(f));
    const gracenotes2 = [{ keys: ['f/4'], stemDirection: -1, duration: '8', slash: true }].map(f.GraceNote.bind(f));
    const gracenotes3 = [
        { keys: ['f/4'], duration: '32', stemDirection: -1 },
        { keys: ['e/4'], duration: '32', stemDirection: -1 },
    ].map(f.GraceNote.bind(f));
    const gracenotes4 = [
        { keys: ['f/5'], duration: '32', stemDirection: 1 },
        { keys: ['e/5'], duration: '32', stemDirection: 1 },
        { keys: ['e/5'], duration: '8', stemDirection: 1 },
    ].map(f.GraceNote.bind(f));
    gracenotes2[0].setStemDirection(-1);
    gracenotes2[0].addModifier(f.Accidental({ type: '#' }), 0);
    notes[1].addModifier(f.GraceNoteGroup({ notes: gracenotes4 }).beamNotes(), 0);
    notes[3].addModifier(f.GraceNoteGroup({ notes: gracenotes1 }), 0);
    notes2[1].addModifier(f.GraceNoteGroup({ notes: gracenotes2 }).beamNotes(), 0);
    notes2[5].addModifier(f.GraceNoteGroup({ notes: gracenotes3 }).beamNotes(), 0);
    const voice = f.Voice().setStrict(false).addTickables(notes);
    const voice2 = f.Voice().setStrict(false).addTickables(notes2);
    f.Beam({ notes: notes.slice(0, 4) });
    f.Beam({ notes: notes.slice(4, 8) });
    f.Beam({ notes: notes2.slice(0, 4) });
    f.Beam({ notes: notes2.slice(4, 8) });
    f.Formatter().joinVoices([voice, voice2]).formatToStave([voice, voice2], stave);
    f.draw();
    f.draw();
    options.assert.ok(true, 'Seventeenth Test');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(GraceNoteTests);



/***/ }),

/***/ "./tests/gracetabnote_tests.ts":
/*!*************************************!*\
  !*** ./tests/gracetabnote_tests.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GraceTabNoteTests: () => (/* binding */ GraceTabNoteTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_flow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/flow */ "./src/flow.ts");
/* harmony import */ var _src_formatter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/formatter */ "./src/formatter.ts");
/* harmony import */ var _src_gracenotegroup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/gracenotegroup */ "./src/gracenotegroup.ts");
/* harmony import */ var _src_gracetabnote__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/gracetabnote */ "./src/gracetabnote.ts");
/* harmony import */ var _src_tabnote__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/tabnote */ "./src/tabnote.ts");
/* harmony import */ var _src_tabstave__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/tabstave */ "./src/tabstave.ts");
/* harmony import */ var _src_voice__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/voice */ "./src/voice.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// GraceTabNote Tests








const GraceTabNoteTests = {
    Start() {
        QUnit.module('Grace Tab Notes');
        // TODO: Rename tests below since it is redundant with the module name.
        // Remove "Grace Tab Note "
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Grace Tab Note Simple', simple);
        run('Grace Tab Note Slurred', slurred);
    },
};
// Helper functions to create TabNote and GraceTabNote objects.
const tabNote = (noteStruct) => new _src_tabnote__WEBPACK_IMPORTED_MODULE_5__.TabNote(noteStruct);
const graceTabNote = (noteStruct) => new _src_gracetabnote__WEBPACK_IMPORTED_MODULE_4__.GraceTabNote(noteStruct);
/**
 * Helper function to build a RenderContext and TabStave.
 */
function setupContext(opts, ctxBuilder) {
    const context = ctxBuilder(opts.elementId, 350, 140);
    const stave = new _src_tabstave__WEBPACK_IMPORTED_MODULE_6__.TabStave(10, 10, 350).addTabGlyph().setContext(context).draw();
    return { context, stave };
}
function simple(options, contextBuilder) {
    const { context, stave } = setupContext(options, contextBuilder);
    const note0 = tabNote({ positions: [{ str: 4, fret: 6 }], duration: '4' });
    const note1 = tabNote({ positions: [{ str: 4, fret: 12 }], duration: '4' });
    const note2 = tabNote({ positions: [{ str: 4, fret: 10 }], duration: '4' });
    const note3 = tabNote({ positions: [{ str: 4, fret: 10 }], duration: '4' });
    const gracenoteGroup0 = [{ positions: [{ str: 4, fret: 'x' }], duration: '8' }];
    const gracenoteGroup1 = [
        { positions: [{ str: 4, fret: 9 }], duration: '16' },
        { positions: [{ str: 4, fret: 10 }], duration: '16' },
    ];
    const gracenoteGroup2 = [{ positions: [{ str: 4, fret: 9 }], duration: '8' }];
    const gracenoteGroup3 = [
        { positions: [{ str: 5, fret: 10 }], duration: '8' },
        { positions: [{ str: 4, fret: 9 }], duration: '8' },
    ];
    const gracenotes0 = gracenoteGroup0.map(graceTabNote);
    const gracenotes1 = gracenoteGroup1.map(graceTabNote);
    const gracenotes2 = gracenoteGroup2.map(graceTabNote);
    gracenotes2[0].setGhost(true);
    const gracenotes3 = gracenoteGroup3.map(graceTabNote);
    note0.addModifier(new _src_gracenotegroup__WEBPACK_IMPORTED_MODULE_3__.GraceNoteGroup(gracenotes0), 0);
    note1.addModifier(new _src_gracenotegroup__WEBPACK_IMPORTED_MODULE_3__.GraceNoteGroup(gracenotes1), 0);
    note2.addModifier(new _src_gracenotegroup__WEBPACK_IMPORTED_MODULE_3__.GraceNoteGroup(gracenotes2), 0);
    note3.addModifier(new _src_gracenotegroup__WEBPACK_IMPORTED_MODULE_3__.GraceNoteGroup(gracenotes3), 0);
    const voice = new _src_voice__WEBPACK_IMPORTED_MODULE_7__.Voice(_src_flow__WEBPACK_IMPORTED_MODULE_1__.Flow.TIME4_4);
    voice.addTickables([note0, note1, note2, note3]);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_2__.Formatter().joinVoices([voice]).format([voice], 250);
    voice.draw(context, stave);
    options.assert.ok(true, 'Simple Test');
}
function slurred(options, contextBuilder) {
    const { context, stave } = setupContext(options, contextBuilder);
    const note0 = tabNote({ positions: [{ str: 4, fret: 12 }], duration: 'h' });
    const note1 = tabNote({ positions: [{ str: 4, fret: 10 }], duration: 'h' });
    const gracenoteGroup0 = [
        { positions: [{ str: 4, fret: 9 }], duration: '8' },
        { positions: [{ str: 4, fret: 10 }], duration: '8' },
    ];
    const gracenoteGroup1 = [
        { positions: [{ str: 4, fret: 7 }], duration: '16' },
        { positions: [{ str: 4, fret: 8 }], duration: '16' },
        { positions: [{ str: 4, fret: 9 }], duration: '16' },
    ];
    const gracenotes0 = gracenoteGroup0.map(graceTabNote);
    const gracenotes1 = gracenoteGroup1.map(graceTabNote);
    note0.addModifier(new _src_gracenotegroup__WEBPACK_IMPORTED_MODULE_3__.GraceNoteGroup(gracenotes0, true), 0);
    note1.addModifier(new _src_gracenotegroup__WEBPACK_IMPORTED_MODULE_3__.GraceNoteGroup(gracenotes1, true), 0);
    const voice = new _src_voice__WEBPACK_IMPORTED_MODULE_7__.Voice(_src_flow__WEBPACK_IMPORTED_MODULE_1__.Flow.TIME4_4);
    voice.addTickables([note0, note1]);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_2__.Formatter().joinVoices([voice]).format([voice], 200);
    voice.draw(context, stave);
    options.assert.ok(true, 'Slurred Test');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(GraceTabNoteTests);



/***/ }),

/***/ "./tests/index.ts":
/*!************************!*\
  !*** ./tests/index.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AccidentalTests: () => (/* reexport safe */ _accidental_tests__WEBPACK_IMPORTED_MODULE_0__.AccidentalTests),
/* harmony export */   AnnotationTests: () => (/* reexport safe */ _annotation_tests__WEBPACK_IMPORTED_MODULE_1__.AnnotationTests),
/* harmony export */   ArticulationTests: () => (/* reexport safe */ _articulation_tests__WEBPACK_IMPORTED_MODULE_2__.ArticulationTests),
/* harmony export */   AutoBeamFormattingTests: () => (/* reexport safe */ _auto_beam_formatting_tests__WEBPACK_IMPORTED_MODULE_3__.AutoBeamFormattingTests),
/* harmony export */   BachDemoTests: () => (/* reexport safe */ _bach_tests__WEBPACK_IMPORTED_MODULE_4__.BachDemoTests),
/* harmony export */   BarlineTests: () => (/* reexport safe */ _barline_tests__WEBPACK_IMPORTED_MODULE_5__.BarlineTests),
/* harmony export */   BeamTests: () => (/* reexport safe */ _beam_tests__WEBPACK_IMPORTED_MODULE_6__.BeamTests),
/* harmony export */   BendTests: () => (/* reexport safe */ _bend_tests__WEBPACK_IMPORTED_MODULE_7__.BendTests),
/* harmony export */   BoundingBoxTests: () => (/* reexport safe */ _boundingbox_tests__WEBPACK_IMPORTED_MODULE_8__.BoundingBoxTests),
/* harmony export */   ChordSymbolTests: () => (/* reexport safe */ _chordsymbol_tests__WEBPACK_IMPORTED_MODULE_9__.ChordSymbolTests),
/* harmony export */   ClefKeySignatureTests: () => (/* reexport safe */ _key_clef_tests__WEBPACK_IMPORTED_MODULE_23__.ClefKeySignatureTests),
/* harmony export */   ClefTests: () => (/* reexport safe */ _clef_tests__WEBPACK_IMPORTED_MODULE_10__.ClefTests),
/* harmony export */   CrossBeamTests: () => (/* reexport safe */ _crossbeam_tests__WEBPACK_IMPORTED_MODULE_11__.CrossBeamTests),
/* harmony export */   CurveTests: () => (/* reexport safe */ _curve_tests__WEBPACK_IMPORTED_MODULE_12__.CurveTests),
/* harmony export */   DotTests: () => (/* reexport safe */ _dot_tests__WEBPACK_IMPORTED_MODULE_13__.DotTests),
/* harmony export */   EasyScoreTests: () => (/* reexport safe */ _easyscore_tests__WEBPACK_IMPORTED_MODULE_14__.EasyScoreTests),
/* harmony export */   FactoryTests: () => (/* reexport safe */ _factory_tests__WEBPACK_IMPORTED_MODULE_15__.FactoryTests),
/* harmony export */   FontTests: () => (/* reexport safe */ _font_tests__WEBPACK_IMPORTED_MODULE_16__.FontTests),
/* harmony export */   FormatterTests: () => (/* reexport safe */ _formatter_tests__WEBPACK_IMPORTED_MODULE_17__.FormatterTests),
/* harmony export */   FractionTests: () => (/* reexport safe */ _fraction_tests__WEBPACK_IMPORTED_MODULE_18__.FractionTests),
/* harmony export */   GhostNoteTests: () => (/* reexport safe */ _ghostnote_tests__WEBPACK_IMPORTED_MODULE_19__.GhostNoteTests),
/* harmony export */   GlyphNoteTests: () => (/* reexport safe */ _glyphnote_tests__WEBPACK_IMPORTED_MODULE_20__.GlyphNoteTests),
/* harmony export */   GraceNoteTests: () => (/* reexport safe */ _gracenote_tests__WEBPACK_IMPORTED_MODULE_21__.GraceNoteTests),
/* harmony export */   GraceTabNoteTests: () => (/* reexport safe */ _gracetabnote_tests__WEBPACK_IMPORTED_MODULE_22__.GraceTabNoteTests),
/* harmony export */   KeyManagerTests: () => (/* reexport safe */ _keymanager_tests__WEBPACK_IMPORTED_MODULE_24__.KeyManagerTests),
/* harmony export */   KeySignatureTests: () => (/* reexport safe */ _keysignature_tests__WEBPACK_IMPORTED_MODULE_25__.KeySignatureTests),
/* harmony export */   ModifierContextTests: () => (/* reexport safe */ _modifier_tests__WEBPACK_IMPORTED_MODULE_26__.ModifierContextTests),
/* harmony export */   MultiMeasureRestTests: () => (/* reexport safe */ _multimeasurerest_tests__WEBPACK_IMPORTED_MODULE_27__.MultiMeasureRestTests),
/* harmony export */   MusicTests: () => (/* reexport safe */ _music_tests__WEBPACK_IMPORTED_MODULE_28__.MusicTests),
/* harmony export */   NoteHeadTests: () => (/* reexport safe */ _notehead_tests__WEBPACK_IMPORTED_MODULE_29__.NoteHeadTests),
/* harmony export */   NoteSubGroupTests: () => (/* reexport safe */ _notesubgroup_tests__WEBPACK_IMPORTED_MODULE_30__.NoteSubGroupTests),
/* harmony export */   OffscreenCanvasTests: () => (/* reexport safe */ _offscreencanvas_tests__WEBPACK_IMPORTED_MODULE_31__.OffscreenCanvasTests),
/* harmony export */   OrnamentTests: () => (/* reexport safe */ _ornament_tests__WEBPACK_IMPORTED_MODULE_32__.OrnamentTests),
/* harmony export */   ParserTests: () => (/* reexport safe */ _parser_tests__WEBPACK_IMPORTED_MODULE_33__.ParserTests),
/* harmony export */   PedalMarkingTests: () => (/* reexport safe */ _pedalmarking_tests__WEBPACK_IMPORTED_MODULE_34__.PedalMarkingTests),
/* harmony export */   PercussionTests: () => (/* reexport safe */ _percussion_tests__WEBPACK_IMPORTED_MODULE_35__.PercussionTests),
/* harmony export */   RegistryTests: () => (/* reexport safe */ _registry_tests__WEBPACK_IMPORTED_MODULE_36__.RegistryTests),
/* harmony export */   RendererTests: () => (/* reexport safe */ _renderer_tests__WEBPACK_IMPORTED_MODULE_37__.RendererTests),
/* harmony export */   RestsTests: () => (/* reexport safe */ _rests_tests__WEBPACK_IMPORTED_MODULE_38__.RestsTests),
/* harmony export */   RhythmTests: () => (/* reexport safe */ _rhythm_tests__WEBPACK_IMPORTED_MODULE_39__.RhythmTests),
/* harmony export */   StaveConnectorTests: () => (/* reexport safe */ _staveconnector_tests__WEBPACK_IMPORTED_MODULE_41__.StaveConnectorTests),
/* harmony export */   StaveHairpinTests: () => (/* reexport safe */ _stavehairpin_tests__WEBPACK_IMPORTED_MODULE_42__.StaveHairpinTests),
/* harmony export */   StaveLineTests: () => (/* reexport safe */ _staveline_tests__WEBPACK_IMPORTED_MODULE_43__.StaveLineTests),
/* harmony export */   StaveModifierTests: () => (/* reexport safe */ _stavemodifier_tests__WEBPACK_IMPORTED_MODULE_44__.StaveModifierTests),
/* harmony export */   StaveNoteTests: () => (/* reexport safe */ _stavenote_tests__WEBPACK_IMPORTED_MODULE_45__.StaveNoteTests),
/* harmony export */   StaveTests: () => (/* reexport safe */ _stave_tests__WEBPACK_IMPORTED_MODULE_40__.StaveTests),
/* harmony export */   StaveTieTests: () => (/* reexport safe */ _stavetie_tests__WEBPACK_IMPORTED_MODULE_46__.StaveTieTests),
/* harmony export */   StringNumberTests: () => (/* reexport safe */ _stringnumber_tests__WEBPACK_IMPORTED_MODULE_47__.StringNumberTests),
/* harmony export */   StrokesTests: () => (/* reexport safe */ _strokes_tests__WEBPACK_IMPORTED_MODULE_48__.StrokesTests),
/* harmony export */   StyleTests: () => (/* reexport safe */ _style_tests__WEBPACK_IMPORTED_MODULE_49__.StyleTests),
/* harmony export */   TabNoteTests: () => (/* reexport safe */ _tabnote_tests__WEBPACK_IMPORTED_MODULE_50__.TabNoteTests),
/* harmony export */   TabSlideTests: () => (/* reexport safe */ _tabslide_tests__WEBPACK_IMPORTED_MODULE_51__.TabSlideTests),
/* harmony export */   TabStaveTests: () => (/* reexport safe */ _tabstave_tests__WEBPACK_IMPORTED_MODULE_52__.TabStaveTests),
/* harmony export */   TabTieTests: () => (/* reexport safe */ _tabtie_tests__WEBPACK_IMPORTED_MODULE_53__.TabTieTests),
/* harmony export */   TextBracketTests: () => (/* reexport safe */ _textbracket_tests__WEBPACK_IMPORTED_MODULE_54__.TextBracketTests),
/* harmony export */   TextNoteTests: () => (/* reexport safe */ _textnote_tests__WEBPACK_IMPORTED_MODULE_55__.TextNoteTests),
/* harmony export */   ThreeVoicesTests: () => (/* reexport safe */ _threevoice_tests__WEBPACK_IMPORTED_MODULE_56__.ThreeVoicesTests),
/* harmony export */   TickContextTests: () => (/* reexport safe */ _tickcontext_tests__WEBPACK_IMPORTED_MODULE_57__.TickContextTests),
/* harmony export */   TimeSignatureTests: () => (/* reexport safe */ _timesignature_tests__WEBPACK_IMPORTED_MODULE_58__.TimeSignatureTests),
/* harmony export */   TremoloTests: () => (/* reexport safe */ _tremolo_tests__WEBPACK_IMPORTED_MODULE_59__.TremoloTests),
/* harmony export */   TuningTests: () => (/* reexport safe */ _tuning_tests__WEBPACK_IMPORTED_MODULE_60__.TuningTests),
/* harmony export */   TupletTests: () => (/* reexport safe */ _tuplet_tests__WEBPACK_IMPORTED_MODULE_61__.TupletTests),
/* harmony export */   TypeGuardTests: () => (/* reexport safe */ _typeguard_tests__WEBPACK_IMPORTED_MODULE_62__.TypeGuardTests),
/* harmony export */   UnisonTests: () => (/* reexport safe */ _unison_tests__WEBPACK_IMPORTED_MODULE_63__.UnisonTests),
/* harmony export */   VFPrefixTests: () => (/* reexport safe */ _vf_prefix_tests__WEBPACK_IMPORTED_MODULE_64__.VFPrefixTests),
/* harmony export */   VibratoBracketTests: () => (/* reexport safe */ _vibratobracket_tests__WEBPACK_IMPORTED_MODULE_66__.VibratoBracketTests),
/* harmony export */   VibratoTests: () => (/* reexport safe */ _vibrato_tests__WEBPACK_IMPORTED_MODULE_65__.VibratoTests),
/* harmony export */   VoiceTests: () => (/* reexport safe */ _voice_tests__WEBPACK_IMPORTED_MODULE_67__.VoiceTests)
/* harmony export */ });
/* harmony import */ var _accidental_tests__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./accidental_tests */ "./tests/accidental_tests.ts");
/* harmony import */ var _annotation_tests__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./annotation_tests */ "./tests/annotation_tests.ts");
/* harmony import */ var _articulation_tests__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./articulation_tests */ "./tests/articulation_tests.ts");
/* harmony import */ var _auto_beam_formatting_tests__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./auto_beam_formatting_tests */ "./tests/auto_beam_formatting_tests.ts");
/* harmony import */ var _bach_tests__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bach_tests */ "./tests/bach_tests.ts");
/* harmony import */ var _barline_tests__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./barline_tests */ "./tests/barline_tests.ts");
/* harmony import */ var _beam_tests__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./beam_tests */ "./tests/beam_tests.ts");
/* harmony import */ var _bend_tests__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./bend_tests */ "./tests/bend_tests.ts");
/* harmony import */ var _boundingbox_tests__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./boundingbox_tests */ "./tests/boundingbox_tests.ts");
/* harmony import */ var _chordsymbol_tests__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./chordsymbol_tests */ "./tests/chordsymbol_tests.ts");
/* harmony import */ var _clef_tests__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./clef_tests */ "./tests/clef_tests.ts");
/* harmony import */ var _crossbeam_tests__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./crossbeam_tests */ "./tests/crossbeam_tests.ts");
/* harmony import */ var _curve_tests__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./curve_tests */ "./tests/curve_tests.ts");
/* harmony import */ var _dot_tests__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./dot_tests */ "./tests/dot_tests.ts");
/* harmony import */ var _easyscore_tests__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./easyscore_tests */ "./tests/easyscore_tests.ts");
/* harmony import */ var _factory_tests__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./factory_tests */ "./tests/factory_tests.ts");
/* harmony import */ var _font_tests__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./font_tests */ "./tests/font_tests.ts");
/* harmony import */ var _formatter_tests__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./formatter_tests */ "./tests/formatter_tests.ts");
/* harmony import */ var _fraction_tests__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./fraction_tests */ "./tests/fraction_tests.ts");
/* harmony import */ var _ghostnote_tests__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./ghostnote_tests */ "./tests/ghostnote_tests.ts");
/* harmony import */ var _glyphnote_tests__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./glyphnote_tests */ "./tests/glyphnote_tests.ts");
/* harmony import */ var _gracenote_tests__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./gracenote_tests */ "./tests/gracenote_tests.ts");
/* harmony import */ var _gracetabnote_tests__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./gracetabnote_tests */ "./tests/gracetabnote_tests.ts");
/* harmony import */ var _key_clef_tests__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./key_clef_tests */ "./tests/key_clef_tests.ts");
/* harmony import */ var _keymanager_tests__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./keymanager_tests */ "./tests/keymanager_tests.ts");
/* harmony import */ var _keysignature_tests__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./keysignature_tests */ "./tests/keysignature_tests.ts");
/* harmony import */ var _modifier_tests__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./modifier_tests */ "./tests/modifier_tests.ts");
/* harmony import */ var _multimeasurerest_tests__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./multimeasurerest_tests */ "./tests/multimeasurerest_tests.ts");
/* harmony import */ var _music_tests__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./music_tests */ "./tests/music_tests.ts");
/* harmony import */ var _notehead_tests__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./notehead_tests */ "./tests/notehead_tests.ts");
/* harmony import */ var _notesubgroup_tests__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./notesubgroup_tests */ "./tests/notesubgroup_tests.ts");
/* harmony import */ var _offscreencanvas_tests__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./offscreencanvas_tests */ "./tests/offscreencanvas_tests.ts");
/* harmony import */ var _ornament_tests__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./ornament_tests */ "./tests/ornament_tests.ts");
/* harmony import */ var _parser_tests__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./parser_tests */ "./tests/parser_tests.ts");
/* harmony import */ var _pedalmarking_tests__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./pedalmarking_tests */ "./tests/pedalmarking_tests.ts");
/* harmony import */ var _percussion_tests__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./percussion_tests */ "./tests/percussion_tests.ts");
/* harmony import */ var _registry_tests__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./registry_tests */ "./tests/registry_tests.ts");
/* harmony import */ var _renderer_tests__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./renderer_tests */ "./tests/renderer_tests.ts");
/* harmony import */ var _rests_tests__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./rests_tests */ "./tests/rests_tests.ts");
/* harmony import */ var _rhythm_tests__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./rhythm_tests */ "./tests/rhythm_tests.ts");
/* harmony import */ var _stave_tests__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./stave_tests */ "./tests/stave_tests.ts");
/* harmony import */ var _staveconnector_tests__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./staveconnector_tests */ "./tests/staveconnector_tests.ts");
/* harmony import */ var _stavehairpin_tests__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./stavehairpin_tests */ "./tests/stavehairpin_tests.ts");
/* harmony import */ var _staveline_tests__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./staveline_tests */ "./tests/staveline_tests.ts");
/* harmony import */ var _stavemodifier_tests__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./stavemodifier_tests */ "./tests/stavemodifier_tests.ts");
/* harmony import */ var _stavenote_tests__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./stavenote_tests */ "./tests/stavenote_tests.ts");
/* harmony import */ var _stavetie_tests__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./stavetie_tests */ "./tests/stavetie_tests.ts");
/* harmony import */ var _stringnumber_tests__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./stringnumber_tests */ "./tests/stringnumber_tests.ts");
/* harmony import */ var _strokes_tests__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./strokes_tests */ "./tests/strokes_tests.ts");
/* harmony import */ var _style_tests__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./style_tests */ "./tests/style_tests.ts");
/* harmony import */ var _tabnote_tests__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./tabnote_tests */ "./tests/tabnote_tests.ts");
/* harmony import */ var _tabslide_tests__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./tabslide_tests */ "./tests/tabslide_tests.ts");
/* harmony import */ var _tabstave_tests__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./tabstave_tests */ "./tests/tabstave_tests.ts");
/* harmony import */ var _tabtie_tests__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./tabtie_tests */ "./tests/tabtie_tests.ts");
/* harmony import */ var _textbracket_tests__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./textbracket_tests */ "./tests/textbracket_tests.ts");
/* harmony import */ var _textnote_tests__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./textnote_tests */ "./tests/textnote_tests.ts");
/* harmony import */ var _threevoice_tests__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./threevoice_tests */ "./tests/threevoice_tests.ts");
/* harmony import */ var _tickcontext_tests__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./tickcontext_tests */ "./tests/tickcontext_tests.ts");
/* harmony import */ var _timesignature_tests__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./timesignature_tests */ "./tests/timesignature_tests.ts");
/* harmony import */ var _tremolo_tests__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./tremolo_tests */ "./tests/tremolo_tests.ts");
/* harmony import */ var _tuning_tests__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./tuning_tests */ "./tests/tuning_tests.ts");
/* harmony import */ var _tuplet_tests__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./tuplet_tests */ "./tests/tuplet_tests.ts");
/* harmony import */ var _typeguard_tests__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./typeguard_tests */ "./tests/typeguard_tests.ts");
/* harmony import */ var _unison_tests__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./unison_tests */ "./tests/unison_tests.ts");
/* harmony import */ var _vf_prefix_tests__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./vf_prefix_tests */ "./tests/vf_prefix_tests.ts");
/* harmony import */ var _vibrato_tests__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./vibrato_tests */ "./tests/vibrato_tests.ts");
/* harmony import */ var _vibratobracket_tests__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./vibratobracket_tests */ "./tests/vibratobracket_tests.ts");
/* harmony import */ var _voice_tests__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./voice_tests */ "./tests/voice_tests.ts");
// vexflow-debug-with-tests.ts includes this module via:
//   export * from '../../tests';
//
// To add a new test module, add a new line:
//   `export * from './xxxx_tests';`
// to this file that points to the new file `xxxx_tests.ts`.
//
// The test module needs to call VexFlowTests.register(...).
// For example, in annotation_tests.ts, the last two lines are:
//   VexFlowTests.register(AnnotationTests);
//   export { AnnotationTests };
//
// In vexflow_test_helpers.ts: VexFlowTests.run() will run all registered tests.
//
// To iterate faster during development, you can comment out most of this file
// and focus on just testing the module(s) you are currently working on.






































































/***/ }),

/***/ "./tests/key_clef_tests.ts":
/*!*********************************!*\
  !*** ./tests/key_clef_tests.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ClefKeySignatureTests: () => (/* binding */ ClefKeySignatureTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/element */ "./src/element.ts");
/* harmony import */ var _src_keysignature__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/keysignature */ "./src/keysignature.ts");
/* harmony import */ var _src_stave__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/stave */ "./src/stave.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Clef Key Signature Tests
//




const ClefKeySignatureTests = {
    Start() {
        QUnit.module('Clef Keys');
        // Removed an identical 'Key Parser Test'. See keysignature_tests.ts.
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Major Key Clef Test', keys, { majorKeys: true });
        run('Minor Key Clef Test', keys, { majorKeys: false });
        run('Stave Helper', staveHelper);
    },
};
function getWidth(code) {
    const el = new _src_element__WEBPACK_IMPORTED_MODULE_1__.Element();
    el.setText(code);
    return el.getWidth();
}
const fontWidths = () => {
    const sharpWidth = getWidth('\ue262' /*accidentalSharp*/) + 1;
    const flatWidth = getWidth('\ue260' /*accidentalFlat*/) + 1;
    const ksPadding = 10; // hard-coded in keysignature.ts
    const naturalWidth = getWidth('\ue261' /*accidentalNatural*/) + 2;
    const clefWidth = getWidth('\ue050' /*gClef*/); // widest clef
    return { sharpWidth, flatWidth, naturalWidth, clefWidth, ksPadding };
};
function keys(options, contextBuilder) {
    const w = fontWidths();
    const accidentalCount = 28; // total number in all the keys
    const sharpTestWidth = accidentalCount * w.sharpWidth + w.clefWidth + _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave.defaultPadding + 6 * w.ksPadding;
    const flatTestWidth = accidentalCount * w.flatWidth + w.clefWidth + _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave.defaultPadding + 6 * w.ksPadding;
    const clefs = [
        'treble',
        'soprano',
        'mezzo-soprano',
        'alto',
        'tenor',
        'baritone-f',
        'baritone-c',
        'bass',
        'french',
        'subbass',
        'percussion',
    ];
    const ctx = contextBuilder(options.elementId, Math.max(sharpTestWidth, flatTestWidth) + 100, 20 + 80 * 2 * clefs.length);
    const staves = [];
    const keys = options.params.majorKeys ? _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.MAJOR_KEYS : _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.MINOR_KEYS;
    let i;
    let flat;
    let sharp;
    let keySig;
    const yOffsetForFlatStaves = 10 + 80 * clefs.length;
    for (i = 0; i < clefs.length; i++) {
        // Render all the sharps first, then all the flats:
        staves[i] = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(10, 10 + 80 * i, flatTestWidth);
        staves[i].addClef(clefs[i]);
        staves[i + clefs.length] = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(10, yOffsetForFlatStaves + 10 + 80 * i, sharpTestWidth);
        staves[i + clefs.length].addClef(clefs[i]);
        for (flat = 0; flat < 8; flat++) {
            keySig = new _src_keysignature__WEBPACK_IMPORTED_MODULE_2__.KeySignature(keys[flat]);
            keySig.addToStave(staves[i]);
        }
        for (sharp = 8; sharp < keys.length; sharp++) {
            keySig = new _src_keysignature__WEBPACK_IMPORTED_MODULE_2__.KeySignature(keys[sharp]);
            keySig.addToStave(staves[i + clefs.length]);
        }
    }
    _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave.formatBegModifiers(staves);
    for (i = 0; i < clefs.length; i++) {
        staves[i].setContext(ctx);
        staves[i].draw();
        staves[i + clefs.length].setContext(ctx);
        staves[i + clefs.length].draw();
    }
    options.assert.ok(true, 'all pass');
}
function staveHelper(options, contextBuilder) {
    const w = fontWidths();
    const accidentalCount = 28; // total number in all the keys
    const sharpTestWidth = accidentalCount * w.sharpWidth + w.clefWidth + _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave.defaultPadding + 7 * w.ksPadding;
    const flatTestWidth = accidentalCount * w.flatWidth + w.clefWidth + _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave.defaultPadding + 7 * w.ksPadding;
    const ctx = contextBuilder(options.elementId, Math.max(sharpTestWidth, flatTestWidth) + 100, 400);
    const stave1 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(10, 10, flatTestWidth);
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(10, 90, flatTestWidth);
    const stave3 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(10, 170, sharpTestWidth);
    const stave4 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(10, 260, sharpTestWidth);
    const keys = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.MAJOR_KEYS;
    stave1.addClef('treble');
    stave2.addClef('bass');
    stave3.addClef('alto');
    stave4.addClef('tenor');
    for (let n = 0; n < 8; ++n) {
        stave1.addKeySignature(keys[n]);
        stave2.addKeySignature(keys[n]);
    }
    for (let i = 8; i < keys.length; ++i) {
        stave3.addKeySignature(keys[i]);
        stave4.addKeySignature(keys[i]);
    }
    stave1.setContext(ctx);
    stave1.draw();
    stave2.setContext(ctx);
    stave2.draw();
    stave3.setContext(ctx);
    stave3.draw();
    stave4.setContext(ctx);
    stave4.draw();
    options.assert.ok(true, 'all pass');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(ClefKeySignatureTests);



/***/ }),

/***/ "./tests/keymanager_tests.ts":
/*!***********************************!*\
  !*** ./tests/keymanager_tests.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeyManagerTests: () => (/* binding */ KeyManagerTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/index */ "./src/index.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Music Key Management Tests
//
// TODO: KeyManager.getAccidental(key) specifies that the return value's .accidental property is string | undefined.
//       However, we check it against null.


const KeyManagerTests = {
    Start() {
        QUnit.module('KeyManager');
        QUnit.test('Valid Notes', works);
        QUnit.test('Select Notes', selectNotes);
    },
};
function works(assert) {
    const manager = new _src_index__WEBPACK_IMPORTED_MODULE_1__.KeyManager('g');
    assert.equal(manager.getAccidental('f').accidental, '#');
    manager.setKey('a');
    assert.equal(manager.getAccidental('c').accidental, '#');
    assert.equal(manager.getAccidental('a').accidental, null);
    assert.equal(manager.getAccidental('f').accidental, '#');
    manager.setKey('A');
    assert.equal(manager.getAccidental('c').accidental, '#');
    assert.equal(manager.getAccidental('a').accidental, null);
    assert.equal(manager.getAccidental('f').accidental, '#');
}
function selectNotes(assert) {
    const manager = new _src_index__WEBPACK_IMPORTED_MODULE_1__.KeyManager('f');
    assert.equal(manager.selectNote('bb').note, 'bb');
    assert.equal(manager.selectNote('bb').accidental, 'b');
    assert.equal(manager.selectNote('g').note, 'g');
    assert.equal(manager.selectNote('g').accidental, null);
    assert.equal(manager.selectNote('b').note, 'b');
    assert.equal(manager.selectNote('b').accidental, null);
    assert.equal(manager.selectNote('a#').note, 'bb');
    assert.equal(manager.selectNote('g#').note, 'g#');
    // Changes have no effect?
    assert.equal(manager.selectNote('g#').note, 'g#');
    assert.equal(manager.selectNote('bb').note, 'bb');
    assert.equal(manager.selectNote('bb').accidental, 'b');
    assert.equal(manager.selectNote('g').note, 'g');
    assert.equal(manager.selectNote('g').accidental, null);
    assert.equal(manager.selectNote('b').note, 'b');
    assert.equal(manager.selectNote('b').accidental, null);
    assert.equal(manager.selectNote('a#').note, 'bb');
    assert.equal(manager.selectNote('g#').note, 'g#');
    // Changes should propagate
    manager.reset();
    assert.equal(manager.selectNote('g#').change, true);
    assert.equal(manager.selectNote('g#').change, false);
    assert.equal(manager.selectNote('g').change, true);
    assert.equal(manager.selectNote('g').change, false);
    assert.equal(manager.selectNote('g#').change, true);
    manager.reset();
    let note = manager.selectNote('bb');
    assert.equal(note.change, false);
    assert.equal(note.accidental, 'b');
    note = manager.selectNote('g');
    assert.equal(note.change, false);
    assert.equal(note.accidental, null);
    note = manager.selectNote('g#');
    assert.equal(note.change, true);
    assert.equal(note.accidental, '#');
    note = manager.selectNote('g');
    assert.equal(note.change, true);
    assert.equal(note.accidental, null);
    note = manager.selectNote('g');
    assert.equal(note.change, false);
    assert.equal(note.accidental, null);
    note = manager.selectNote('g#');
    assert.equal(note.change, true);
    assert.equal(note.accidental, '#');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(KeyManagerTests);



/***/ }),

/***/ "./tests/keysignature_tests.ts":
/*!*************************************!*\
  !*** ./tests/keysignature_tests.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeySignatureTests: () => (/* binding */ KeySignatureTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/element */ "./src/element.ts");
/* harmony import */ var _src_flow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/flow */ "./src/flow.ts");
/* harmony import */ var _src_keysignature__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/keysignature */ "./src/keysignature.ts");
/* harmony import */ var _src_stave__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/stave */ "./src/stave.ts");
/* harmony import */ var _src_stavebarline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/stavebarline */ "./src/stavebarline.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Key Signature Tests
//






const KeySignatureTests = {
    Start() {
        QUnit.module('KeySignature');
        QUnit.test('Key Parser Test', parser);
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Major Key Test', majorKeys);
        run('Minor Key Test', minorKeys);
        run('Stave Helper', staveHelper);
        run('Cancelled key test', majorKeysCanceled);
        run('Cancelled key (for each clef) test', keysCanceledForEachClef);
        run('Altered key test', majorKeysAltered);
        run('End key with clef test', endKeyWithClef);
        run('Key Signature Change test', changeKey);
    },
};
function getWidth(code) {
    const el = new _src_element__WEBPACK_IMPORTED_MODULE_1__.Element();
    el.setText(code);
    return el.getWidth();
}
const fontWidths = () => {
    const sharpWidth = getWidth('\ue262' /*accidentalSharp*/) + 1;
    const flatWidth = getWidth('\ue260' /*accidentalFlat*/) + 1;
    const naturalWidth = getWidth('\ue261' /*accidentalNatural*/) + 2;
    const clefWidth = getWidth('\ue050' /*gClef*/) * 2; // widest clef
    return { sharpWidth, flatWidth, naturalWidth, clefWidth };
};
function parser(assert) {
    assert.expect(11);
    function catchError(spec) {
        assert.throws(() => _src_flow__WEBPACK_IMPORTED_MODULE_2__.Flow.keySignature(spec), /BadKeySignature/);
    }
    catchError('asdf');
    catchError('D!');
    catchError('E#');
    catchError('D#');
    catchError('#');
    catchError('b');
    catchError('Kb');
    catchError('Fb');
    catchError('Dbm');
    catchError('B#m');
    _src_flow__WEBPACK_IMPORTED_MODULE_2__.Flow.keySignature('B');
    _src_flow__WEBPACK_IMPORTED_MODULE_2__.Flow.keySignature('C');
    _src_flow__WEBPACK_IMPORTED_MODULE_2__.Flow.keySignature('Fm');
    _src_flow__WEBPACK_IMPORTED_MODULE_2__.Flow.keySignature('Ab');
    _src_flow__WEBPACK_IMPORTED_MODULE_2__.Flow.keySignature('Abm');
    _src_flow__WEBPACK_IMPORTED_MODULE_2__.Flow.keySignature('F#');
    _src_flow__WEBPACK_IMPORTED_MODULE_2__.Flow.keySignature('G#m');
    assert.ok(true, 'all pass');
}
function majorKeys(options, contextBuilder) {
    const w = fontWidths();
    const accidentalCount = 28; // total number in all the keys
    const casePadding = 10; // hard-coded in staveModifier
    const testCases = 7; // all keys, but includes key of C
    const sharpTestWidth = accidentalCount * w.sharpWidth + casePadding * testCases + _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave.defaultPadding;
    const flatTestWidth = accidentalCount * w.flatWidth + casePadding * testCases + _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave.defaultPadding;
    const ctx = contextBuilder(options.elementId, Math.max(sharpTestWidth, flatTestWidth) + 100, 240);
    const stave1 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 10, flatTestWidth);
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 90, sharpTestWidth);
    const keys = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.MAJOR_KEYS;
    let keySig = null;
    for (let i = 0; i < 8; ++i) {
        keySig = new _src_keysignature__WEBPACK_IMPORTED_MODULE_3__.KeySignature(keys[i]);
        keySig.addToStave(stave1);
    }
    for (let n = 8; n < keys.length; ++n) {
        keySig = new _src_keysignature__WEBPACK_IMPORTED_MODULE_3__.KeySignature(keys[n]);
        keySig.addToStave(stave2);
    }
    stave1.setContext(ctx);
    stave1.draw();
    stave2.setContext(ctx);
    stave2.draw();
    options.assert.ok(true, 'all pass');
}
function majorKeysCanceled(options, contextBuilder) {
    const scale = 0.9;
    const w = fontWidths();
    const flatPadding = 18;
    const sharpPadding = 20;
    const flatTestCases = 8;
    const sharpTestCases = 7;
    // magic numbers are the numbers of that symbol that appear in the test case
    const sharpTestWidth = 28 * w.sharpWidth + 21 * w.naturalWidth + sharpPadding * sharpTestCases + _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave.defaultPadding + w.clefWidth;
    const flatTestWidth = 28 * w.flatWidth + 28 * w.naturalWidth + flatPadding * flatTestCases + _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave.defaultPadding + w.clefWidth;
    const eFlatTestWidth = 28 * w.flatWidth + 32 * w.naturalWidth + flatPadding * flatTestCases + _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave.defaultPadding + w.clefWidth;
    const eSharpTestWidth = 28 * w.sharpWidth + 28 * w.naturalWidth + sharpPadding * sharpTestCases + _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave.defaultPadding + w.clefWidth;
    const maxWidth = Math.max(Math.max(sharpTestWidth, flatTestWidth, Math.max(eSharpTestWidth, eFlatTestWidth)));
    const ctx = contextBuilder(options.elementId, maxWidth + 100, 500);
    ctx.scale(scale, scale);
    const stave1 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 10, flatTestWidth).addClef('treble');
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 90, sharpTestWidth).addClef('treble');
    const stave3 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 170, eFlatTestWidth).addClef('treble');
    const stave4 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 250, eSharpTestWidth).addClef('treble');
    const keys = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.MAJOR_KEYS;
    let keySig = null;
    let i;
    let n;
    for (i = 0; i < 8; ++i) {
        keySig = new _src_keysignature__WEBPACK_IMPORTED_MODULE_3__.KeySignature(keys[i]);
        keySig.cancelKey('Cb');
        keySig.setPadding(flatPadding);
        keySig.addToStave(stave1);
    }
    for (n = 8; n < keys.length; ++n) {
        keySig = new _src_keysignature__WEBPACK_IMPORTED_MODULE_3__.KeySignature(keys[n]);
        keySig.cancelKey('C#');
        keySig.setPadding(sharpPadding);
        keySig.addToStave(stave2);
    }
    for (i = 0; i < 8; ++i) {
        keySig = new _src_keysignature__WEBPACK_IMPORTED_MODULE_3__.KeySignature(keys[i]);
        keySig.cancelKey('E');
        keySig.setPadding(flatPadding);
        keySig.addToStave(stave3);
    }
    for (n = 8; n < keys.length; ++n) {
        keySig = new _src_keysignature__WEBPACK_IMPORTED_MODULE_3__.KeySignature(keys[n]);
        keySig.cancelKey('Ab');
        keySig.setPadding(sharpPadding);
        keySig.addToStave(stave4);
    }
    stave1.setContext(ctx);
    stave1.draw();
    stave2.setContext(ctx);
    stave2.draw();
    stave3.setContext(ctx);
    stave3.draw();
    stave4.setContext(ctx);
    stave4.draw();
    options.assert.ok(true, 'all pass');
}
function keysCanceledForEachClef(options, contextBuilder) {
    const scale = 0.8;
    const w = fontWidths();
    const keyPadding = 10;
    const keys = ['C#', 'Cb'];
    const flatsKey = [7, 14];
    const sharpsKey = [14, 7];
    const natsKey = [7, 7];
    const max = 21 * Math.max(w.sharpWidth, w.flatWidth) * 2 + keyPadding * 6 + _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave.defaultPadding + w.clefWidth;
    const ctx = contextBuilder(options.elementId, max + 100, 380);
    ctx.scale(scale, scale);
    const x = 20;
    let y = 20;
    let tx = x;
    ['bass', 'tenor', 'soprano', 'mezzo-soprano', 'baritone-f'].forEach(function (clef) {
        keys.forEach((key, keyIx) => {
            const cancelKey = keys[(keyIx + 1) % 2];
            const width = flatsKey[keyIx] * w.flatWidth +
                natsKey[keyIx] * w.naturalWidth +
                sharpsKey[keyIx] * w.sharpWidth +
                keyPadding * 3 +
                w.clefWidth +
                _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave.defaultPadding;
            const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(tx, y, width);
            stave.setClef(clef);
            stave.addKeySignature(cancelKey);
            stave.addKeySignature(key, cancelKey);
            stave.addKeySignature(key);
            stave.setContext(ctx).draw();
            tx += width;
        });
        tx = x;
        y += 80;
    });
    options.assert.ok(true, 'all pass');
}
function majorKeysAltered(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 780, 500);
    ctx.scale(0.9, 0.9);
    const stave1 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 10, 750).addClef('treble');
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 90, 750).addClef('treble');
    const stave3 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 170, 750).addClef('treble');
    const stave4 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 250, 750).addClef('treble');
    const keys = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.MAJOR_KEYS;
    let keySig = null;
    let i;
    let n;
    for (i = 0; i < 8; ++i) {
        keySig = new _src_keysignature__WEBPACK_IMPORTED_MODULE_3__.KeySignature(keys[i]);
        keySig.alterKey(['bs', 'bs']);
        keySig.setPadding(18);
        keySig.addToStave(stave1);
    }
    for (n = 8; n < keys.length; ++n) {
        keySig = new _src_keysignature__WEBPACK_IMPORTED_MODULE_3__.KeySignature(keys[n]);
        keySig.alterKey(['+', '+', '+']);
        keySig.setPadding(20);
        keySig.addToStave(stave2);
    }
    for (i = 0; i < 8; ++i) {
        keySig = new _src_keysignature__WEBPACK_IMPORTED_MODULE_3__.KeySignature(keys[i]);
        keySig.alterKey(['n', 'bs', 'bb']);
        keySig.setPadding(18);
        keySig.addToStave(stave3);
    }
    for (n = 8; n < keys.length; ++n) {
        keySig = new _src_keysignature__WEBPACK_IMPORTED_MODULE_3__.KeySignature(keys[n]);
        keySig.alterKey(['++', '+', 'n', '+']);
        keySig.setPadding(20);
        keySig.addToStave(stave4);
    }
    stave1.setContext(ctx);
    stave1.draw();
    stave2.setContext(ctx);
    stave2.draw();
    stave3.setContext(ctx);
    stave3.draw();
    stave4.setContext(ctx);
    stave4.draw();
    options.assert.ok(true, 'all pass');
}
function minorKeys(options, contextBuilder) {
    const accidentalCount = 28; // total number in all the keys
    const w = fontWidths();
    const casePadding = 10; // hard-coded in staveModifier
    const testCases = 7; // all keys, but includes key of C
    const sharpTestWidth = accidentalCount * w.sharpWidth + casePadding * testCases + _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave.defaultPadding;
    const flatTestWidth = accidentalCount * w.flatWidth + casePadding * testCases + _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave.defaultPadding;
    const ctx = contextBuilder(options.elementId, Math.max(sharpTestWidth, flatTestWidth) + 100, 240);
    const stave1 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 10, flatTestWidth);
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 90, sharpTestWidth);
    const keys = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.MINOR_KEYS;
    let keySig = null;
    for (let i = 0; i < 8; ++i) {
        keySig = new _src_keysignature__WEBPACK_IMPORTED_MODULE_3__.KeySignature(keys[i]);
        keySig.addToStave(stave1);
    }
    for (let n = 8; n < keys.length; ++n) {
        keySig = new _src_keysignature__WEBPACK_IMPORTED_MODULE_3__.KeySignature(keys[n]);
        keySig.addToStave(stave2);
    }
    stave1.setContext(ctx);
    stave1.draw();
    stave2.setContext(ctx);
    stave2.draw();
    options.assert.ok(true, 'all pass');
}
function endKeyWithClef(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 200);
    ctx.scale(0.9, 0.9);
    const stave1 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 10, 350);
    stave1
        .setKeySignature('G')
        .setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.REPEAT_BEGIN)
        .setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.REPEAT_END)
        .setClef('treble')
        .addTimeSignature('4/4')
        .setEndClef('bass')
        .setEndKeySignature('Cb');
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 90, 350);
    stave2.setKeySignature('Cb').setClef('bass').setEndClef('treble').setEndKeySignature('G');
    stave1.setContext(ctx).draw();
    stave2.setContext(ctx).draw();
    options.assert.ok(true, 'all pass');
}
function staveHelper(options, contextBuilder) {
    const w = fontWidths();
    const accidentalCount = 28; // total number in all the keys
    const casePadding = 10; // hard-coded in staveModifier
    const testCases = 7; // all keys, but includes key of C
    const sharpTestWidth = accidentalCount * w.sharpWidth + casePadding * testCases + _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave.defaultPadding;
    const flatTestWidth = accidentalCount * w.flatWidth + casePadding * testCases + _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave.defaultPadding;
    const ctx = contextBuilder(options.elementId, Math.max(sharpTestWidth, flatTestWidth) + 100, 240);
    const stave1 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 10, flatTestWidth);
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 90, sharpTestWidth);
    const keys = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.MAJOR_KEYS;
    for (let i = 0; i < 8; ++i) {
        stave1.addKeySignature(keys[i]);
    }
    for (let n = 8; n < keys.length; ++n) {
        stave2.addKeySignature(keys[n]);
    }
    stave1.setContext(ctx);
    stave1.draw();
    stave2.setContext(ctx);
    stave2.draw();
    options.assert.ok(true, 'all pass');
}
function changeKey(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 900);
    // The previous code was buggy: f.Stave(10, 10, 800), even though Factory.Stave() only accepts 1 argument.
    const stave = f.Stave({ x: 10, y: 10, width: 800 }).addClef('treble').addTimeSignature('C|');
    const voice = f
        .Voice()
        .setStrict(false)
        .addTickables([
        f.KeySigNote({ key: 'Bb' }),
        f.StaveNote({ keys: ['c/4'], duration: '1' }),
        f.BarNote(),
        f.KeySigNote({ key: 'D', cancelKey: 'Bb' }),
        f.StaveNote({ keys: ['c/4'], duration: '1' }),
        f.BarNote(),
        f.KeySigNote({ key: 'Bb' }),
        f.StaveNote({ keys: ['c/4'], duration: '1' }),
        f.BarNote(),
        f.KeySigNote({ key: 'D', alterKey: ['b', 'n'] }),
        f.StaveNote({ keys: ['c/4'], duration: '1' }),
    ]);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'all pass');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(KeySignatureTests);



/***/ }),

/***/ "./tests/mocks.ts":
/*!************************!*\
  !*** ./tests/mocks.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MockTickable: () => (/* binding */ MockTickable)
/* harmony export */ });
/* harmony import */ var _src_fraction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/fraction */ "./src/fraction.ts");
/* harmony import */ var _src_tickable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/tickable */ "./src/tickable.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// TickContext Mocks


class MockTickable extends _src_tickable__WEBPACK_IMPORTED_MODULE_1__.Tickable {
    constructor() {
        super(...arguments);
        this.ticks = new _src_fraction__WEBPACK_IMPORTED_MODULE_0__.Fraction(1, 1);
        this.ignoreTicks = false;
    }
    init() {
        // DO NOTHING.
    }
    getX() {
        // eslint-disable-next-line
        return this.tickContext.getX();
    }
    getIntrinsicTicks() {
        return this.ticks.value();
    }
    getTicks() {
        return this.ticks;
    }
    setTicks(t) {
        this.ticks = new _src_fraction__WEBPACK_IMPORTED_MODULE_0__.Fraction(t, 1);
        return this;
    }
    // Called by TickContext.preFormat().
    getMetrics() {
        return {
            width: 0,
            glyphWidth: 0,
            notePx: this.width,
            modLeftPx: 0,
            modRightPx: 0,
            leftDisplacedHeadPx: 0,
            rightDisplacedHeadPx: 0,
            glyphPx: 0,
        };
    }
    getWidth() {
        return this.width;
    }
    setWidth(w) {
        this.width = w;
        return this;
    }
    setVoice(v) {
        this.voice = v;
        return this;
    }
    setStave(stave) {
        this.stave = stave;
        return this;
    }
    getStave() {
        return this.stave;
    }
    setTickContext(tc) {
        this.tickContext = tc;
        return this;
    }
    setIgnoreTicks(flag) {
        this.ignoreTicks = flag;
        return this;
    }
    shouldIgnoreTicks() {
        return this.ignoreTicks;
    }
    preFormat() {
        // DO NOTHING.
    }
    // eslint-disable-next-line
    draw(...args) {
        // DO NOTHING.
    }
}



/***/ }),

/***/ "./tests/modifier_tests.ts":
/*!*********************************!*\
  !*** ./tests/modifier_tests.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ModifierContextTests: () => (/* binding */ ModifierContextTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/index */ "./src/index.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// ModifierContext Tests


const ModifierContextTests = {
    Start() {
        QUnit.module('ModifierContext');
        QUnit.test('Modifier Width Test', width);
        QUnit.test('Modifier Management', management);
    },
};
function width(assert) {
    const mc = new _src_index__WEBPACK_IMPORTED_MODULE_1__.ModifierContext();
    assert.equal(mc.getWidth(), 0, 'New modifier context has no width');
}
function management(assert) {
    const mc = new _src_index__WEBPACK_IMPORTED_MODULE_1__.ModifierContext();
    const modifier1 = new _src_index__WEBPACK_IMPORTED_MODULE_1__.Modifier();
    const modifier2 = new _src_index__WEBPACK_IMPORTED_MODULE_1__.Modifier();
    mc.addMember(modifier1);
    mc.addMember(modifier2);
    const modifiers = mc.getMembers(_src_index__WEBPACK_IMPORTED_MODULE_1__.Modifier.CATEGORY);
    assert.equal(modifiers.length, 2, 'Added two modifiers');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(ModifierContextTests);



/***/ }),

/***/ "./tests/multimeasurerest_tests.ts":
/*!*****************************************!*\
  !*** ./tests/multimeasurerest_tests.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MultiMeasureRestTests: () => (/* binding */ MultiMeasureRestTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/element */ "./src/element.ts");
/* harmony import */ var _src_flow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/flow */ "./src/flow.ts");
/* harmony import */ var _src_metrics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/metrics */ "./src/metrics.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// MultiMeasureRest Tests




const MultiMeasureRestTests = {
    Start() {
        QUnit.module('MultiMeasureRest');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Simple Test', simple);
        run('Stave with modifiers Test', staveWithModifiers);
    },
};
function simple(options) {
    const width = 910;
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, width, 300);
    const lineSpacing15px = { options: { spacingBetweenLinesPx: 15 } };
    // Each item below is an array that contains:
    //   item[0] => staveParams to adjust vertical spacing between lines
    //   item[1] => multiMeasureRestParams
    // eslint-disable-next-line
    const params = [
        [{}, { numberOfMeasures: 2, showNumber: false }],
        [{}, { numberOfMeasures: 2 }],
        [{}, { numberOfMeasures: 2, lineThickness: 8, serifThickness: 3 }],
        [{}, { numberOfMeasures: 1, useSymbols: true }],
        [{}, { numberOfMeasures: 2, useSymbols: true }],
        [{}, { numberOfMeasures: 3, useSymbols: true }],
        [{}, { numberOfMeasures: 4, useSymbols: true }],
        [{}, { numberOfMeasures: 5, useSymbols: true }],
        [{}, { numberOfMeasures: 6, useSymbols: true }],
        [{}, { numberOfMeasures: 7, useSymbols: true }],
        [{}, { numberOfMeasures: 8, useSymbols: true }],
        [{}, { numberOfMeasures: 9, useSymbols: true }],
        [{}, { numberOfMeasures: 10, useSymbols: true }],
        [{}, { numberOfMeasures: 11, useSymbols: true }],
        [{}, { numberOfMeasures: 11, useSymbols: false, paddingLeft: 20, paddingRight: 20 }],
        [{}, { numberOfMeasures: 11, useSymbols: true, symbolSpacing: 5 }],
        [{}, { numberOfMeasures: 11, useSymbols: false, line: 3, numberLine: 2 }],
        [{}, { numberOfMeasures: 11, useSymbols: true, line: 3, numberLine: 2 }],
        [lineSpacing15px, { numberOfMeasures: 12 }],
        [lineSpacing15px, { numberOfMeasures: 9, useSymbols: true }],
        [lineSpacing15px, { numberOfMeasures: 12, spacingBetweenLinesPx: 15, numberGlyphPoint: 40 * 1.5 }],
        [
            lineSpacing15px,
            {
                numberOfMeasures: 9,
                spacingBetweenLinesPx: 15,
                useSymbols: true,
                numberGlyphPoint: 40 * 1.5,
            },
        ],
        [
            lineSpacing15px,
            {
                numberOfMeasures: 9,
                spacingBetweenLinesPx: 15,
                useSymbols: true,
                numberGlyphPoint: 40 * 1.5,
                semibreveRestGlyphScale: _src_flow__WEBPACK_IMPORTED_MODULE_2__.Flow.NOTATION_FONT_SCALE * 1.5,
            },
        ],
    ];
    const staveWidth = 100;
    let x = 0;
    let y = 0;
    const mmRests = params.map((param) => {
        if (x + staveWidth * 2 > width) {
            x = 0;
            y += 80;
        }
        const staveParams = param[0];
        const mmRestParams = param[1];
        staveParams.x = x;
        staveParams.y = y;
        staveParams.width = staveWidth;
        x += staveWidth;
        const stave = f.Stave(staveParams);
        return f.MultiMeasureRest(mmRestParams).setStave(stave);
    });
    f.draw();
    const xs = mmRests[0].getXs();
    // eslint-disable-next-line
    const strY = mmRests[0].getStave().getYForLine(-0.5);
    const str = 'TACET';
    const context = f.getContext();
    const element = new _src_element__WEBPACK_IMPORTED_MODULE_1__.Element();
    element.setText(str);
    element.setFont(_src_metrics__WEBPACK_IMPORTED_MODULE_3__.Metrics.get('fontFamily'), 16, 'bold');
    element.renderText(context, xs.left + (xs.right - xs.left) * 0.5 - element.getWidth() * 0.5, strY);
    options.assert.ok(true, 'Simple Test');
}
function staveWithModifiers(options) {
    const width = 910;
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, width, 200);
    let x = 0;
    let y = 0;
    // eslint-disable-next-line
    const params = [
        [{ clef: 'treble', params: { width: 150 } }, { numberOfMeasures: 5 }],
        [{ clef: 'treble', keySig: 'G', params: { width: 150 } }, { numberOfMeasures: 5 }],
        [{ clef: 'treble', timeSig: '4/4', keySig: 'G', params: { width: 150 } }, { numberOfMeasures: 5 }],
        [{ clef: 'treble', endClef: 'bass', params: { width: 150 } }, { numberOfMeasures: 5 }],
        [{ clef: 'treble', endKeySig: 'F', params: { width: 150 } }, { numberOfMeasures: 5 }],
        [{ clef: 'treble', endTimeSig: '2/4', params: { width: 150 } }, { numberOfMeasures: 5 }],
        [{ clef: 'treble', endClef: 'bass', endTimeSig: '2/4', params: { width: 150 } }, { numberOfMeasures: 5 }],
        [
            { clef: 'treble', endClef: 'bass', endTimeSig: '2/4', params: { width: 150 } },
            { numberOfMeasures: 5, useSymbols: true },
        ],
    ];
    params.forEach((param) => {
        const staveOptions = param[0];
        // eslint-disable-next-line
        const staveParams = staveOptions.params;
        const mmrestParams = param[1];
        if (x + staveParams.width > width) {
            x = 0;
            y += 80;
        }
        staveParams.x = x;
        x += staveParams.width;
        staveParams.y = y;
        const stave = f.Stave(staveParams);
        if (staveOptions.clef) {
            stave.addClef(staveOptions.clef);
        }
        if (staveOptions.timeSig) {
            stave.addTimeSignature(staveOptions.timeSig);
        }
        if (staveOptions.keySig) {
            stave.addKeySignature(staveOptions.keySig);
        }
        if (staveOptions.endClef) {
            stave.addEndClef(staveOptions.endClef);
        }
        if (staveOptions.endKeySig) {
            stave.setEndKeySignature(staveOptions.endKeySig);
        }
        if (staveOptions.endTimeSig) {
            stave.setEndTimeSignature(staveOptions.endTimeSig);
        }
        return f.MultiMeasureRest(mmrestParams).setStave(stave);
    });
    f.draw();
    options.assert.ok(true, 'Stave with modifiers Test');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(MultiMeasureRestTests);



/***/ }),

/***/ "./tests/music_tests.ts":
/*!******************************!*\
  !*** ./tests/music_tests.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MusicTests: () => (/* binding */ MusicTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_keymanager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/keymanager */ "./src/keymanager.ts");
/* harmony import */ var _src_music__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/music */ "./src/music.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Music Tests



const MusicTests = {
    Start() {
        QUnit.module('MusicTests');
        QUnit.test('Valid Notes', validNotes);
        QUnit.test('Valid Keys', validKeys);
        QUnit.test('Note Values', noteValue);
        QUnit.test('Interval Values', intervalValue);
        QUnit.test('Relative Notes', relativeNotes);
        QUnit.test('Relative Note Names', relativeNoteNames);
        QUnit.test('Canonical Notes', canonicalNotes);
        QUnit.test('Canonical Intervals', canonicalIntervals);
        QUnit.test('Scale Tones', scaleTones);
        QUnit.test('Scale Intervals', scaleIntervals);
    },
};
function validNotes(assert) {
    assert.expect(10);
    const music = new _src_music__WEBPACK_IMPORTED_MODULE_2__.Music();
    let parts = music.getNoteParts('c');
    assert.equal(parts.root, 'c');
    assert.equal(parts.accidental, null);
    // getNoteParts() converts its argument to lowercase.
    parts = music.getNoteParts('C');
    assert.equal(parts.root, 'c');
    assert.equal(parts.accidental, null);
    parts = music.getNoteParts('c#');
    assert.equal(parts.root, 'c');
    assert.equal(parts.accidental, '#');
    parts = music.getNoteParts('c##');
    assert.equal(parts.root, 'c');
    assert.equal(parts.accidental, '##');
    assert.throws(() => music.getNoteParts('r'), /BadArguments/, 'Invalid note: r');
    assert.throws(() => music.getNoteParts(''), /BadArguments/, "Invalid note: ''");
}
function validKeys(assert) {
    assert.expect(18);
    const music = new _src_music__WEBPACK_IMPORTED_MODULE_2__.Music();
    let parts = music.getKeyParts('c');
    assert.equal(parts.root, 'c');
    assert.equal(parts.accidental, null);
    assert.equal(parts.type, 'M');
    parts = music.getKeyParts('d#');
    assert.equal(parts.root, 'd');
    assert.equal(parts.accidental, '#');
    assert.equal(parts.type, 'M');
    parts = music.getKeyParts('fbm');
    assert.equal(parts.root, 'f');
    assert.equal(parts.accidental, 'b');
    assert.equal(parts.type, 'm');
    parts = music.getKeyParts('c#mel');
    assert.equal(parts.root, 'c');
    assert.equal(parts.accidental, '#');
    assert.equal(parts.type, 'mel');
    parts = music.getKeyParts('g#harm');
    assert.equal(parts.root, 'g');
    assert.equal(parts.accidental, '#');
    assert.equal(parts.type, 'harm');
    assert.throws(() => music.getKeyParts('r'), /BadArguments/, 'Invalid key: r');
    assert.throws(() => music.getKeyParts(''), /BadArguments/, `Invalid key: ''`);
    assert.throws(() => music.getKeyParts('#m'), /BadArguments/, 'Invalid key: #m');
}
function noteValue(assert) {
    assert.expect(3);
    const music = new _src_music__WEBPACK_IMPORTED_MODULE_2__.Music();
    let note = music.getNoteValue('c');
    assert.equal(note, 0);
    assert.throws(() => music.getNoteValue('r'), /BadArguments/, 'Invalid note name');
    note = music.getNoteValue('f#');
    assert.equal(note, 6);
}
function intervalValue(assert) {
    assert.expect(2);
    const music = new _src_music__WEBPACK_IMPORTED_MODULE_2__.Music();
    const value = music.getIntervalValue('b2');
    assert.equal(value, 1);
    assert.throws(() => music.getIntervalValue('7'), /BadArguments/, 'Invalid interval name');
}
function relativeNotes(assert) {
    assert.expect(8);
    const music = new _src_music__WEBPACK_IMPORTED_MODULE_2__.Music();
    let value = music.getRelativeNoteValue(music.getNoteValue('c'), music.getIntervalValue('b5'));
    assert.equal(value, 6);
    assert.throws(() => music.getRelativeNoteValue(music.getNoteValue('bc'), music.getIntervalValue('b2')), /BadArguments/, 'Invalid note');
    assert.throws(() => music.getRelativeNoteValue(music.getNoteValue('b'), music.getIntervalValue('p3')), /BadArguments/, 'Invalid interval');
    // Direction
    value = music.getRelativeNoteValue(music.getNoteValue('d'), music.getIntervalValue('2'), -1);
    assert.equal(value, 0);
    assert.throws(() => music.getRelativeNoteValue(music.getNoteValue('b'), music.getIntervalValue('p4'), 0), /BadArguments/, 'Invalid direction: 0');
    // Rollover
    value = music.getRelativeNoteValue(music.getNoteValue('b'), music.getIntervalValue('b5'));
    assert.equal(value, 5);
    // Reverse rollover
    value = music.getRelativeNoteValue(music.getNoteValue('c'), music.getIntervalValue('b2'), -1);
    assert.equal(value, 11);
    // Practical tests
    value = music.getRelativeNoteValue(music.getNoteValue('g'), music.getIntervalValue('p5'));
    assert.equal(value, 2);
}
function relativeNoteNames(assert) {
    assert.expect(9);
    const music = new _src_music__WEBPACK_IMPORTED_MODULE_2__.Music();
    assert.equal(music.getRelativeNoteName('b', music.getNoteValue('c#')), 'b##');
    assert.equal(music.getRelativeNoteName('c', music.getNoteValue('c')), 'c');
    assert.equal(music.getRelativeNoteName('c', music.getNoteValue('db')), 'c#');
    assert.equal(music.getRelativeNoteName('c', music.getNoteValue('b')), 'cb');
    assert.equal(music.getRelativeNoteName('c#', music.getNoteValue('db')), 'c#');
    assert.equal(music.getRelativeNoteName('e', music.getNoteValue('f#')), 'e##');
    assert.equal(music.getRelativeNoteName('e', music.getNoteValue('d#')), 'eb');
    assert.equal(music.getRelativeNoteName('e', music.getNoteValue('fb')), 'e');
    assert.throws(() => music.getRelativeNoteName('e', music.getNoteValue('g#')), /BadArguments/, 'Too far away. Notes not related.');
}
function canonicalNotes(assert) {
    assert.expect(3);
    const music = new _src_music__WEBPACK_IMPORTED_MODULE_2__.Music();
    assert.equal(music.getCanonicalNoteName(0), 'c');
    assert.equal(music.getCanonicalNoteName(2), 'd');
    assert.throws(() => music.getCanonicalNoteName(-1), /BadArguments/, 'Invalid note value');
}
function canonicalIntervals(assert) {
    assert.expect(3);
    const music = new _src_music__WEBPACK_IMPORTED_MODULE_2__.Music();
    assert.equal(music.getCanonicalIntervalName(0), 'unison');
    assert.equal(music.getCanonicalIntervalName(2), 'M2');
    assert.throws(() => music.getCanonicalIntervalName(-1), /BadArguments/, 'Invalid interval value');
}
function scaleTones(assert) {
    assert.expect(24);
    // C Major
    const music = new _src_music__WEBPACK_IMPORTED_MODULE_2__.Music();
    const manager = new _src_keymanager__WEBPACK_IMPORTED_MODULE_1__.KeyManager('CM');
    const C_MAJOR = music.getScaleTones(music.getNoteValue('c'), _src_music__WEBPACK_IMPORTED_MODULE_2__.Music.scales.major);
    let values = ['c', 'd', 'e', 'f', 'g', 'a', 'b'];
    assert.equal(C_MAJOR.length, 7);
    for (let i = 0; i < C_MAJOR.length; ++i) {
        assert.equal(music.getCanonicalNoteName(C_MAJOR[i]), values[i]);
    }
    // Dorian
    const C_DORIAN = music.getScaleTones(music.getNoteValue('c'), _src_music__WEBPACK_IMPORTED_MODULE_2__.Music.scales.dorian);
    values = ['c', 'd', 'eb', 'f', 'g', 'a', 'bb'];
    let note = null;
    assert.equal(C_DORIAN.length, 7);
    for (let i = 0; i < C_DORIAN.length; ++i) {
        note = music.getCanonicalNoteName(C_DORIAN[i]);
        assert.equal(manager.selectNote(note).note, values[i]);
    }
    // Mixolydian
    const C_MIXOLYDIAN = music.getScaleTones(music.getNoteValue('c'), _src_music__WEBPACK_IMPORTED_MODULE_2__.Music.scales.mixolydian);
    values = ['c', 'd', 'e', 'f', 'g', 'a', 'bb'];
    assert.equal(C_MIXOLYDIAN.length, 7);
    for (let i = 0; i < C_MIXOLYDIAN.length; ++i) {
        note = music.getCanonicalNoteName(C_MIXOLYDIAN[i]);
        assert.equal(manager.selectNote(note).note, values[i]);
    }
}
function scaleIntervals(assert) {
    assert.expect(6);
    const m = new _src_music__WEBPACK_IMPORTED_MODULE_2__.Music();
    assert.equal(m.getCanonicalIntervalName(m.getIntervalBetween(m.getNoteValue('c'), m.getNoteValue('d'))), 'M2');
    assert.equal(m.getCanonicalIntervalName(m.getIntervalBetween(m.getNoteValue('g'), m.getNoteValue('c'))), 'p4');
    assert.equal(m.getCanonicalIntervalName(m.getIntervalBetween(m.getNoteValue('c'), m.getNoteValue('c'))), 'unison');
    assert.equal(m.getCanonicalIntervalName(m.getIntervalBetween(m.getNoteValue('f'), m.getNoteValue('cb'))), 'dim5');
    // Forwards and backwards
    assert.equal(m.getCanonicalIntervalName(m.getIntervalBetween(m.getNoteValue('d'), m.getNoteValue('c'), 1)), 'b7');
    assert.equal(m.getCanonicalIntervalName(m.getIntervalBetween(m.getNoteValue('d'), m.getNoteValue('c'), -1)), 'M2');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(MusicTests);



/***/ }),

/***/ "./tests/notehead_tests.ts":
/*!*********************************!*\
  !*** ./tests/notehead_tests.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NoteHeadTests: () => (/* binding */ NoteHeadTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_flow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/flow */ "./src/flow.ts");
/* harmony import */ var _src_formatter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/formatter */ "./src/formatter.ts");
/* harmony import */ var _src_notehead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/notehead */ "./src/notehead.ts");
/* harmony import */ var _src_stave__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/stave */ "./src/stave.ts");
/* harmony import */ var _src_stavenote__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/stavenote */ "./src/stavenote.ts");
/* harmony import */ var _src_tickcontext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/tickcontext */ "./src/tickcontext.ts");
/* harmony import */ var _src_voice__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/voice */ "./src/voice.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// NoteHead Tests
// TODO: There is a bug in RenderContext.scale(). The CanvasContext works as expected.
//       Each time you call scale(sx, sy), it multiplies the sx and sy by the currently stored scale.
//       The SVGContext operates differently. It just sets the sx and sy as the new scale, instead of multiplying it.
//       See: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/scale








const NoteHeadTests = {
    Start() {
        QUnit.module('NoteHead');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Basic', basic);
        run('Various Note Heads 1', variousNoteHeads);
        run('Various Note Heads 2', variousNoteHeads2);
        run('Various Heads', variousHeads);
        run('Drum Chord Heads', drumChordHeads);
        run('Bounding Boxes', basicBoundingBoxes);
    },
};
function setContextStyle(ctx) {
    // The final scale should be 1.8.
    ctx.scale(0.9, 0.9);
    ctx.scale(2.0, 2.0);
    //ctx.scale(1.8, 1.8);
    ctx.font = '10pt Arial';
}
function basic(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 450, 250);
    setContextStyle(ctx);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 0, 250).addClef('treble');
    stave.setContext(ctx).draw();
    const formatter = new _src_formatter__WEBPACK_IMPORTED_MODULE_2__.Formatter();
    const voice = new _src_voice__WEBPACK_IMPORTED_MODULE_7__.Voice(_src_flow__WEBPACK_IMPORTED_MODULE_1__.Flow.TIME4_4).setStrict(false);
    const noteHead1 = new _src_notehead__WEBPACK_IMPORTED_MODULE_3__.NoteHead({ duration: '4', line: 3 });
    const noteHead2 = new _src_notehead__WEBPACK_IMPORTED_MODULE_3__.NoteHead({ duration: '1', line: 2.5 });
    const noteHead3 = new _src_notehead__WEBPACK_IMPORTED_MODULE_3__.NoteHead({ duration: '2', line: 0 });
    voice.addTickables([noteHead1, noteHead2, noteHead3]);
    formatter.joinVoices([voice]).formatToStave([voice], stave);
    voice.draw(ctx, stave);
    options.assert.ok('Basic NoteHead test');
}
/**
 * Used by the next two test cases to draw a note.
 */
function showNote(noteStruct, stave, ctx, x) {
    const note = new _src_stavenote__WEBPACK_IMPORTED_MODULE_5__.StaveNote(noteStruct).setStave(stave);
    new _src_tickcontext__WEBPACK_IMPORTED_MODULE_6__.TickContext().addTickable(note).preFormat().setX(x);
    note.setContext(ctx).draw();
    return note;
}
function variousHeads(options, contextBuilder) {
    const notes = [
        { keys: ['g/5/d0'], duration: '4' },
        { keys: ['g/5/d1'], duration: '4' },
        { keys: ['g/5/d2'], duration: '4' },
        { keys: ['g/5/d3'], duration: '4' },
        { keys: ['x/'], duration: '1' },
        { keys: ['g/5/t0'], duration: '1' },
        { keys: ['g/5/t1'], duration: '4' },
        { keys: ['g/5/t2'], duration: '4' },
        { keys: ['g/5/t3'], duration: '4' },
        { keys: ['x/'], duration: '1' },
        { keys: ['g/5/x0'], duration: '1' },
        { keys: ['g/5/x1'], duration: '4' },
        { keys: ['g/5/x2'], duration: '4' },
        { keys: ['g/5/x3'], duration: '4' },
        { keys: ['x/'], duration: '1' },
        { keys: ['g/5/s1'], duration: '4' },
        { keys: ['g/5/s2'], duration: '4' },
        { keys: ['x/'], duration: '1' },
        { keys: ['g/5/r1'], duration: '4' },
        { keys: ['g/5/r2'], duration: '4' },
    ];
    const ctx = contextBuilder(options.elementId, notes.length * 25 + 100, 240);
    // Draw two staves, one with up-stems and one with down-stems.
    for (let staveNum = 0; staveNum < 2; ++staveNum) {
        const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 10 + staveNum * 120, notes.length * 25 + 75)
            .addClef('percussion')
            .setContext(ctx)
            .draw();
        for (let i = 0; i < notes.length; ++i) {
            const note = notes[i];
            note.stemDirection = staveNum === 0 ? -1 : 1;
            const staveNote = showNote(note, stave, ctx, (i + 1) * 25);
            options.assert.ok(staveNote.getX() > 0, 'Note ' + i + ' has X value');
            options.assert.ok(staveNote.getYs().length > 0, 'Note ' + i + ' has Y values');
        }
    }
}
function variousNoteHeads(options, contextBuilder) {
    const notes = [
        { keys: ['g/5/d'], duration: '1/2' },
        { keys: ['g/5/d'], duration: '1' },
        { keys: ['g/5/d'], duration: '2' },
        { keys: ['g/5/d'], duration: '4' },
        { keys: ['x/'], duration: '1' },
        { keys: ['g/5/x'], duration: '1/2' },
        { keys: ['g/5/x'], duration: '1' },
        { keys: ['g/5/x'], duration: '2' },
        { keys: ['g/5/x'], duration: '4' },
        { keys: ['x/'], duration: '1' },
        { keys: ['g/5/cx'], duration: '1/2' },
        { keys: ['g/5/cx'], duration: '1' },
        { keys: ['g/5/cx'], duration: '2' },
        { keys: ['g/5/cx'], duration: '4' },
        { keys: ['x/'], duration: '1' },
        { keys: ['g/5/tu'], duration: '1/2' },
        { keys: ['g/5/tu'], duration: '1' },
        { keys: ['g/5/tu'], duration: '2' },
        { keys: ['g/5/tu'], duration: '4' },
        { keys: ['x/'], duration: '1' },
        { keys: ['g/5/td'], duration: '1/2' },
        { keys: ['g/5/td'], duration: '1' },
        { keys: ['g/5/td'], duration: '2' },
        { keys: ['g/5/td'], duration: '4' },
        { keys: ['x/'], duration: '1' },
        { keys: ['g/5/sf'], duration: '1/2' },
        { keys: ['g/5/sf'], duration: '1' },
        { keys: ['g/5/sf'], duration: '2' },
        { keys: ['g/5/sf'], duration: '4' },
        { keys: ['x/'], duration: '1' },
        { keys: ['g/5/sb'], duration: '1/2' },
        { keys: ['g/5/sb'], duration: '1' },
        { keys: ['g/5/sb'], duration: '2' },
        { keys: ['g/5/sb'], duration: '4' },
        { keys: ['x/'], duration: '1' },
        { keys: ['g/5/ci'], duration: '1/2' },
        { keys: ['g/5/ci'], duration: '1' },
        { keys: ['g/5/ci'], duration: '2' },
        { keys: ['g/5/ci'], duration: '4' },
        { keys: ['x/'], duration: '1' },
        { keys: ['g/5/sq'], duration: '1/2' },
        { keys: ['g/5/sq'], duration: '1' },
        { keys: ['g/5/sq'], duration: '2' },
        { keys: ['g/5/sq'], duration: '4' },
        { keys: ['x/'], duration: '1' },
    ];
    const ctx = contextBuilder(options.elementId, notes.length * 25 + 100, 240);
    // Draw two staves, one with up-stems and one with down-stems.
    for (let staveNum = 0; staveNum < 2; ++staveNum) {
        const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 10 + staveNum * 120, notes.length * 25 + 75)
            .addClef('percussion')
            .setContext(ctx)
            .draw();
        for (let i = 0; i < notes.length; ++i) {
            const note = notes[i];
            note.stemDirection = staveNum === 0 ? -1 : 1;
            const staveNote = showNote(note, stave, ctx, (i + 1) * 25);
            options.assert.ok(staveNote.getX() > 0, 'Note ' + i + ' has X value');
            options.assert.ok(staveNote.getYs().length > 0, 'Note ' + i + ' has Y values');
        }
    }
}
function variousNoteHeads2(options, contextBuilder) {
    const notes = [
        { keys: ['g/5/do'], duration: '4', autoStem: true },
        { keys: ['g/5/re'], duration: '4', autoStem: true },
        { keys: ['g/5/mi'], duration: '4', autoStem: true },
        { keys: ['g/5/fa'], duration: '4', autoStem: true },
        { keys: ['e/4/faup'], duration: '4', autoStem: true },
        { keys: ['g/5/so'], duration: '4', autoStem: true },
        { keys: ['g/5/la'], duration: '4', autoStem: true },
        { keys: ['g/5/ti'], duration: '4', autoStem: true },
    ];
    const ctx = contextBuilder(options.elementId, notes.length * 25 + 100, 240);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 10, notes.length * 25 + 75).addClef('percussion').setContext(ctx).draw();
    for (let i = 0; i < notes.length; ++i) {
        const note = notes[i];
        const staveNote = showNote(note, stave, ctx, (i + 1) * 25);
        options.assert.ok(staveNote.getX() > 0, 'Note ' + i + ' has X value');
        options.assert.ok(staveNote.getYs().length > 0, 'Note ' + i + ' has Y values');
    }
}
function drumChordHeads(options, contextBuilder) {
    const notes = [
        { keys: ['a/4/d0', 'g/5/x3'], duration: '4' },
        { keys: ['a/4/x3', 'g/5/d0'], duration: '4' },
        { keys: ['a/4/d1', 'g/5/x2'], duration: '4' },
        { keys: ['a/4/x2', 'g/5/d1'], duration: '4' },
        { keys: ['a/4/d2', 'g/5/x1'], duration: '4' },
        { keys: ['a/4/x1', 'g/5/d2'], duration: '4' },
        { keys: ['a/4/d3', 'g/5/x0'], duration: '4' },
        { keys: ['a/4/x0', 'g/5/d3'], duration: '4' },
        { keys: ['a/4', 'g/5/d0'], duration: '4' },
        { keys: ['a/4/x3', 'g/5'], duration: '4' },
        { keys: ['a/4/t0', 'g/5/s1'], duration: '4' },
        { keys: ['a/4/s1', 'g/5/t0'], duration: '4' },
        { keys: ['a/4/t1', 'g/5/s2'], duration: '4' },
        { keys: ['a/4/s2', 'g/5/t1'], duration: '4' },
        { keys: ['a/4/t2', 'g/5/r1'], duration: '4' },
        { keys: ['a/4/r1', 'g/5/t2'], duration: '4' },
        { keys: ['a/4/t3', 'g/5/r2'], duration: '4' },
        { keys: ['a/4/r2', 'g/5/t3'], duration: '4' },
    ];
    const ctx = contextBuilder(options.elementId, notes.length * 25 + 100, 240);
    // Draw two staves, one with up-stems and one with down-stems.
    for (let h = 0; h < 2; ++h) {
        const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 10 + h * 120, notes.length * 25 + 75).addClef('percussion').setContext(ctx).draw();
        for (let i = 0; i < notes.length; ++i) {
            const note = notes[i];
            note.stemDirection = h === 0 ? -1 : 1;
            const staveNote = showNote(note, stave, ctx, (i + 1) * 25);
            options.assert.ok(staveNote.getX() > 0, 'Note ' + i + ' has X value');
            options.assert.ok(staveNote.getYs().length > 0, 'Note ' + i + ' has Y values');
        }
    }
}
function basicBoundingBoxes(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 450, 250);
    setContextStyle(ctx);
    // 250 is 450/1.8
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 0, 250).addClef('treble');
    stave.setContext(ctx).draw();
    const formatter = new _src_formatter__WEBPACK_IMPORTED_MODULE_2__.Formatter();
    const voice = new _src_voice__WEBPACK_IMPORTED_MODULE_7__.Voice(_src_flow__WEBPACK_IMPORTED_MODULE_1__.Flow.TIME4_4).setStrict(false);
    const nh1 = new _src_stavenote__WEBPACK_IMPORTED_MODULE_5__.StaveNote({ keys: ['b/4'], duration: '4' });
    const nh2 = new _src_stavenote__WEBPACK_IMPORTED_MODULE_5__.StaveNote({ keys: ['a/4'], duration: '2' });
    const nh3 = new _src_notehead__WEBPACK_IMPORTED_MODULE_3__.NoteHead({ duration: '1', line: 0 });
    voice.addTickables([nh1, nh2, nh3]);
    formatter.joinVoices([voice]).formatToStave([voice], stave);
    voice.draw(ctx, stave);
    for (const bb of [nh1.noteHeads[0].getBoundingBox(), nh2.noteHeads[0].getBoundingBox(), nh3.getBoundingBox()]) {
        ctx.rect(bb.getX(), bb.getY(), bb.getW(), bb.getH());
    }
    ctx.stroke();
    options.assert.ok('NoteHead Bounding Boxes');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(NoteHeadTests);



/***/ }),

/***/ "./tests/notesubgroup_tests.ts":
/*!*************************************!*\
  !*** ./tests/notesubgroup_tests.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NoteSubGroupTests: () => (/* binding */ NoteSubGroupTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_barnote__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/barnote */ "./src/barnote.ts");
/* harmony import */ var _src_note__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/note */ "./src/note.ts");
/* harmony import */ var _src_stavebarline__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/stavebarline */ "./src/stavebarline.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
// @author Taehoon Moon 2016
//
// NoteSubGroup Tests




const NoteSubGroupTests = {
    Start() {
        QUnit.module('NoteSubGroup');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Basic - ClefNote, TimeSigNote and BarNote', basic);
        run('Multi Voice', multiVoiceSingleDraw);
        run('Multi Voice Multiple Draws', multiVoiceDoubleDraw);
        run('Multi Staff', multiStaff);
    },
};
// Return three helper functions for creating StaveNotes, and adding Accidental & NoteSubGroup to those StaveNotes.
function createShortcuts(f) {
    return {
        createStaveNote: (noteStruct) => f.StaveNote(noteStruct),
        addAccidental: (note, accid) => note.addModifier(f.Accidental({ type: accid }), 0),
        addSubGroup: (note, subNotes) => note.addModifier(f.NoteSubGroup({ notes: subNotes }), 0),
    };
}
function basic(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 750, 200);
    const ctx = f.getContext();
    const stave = f.Stave({ width: 600 }).addClef('treble');
    const { createStaveNote, addAccidental, addSubGroup } = createShortcuts(f);
    const notes = [
        { keys: ['f/5'], stemDirection: -1, duration: '4' },
        { keys: ['d/4'], stemDirection: -1, duration: '4', clef: 'bass' },
        { keys: ['g/4'], stemDirection: -1, duration: '4', clef: 'alto' },
        { keys: ['a/4'], stemDirection: -1, duration: '4', clef: 'alto' },
        { keys: ['c/4'], stemDirection: -1, duration: '4', clef: 'tenor' },
        { keys: ['c/3'], stemDirection: +1, duration: '4', clef: 'tenor' },
        { keys: ['d/4'], stemDirection: -1, duration: '4', clef: 'tenor' },
        { keys: ['f/4'], stemDirection: -1, duration: '4', clef: 'tenor' },
    ].map(createStaveNote);
    addAccidental(notes[1], '#');
    addAccidental(notes[2], 'n');
    addSubGroup(notes[1], [f.ClefNote({ type: 'bass', options: { size: 'small' } })]);
    addSubGroup(notes[2], [f.ClefNote({ type: 'alto', options: { size: 'small' } })]);
    addSubGroup(notes[4], [f.ClefNote({ type: 'tenor', options: { size: 'small' } }), new _src_barnote__WEBPACK_IMPORTED_MODULE_1__.BarNote()]);
    addSubGroup(notes[5], [f.TimeSigNote({ time: '6/8' })]);
    addSubGroup(notes[6], [new _src_barnote__WEBPACK_IMPORTED_MODULE_1__.BarNote(_src_stavebarline__WEBPACK_IMPORTED_MODULE_3__.BarlineType.REPEAT_BEGIN)]);
    addAccidental(notes[4], 'b');
    addAccidental(notes[6], 'bb');
    const voice = f.Voice().setStrict(false).addTickables(notes);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    notes.forEach((note) => _src_note__WEBPACK_IMPORTED_MODULE_2__.Note.plotMetrics(ctx, note, 150));
    _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.plotLegendForNoteWidth(ctx, 620, 120);
    options.assert.ok(true, 'all pass');
}
function multiVoiceSingleDraw(options) {
    multiVoiceHelper(options, 1);
}
/**
 * Call Factory.draw() twice. It should look identical to the multiVoice test case above.
 */
function multiVoiceDoubleDraw(options) {
    multiVoiceHelper(options, 2);
}
/**
 * Used by multiVoiceSingleDraw and multiVoiceDoubleDraw above.
 */
function multiVoiceHelper(options, numDraws) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 550, 200);
    const ctx = f.getContext();
    const stave = f.Stave().addClef('treble');
    const { createStaveNote, addAccidental, addSubGroup } = createShortcuts(f);
    const notes1 = [
        { keys: ['f/5'], stemDirection: 1, duration: '4' },
        { keys: ['d/4'], stemDirection: 1, duration: '4', clef: 'bass' },
        { keys: ['c/5'], stemDirection: 1, duration: '4', clef: 'alto' },
        { keys: ['c/5'], stemDirection: 1, duration: '4', clef: 'soprano' },
    ].map(createStaveNote);
    const notes2 = [
        { keys: ['c/4'], stemDirection: -1, duration: '4' },
        { keys: ['c/3'], stemDirection: -1, duration: '4', clef: 'bass' },
        { keys: ['d/4'], stemDirection: -1, duration: '4', clef: 'alto' },
        { keys: ['f/4'], stemDirection: -1, duration: '4', clef: 'soprano' },
    ].map(createStaveNote);
    addAccidental(notes1[1], '#');
    addSubGroup(notes1[1], [
        f.ClefNote({ type: 'bass', options: { size: 'small' } }),
        new _src_barnote__WEBPACK_IMPORTED_MODULE_1__.BarNote(_src_stavebarline__WEBPACK_IMPORTED_MODULE_3__.BarlineType.REPEAT_BEGIN),
        f.TimeSigNote({ time: '3/4' }),
    ]);
    addSubGroup(notes2[2], [
        f.ClefNote({ type: 'alto', options: { size: 'small' } }),
        f.TimeSigNote({ time: '9/8' }),
        new _src_barnote__WEBPACK_IMPORTED_MODULE_1__.BarNote(_src_stavebarline__WEBPACK_IMPORTED_MODULE_3__.BarlineType.DOUBLE),
    ]);
    addSubGroup(notes1[3], [f.ClefNote({ type: 'soprano', options: { size: 'small' } })]);
    addAccidental(notes1[2], 'b');
    addAccidental(notes2[3], '#');
    const voices = [f.Voice().addTickables(notes1), f.Voice().addTickables(notes2)];
    f.Formatter().joinVoices(voices).formatToStave(voices, stave);
    for (let i = 0; i < numDraws; i++) {
        f.draw();
    }
    notes1.forEach((note) => _src_note__WEBPACK_IMPORTED_MODULE_2__.Note.plotMetrics(ctx, note, 150));
    options.assert.ok(true, 'all pass');
}
function multiStaff(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 550, 400);
    const { createStaveNote, addAccidental, addSubGroup } = createShortcuts(f);
    const stave1 = f.Stave({ x: 15, y: 30, width: 500 }).setClef('treble');
    const notes1 = [
        { keys: ['f/5'], stemDirection: 1, duration: '4' },
        { keys: ['d/4'], stemDirection: 1, duration: '4', clef: 'bass' },
        { keys: ['c/5'], stemDirection: 1, duration: '4', clef: 'alto' },
        { keys: ['c/5'], stemDirection: 1, duration: '4', clef: 'soprano' },
    ].map(createStaveNote);
    const notes2 = [
        { keys: ['c/4'], stemDirection: -1, duration: '4' },
        { keys: ['c/3'], stemDirection: -1, duration: '4', clef: 'bass' },
        { keys: ['d/4'], stemDirection: -1, duration: '4', clef: 'alto' },
        { keys: ['f/4'], stemDirection: -1, duration: '4', clef: 'soprano' },
    ].map(createStaveNote);
    const stave2 = f.Stave({ x: 15, y: 150, width: 500 }).setClef('bass');
    const notes3 = [
        { keys: ['e/3'], duration: '8', stemDirection: -1, clef: 'bass' },
        { keys: ['g/4'], duration: '8', stemDirection: 1, clef: 'treble' },
        { keys: ['d/4'], duration: '8', stemDirection: 1, clef: 'treble' },
        { keys: ['f/4'], duration: '8', stemDirection: 1, clef: 'treble' },
        { keys: ['c/4'], duration: '8', stemDirection: 1, clef: 'treble' },
        { keys: ['g/3'], duration: '8', stemDirection: -1, clef: 'bass' },
        { keys: ['d/3'], duration: '8', stemDirection: -1, clef: 'bass' },
        { keys: ['f/3'], duration: '8', stemDirection: -1, clef: 'bass' },
    ].map(createStaveNote);
    f.StaveConnector({ topStave: stave1, bottomStave: stave2, type: 'brace' });
    f.StaveConnector({ topStave: stave1, bottomStave: stave2, type: 'singleLeft' });
    f.StaveConnector({ topStave: stave1, bottomStave: stave2, type: 'singleRight' });
    f.Beam({ notes: notes3.slice(1, 4) });
    f.Beam({ notes: notes3.slice(5) });
    addAccidental(notes1[1], '#');
    addSubGroup(notes1[1], [f.ClefNote({ type: 'bass', options: { size: 'small' } }), f.TimeSigNote({ time: '3/4' })]);
    addSubGroup(notes2[2], [f.ClefNote({ type: 'alto', options: { size: 'small' } }), f.TimeSigNote({ time: '9/8' })]);
    addSubGroup(notes1[3], [f.ClefNote({ type: 'soprano', options: { size: 'small' } })]);
    addSubGroup(notes3[1], [f.ClefNote({ type: 'treble', options: { size: 'small' } })]);
    addSubGroup(notes3[5], [f.ClefNote({ type: 'bass', options: { size: 'small' } })]);
    addAccidental(notes3[0], '#');
    addAccidental(notes3[3], 'b');
    addAccidental(notes3[5], '#');
    addAccidental(notes1[2], 'b');
    addAccidental(notes2[3], '#');
    const voice1 = f.Voice().addTickables(notes1);
    const voice2 = f.Voice().addTickables(notes2);
    const voice3 = f.Voice().addTickables(notes3);
    f.Formatter().joinVoices([voice1, voice2]).joinVoices([voice3]).formatToStave([voice1, voice2, voice3], stave1);
    f.draw();
    options.assert.ok(true, 'all pass');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(NoteSubGroupTests);



/***/ }),

/***/ "./tests/offscreencanvas_tests.ts":
/*!****************************************!*\
  !*** ./tests/offscreencanvas_tests.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OffscreenCanvasTests: () => (/* binding */ OffscreenCanvasTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_canvascontext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/canvascontext */ "./src/canvascontext.ts");
/* harmony import */ var _src_formatter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/formatter */ "./src/formatter.ts");
/* harmony import */ var _src_stave__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/stave */ "./src/stave.ts");
/* harmony import */ var _src_stavebarline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/stavebarline */ "./src/stavebarline.ts");
/* harmony import */ var _src_stavenote__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/stavenote */ "./src/stavenote.ts");
/* harmony import */ var _src_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// OffscreenCanvas Tests







const OffscreenCanvasTests = {
    Start() {
        // At the time of writing, OffscreenCanvas is still an experimental technology.
        if ((0,_src_util__WEBPACK_IMPORTED_MODULE_6__.globalObject)().OffscreenCanvas === undefined) {
            return;
        }
        QUnit.module('OffscreenCanvas');
        QUnit.test('Simple Test', simpleTest);
    },
};
function simpleTest(assert) {
    // Create a CanvasContext from an OffscreenCanvas.
    // eslint-disable-next-line
    // @ts-ignore
    const offscreenCanvas = new OffscreenCanvas(550, 200);
    // eslint-disable-next-line
    // @ts-ignore
    const offscreenCtx = offscreenCanvas.getContext('2d');
    if (offscreenCtx === null) {
        throw new Error("Couldn't create offscreen context");
    }
    const ctx = new _src_canvascontext__WEBPACK_IMPORTED_MODULE_1__.CanvasContext(offscreenCtx);
    // Render to the OffscreenCavans.
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(10, 50, 200);
    stave.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.END);
    stave.addClef('treble').setContext(ctx).draw();
    const notes = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_5__.StaveNote({ keys: ['c/4'], duration: 'q' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_5__.StaveNote({ keys: ['d/4'], duration: 'q' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_5__.StaveNote({ keys: ['b/4'], duration: 'qr' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_5__.StaveNote({ keys: ['c/4', 'e/4', 'g/4'], duration: 'q' }),
    ];
    _src_formatter__WEBPACK_IMPORTED_MODULE_2__.Formatter.FormatAndDraw(ctx, stave, notes);
    // Copy the contents of the OffscreenCanvas to an HTMLCanvasElement.
    const imgBmp = offscreenCanvas.transferToImageBitmap();
    const canvas = document.createElement('canvas');
    canvas.width = offscreenCanvas.width;
    canvas.height = offscreenCanvas.height;
    const canvasCtx = canvas.getContext('2d');
    if (canvasCtx === null) {
        throw new Error("Couldn't create canvas context");
    }
    canvasCtx.drawImage(imgBmp, 0, 0);
    document.body.appendChild(canvas);
    assert.ok(true, 'all pass');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(OffscreenCanvasTests);



/***/ }),

/***/ "./tests/ornament_tests.ts":
/*!*********************************!*\
  !*** ./tests/ornament_tests.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OrnamentTests: () => (/* binding */ OrnamentTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_accidental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/accidental */ "./src/accidental.ts");
/* harmony import */ var _src_beam__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/beam */ "./src/beam.ts");
/* harmony import */ var _src_dot__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/dot */ "./src/dot.ts");
/* harmony import */ var _src_element__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/element */ "./src/element.ts");
/* harmony import */ var _src_formatter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/formatter */ "./src/formatter.ts");
/* harmony import */ var _src_ornament__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/ornament */ "./src/ornament.ts");
/* harmony import */ var _src_stave__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/stave */ "./src/stave.ts");
/* harmony import */ var _src_stavenote__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/stavenote */ "./src/stavenote.ts");
/* harmony import */ var _src_voice__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/voice */ "./src/voice.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
// @author Cyril Silverman
//
// Ornament Tests
// TODO: Formatting for Jazz Ornaments is incorrect. The last note + ornament bleeds into the next measure.










const OrnamentTests = {
    Start() {
        QUnit.module('Ornament');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Ornaments', drawOrnaments);
        run('Ornaments Vertically Shifted', drawOrnamentsDisplaced);
        run('Ornaments - Delayed turns', drawOrnamentsDelayed);
        run('Ornaments - Delayed turns, Multiple Draws', drawOrnamentsDelayedMultipleDraws);
        run('Stacked', drawOrnamentsStacked);
        run('With Upper/Lower Accidentals', drawOrnamentsWithAccidentals);
        run('Jazz Ornaments', jazzOrnaments);
    },
};
function drawOrnaments(options, contextBuilder) {
    options.assert.expect(0);
    // Get the rendering context
    const ctx = contextBuilder(options.elementId, 750, 195);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(10, 30, 700);
    stave.setContext(ctx).draw();
    const notes = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: 1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: 1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: 1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: 1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: 1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: 1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: 1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: 1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: 1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: 1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: 1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: 1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: 1 }),
    ];
    notes[0].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('mordent'), 0);
    notes[1].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('mordentInverted'), 0);
    notes[2].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('turn'), 0);
    notes[3].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('turnInverted'), 0);
    notes[4].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('tr'), 0);
    notes[5].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('upprall'), 0);
    notes[6].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('downprall'), 0);
    notes[7].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('prallup'), 0);
    notes[8].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('pralldown'), 0);
    notes[9].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('upmordent'), 0);
    notes[10].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('downmordent'), 0);
    notes[11].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('lineprall'), 0);
    notes[12].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('prallprall'), 0);
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_5__.Formatter.FormatAndDraw(ctx, stave, notes);
}
function drawOrnamentsDisplaced(options, contextBuilder) {
    options.assert.expect(0);
    // Get the rendering context
    const ctx = contextBuilder(options.elementId, 750, 195);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(10, 30, 700);
    stave.setContext(ctx).draw();
    const notes = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['a/5'], duration: '4', stemDirection: -1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['a/5'], duration: '4', stemDirection: -1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['a/5'], duration: '4', stemDirection: -1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['a/5'], duration: '4', stemDirection: -1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['a/5'], duration: '4', stemDirection: -1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['a/5'], duration: '4', stemDirection: -1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['a/5'], duration: '4', stemDirection: -1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['a/4'], duration: '4', stemDirection: 1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['a/4'], duration: '4', stemDirection: 1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['a/4'], duration: '4', stemDirection: 1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['a/4'], duration: '4', stemDirection: 1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['a/4'], duration: '4', stemDirection: 1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys: ['a/4'], duration: '4', stemDirection: 1 }),
    ];
    notes[0].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('mordent'), 0);
    notes[1].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('mordentInverted'), 0);
    notes[1].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('mordentInverted'), 0);
    notes[2].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('turn'), 0);
    notes[3].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('turnInverted'), 0);
    notes[4].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('tr'), 0);
    notes[5].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('upprall'), 0);
    notes[6].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('downprall'), 0);
    notes[7].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('prallup'), 0);
    notes[8].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('pralldown'), 0);
    notes[9].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('upmordent'), 0);
    notes[10].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('downmordent'), 0);
    notes[11].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('lineprall'), 0);
    notes[12].addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_6__.Ornament('prallprall'), 0);
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_5__.Formatter.FormatAndDraw(ctx, stave, notes);
}
/**
 * Helper function for the next two tests: drawOrnamentsDelayed and drawOrnamentsDelayedMultipleDraws.
 * setDelayed(true) shifts the turn symbol to the right (after its note).
 */
const addDelayedTurns = (f) => {
    // Get the rendering context
    const context = f.getContext();
    const stave = f.Stave({ x: 10, y: 30, width: 500 });
    stave.setContext(context).draw();
    const notes = [
        f.StaveNote({ keys: ['a/4'], duration: '4', stemDirection: 1 }),
        f.StaveNote({ keys: ['a/4'], duration: '4', stemDirection: 1 }),
        f.StaveNote({ keys: ['a/4'], duration: '4', stemDirection: 1 }),
        f.StaveNote({ keys: ['a/4'], duration: '4', stemDirection: 1 }),
    ];
    notes[0].addModifier(f.Ornament('turn', { delayed: true }), 0);
    notes[1].addModifier(f.Ornament('turnInverted', { delayed: true }), 0);
    notes[2].addModifier(f.Ornament('turnInverted', { delayed: true }), 0);
    notes[3].addModifier(f.Ornament('turn', { delayed: true }), 0);
    return { context, stave, notes };
};
function drawOrnamentsDelayed(options) {
    options.assert.expect(0);
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 550, 195);
    const { context, stave, notes } = addDelayedTurns(f);
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_5__.Formatter.FormatAndDraw(context, stave, notes);
}
function drawOrnamentsDelayedMultipleDraws(options) {
    options.assert.expect(0);
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 550, 195);
    const { context, stave, notes } = addDelayedTurns(f);
    // We can FormatAndDraw() two times, and it looks fine.
    // However, if you inspect the SVG element, you will see duplicate paths.
    _src_formatter__WEBPACK_IMPORTED_MODULE_5__.Formatter.FormatAndDraw(context, stave, notes);
    _src_formatter__WEBPACK_IMPORTED_MODULE_5__.Formatter.FormatAndDraw(context, stave, notes);
}
function drawOrnamentsStacked(options) {
    options.assert.expect(0);
    // Get the rendering context
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 550, 195);
    const ctx = f.getContext();
    const stave = f.Stave({ x: 10, y: 30, width: 500 });
    stave.setContext(ctx).draw();
    const notes = [
        f.StaveNote({ keys: ['a/4'], duration: '4', stemDirection: 1 }),
        f.StaveNote({ keys: ['a/4'], duration: '4', stemDirection: 1 }),
        f.StaveNote({ keys: ['a/4'], duration: '4', stemDirection: 1 }),
        f.StaveNote({ keys: ['a/4'], duration: '4', stemDirection: 1 }),
    ];
    notes[0].addModifier(f.Ornament('mordent'), 0);
    notes[1].addModifier(f.Ornament('turnInverted'), 0);
    notes[2].addModifier(f.Ornament('turn'), 0);
    notes[3].addModifier(f.Ornament('turnInverted'), 0);
    notes[0].addModifier(f.Ornament('turn'), 0);
    notes[1].addModifier(f.Ornament('prallup'), 0);
    notes[2].addModifier(f.Ornament('upmordent'), 0);
    notes[3].addModifier(f.Ornament('lineprall'), 0);
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_5__.Formatter.FormatAndDraw(ctx, stave, notes);
}
function drawOrnamentsWithAccidentals(options) {
    options.assert.expect(0);
    // Get the rendering context
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 650, 250);
    const ctx = f.getContext();
    const stave = f.Stave({ x: 10, y: 60, width: 600 });
    stave.setContext(ctx).draw();
    const notes = [
        f.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: 1 }),
        f.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: 1 }),
        f.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: 1 }),
        f.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: 1 }),
        f.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: 1 }),
        f.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: 1 }),
        f.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: 1 }),
        f.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: 1 }),
        f.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: 1 }),
        f.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: 1 }),
        f.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: 1 }),
    ];
    notes[0].addModifier(f.Ornament('mordent', { lowerAccidental: '#', upperAccidental: '#' }), 0);
    notes[1].addModifier(f.Ornament('turnInverted', { lowerAccidental: 'b', upperAccidental: 'b' }), 0);
    notes[2].addModifier(f.Ornament('turn', { upperAccidental: '##', lowerAccidental: '##' }), 0);
    notes[3].addModifier(f.Ornament('mordentInverted', { lowerAccidental: 'db', upperAccidental: 'db' }), 0);
    notes[4].addModifier(f.Ornament('turnInverted', { upperAccidental: '++', lowerAccidental: '++' }), 0);
    notes[5].addModifier(f.Ornament('tr', { upperAccidental: 'n', lowerAccidental: 'n' }), 0);
    notes[6].addModifier(f.Ornament('prallup', { upperAccidental: 'd', lowerAccidental: 'd' }), 0);
    notes[7].addModifier(f.Ornament('lineprall', { upperAccidental: 'db', lowerAccidental: 'db' }), 0);
    notes[8].addModifier(f.Ornament('upmordent', { upperAccidental: 'bbs', lowerAccidental: 'bbs' }), 0);
    notes[9].addModifier(f.Ornament('prallprall', { upperAccidental: 'bb', lowerAccidental: 'bb' }), 0);
    notes[10].addModifier(f.Ornament('turnInverted', { upperAccidental: '+', lowerAccidental: '+' }), 0);
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_5__.Formatter.FormatAndDraw(ctx, stave, notes);
}
function jazzOrnaments(options) {
    const el = new _src_element__WEBPACK_IMPORTED_MODULE_4__.Element();
    el.setText('\ue050' /* gClef */); // widest clef
    const clefWidth = el.getWidth();
    // Helper function.
    function draw(modifiers, keys, x, width, y, stemDirection) {
        // Helper function to create a StaveNote.
        const note = (keys, duration, modifier, stemDirection) => {
            const n = new _src_stavenote__WEBPACK_IMPORTED_MODULE_8__.StaveNote({ keys, duration, stemDirection })
                .addModifier(modifier, 0)
                .addModifier(new _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental('b'), 0);
            const dot = duration.indexOf('d') >= 0;
            if (dot) {
                _src_dot__WEBPACK_IMPORTED_MODULE_3__.Dot.buildAndAttach([n], { all: true });
            }
            return n;
        };
        const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(x, y, width).addClef('treble').setContext(ctx).draw();
        const notes = [
            note(keys, '4d', modifiers[0], stemDirection),
            note(keys, '8', modifiers[1], stemDirection),
            note(keys, '4d', modifiers[2], stemDirection),
            note(keys, '8', modifiers[3], stemDirection),
        ];
        if (modifiers.length > 4) {
            notes[3].addModifier(modifiers[4], 0);
        }
        _src_beam__WEBPACK_IMPORTED_MODULE_2__.Beam.generateBeams(notes);
        const voice = new _src_voice__WEBPACK_IMPORTED_MODULE_9__.Voice({
            numBeats: 4,
            beatValue: 4,
        }).setMode(_src_voice__WEBPACK_IMPORTED_MODULE_9__.VoiceMode.SOFT);
        voice.addTickables(notes);
        const formatter = new _src_formatter__WEBPACK_IMPORTED_MODULE_5__.Formatter().joinVoices([voice]);
        formatter.format([voice], width - _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave.defaultPadding - clefWidth);
        stave.setContext(ctx).draw();
        voice.draw(ctx, stave);
    }
    options.assert.expect(0);
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 950, 400);
    const ctx = f.getContext();
    ctx.scale(1, 1);
    const xStart = 10;
    const width = 300;
    const yStart = 50;
    const staffHeight = 70;
    let curX = xStart;
    let curY = yStart;
    let mods = [
        // measure 1
        f.Ornament('scoop'),
        f.Ornament('doit'),
        f.Ornament('fall'),
        f.Ornament('doitLong'),
    ];
    draw(mods, ['a/5'], curX, width, curY, -1);
    curX += width;
    mods = [
        // measure 2
        f.Ornament('fallLong'),
        f.Ornament('bend'),
        f.Ornament('plungerClosed'),
        f.Ornament('plungerOpen'),
        f.Ornament('bend'),
    ];
    draw(mods, ['a/5'], curX, width, curY, -1);
    curX += width;
    mods = [
        // measure 3
        f.Ornament('flip'),
        f.Ornament('jazzTurn'),
        f.Ornament('smear'),
        f.Ornament('doit'),
    ];
    draw(mods, ['a/5'], curX, width, curY, 1);
    // second line
    curX = xStart;
    curY += staffHeight;
    mods = [
        // measure 4
        f.Ornament('scoop'),
        f.Ornament('doit'),
        f.Ornament('fall'),
        f.Ornament('doitLong'),
    ];
    draw(mods, ['e/5'], curX, width, curY);
    curX += width;
    mods = [
        // measure 5
        f.Ornament('fallLong'),
        f.Ornament('bend'),
        f.Ornament('plungerClosed'),
        f.Ornament('plungerOpen'),
        f.Ornament('bend'),
    ];
    draw(mods, ['e/5'], curX, width, curY);
    curX += width;
    mods = [
        // measure 6
        f.Ornament('flip'),
        f.Ornament('jazzTurn'),
        f.Ornament('smear'),
        f.Ornament('doit'),
    ];
    draw(mods, ['e/5'], curX, width, curY);
    // third line
    curX = xStart;
    curY += staffHeight;
    mods = [
        // measure 7
        f.Ornament('scoop'),
        f.Ornament('doit'),
        f.Ornament('fall'),
        f.Ornament('doitLong'),
    ];
    draw(mods, ['e/4'], curX, width, curY);
    curX += width;
    mods = [
        // measure 8
        f.Ornament('fallLong'),
        f.Ornament('bend'),
        f.Ornament('plungerClosed'),
        f.Ornament('plungerOpen'),
        f.Ornament('bend'),
    ];
    draw(mods, ['e/4'], curX, width, curY);
    curX += width;
    mods = [
        // measure 9
        f.Ornament('flip'),
        f.Ornament('jazzTurn'),
        f.Ornament('smear'),
        f.Ornament('doit'),
    ];
    draw(mods, ['e/4'], curX, width, curY);
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(OrnamentTests);



/***/ }),

/***/ "./tests/parser_tests.ts":
/*!*******************************!*\
  !*** ./tests/parser_tests.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ParserTests: () => (/* binding */ ParserTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/parser */ "./src/parser.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Parser Tests


const ParserTests = {
    Start() {
        QUnit.module('Parser');
        QUnit.test('Basic', basic);
        QUnit.test('Advanced', advanced);
        QUnit.test('Mixed', mixed);
        QUnit.test('Micro Score', microscore);
    },
};
/**
 * Grammar used in the first three test cases: basic, advanced, mixed.
 */
class TestGrammar {
    // The begin() function is the only requirement when implementing the Grammar interface.
    begin() {
        return () => ({ expect: this.expect });
    }
    BIGORLITTLE() {
        return { expect: [this.BIGLINE, this.LITTLELINE], or: true };
    }
    BIGLINE() {
        return { expect: [this.LBRACE, this.WORD, this.WORDS, this.MAYBEEXCLAIM, this.RBRACE] };
    }
    LITTLELINE() {
        return { expect: [this.WORD, this.WORDS] };
    }
    WORDS() {
        return { expect: [this.COMMA, this.WORD], zeroOrMore: true };
    }
    MAYBEEXCLAIM() {
        return { expect: [this.EXCLAIM], maybe: true };
    }
    LBRACE() {
        return { token: '[{]' };
    }
    RBRACE() {
        return { token: '[}]' };
    }
    WORD() {
        return { token: '[a-zA-Z]+' };
    }
    COMMA() {
        return { token: '[,]' };
    }
    EXCLAIM() {
        return { token: '[!]' };
    }
    EOL() {
        return { token: '$' };
    }
}
/**
 * Grammar used in the microscore test case.
 * It represents a series of piano key numbers (Middle C == 40) separated by whitespace.
 *   C Major Scale => 40 42 44 45 47 49 51 52
 * A chord is 2 or more piano key numbers surrounded by BRACKETS and separated by PERIODS
 *   C Major == [40.44.47]
 *   C-major F-major G-major A-minor chord progression => [40.44.47] [45.49.52] [47.51.54] [49.52.56]
 */
class MicroScoreGrammar {
    constructor() {
        this.ITEM = () => ({ expect: [this.PIANO_KEY_NUMBER, this.CHORD], or: true });
        this.MAYBE_MORE_ITEMS = () => ({ expect: [this.ITEM], zeroOrMore: true });
        this.PIANO_KEY_NUMBER = () => ({ expect: [this.NUM], oneOrMore: true });
        this.CHORD = () => ({ expect: [this.LEFT_BRACKET, this.PIANO_KEY_NUMBER, this.MORE_CHORD_PARTS, this.RIGHT_BRACKET] });
        this.MORE_CHORD_PARTS = () => ({ expect: [this.PERIOD, this.PIANO_KEY_NUMBER], oneOrMore: true });
        this.NUM = () => ({ token: '\\d+' });
        this.WHITESPACE = () => ({ token: '\\s+' });
        this.PERIOD = () => ({ token: '\\.' });
        this.LEFT_BRACKET = () => ({ token: '\\[' });
        this.RIGHT_BRACKET = () => ({ token: '\\]' });
        this.EOL = () => ({ token: '$' });
    }
    begin() {
        return () => ({ expect: [this.ITEM, this.MAYBE_MORE_ITEMS, this.EOL] });
    }
}
/**
 * Check that the result is a parse failure, and verify the error position.
 */
function fails(assert, result, expectedErrorPos, msg) {
    assert.notOk(result.success, msg);
    assert.equal(result.errorPos, expectedErrorPos, msg);
}
function basic(assert) {
    const grammar = new TestGrammar();
    grammar.expect = [grammar.LITTLELINE, grammar.EOL];
    const parser = new _src_parser__WEBPACK_IMPORTED_MODULE_1__.Parser(grammar);
    // Each of these strings will parse correctly.
    const mustPass = ['first, second', 'first,second', 'first', 'first,second, third'];
    mustPass.forEach((line) => assert.equal(parser.parse(line).success, true, line));
    fails(assert, parser.parse(''), 0);
    fails(assert, parser.parse('first second'), 6);
    fails(assert, parser.parse('first,,'), 5);
    fails(assert, parser.parse('first,'), 5);
    fails(assert, parser.parse(',,'), 0);
}
function advanced(assert) {
    const grammar = new TestGrammar();
    grammar.expect = [grammar.BIGLINE, grammar.EOL];
    const parser = new _src_parser__WEBPACK_IMPORTED_MODULE_1__.Parser(grammar);
    const mustPass = ['{first}', '{first!}', '{first,second}', '{first,second!}', '{first,second,third!}'];
    mustPass.forEach((line) => assert.equal(parser.parse(line).success, true, line));
    fails(assert, parser.parse('{first,second,third,}'), 19);
    fails(assert, parser.parse('first,second,third'), 0);
    fails(assert, parser.parse('{first,second,third'), 19);
    fails(assert, parser.parse('{!}'), 1);
}
function mixed(assert) {
    const grammar = new TestGrammar();
    grammar.expect = [grammar.BIGORLITTLE, grammar.EOL];
    const parser = new _src_parser__WEBPACK_IMPORTED_MODULE_1__.Parser(grammar);
    const mustPass = ['{first,second,third!}', 'first, second'];
    mustPass.forEach((line) => assert.equal(parser.parse(line).success, true, line));
    fails(assert, parser.parse('first second'), 6);
}
function microscore(assert) {
    const grammar = new MicroScoreGrammar();
    const parser = new _src_parser__WEBPACK_IMPORTED_MODULE_1__.Parser(grammar);
    const mustPass = [
        '40 42 44 45 47 49 51 52',
        '[40.44.47] [45.49.52] [47.51.54] [49.52.56]',
        '40 [40.44.47] 45 47 [44.47.51]', // Mixed Notes and Chords: C4 [Cmajor] F4 G4 [Eminor]
    ];
    mustPass.forEach((line) => {
        var _a;
        const result = parser.parse(line);
        assert.equal(result.success, true, line);
        assert.equal((_a = result.matches) === null || _a === void 0 ? void 0 : _a.length, 3, line);
    });
    fails(assert, parser.parse('40 42 44 45 47 49 5A 52'), 19);
    fails(assert, parser.parse('40.44.47] [45.49.52] [47.51.54] [49.52.56]'), 2);
    fails(assert, parser.parse('40 [40] 45 47 [44.47.51]'), 3); // A chord with a single note is not allowed.
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(ParserTests);



/***/ }),

/***/ "./tests/pedalmarking_tests.ts":
/*!*************************************!*\
  !*** ./tests/pedalmarking_tests.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PedalMarkingTests: () => (/* binding */ PedalMarkingTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// PedalMarking Tests
// TODO: Fix Error => Type 'Tickable' is not assignable to type 'StaveNote'.

const PedalMarkingTests = {
    Start() {
        QUnit.module('PedalMarking');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Simple Pedal 1', simple1);
        run('Simple Pedal 2', simple2);
        run('Simple Pedal 3', simple3);
        run('Release and Depress on Same Note 1', releaseDepress1);
        run('Release and Depress on Same Note 2', releaseDepress2);
        run('Custom Text 1', customTest1);
        run('Custom Text 2', customTest2);
    },
};
/**
 * Every test below uses this to set up the score and two staves/voices.
 */
function createTest(makePedal) {
    return (options) => {
        const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 550, 200);
        const score = f.EasyScore();
        const stave0 = f.Stave({ width: 250 }).addClef('treble');
        const voice0 = score.voice(score.notes('b4/4, b4, b4, b4[stem="down"]', { stem: 'up' }));
        f.Formatter().joinVoices([voice0]).formatToStave([voice0], stave0);
        const stave1 = f.Stave({ width: 260, x: 250 });
        const voice1 = score.voice(score.notes('c4/4, c4, c4, c4', { stem: 'up' }));
        f.Formatter().joinVoices([voice1]).formatToStave([voice1], stave1);
        makePedal(f, voice0.getTickables(), voice1.getTickables());
        f.draw();
        options.assert.ok(true, 'Must render');
    };
}
function withSimplePedal(style) {
    return (factory, notes0, notes1) => factory.PedalMarking({
        notes: [notes0[0], notes0[2], notes0[3], notes1[3]],
        options: { style },
    });
}
function withReleaseAndDepressedPedal(style) {
    return (factory, notes0, notes1) => factory.PedalMarking({
        notes: [notes0[0], notes0[3], notes0[3], notes1[1], notes1[1], notes1[3]],
        options: { style },
    });
}
const simple1 = createTest(withSimplePedal('text'));
const simple2 = createTest(withSimplePedal('bracket'));
const simple3 = createTest(withSimplePedal('mixed'));
const releaseDepress1 = createTest(withReleaseAndDepressedPedal('bracket'));
const releaseDepress2 = createTest(withReleaseAndDepressedPedal('mixed'));
const customTest1 = createTest((factory, notes0, notes1) => {
    const pedal = factory.PedalMarking({
        notes: [notes0[0], notes1[3]],
        options: { style: 'text' },
    });
    pedal.setCustomText('una corda', 'tre corda');
    return pedal;
});
const customTest2 = createTest((factory, notes0, notes1) => {
    const pedal = factory.PedalMarking({
        notes: [notes0[0], notes1[3]],
        options: { style: 'mixed' },
    });
    pedal.setCustomText('Sost. Ped.');
    return pedal;
});
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(PedalMarkingTests);



/***/ }),

/***/ "./tests/percussion_tests.ts":
/*!***********************************!*\
  !*** ./tests/percussion_tests.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PercussionTests: () => (/* binding */ PercussionTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/index */ "./src/index.ts");
/* harmony import */ var _src_metrics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/metrics */ "./src/metrics.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
// @author Mike Corrigan 2012 <corrigan@gmail.com>
//
// Percussion Tests
// TODO: Type 'Tickable[]' is not assignable to type 'StemmableNote[]'.



const PercussionTests = {
    Start() {
        QUnit.module('Percussion');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Percussion Clef', draw);
        run('Percussion Notes', drawNotes);
        run('Percussion Basic0', basic0);
        run('Percussion Basic1', basic1);
        run('Percussion Basic2', basic2);
        run('Percussion Snare0', snare0);
        run('Percussion Snare1', snare1);
        run('Percussion Snare2', snare2);
        run('Percussion Snare3', snare3);
    },
};
function draw(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 120);
    new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stave(10, 10, 300).addClef('percussion').setContext(ctx).draw();
    options.assert.ok(true);
}
/**
 * Helper function used by the drawNotes() test case below.
 */
function showNote(struct, stave, ctx, x) {
    const staveNote = new _src_index__WEBPACK_IMPORTED_MODULE_1__.StaveNote(struct).setStave(stave);
    new _src_index__WEBPACK_IMPORTED_MODULE_1__.TickContext().addTickable(staveNote).preFormat().setX(x);
    staveNote.setContext(ctx).draw();
    return staveNote;
}
function drawNotes(options, contextBuilder) {
    const notes = [
        { keys: ['g/5/d0'], duration: '4' },
        { keys: ['g/5/d1'], duration: '4' },
        { keys: ['g/5/d2'], duration: '4' },
        { keys: ['g/5/d3'], duration: '4' },
        { keys: ['x/'], duration: '1' },
        { keys: ['g/5/t0'], duration: '1' },
        { keys: ['g/5/t1'], duration: '4' },
        { keys: ['g/5/t2'], duration: '4' },
        { keys: ['g/5/t3'], duration: '4' },
        { keys: ['x/'], duration: '1' },
        { keys: ['g/5/x0'], duration: '1' },
        { keys: ['g/5/x1'], duration: '4' },
        { keys: ['g/5/x2'], duration: '4' },
        { keys: ['g/5/x3'], duration: '4' },
    ];
    const ctx = contextBuilder(options.elementId, notes.length * 25 + 100, 240);
    // Draw two staves, one with up-stems and one with down-stems.
    for (let h = 0; h < 2; ++h) {
        const stave = new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stave(10, 10 + h * 120, notes.length * 25 + 75).addClef('percussion').setContext(ctx).draw();
        for (let i = 0; i < notes.length; ++i) {
            const note = notes[i];
            note.stemDirection = h === 0 ? -1 : 1;
            const staveNote = showNote(note, stave, ctx, (i + 1) * 25);
            options.assert.ok(staveNote.getX() > 0, 'Note ' + i + ' has X value');
            options.assert.ok(staveNote.getYs().length > 0, 'Note ' + i + ' has Y values');
        }
    }
}
/**
 * Helper function for the seven test cases below.
 * Adds a percussion clef (two short vertical bars, like a pause sign) to the stave.
 */
function createSingleMeasureTest(setup) {
    return (options) => {
        const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 500);
        const stave = f.Stave().addClef('percussion').setTimeSignature('4/4');
        setup(f);
        f.Formatter().joinVoices(f.getVoices()).formatToStave(f.getVoices(), stave);
        f.draw();
        options.assert.ok(true);
    };
}
const basic0 = createSingleMeasureTest((f) => {
    const voice0 = f
        .Voice()
        .addTickables([
        f.StaveNote({ keys: ['g/5/x2'], duration: '8' }),
        f.StaveNote({ keys: ['g/5/x2'], duration: '8' }),
        f.StaveNote({ keys: ['g/5/x2'], duration: '8' }),
        f.StaveNote({ keys: ['g/5/x2'], duration: '8' }),
        f.StaveNote({ keys: ['g/5/x2'], duration: '8' }),
        f.StaveNote({ keys: ['g/5/x2'], duration: '8' }),
        f.StaveNote({ keys: ['g/5/x2'], duration: '8' }),
        f.StaveNote({ keys: ['g/5/x2'], duration: '8' }),
    ]);
    const voice1 = f
        .Voice()
        .addTickables([
        f.StaveNote({ keys: ['f/4'], duration: '8', stemDirection: -1 }),
        f.StaveNote({ keys: ['f/4'], duration: '8', stemDirection: -1 }),
        f.StaveNote({ keys: ['d/4/x2', 'c/5'], duration: '4', stemDirection: -1 }),
        f.StaveNote({ keys: ['f/4'], duration: '8', stemDirection: -1 }),
        f.StaveNote({ keys: ['f/4'], duration: '8', stemDirection: -1 }),
        f.StaveNote({ keys: ['d/4/x2', 'c/5'], duration: '4', stemDirection: -1 }),
    ]);
    f.Beam({ notes: voice0.getTickables() });
    f.Beam({ notes: voice1.getTickables().slice(0, 2) });
    f.Beam({ notes: voice1.getTickables().slice(3, 5) });
});
const basic1 = createSingleMeasureTest((f) => {
    f.Voice().addTickables([
        f.StaveNote({ keys: ['f/5/x2'], duration: '4' }),
        f.StaveNote({ keys: ['f/5/x2'], duration: '4' }),
        f.StaveNote({ keys: ['f/5/x2'], duration: '4' }),
        f.StaveNote({ keys: ['f/5/x2'], duration: '4' }),
    ]);
    f.Voice().addTickables([
        f.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: -1 }),
        f.StaveNote({ keys: ['d/4/x2', 'c/5'], duration: '4', stemDirection: -1 }),
        f.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: -1 }),
        f.StaveNote({ keys: ['d/4/x2', 'c/5'], duration: '4', stemDirection: -1 }),
    ]);
});
const basic2 = createSingleMeasureTest((f) => {
    const voice0 = f
        .Voice()
        .addTickables([
        f.StaveNote({ keys: ['a/5/x3'], duration: '8' }),
        f.StaveNote({ keys: ['g/5/x2'], duration: '8' }),
        f.StaveNote({ keys: ['g/5'], duration: '8' }),
        f.StaveNote({ keys: ['g/4/n', 'g/5/x2'], duration: '8' }),
        f.StaveNote({ keys: ['g/5/x2'], duration: '8' }),
        f.StaveNote({ keys: ['g/5/x2'], duration: '8' }),
        f.StaveNote({ keys: ['g/5/x2'], duration: '8' }),
        f.StaveNote({ keys: ['g/5/x2'], duration: '8' }),
    ]);
    f.Beam({ notes: voice0.getTickables().slice(1, 8) });
    const notes1 = [
        f.StaveNote({ keys: ['f/4'], duration: '8', stemDirection: -1 }),
        f.StaveNote({ keys: ['f/4'], duration: '8', stemDirection: -1 }),
        f.StaveNote({ keys: ['d/4/x2', 'c/5'], duration: '4', stemDirection: -1 }),
        f.StaveNote({ keys: ['f/4'], duration: '4', stemDirection: -1 }),
        f.StaveNote({ keys: ['d/4/x2', 'c/5'], duration: '8d', stemDirection: -1 }),
        f.StaveNote({ keys: ['c/5'], duration: '16', stemDirection: -1 }),
    ];
    _src_index__WEBPACK_IMPORTED_MODULE_1__.Dot.buildAndAttach([notes1[4]], { all: true });
    const voice1 = f.Voice().addTickables(notes1);
    f.Beam({ notes: voice1.getTickables().slice(0, 2) });
    f.Beam({ notes: voice1.getTickables().slice(4, 6) });
});
const snare0 = createSingleMeasureTest((f) => {
    const font = {
        family: _src_metrics__WEBPACK_IMPORTED_MODULE_2__.Metrics.get('fontFamily'),
        size: 14,
        weight: _src_index__WEBPACK_IMPORTED_MODULE_1__.FontWeight.BOLD,
        style: _src_index__WEBPACK_IMPORTED_MODULE_1__.FontStyle.ITALIC,
    };
    f.Voice().addTickables([
        f
            .StaveNote({ keys: ['c/5'], duration: '4', stemDirection: -1 })
            .addModifier(f.Articulation({ type: 'a>' }), 0)
            .addModifier(f.Annotation({ text: 'L', font }), 0),
        f.StaveNote({ keys: ['c/5'], duration: '4', stemDirection: -1 }).addModifier(f.Annotation({ text: 'R', font }), 0),
        f.StaveNote({ keys: ['c/5'], duration: '4', stemDirection: -1 }).addModifier(f.Annotation({ text: 'L', font }), 0),
        f.StaveNote({ keys: ['c/5'], duration: '4', stemDirection: -1 }).addModifier(f.Annotation({ text: 'L', font }), 0),
    ]);
});
const snare1 = createSingleMeasureTest((f) => {
    f.Voice().addTickables([
        f.StaveNote({ keys: ['g/5/x2'], duration: '4', stemDirection: -1 }).addModifier(f.Articulation({ type: 'ah' }), 0),
        f.StaveNote({ keys: ['g/5/x2'], duration: '4', stemDirection: -1 }),
        f.StaveNote({ keys: ['g/5/x2'], duration: '4', stemDirection: -1 }).addModifier(f.Articulation({ type: 'ah' }), 0),
        f.StaveNote({ keys: ['a/5/x3'], duration: '4', stemDirection: -1 }).addModifier(f.Articulation({ type: 'a,' }), 0),
    ]);
});
const snare2 = createSingleMeasureTest((f) => {
    f.Voice().addTickables([
        f.StaveNote({ keys: ['c/5'], duration: '4', stemDirection: -1 }).addModifier(new _src_index__WEBPACK_IMPORTED_MODULE_1__.Tremolo(1), 0),
        f.GraceNote({ keys: ['c/5'], duration: '4', stemDirection: -1 }).addModifier(new _src_index__WEBPACK_IMPORTED_MODULE_1__.Tremolo(1), 0),
        f.StaveNote({ keys: ['c/5'], duration: '4', stemDirection: -1 }).addModifier(new _src_index__WEBPACK_IMPORTED_MODULE_1__.Tremolo(3), 0),
        f.StaveNote({ keys: ['c/5'], duration: '4', stemDirection: -1 }).addModifier(new _src_index__WEBPACK_IMPORTED_MODULE_1__.Tremolo(4), 0),
    ]);
});
const snare3 = createSingleMeasureTest((factory) => {
    factory
        .Voice()
        .addTickables([
        factory.StaveNote({ keys: ['c/5'], duration: '4', stemDirection: 1 }).addModifier(new _src_index__WEBPACK_IMPORTED_MODULE_1__.Tremolo(2), 0),
        factory.GraceNote({ keys: ['c/5'], duration: '4', stemDirection: 1 }).addModifier(new _src_index__WEBPACK_IMPORTED_MODULE_1__.Tremolo(2), 0),
        factory.GraceNote({ keys: ['c/5'], duration: '4', stemDirection: 1 }).addModifier(new _src_index__WEBPACK_IMPORTED_MODULE_1__.Tremolo(3), 0),
        factory.StaveNote({ keys: ['c/5'], duration: '4', stemDirection: 1 }).addModifier(new _src_index__WEBPACK_IMPORTED_MODULE_1__.Tremolo(4), 0),
    ]);
});
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(PercussionTests);



/***/ }),

/***/ "./tests/registry_tests.ts":
/*!*********************************!*\
  !*** ./tests/registry_tests.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RegistryTests: () => (/* binding */ RegistryTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/index */ "./src/index.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Registry Tests


const RegistryTests = {
    Start() {
        QUnit.module('Registry');
        QUnit.test('Register and Clear', registerAndClear);
        QUnit.test('Default Registry', defaultRegistry);
        QUnit.test('Multiple Classes', classes);
    },
};
function registerAndClear(assert) {
    const registry = new _src_index__WEBPACK_IMPORTED_MODULE_1__.Registry();
    const score = new _src_index__WEBPACK_IMPORTED_MODULE_1__.EasyScore({ factory: _src_index__WEBPACK_IMPORTED_MODULE_1__.Factory.newFromElementId(null) });
    registry.register(score.notes('C4')[0], 'foobar');
    const foobar = registry.getElementById('foobar');
    assert.ok(foobar);
    assert.equal(foobar.getAttribute('id'), 'foobar');
    registry.clear();
    assert.notOk(registry.getElementById('foobar'));
    // eslint-disable-next-line
    // @ts-ignore: intentional type mismatch to trigger an error.
    assert.throws(() => registry.register(score.notes('C4')));
    registry.clear();
    assert.ok(registry.register(score.notes('C4[id="boobar"]')[0]).getElementById('boobar'));
}
function defaultRegistry(assert) {
    const registry = new _src_index__WEBPACK_IMPORTED_MODULE_1__.Registry();
    const score = new _src_index__WEBPACK_IMPORTED_MODULE_1__.EasyScore({ factory: _src_index__WEBPACK_IMPORTED_MODULE_1__.Factory.newFromElementId(null) });
    _src_index__WEBPACK_IMPORTED_MODULE_1__.Registry.enableDefaultRegistry(registry);
    score.notes('C4[id="foobar"]');
    const note = registry.getElementById('foobar');
    assert.ok(note);
    note.setAttribute('id', 'boobar');
    assert.ok(registry.getElementById('boobar'));
    assert.notOk(registry.getElementById('foobar'));
    registry.clear();
    assert.equal(registry.getElementsByType(_src_index__WEBPACK_IMPORTED_MODULE_1__.StaveNote.CATEGORY).length, 0);
    score.notes('C5');
    const elements = registry.getElementsByType(_src_index__WEBPACK_IMPORTED_MODULE_1__.StaveNote.CATEGORY);
    assert.equal(elements.length, 1);
}
function classes(assert) {
    const registry = new _src_index__WEBPACK_IMPORTED_MODULE_1__.Registry();
    const score = new _src_index__WEBPACK_IMPORTED_MODULE_1__.EasyScore({ factory: _src_index__WEBPACK_IMPORTED_MODULE_1__.Factory.newFromElementId(null) });
    _src_index__WEBPACK_IMPORTED_MODULE_1__.Registry.enableDefaultRegistry(registry);
    score.notes('C4[id="foobar"]');
    const note = registry.getElementById('foobar');
    note.addClass('foo');
    assert.ok(note.hasClass('foo'));
    assert.notOk(note.hasClass('boo'));
    assert.equal(registry.getElementsByClass('foo').length, 1);
    assert.equal(registry.getElementsByClass('boo').length, 0);
    note.addClass('boo');
    assert.ok(note.hasClass('foo'));
    assert.ok(note.hasClass('boo'));
    assert.equal(registry.getElementsByClass('foo').length, 1);
    assert.equal(registry.getElementsByClass('boo').length, 1);
    note.removeClass('boo');
    note.removeClass('foo');
    assert.notOk(note.hasClass('foo'));
    assert.notOk(note.hasClass('boo'));
    assert.equal(registry.getElementsByClass('foo').length, 0);
    assert.equal(registry.getElementsByClass('boo').length, 0);
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(RegistryTests);



/***/ }),

/***/ "./tests/renderer_tests.ts":
/*!*********************************!*\
  !*** ./tests/renderer_tests.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RendererTests: () => (/* binding */ RendererTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/index */ "./src/index.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// @author Ron B. Yeh
// MIT License
//
// Renderer Tests


// TODO: Should FactoryOptions.renderer.elementId also accept a canvas | div?
const STAVE_WIDTH = 700;
const STAVE_HEIGHT = 100;
// FactoryOptions.stave.space defaults to 10.
// We subtract 10 to make the useRendererAPI() output look identical to useFactoryAPI().
const STAVE_RIGHT_MARGIN = 10;
const USE_RENDERER = { useRendererAPI: true };
const USE_FACTORY = { useRendererAPI: false };
const RendererTests = {
    Start() {
        QUnit.module('Renderer');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        // Randomly choose one of four setup paths. See below for a description.
        // Refresh `flow.html` to see the test change each time.
        // We can manually check that they look identical
        // by opening `flow.html` in multiple tabs & quickly switching between tabs.
        run('Random', random);
        // These are the four setup paths. They should all produce the same output.
        //   Use the:  Renderer API       OR  Factory API
        //   Pass in:  element ID string  OR  canvas/div element.
        run('Renderer API with element ID string', stringElementId, USE_RENDERER);
        run('Renderer API with canvas or div', canvasOrDivElement, USE_RENDERER);
        run('Renderer API with context', passRenderContext);
        run('Factory API with element ID string', stringElementId, USE_FACTORY);
        run('Factory API with canvas or div', canvasOrDivElement, USE_FACTORY);
    },
};
/**
 * Helper function to add three notes to a stave.
 */
function drawStave(stave, context) {
    stave.addClef('bass').addTimeSignature('3/4').draw();
    _src_index__WEBPACK_IMPORTED_MODULE_1__.Formatter.FormatAndDraw(context, stave, [
        new _src_index__WEBPACK_IMPORTED_MODULE_1__.StaveNote({ keys: ['C/4'], duration: '4' }),
        new _src_index__WEBPACK_IMPORTED_MODULE_1__.StaveNote({ keys: ['E/4'], duration: '4' }),
        new _src_index__WEBPACK_IMPORTED_MODULE_1__.StaveNote({ keys: ['G/4'], duration: '4' }),
    ]);
}
/**
 * Randomize the test upon each refresh (for verifying that the output is identical).
 * Draw a colored outline to indicate which of the four options is shown.
 * - blue = element is a SVG or Canvas element
 * - gray = element ID is a string
 * - solid outline = use the Renderer API directly
 * - dashed outline = use the Factory API
 */
function random(options) {
    const useElementIDString = Math.random() > 0.5;
    const useRendererAPI = Math.random() > 0.5;
    options.params = { useRendererAPI };
    if (useElementIDString) {
        stringElementId(options);
    }
    else {
        canvasOrDivElement(options);
    }
    // eslint-disable-next-line
    const element = document.getElementById(options.elementId);
    const colorForElementType = useElementIDString ? '#CCCCCC' /* light gray */ : '#0074d9'; /* blue */
    const lineStyleForWhichAPI = useRendererAPI ? 'solid' : 'dashed';
    const borderStyle = `3px ${lineStyleForWhichAPI} ${colorForElementType}`;
    let elementType;
    if (options.backend === _src_index__WEBPACK_IMPORTED_MODULE_1__.Renderer.Backends.CANVAS) {
        // If the backend is canvas, we draw a border around the canvas directly.
        element.style.border = borderStyle;
        elementType = '&lt;canvas&gt; element object';
    }
    else {
        // If the backend is SVG, we draw a border around the SVG child of the DIV.
        element.children[0].style.border = borderStyle;
        elementType = '&lt;svg&gt; element object';
    }
    if (useElementIDString) {
        elementType = 'elementID string';
    }
    const whichAPI = useRendererAPI ? 'Renderer API' : 'Factory API';
    element.parentElement.insertAdjacentHTML('beforeend', `<div style='position:relative; bottom: 100px; font-size: 12pt;'>` +
        `<span style="border-bottom: ${borderStyle}; padding-bottom: 3px; ${lineStyleForWhichAPI}">${whichAPI}</span>` +
        ` with ` +
        `<span style="background-color:${colorForElementType}; padding: 3px; color:white;">${elementType}</span>` +
        `</div><br>`);
}
function useRendererAPI(e, backend) {
    const renderer = new _src_index__WEBPACK_IMPORTED_MODULE_1__.Renderer(e, backend);
    renderer.resize(STAVE_WIDTH, STAVE_HEIGHT);
    const context = renderer.getContext();
    drawStave(new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stave(0, 0, STAVE_WIDTH - STAVE_RIGHT_MARGIN).setContext(context), context);
}
/**
 * Alternatively, use the Factory API!
 * The Factory API declares elementId to be string | null.
 * However, if we pass in a canvas or div element, it will still work.
 * This is because Factory calls new Renderer(elementId, ...) via Renderer.buildContext().
 */
function useFactoryAPI(e, backend) {
    const opts = {
        renderer: { elementId: e, width: STAVE_WIDTH, height: STAVE_HEIGHT, backend },
    };
    const factory = new _src_index__WEBPACK_IMPORTED_MODULE_1__.Factory(opts);
    drawStave(factory.Stave(), factory.getContext());
}
/**
 * Pass in a elementId string. Renderer will call document.getElementById().
 */
function stringElementId(options) {
    const elementId = options.elementId;
    if (options.params.useRendererAPI) {
        useRendererAPI(elementId, options.backend);
    }
    else {
        useFactoryAPI(elementId, options.backend);
    }
    options.assert.ok(true);
}
/**
 * Pass a canvas or div element directly to the Renderer constructor.
 */
function canvasOrDivElement(options) {
    const element = document.getElementById(options.elementId);
    if (options.params.useRendererAPI) {
        useRendererAPI(element, options.backend);
    }
    else {
        useFactoryAPI(element, options.backend);
    }
    options.assert.ok(true);
}
/**
 * Pass the render context directly to the Renderer constructor.
 */
function passRenderContext(options) {
    let context;
    const element = document.getElementById(options.elementId);
    if ((0,_src_index__WEBPACK_IMPORTED_MODULE_1__.isHTMLCanvas)(element)) {
        const ctx = element.getContext('2d');
        if (!ctx) {
            throw new _src_index__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(`Couldn't get context from element "${options.elementId}"`);
        }
        context = new _src_index__WEBPACK_IMPORTED_MODULE_1__.CanvasContext(ctx);
    }
    else {
        context = new _src_index__WEBPACK_IMPORTED_MODULE_1__.SVGContext(element);
    }
    const renderer = new _src_index__WEBPACK_IMPORTED_MODULE_1__.Renderer(context);
    renderer.resize(STAVE_WIDTH, STAVE_HEIGHT);
    drawStave(new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stave(0, 0, STAVE_WIDTH - STAVE_RIGHT_MARGIN).setContext(context), context);
    options.assert.ok(true);
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(RendererTests);



/***/ }),

/***/ "./tests/rests_tests.ts":
/*!******************************!*\
  !*** ./tests/rests_tests.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RestsTests: () => (/* binding */ RestsTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_beam__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/beam */ "./src/beam.ts");
/* harmony import */ var _src_dot__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/dot */ "./src/dot.ts");
/* harmony import */ var _src_flow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/flow */ "./src/flow.ts");
/* harmony import */ var _src_formatter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/formatter */ "./src/formatter.ts");
/* harmony import */ var _src_stave__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/stave */ "./src/stave.ts");
/* harmony import */ var _src_stavenote__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/stavenote */ "./src/stavenote.ts");
/* harmony import */ var _src_tuplet__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/tuplet */ "./src/tuplet.ts");
/* harmony import */ var _src_voice__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/voice */ "./src/voice.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Rests Tests









const RestsTests = {
    Start() {
        QUnit.module('Rests');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Outside Stave', ledgerRest);
        run('Dotted', basic);
        run('Auto Align - Beamed Notes Stems Up', beamsUp);
        run('Auto Align - Beamed Notes Stems Down', beamsDown);
        run('Auto Align - Tuplets Stems Up', tupletsUp);
        run('Auto Align - Tuplets Stems Down', tupletsDown);
        run('Auto Align - Single Voice (Default)', singleVoiceDefaultAlignment);
        run('Auto Align - Single Voice (Align All)', singleVoiceAlignAll);
        run('Auto Align - Multi Voice', multiVoice);
    },
};
/**
 * Helper function to create a context and stave.
 *
 * @param options
 * @param contextBuilder static function in renderer.ts (Renderer.getSVGContext or Renderer.getCanvasContext).
 * @param width
 * @param height
 * @returns object with .context and .stave properties
 */
function setupContext(options, contextBuilder, width = 350, height = 150) {
    // context is SVGContext or CanvasRenderingContext2D (native) or CanvasContext (only if Renderer.USE_CANVAS_PROXY is true).
    const context = contextBuilder(options.elementId, width, height);
    context.scale(0.9, 0.9);
    context.font = '10pt Arial';
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_5__.Stave(10, 30, width).addClef('treble').addTimeSignature('4/4').setContext(context).draw();
    return { context, stave };
}
/**
 * Dotted rests (whole to 128th).
 * The rest duration is specified as 'wr', 'hr', ..., '128r'.
 */
function basic(options, contextBuilder) {
    const { context, stave } = setupContext(options, contextBuilder, 700);
    const notes = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({ keys: ['b/4'], stemDirection: 1, duration: 'wr' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({ keys: ['b/4'], stemDirection: 1, duration: 'hr' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({ keys: ['b/4'], stemDirection: 1, duration: '4r' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({ keys: ['b/4'], stemDirection: 1, duration: '8r' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({ keys: ['b/4'], stemDirection: 1, duration: '16r' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({ keys: ['b/4'], stemDirection: 1, duration: '32r' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({ keys: ['b/4'], stemDirection: 1, duration: '64r' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({ keys: ['b/4'], stemDirection: 1, duration: '128r' }),
    ];
    _src_dot__WEBPACK_IMPORTED_MODULE_2__.Dot.buildAndAttach(notes, { all: true });
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(context, stave, notes);
    options.assert.ok(true, 'Dotted Rest Test');
}
/**
 * Use the ledger glyph if the whole or half rest is above/below the staff
 */
function ledgerRest(options, contextBuilder) {
    const { context, stave } = setupContext(options, contextBuilder, 700);
    const notes = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({ keys: ['a/5'], stemDirection: 1, duration: 'wr' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({ keys: ['c/6'], stemDirection: 1, duration: 'hr' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({ keys: ['b/4'], stemDirection: 1, duration: 'hr' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({ keys: ['a/3'], stemDirection: 1, duration: 'wr' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({ keys: ['f/3'], stemDirection: 1, duration: 'hr' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({ keys: ['b/4'], stemDirection: 1, duration: 'wr' }),
    ];
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(context, stave, notes);
    options.assert.ok(true, 'Leger/Ledger Rest Test');
}
// Optional: Use a helper function to make your code more concise.
const note = (noteStruct) => new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote(noteStruct);
/**
 * Rests are intermixed within beamed notes (with the stems and beams at the top).
 */
function beamsUp(options, contextBuilder) {
    const { context, stave } = setupContext(options, contextBuilder, 600, 160);
    const notes = [
        note({ keys: ['e/5'], stemDirection: 1, duration: '8' }),
        note({ keys: ['b/4'], stemDirection: 1, duration: '8r' }),
        note({ keys: ['b/5'], stemDirection: 1, duration: '8' }),
        note({ keys: ['c/5'], stemDirection: 1, duration: '8' }),
        note({ keys: ['b/4', 'd/5', 'a/5'], stemDirection: 1, duration: '8' }),
        note({ keys: ['b/4'], stemDirection: 1, duration: '8r' }),
        note({ keys: ['b/4'], stemDirection: 1, duration: '8r' }),
        note({ keys: ['c/4'], stemDirection: 1, duration: '8' }),
        note({ keys: ['b/4', 'd/5', 'a/5'], stemDirection: 1, duration: '8' }),
        note({ keys: ['b/4'], stemDirection: 1, duration: '8' }),
        note({ keys: ['b/4'], stemDirection: 1, duration: '8r' }),
        note({ keys: ['c/4'], stemDirection: 1, duration: '8' }),
    ];
    const beam1 = new _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam(notes.slice(0, 4));
    const beam2 = new _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam(notes.slice(4, 8));
    const beam3 = new _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam(notes.slice(8, 12));
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(context, stave, notes);
    beam1.setContext(context).draw();
    beam2.setContext(context).draw();
    beam3.setContext(context).draw();
    options.assert.ok(true, 'Auto Align Rests - Beams Up Test');
}
/**
 * Rests are intermixed within beamed notes (with the stems and beams at the bottom).
 */
function beamsDown(options, contextBuilder) {
    const { context, stave } = setupContext(options, contextBuilder, 600, 160);
    const notes = [
        note({ keys: ['a/5'], stemDirection: -1, duration: '8' }),
        note({ keys: ['b/4'], stemDirection: -1, duration: '8r' }),
        note({ keys: ['b/5'], stemDirection: -1, duration: '8' }),
        note({ keys: ['c/5'], stemDirection: -1, duration: '8' }),
        note({ keys: ['b/4', 'd/5', 'a/5'], stemDirection: -1, duration: '8' }),
        note({ keys: ['b/4'], stemDirection: -1, duration: '8r' }),
        note({ keys: ['b/4'], stemDirection: -1, duration: '8r' }),
        note({ keys: ['e/4'], stemDirection: -1, duration: '8' }),
        note({ keys: ['b/4', 'd/5', 'a/5'], stemDirection: -1, duration: '8' }),
        note({ keys: ['b/4'], stemDirection: -1, duration: '8' }),
        note({ keys: ['b/4'], stemDirection: -1, duration: '8r' }),
        note({ keys: ['e/4'], stemDirection: -1, duration: '8' }),
    ];
    const beam1 = new _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam(notes.slice(0, 4));
    const beam2 = new _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam(notes.slice(4, 8));
    const beam3 = new _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam(notes.slice(8, 12));
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(context, stave, notes);
    beam1.setContext(context).draw();
    beam2.setContext(context).draw();
    beam3.setContext(context).draw();
    options.assert.ok(true, 'Auto Align Rests - Beams Down Test');
}
/**
 * Call setTupletLocation(Tuplet.LOCATION_TOP) to place the tuplet indicator (bracket and number) at the
 * top of the group of notes. Tuplet.LOCATION_TOP is the default, so this is optional.
 */
function tupletsUp(options, contextBuilder) {
    const { context, stave } = setupContext(options, contextBuilder, 600, 160);
    const notes = [
        note({ keys: ['b/4'], stemDirection: 1, duration: '4' }),
        note({ keys: ['b/4'], stemDirection: 1, duration: '4' }),
        note({ keys: ['a/5'], stemDirection: 1, duration: '4r' }),
        note({ keys: ['a/5'], stemDirection: 1, duration: '4r' }),
        note({ keys: ['g/5'], stemDirection: 1, duration: '4r' }),
        note({ keys: ['b/5'], stemDirection: 1, duration: '4' }),
        note({ keys: ['a/5'], stemDirection: 1, duration: '4' }),
        note({ keys: ['g/5'], stemDirection: 1, duration: '4r' }),
        note({ keys: ['b/4'], stemDirection: 1, duration: '4' }),
        note({ keys: ['a/5'], stemDirection: 1, duration: '4' }),
        note({ keys: ['b/4'], stemDirection: 1, duration: '4r' }),
        note({ keys: ['b/4'], stemDirection: 1, duration: '4r' }),
    ];
    const tuplet1 = new _src_tuplet__WEBPACK_IMPORTED_MODULE_7__.Tuplet(notes.slice(0, 3)).setTupletLocation(_src_tuplet__WEBPACK_IMPORTED_MODULE_7__.Tuplet.LOCATION_TOP);
    const tuplet2 = new _src_tuplet__WEBPACK_IMPORTED_MODULE_7__.Tuplet(notes.slice(3, 6)).setTupletLocation(_src_tuplet__WEBPACK_IMPORTED_MODULE_7__.Tuplet.LOCATION_TOP);
    const tuplet3 = new _src_tuplet__WEBPACK_IMPORTED_MODULE_7__.Tuplet(notes.slice(6, 9)).setTupletLocation(_src_tuplet__WEBPACK_IMPORTED_MODULE_7__.Tuplet.LOCATION_TOP);
    const tuplet4 = new _src_tuplet__WEBPACK_IMPORTED_MODULE_7__.Tuplet(notes.slice(9, 12)).setTupletLocation(_src_tuplet__WEBPACK_IMPORTED_MODULE_7__.Tuplet.LOCATION_TOP);
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(context, stave, notes);
    tuplet1.setContext(context).draw();
    tuplet2.setContext(context).draw();
    tuplet3.setContext(context).draw();
    tuplet4.setContext(context).draw();
    options.assert.ok(true, 'Auto Align Rests - Tuplets Stem Up Test');
}
/**
 * Call setTupletLocation(Tuplet.LOCATION_BOTTOM) to place the tuplet indicator (bracket and number) at the
 * bottom of the group of notes.
 */
function tupletsDown(options, contextBuilder) {
    const { context, stave } = setupContext(options, contextBuilder, 600, 160);
    const notes = [
        note({ keys: ['a/5'], stemDirection: -1, duration: '8r' }),
        note({ keys: ['g/5'], stemDirection: -1, duration: '8r' }),
        note({ keys: ['b/4'], stemDirection: -1, duration: '8' }),
        note({ keys: ['a/5'], stemDirection: -1, duration: '8r' }),
        note({ keys: ['g/5'], stemDirection: -1, duration: '8' }),
        note({ keys: ['b/5'], stemDirection: -1, duration: '8' }),
        note({ keys: ['a/5'], stemDirection: -1, duration: '8' }),
        note({ keys: ['g/5'], stemDirection: -1, duration: '8r' }),
        note({ keys: ['b/4'], stemDirection: -1, duration: '8' }),
        note({ keys: ['a/5'], stemDirection: -1, duration: '8' }),
        note({ keys: ['g/5'], stemDirection: -1, duration: '8r' }),
        note({ keys: ['b/4'], stemDirection: -1, duration: '8r' }),
    ];
    const beam1 = new _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam(notes.slice(0, 3));
    const beam2 = new _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam(notes.slice(3, 6));
    const beam3 = new _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam(notes.slice(6, 9));
    const beam4 = new _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam(notes.slice(9, 12));
    const tuplet1 = new _src_tuplet__WEBPACK_IMPORTED_MODULE_7__.Tuplet(notes.slice(0, 3)).setTupletLocation(_src_tuplet__WEBPACK_IMPORTED_MODULE_7__.Tuplet.LOCATION_BOTTOM);
    const tuplet2 = new _src_tuplet__WEBPACK_IMPORTED_MODULE_7__.Tuplet(notes.slice(3, 6)).setTupletLocation(_src_tuplet__WEBPACK_IMPORTED_MODULE_7__.Tuplet.LOCATION_BOTTOM);
    const tuplet3 = new _src_tuplet__WEBPACK_IMPORTED_MODULE_7__.Tuplet(notes.slice(6, 9)).setTupletLocation(_src_tuplet__WEBPACK_IMPORTED_MODULE_7__.Tuplet.LOCATION_BOTTOM);
    const tuplet4 = new _src_tuplet__WEBPACK_IMPORTED_MODULE_7__.Tuplet(notes.slice(9, 12)).setTupletLocation(_src_tuplet__WEBPACK_IMPORTED_MODULE_7__.Tuplet.LOCATION_BOTTOM);
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(context, stave, notes);
    tuplet1.setContext(context).draw();
    tuplet2.setContext(context).draw();
    tuplet3.setContext(context).draw();
    tuplet4.setContext(context).draw();
    beam1.setContext(context).draw();
    beam2.setContext(context).draw();
    beam3.setContext(context).draw();
    beam4.setContext(context).draw();
    options.assert.ok(true, 'Auto Align Rests - Tuplets Stem Down Test');
}
/**
 * By default rests are centered vertically within the stave, except
 * when they are inside a group of beamed notes (in which case they are
 * centered vertically within that group).
 */
function singleVoiceDefaultAlignment(options, contextBuilder) {
    const { context, stave } = setupContext(options, contextBuilder, 600, 160);
    const notes = [
        note({ keys: ['b/4'], stemDirection: -1, duration: '4r' }),
        note({ keys: ['b/4'], stemDirection: -1, duration: '4r' }),
        note({ keys: ['f/4'], stemDirection: -1, duration: '4' }),
        note({ keys: ['e/5'], stemDirection: -1, duration: '8' }),
        note({ keys: ['b/4'], stemDirection: -1, duration: '8r' }),
        note({ keys: ['a/5'], stemDirection: -1, duration: '8' }),
        note({ keys: ['b/4'], stemDirection: -1, duration: '8r' }),
        note({ keys: ['b/4'], stemDirection: -1, duration: '8' }),
        note({ keys: ['e/5'], stemDirection: -1, duration: '8' }),
        note({ keys: ['a/5'], stemDirection: 1, duration: '4' }),
        note({ keys: ['b/4'], stemDirection: 1, duration: '4r' }),
        note({ keys: ['b/5'], stemDirection: 1, duration: '4' }),
        note({ keys: ['d/5'], stemDirection: -1, duration: '4' }),
        note({ keys: ['g/5'], stemDirection: -1, duration: '4' }),
        note({ keys: ['b/4'], stemDirection: -1, duration: '4r' }),
        note({ keys: ['b/4'], stemDirection: -1, duration: '4r' }),
    ];
    const beam = new _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam(notes.slice(5, 9));
    const tuplet = new _src_tuplet__WEBPACK_IMPORTED_MODULE_7__.Tuplet(notes.slice(9, 12)).setTupletLocation(_src_tuplet__WEBPACK_IMPORTED_MODULE_7__.Tuplet.LOCATION_TOP);
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(context, stave, notes);
    tuplet.setContext(context).draw();
    beam.setContext(context).draw();
    options.assert.ok(true, 'Auto Align Rests - Default Test');
}
/**
 * The only difference between staveRestsAll() and staveRests() is that this test case
 * passes { alignRests: true } to Formatter.FormatAndDraw(...).
 */
function singleVoiceAlignAll(options, contextBuilder) {
    const { context, stave } = setupContext(options, contextBuilder, 600, 160);
    const notes = [
        note({ keys: ['b/4'], stemDirection: -1, duration: '4r' }),
        note({ keys: ['b/4'], stemDirection: -1, duration: '4r' }),
        note({ keys: ['f/4'], stemDirection: -1, duration: '4' }),
        note({ keys: ['e/5'], stemDirection: -1, duration: '8' }),
        note({ keys: ['b/4'], stemDirection: -1, duration: '8r' }),
        note({ keys: ['a/5'], stemDirection: -1, duration: '8' }),
        note({ keys: ['b/4'], stemDirection: -1, duration: '8r' }),
        note({ keys: ['b/4'], stemDirection: -1, duration: '8' }),
        note({ keys: ['e/5'], stemDirection: -1, duration: '8' }),
        note({ keys: ['a/5'], stemDirection: 1, duration: '4' }),
        note({ keys: ['b/4'], stemDirection: 1, duration: '4r' }),
        note({ keys: ['b/5'], stemDirection: 1, duration: '4' }),
        note({ keys: ['d/5'], stemDirection: -1, duration: '4' }),
        note({ keys: ['g/5'], stemDirection: -1, duration: '4' }),
        note({ keys: ['b/4'], stemDirection: -1, duration: '4r' }),
        note({ keys: ['b/4'], stemDirection: -1, duration: '4r' }),
    ];
    const beam = new _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam(notes.slice(5, 9));
    const tuplet = new _src_tuplet__WEBPACK_IMPORTED_MODULE_7__.Tuplet(notes.slice(9, 12)).setTupletLocation(_src_tuplet__WEBPACK_IMPORTED_MODULE_7__.Tuplet.LOCATION_TOP);
    // Set { alignRests: true } to align rests (vertically) with nearby notes in each voice.
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(context, stave, notes, { alignRests: true });
    tuplet.setContext(context).draw();
    beam.setContext(context).draw();
    options.assert.ok(true, 'Auto Align Rests - Align All Test');
}
/**
 * Multi Voice
 * The top voice shows quarter-note chords alternating with quarter rests.
 * The bottom voice shows two groups of beamed eighth notes, with eighth rests.
 */
function multiVoice(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 600, 200);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_5__.Stave(50, 10, 500).addClef('treble').setContext(ctx).addTimeSignature('4/4').draw();
    const noteOnStave = (noteStruct) => new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote(noteStruct).setStave(stave);
    const notes1 = [
        noteOnStave({ keys: ['c/4', 'e/4', 'g/4'], duration: '4' }),
        noteOnStave({ keys: ['b/4'], duration: '4r' }),
        noteOnStave({ keys: ['c/4', 'd/4', 'a/4'], duration: '4' }),
        noteOnStave({ keys: ['b/4'], duration: '4r' }),
    ];
    const notes2 = [
        noteOnStave({ keys: ['e/3'], stemDirection: -1, duration: '8' }),
        noteOnStave({ keys: ['b/4'], stemDirection: -1, duration: '8r' }),
        noteOnStave({ keys: ['b/4'], stemDirection: -1, duration: '8r' }),
        noteOnStave({ keys: ['e/3'], stemDirection: -1, duration: '8' }),
        noteOnStave({ keys: ['e/3'], stemDirection: -1, duration: '8' }),
        noteOnStave({ keys: ['b/4'], stemDirection: -1, duration: '8r' }),
        noteOnStave({ keys: ['e/3'], stemDirection: -1, duration: '8' }),
        noteOnStave({ keys: ['e/3'], stemDirection: -1, duration: '8' }),
    ];
    const voice1 = new _src_voice__WEBPACK_IMPORTED_MODULE_8__.Voice(_src_flow__WEBPACK_IMPORTED_MODULE_3__.Flow.TIME4_4).addTickables(notes1);
    const voice2 = new _src_voice__WEBPACK_IMPORTED_MODULE_8__.Voice(_src_flow__WEBPACK_IMPORTED_MODULE_3__.Flow.TIME4_4).addTickables(notes2);
    // Set { alignRests: true } to align rests (vertically) with nearby notes in each voice.
    new _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter().joinVoices([voice1, voice2]).formatToStave([voice1, voice2], stave, { alignRests: true });
    /* eslint-disable camelcase*/
    const beam2_1 = new _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam(notes2.slice(0, 4));
    const beam2_2 = new _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam(notes2.slice(4, 8));
    // Important Note: we need to draw voice2 first, since voice2 generates ledger lines.
    // Otherwise, the ledger lines will be drawn on top of middle C notes in voice1.
    voice2.draw(ctx);
    voice1.draw(ctx);
    beam2_1.setContext(ctx).draw();
    beam2_2.setContext(ctx).draw();
    options.assert.ok(true, 'Strokes Test Multi Voice');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(RestsTests);



/***/ }),

/***/ "./tests/rhythm_tests.ts":
/*!*******************************!*\
  !*** ./tests/rhythm_tests.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RhythmTests: () => (/* binding */ RhythmTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_annotation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/annotation */ "./src/annotation.ts");
/* harmony import */ var _src_beam__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/beam */ "./src/beam.ts");
/* harmony import */ var _src_formatter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/formatter */ "./src/formatter.ts");
/* harmony import */ var _src_stave__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/stave */ "./src/stave.ts");
/* harmony import */ var _src_stavebarline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/stavebarline */ "./src/stavebarline.ts");
/* harmony import */ var _src_stavenote__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/stavenote */ "./src/stavenote.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Rhythm Tests







const RhythmTests = {
    Start() {
        QUnit.module('Rhythm');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        // TODO: Simplify test names by removing 'Rhythm Draw - '.
        run('Rhythm Draw - slash notes', drawBasic);
        run('Rhythm Draw - beamed slash notes', drawBeamedSlashNotes);
        run('Rhythm Draw - beamed slash notes, some rests', drawSlashAndBeamAndRests);
        run('Rhythm Draw - 16th note rhythm with scratches', drawSixtenthWithScratches);
        run('Rhythm Draw - 32nd note rhythm with scratches', drawThirtySecondWithScratches);
    },
};
// CURRENTLY UNUSED. Draws 7 different slash notes without beams.
/*
function drawSlash(options: TestOptions, contextBuilder: ContextBuilder): void {
  const ctx = contextBuilder(options.elementId, 350, 180);
  const stave = new Stave(10, 10, 350);
  stave.setContext(ctx);
  stave.draw();

  const notes: StaveNoteStruct[] = [
    { keys: ['b/4'], duration: 'ws', stemDirection: -1 },
    { keys: ['b/4'], duration: 'hs', stemDirection: -1 },
    { keys: ['b/4'], duration: 'qs', stemDirection: -1 },
    { keys: ['b/4'], duration: '8s', stemDirection: -1 },
    { keys: ['b/4'], duration: '16s', stemDirection: -1 },
    { keys: ['b/4'], duration: '32s', stemDirection: -1 },
    { keys: ['b/4'], duration: '64s', stemDirection: -1 },
  ];
  options.assert.expect(notes.length * 2);

  for (let i = 0; i < notes.length; ++i) {
    const staveNote = new StaveNote(notes[i]).setStave(stave);
    new TickContext()
      .addTickable(staveNote)
      .preFormat()
      .setX((i + 1) * 25);
    staveNote.setContext(ctx).draw();

    options.assert.ok(staveNote.getX() > 0, 'Note ' + i + ' has X value');
    options.assert.ok(staveNote.getYs().length > 0, 'Note ' + i + ' has Y values');
  }
}
*/
function drawBasic(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 800, 150);
    // bar 1
    const staveBar1 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 30, 150);
    staveBar1.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.DOUBLE);
    staveBar1.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.SINGLE);
    staveBar1.addClef('treble');
    staveBar1.addTimeSignature('4/4');
    staveBar1.addKeySignature('C');
    staveBar1.setContext(ctx).draw();
    const notesBar1 = [new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({ keys: ['b/4'], duration: '1s', stemDirection: -1 })];
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_3__.Formatter.FormatAndDraw(ctx, staveBar1, notesBar1);
    // bar 2 - juxtaposing second bar next to first bar
    const staveBar2 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(staveBar1.getWidth() + staveBar1.getX(), staveBar1.getY(), 120);
    staveBar2.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.SINGLE);
    staveBar2.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.SINGLE);
    staveBar2.setContext(ctx).draw();
    // bar 2
    const notesBar2 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({ keys: ['b/4'], duration: '2s', stemDirection: -1 }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({ keys: ['b/4'], duration: '2s', stemDirection: -1 }),
    ];
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_3__.Formatter.FormatAndDraw(ctx, staveBar2, notesBar2);
    // bar 3 - juxtaposing second bar next to first bar
    const staveBar3 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(staveBar2.getWidth() + staveBar2.getX(), staveBar2.getY(), 170);
    staveBar3.setContext(ctx).draw();
    // bar 3
    const notesBar3 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '4s',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '4s',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '4s',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '4s',
            stemDirection: -1,
        }),
    ];
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_3__.Formatter.FormatAndDraw(ctx, staveBar3, notesBar3);
    // bar 4 - juxtaposing second bar next to first bar
    const staveBar4 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(staveBar3.getWidth() + staveBar3.getX(), staveBar3.getY(), 200);
    staveBar4.setContext(ctx).draw();
    // bar 4
    const notesBar4 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '8s',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '8s',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '8s',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '8s',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '8s',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '8s',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '8s',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '8s',
            stemDirection: -1,
        }),
    ];
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_3__.Formatter.FormatAndDraw(ctx, staveBar4, notesBar4);
    options.assert.expect(0);
}
function drawBeamedSlashNotes(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 800, 150);
    // bar 1
    const staveBar1 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 30, 300);
    staveBar1.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.DOUBLE);
    staveBar1.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.SINGLE);
    staveBar1.addClef('treble');
    staveBar1.addTimeSignature('4/4');
    staveBar1.addKeySignature('C');
    staveBar1.setContext(ctx).draw();
    // bar 4
    const notesBar1Part1 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '8s',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '8s',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '8s',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '8s',
            stemDirection: -1,
        }),
    ];
    const notesBar1Part2 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '8s',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '8s',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '8s',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '8s',
            stemDirection: -1,
        }),
    ];
    // create the beams for 8th notes in 2nd measure
    const beam1 = new _src_beam__WEBPACK_IMPORTED_MODULE_2__.Beam(notesBar1Part1);
    const beam2 = new _src_beam__WEBPACK_IMPORTED_MODULE_2__.Beam(notesBar1Part2);
    const notesBar1 = notesBar1Part1.concat(notesBar1Part2);
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_3__.Formatter.FormatAndDraw(ctx, staveBar1, notesBar1);
    // Render beams
    beam1.setContext(ctx).draw();
    beam2.setContext(ctx).draw();
    options.assert.expect(0);
}
function drawSlashAndBeamAndRests(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 800, 150);
    // bar 1
    const staveBar1 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 30, 300);
    staveBar1.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.DOUBLE);
    staveBar1.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.SINGLE);
    staveBar1.addClef('treble');
    staveBar1.addTimeSignature('4/4');
    staveBar1.addKeySignature('F');
    staveBar1.setContext(ctx).draw();
    // bar 1
    const notesBar1Part1 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '8s',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({ keys: ['b/4'], duration: '8s', stemDirection: -1 }),
    ];
    notesBar1Part1[0].addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('C7').setFont('Times', _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.Font.size + 2), 0);
    const notesBar1Part2 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '8r',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '8s',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '8r',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '8s',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '8r',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '8s',
            stemDirection: -1,
        }),
    ];
    // create the beams for 8th notes in 2nd measure
    const beam1 = new _src_beam__WEBPACK_IMPORTED_MODULE_2__.Beam(notesBar1Part1);
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_3__.Formatter.FormatAndDraw(ctx, staveBar1, notesBar1Part1.concat(notesBar1Part2));
    // Render beams
    beam1.setContext(ctx).draw();
    // bar 2 - juxtaposing second bar next to first bar
    const staveBar2 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(staveBar1.getWidth() + staveBar1.getX(), staveBar1.getY(), 220);
    staveBar2.setContext(ctx).draw();
    const notesBar2 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '1s',
            stemDirection: -1,
        }),
    ];
    notesBar2[0].addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('F').setFont('Times', _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.Font.size + 2), 0);
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_3__.Formatter.FormatAndDraw(ctx, staveBar2, notesBar2);
    options.assert.expect(0);
}
function drawSixtenthWithScratches(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 800, 150);
    // bar 1
    const staveBar1 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 30, 300);
    staveBar1.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.DOUBLE);
    staveBar1.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.SINGLE);
    staveBar1.addClef('treble');
    staveBar1.addTimeSignature('4/4');
    staveBar1.addKeySignature('F');
    staveBar1.setContext(ctx).draw();
    // bar 1
    const notesBar1Part1 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '16s',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '16s',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '16m',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '16s',
            stemDirection: -1,
        }),
    ];
    const notesBar1Part2 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '16m',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '16s',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '16r',
            stemDirection: -1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '16s',
            stemDirection: -1,
        }),
    ];
    notesBar1Part1[0].addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('C7').setFont('Times', _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.Font.size + 3), 0);
    // create the beams for 8th notes in 2nd measure
    const beam1 = new _src_beam__WEBPACK_IMPORTED_MODULE_2__.Beam(notesBar1Part1);
    const beam2 = new _src_beam__WEBPACK_IMPORTED_MODULE_2__.Beam(notesBar1Part2);
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_3__.Formatter.FormatAndDraw(ctx, staveBar1, notesBar1Part1.concat(notesBar1Part2));
    // Render beams
    beam1.setContext(ctx).draw();
    beam2.setContext(ctx).draw();
    options.assert.expect(0);
}
function drawThirtySecondWithScratches(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 800, 150);
    // bar 1
    const staveBar1 = new _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave(10, 30, 300);
    staveBar1.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.DOUBLE);
    staveBar1.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_5__.BarlineType.SINGLE);
    staveBar1.addClef('treble');
    staveBar1.addTimeSignature('4/4');
    staveBar1.addKeySignature('F');
    staveBar1.setContext(ctx).draw();
    // bar 1
    const notesBar1Part1 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '32s',
            stemDirection: 1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '32s',
            stemDirection: 1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '32m',
            stemDirection: 1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '32s',
            stemDirection: 1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '32m',
            stemDirection: 1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '32s',
            stemDirection: 1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '32r',
            stemDirection: 1,
        }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_6__.StaveNote({
            keys: ['b/4'],
            duration: '32s',
            stemDirection: 1,
        }),
    ];
    notesBar1Part1[0].addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('C7').setFont('Times', _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.Font.size + 3), 0);
    // Create the beams for 8th notes in 2nd measure.
    const beam1 = new _src_beam__WEBPACK_IMPORTED_MODULE_2__.Beam(notesBar1Part1);
    // Helper function to justify and draw a 4/4 voice.
    _src_formatter__WEBPACK_IMPORTED_MODULE_3__.Formatter.FormatAndDraw(ctx, staveBar1, notesBar1Part1);
    // Render beams
    beam1.setContext(ctx).draw();
    options.assert.expect(0);
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(RhythmTests);



/***/ }),

/***/ "./tests/stave_tests.ts":
/*!******************************!*\
  !*** ./tests/stave_tests.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StaveTests: () => (/* binding */ StaveTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_accidental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/accidental */ "./src/accidental.ts");
/* harmony import */ var _src_beam__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/beam */ "./src/beam.ts");
/* harmony import */ var _src_clef__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/clef */ "./src/clef.ts");
/* harmony import */ var _src_formatter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/formatter */ "./src/formatter.ts");
/* harmony import */ var _src_keysignature__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/keysignature */ "./src/keysignature.ts");
/* harmony import */ var _src_modifier__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/modifier */ "./src/modifier.ts");
/* harmony import */ var _src_stave__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/stave */ "./src/stave.ts");
/* harmony import */ var _src_stavebarline__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/stavebarline */ "./src/stavebarline.ts");
/* harmony import */ var _src_stavenote__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/stavenote */ "./src/stavenote.ts");
/* harmony import */ var _src_staverepetition__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../src/staverepetition */ "./src/staverepetition.ts");
/* harmony import */ var _src_stavevolta__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../src/stavevolta */ "./src/stavevolta.ts");
/* harmony import */ var _src_textnote__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../src/textnote */ "./src/textnote.ts");
/* harmony import */ var _src_timesignature__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../src/timesignature */ "./src/timesignature.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Basic Stave Tests
// TODO: Like Stave.setTempo(t: StaveTempoOptions, ...), Stave.setText(...) could declare an interface called StaveTextOptions.
//       This helps developers because they can use the named type in their code for type checking.














const StaveTests = {
    Start() {
        QUnit.module('Stave');
        QUnit.test('StaveModifiers SortByCategory', sortByCategory);
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Stave Draw Test', draw);
        run('Open Stave Draw Test', drawOpenStave);
        run('Multiple Stave Barline Test', drawMultipleMeasures);
        run('Multiple Stave Barline Test (14pt Section)', drawMultipleMeasures, { fontSize: 14 });
        run('Multiple Stave Repeats Test', drawRepeats);
        run('Stave End Modifiers Test', drawEndModifiers);
        run('Stave Repetition (CODA) Positioning', drawStaveRepetition, { yShift: 0 });
        run('Stave Repetition (CODA) Positioning (-20)', drawStaveRepetition, { yShift: -20 });
        run('Stave Repetition (CODA) Positioning (+10)', drawStaveRepetition, { yShift: +10 });
        run('Multiple Staves Volta Test', drawVolta);
        run('Volta + Modifier Measure Test', drawVoltaModifier);
        run('Tempo Test', drawTempo);
        run('Single Line Configuration Test', configureSingleLine);
        run('Batch Line Configuration Test', configureAllLines);
        run('Stave Text Test', drawStaveText);
        run('Multiple Line Stave Text Test', drawStaveTextMultiLine);
        run('Factory API', factoryAPI);
    },
};
function sortByCategory(assert) {
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(0, 0, 300);
    const clef0 = new _src_clef__WEBPACK_IMPORTED_MODULE_3__.Clef('treble');
    const clef1 = new _src_clef__WEBPACK_IMPORTED_MODULE_3__.Clef('alto');
    const clef2 = new _src_clef__WEBPACK_IMPORTED_MODULE_3__.Clef('bass');
    const time0 = new _src_timesignature__WEBPACK_IMPORTED_MODULE_13__.TimeSignature('C');
    const time1 = new _src_timesignature__WEBPACK_IMPORTED_MODULE_13__.TimeSignature('C|');
    const time2 = new _src_timesignature__WEBPACK_IMPORTED_MODULE_13__.TimeSignature('9/8');
    const key0 = new _src_keysignature__WEBPACK_IMPORTED_MODULE_5__.KeySignature('G');
    const key1 = new _src_keysignature__WEBPACK_IMPORTED_MODULE_5__.KeySignature('F');
    const key2 = new _src_keysignature__WEBPACK_IMPORTED_MODULE_5__.KeySignature('D');
    const bar0 = new _src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.Barline(_src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.SINGLE);
    const bar1 = new _src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.Barline(_src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.DOUBLE);
    const bar2 = new _src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.Barline(_src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.NONE);
    // const order0 = { barlines: 0, clefs: 1, keysignatures: 2, timesignatures: 3 };
    // const order1 = { timesignatures: 0, keysignatures: 1, barlines: 2, clefs: 3 };
    const order0 = { Barline: 0, Clef: 1, KeySignature: 2, TimeSignature: 3 };
    const order1 = { TimeSignature: 0, KeySignature: 1, Barline: 2, Clef: 3 };
    const sortAndCompare = (title, a, b, order) => {
        stave.sortByCategory(a, order);
        // Verify that the two arrays are identical.
        let isSame = true;
        if (a.length !== b.length)
            isSame = false;
        for (let i = 0; i < a.length; ++i) {
            if (a[i] !== b[i])
                isSame = false;
        }
        assert.ok(isSame, title);
    };
    sortAndCompare('Keep the original order 1', [bar0, bar1, clef0, clef1, key0, key1, time0, time1], [bar0, bar1, clef0, clef1, key0, key1, time0, time1], order0);
    sortAndCompare('Keep the original order 2', [time0, time1, key0, key1, bar0, bar1, clef0, clef1], [time0, time1, key0, key1, bar0, bar1, clef0, clef1], order1);
    sortAndCompare('Sort and keep 1', [bar0, bar1, clef0, clef1, key0, key1, time0, time1], [time0, time1, key0, key1, bar0, bar1, clef0, clef1], order1);
    sortAndCompare('Sort and keep 2', [bar0, clef0, key0, time0, key1, time1, clef1, bar1, time2, clef2, bar2, key2], [bar0, bar1, bar2, clef0, clef1, clef2, key0, key1, key2, time0, time1, time2], order0);
    sortAndCompare('Sort and keep 3', [bar2, clef2, key2, time0, key0, time2, clef1, bar1, time1, clef0, bar0, key1], [time0, time2, time1, key2, key0, key1, bar2, bar1, bar0, clef2, clef1, clef0], order1);
}
function draw(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 150);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(10, 10, 300);
    stave.setContext(ctx);
    stave.draw();
    options.assert.equal(stave.getYForNote(0), 100, 'getYForNote(0)');
    options.assert.equal(stave.getYForLine(5), 100, 'getYForLine(5)');
    options.assert.equal(stave.getYForLine(0), 50, 'getYForLine(0) - Top Line');
    options.assert.equal(stave.getYForLine(4), 90, 'getYForLine(4) - Bottom Line');
    options.assert.ok(true, 'all pass');
}
function drawOpenStave(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 350);
    let stave = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(10, 10, 300, { leftBar: false });
    stave.setContext(ctx);
    stave.draw();
    stave = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(10, 150, 300, { rightBar: false });
    stave.setContext(ctx);
    stave.draw();
    options.assert.ok(true, 'all pass');
}
function drawMultipleMeasures(options, contextBuilder) {
    var _a, _b;
    options.assert.expect(0);
    // Get the rendering context
    const ctx = contextBuilder(options.elementId, 550, 200);
    // bar 1
    const staveBar1 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(10, 50, 200);
    staveBar1.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.REPEAT_BEGIN);
    staveBar1.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.DOUBLE);
    staveBar1.setSection('A', 0, 0, (_a = options.params) === null || _a === void 0 ? void 0 : _a.fontSize, false);
    staveBar1.addClef('treble').setContext(ctx).draw();
    const notesBar1 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4'], duration: 'q' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['d/4'], duration: 'q' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['b/4'], duration: 'qr' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4', 'e/4', 'g/4'], duration: 'q' }),
    ];
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, staveBar1, notesBar1);
    // bar 2 - juxtaposing second bar next to first bar
    const staveBar2 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(staveBar1.getWidth() + staveBar1.getX(), staveBar1.getY(), 300);
    staveBar2.setSection('B', 0, 0, (_b = options.params) === null || _b === void 0 ? void 0 : _b.fontSize);
    staveBar2.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.END);
    staveBar2.setContext(ctx).draw();
    const notesBar2Part1 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['d/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['g/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['e/4'], duration: '8' }),
    ];
    const notesBar2Part2 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['d/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['g/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['e/4'], duration: '8' }),
    ];
    // create the beams for 8th notes in 2nd measure
    const beam1 = new _src_beam__WEBPACK_IMPORTED_MODULE_2__.Beam(notesBar2Part1);
    const beam2 = new _src_beam__WEBPACK_IMPORTED_MODULE_2__.Beam(notesBar2Part2);
    const notesBar2 = notesBar2Part1.concat(notesBar2Part2);
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, staveBar2, notesBar2);
    // Render beams
    beam1.setContext(ctx).draw();
    beam2.setContext(ctx).draw();
}
function drawRepeats(options, contextBuilder) {
    options.assert.expect(0);
    // Get the rendering context
    const ctx = contextBuilder(options.elementId, 750, 120);
    // bar 1
    const staveBar1 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(10, 0, 250);
    staveBar1.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.REPEAT_BEGIN);
    staveBar1.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.REPEAT_END);
    staveBar1.addClef('treble');
    staveBar1.addKeySignature('A');
    staveBar1.setContext(ctx).draw();
    const notesBar1 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4'], duration: 'q' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['d/4'], duration: 'q' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['b/4'], duration: 'qr' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4', 'e/4', 'g/4'], duration: 'q' }),
    ];
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, staveBar1, notesBar1);
    // bar 2 - juxtaposing second bar next to first bar
    const staveBar2 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(staveBar1.getWidth() + staveBar1.getX(), staveBar1.getY(), 250);
    staveBar2.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.REPEAT_BEGIN);
    staveBar2.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.REPEAT_END);
    staveBar2.setContext(ctx).draw();
    const notesBar2Part1 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['d/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['g/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['e/4'], duration: '8' }),
    ];
    const notesBar2Part2 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['d/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['g/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['e/4'], duration: '8' }),
    ];
    notesBar2Part2[0].addModifier(new _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental('#'), 0);
    notesBar2Part2[1].addModifier(new _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental('#'), 0);
    notesBar2Part2[3].addModifier(new _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental('b'), 0);
    // create the beams for 8th notes in 2nd measure
    const beam1 = new _src_beam__WEBPACK_IMPORTED_MODULE_2__.Beam(notesBar2Part1);
    const beam2 = new _src_beam__WEBPACK_IMPORTED_MODULE_2__.Beam(notesBar2Part2);
    const notesBar2 = notesBar2Part1.concat(notesBar2Part2);
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, staveBar2, notesBar2);
    // Render beams
    beam1.setContext(ctx).draw();
    beam2.setContext(ctx).draw();
    // bar 3 - juxtaposing third bar next to second bar
    const staveBar3 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(staveBar2.getWidth() + staveBar2.getX(), staveBar2.getY(), 50);
    staveBar3.setContext(ctx).draw();
    const notesBar3 = [new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['d/5'], duration: 'wr' })];
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, staveBar3, notesBar3);
    // bar 4 - juxtaposing third bar next to third bar
    const staveBar4 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(staveBar3.getWidth() + staveBar3.getX(), staveBar3.getY(), 250 - staveBar1.getModifierXShift());
    staveBar4.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.REPEAT_BEGIN);
    staveBar4.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.REPEAT_END);
    staveBar4.setContext(ctx).draw();
    const notesBar4 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4'], duration: 'q' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['d/4'], duration: 'q' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['b/4'], duration: 'qr' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4', 'e/4', 'g/4'], duration: 'q' }),
    ];
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, staveBar4, notesBar4);
}
function drawEndModifiers(options, contextBuilder) {
    options.assert.expect(0);
    const staveWidth = 230;
    const blockHeight = 80;
    let x = 10;
    let y = 0;
    const ctx = contextBuilder(options.elementId, 800, 700);
    function drawStavesInTwoLines(endBarLine) {
        // Draw a stave with one measure. Change the ending modifiers.
        // eslint-disable-next-line
        function drawStave(x, y, width, begMods, endMods) {
            const staveBar = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(x, y, width - 10);
            if (begMods) {
                if (begMods.barLine !== undefined) {
                    staveBar.setBegBarType(begMods.barLine);
                }
                if (begMods.clef !== undefined) {
                    staveBar.addClef(begMods.clef);
                }
                if (begMods.keySig !== undefined) {
                    staveBar.addKeySignature(begMods.keySig);
                }
                if (begMods.timeSig !== undefined) {
                    staveBar.setTimeSignature(begMods.timeSig);
                }
            }
            if (endMods) {
                if (endMods.barLine !== undefined) {
                    staveBar.setEndBarType(endMods.barLine);
                }
                if (endMods.clef !== undefined) {
                    staveBar.addEndClef(endMods.clef);
                }
                if (endMods.keySig !== undefined) {
                    staveBar.setEndKeySignature(endMods.keySig);
                }
                if (endMods.timeSig !== undefined) {
                    staveBar.setEndTimeSignature(endMods.timeSig);
                }
            }
            staveBar.setContext(ctx).draw();
            const notesBar = [
                new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4'], duration: 'q' }),
                new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['d/4'], duration: 'q' }),
                new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['b/4'], duration: 'qr' }),
                new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4', 'e/4', 'g/4'], duration: 'q' }),
            ];
            _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, staveBar, notesBar);
        }
        drawStave(x, y, staveWidth + 50, { barLine: _src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.REPEAT_BEGIN, clef: 'treble', keySig: 'A' }, { barLine: endBarLine, clef: 'bass' });
        x += staveWidth + 50;
        drawStave(x, y, staveWidth, { barLine: _src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.REPEAT_BEGIN }, { barLine: endBarLine, keySig: 'E' });
        x += staveWidth;
        drawStave(x, y, staveWidth, { barLine: _src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.REPEAT_BEGIN }, { barLine: endBarLine, timeSig: '2/4' });
        x += staveWidth;
        x = 10;
        y += blockHeight;
        drawStave(x, y, staveWidth, { barLine: _src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.REPEAT_BEGIN }, { barLine: endBarLine, clef: 'bass', timeSig: '2/4' });
        x += staveWidth;
        drawStave(x, y, staveWidth, { barLine: _src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.REPEAT_BEGIN }, { barLine: endBarLine, clef: 'treble', keySig: 'Ab' });
        x += staveWidth;
        drawStave(x, y, staveWidth, { barLine: _src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.REPEAT_BEGIN }, { barLine: endBarLine, clef: 'bass', keySig: 'Ab', timeSig: '2/4' });
        x += staveWidth;
    }
    y = 0;
    x = 10;
    // First pair of staves.
    drawStavesInTwoLines(_src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.SINGLE);
    y += blockHeight + 10;
    x = 10;
    // Second pair of staves, with double barlines.
    drawStavesInTwoLines(_src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.DOUBLE);
    y += blockHeight + 10;
    x = 10;
    // Third pair of staves, with "two dot" repeat barlines.
    drawStavesInTwoLines(_src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.REPEAT_END);
    y += blockHeight + 10;
    x = 10;
    // Fourth pair of staves, with "two dots" on each side of the barlines.
    drawStavesInTwoLines(_src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.REPEAT_BOTH);
}
function drawStaveRepetition(options, contextBuilder) {
    options.assert.expect(0);
    // Get the rendering context
    const ctx = contextBuilder(options.elementId, 725, 200);
    // bar 1
    const mm1 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(10, 50, 150);
    mm1.addClef('treble');
    mm1.setRepetitionType(_src_staverepetition__WEBPACK_IMPORTED_MODULE_10__.Repetition.type.DS_AL_FINE, options.params.yShift);
    mm1.setMeasure(1);
    mm1.setContext(ctx).draw();
    const notesmm1 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['a/4'], duration: 'q' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['f/4'], duration: 'q' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['f/4'], duration: 'q' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['a/4'], duration: 'q' }),
    ];
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, mm1, notesmm1);
    // bar 2 - juxtapose second measure
    const mm2 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(mm1.getWidth() + mm1.getX(), mm1.getY(), 150);
    mm2.setRepetitionType(_src_staverepetition__WEBPACK_IMPORTED_MODULE_10__.Repetition.type.TO_CODA, options.params.yShift);
    mm2.setMeasure(2);
    mm2.setContext(ctx).draw();
    const notesmm2 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['a/4'], duration: 'q' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['f/4'], duration: 'q' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['f/4'], duration: 'q' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['a/4'], duration: 'q' }),
    ];
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, mm2, notesmm2);
    // bar 3 - juxtapose third measure
    const mm3 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(mm2.getWidth() + mm2.getX(), mm1.getY(), 150);
    mm3.setRepetitionType(_src_staverepetition__WEBPACK_IMPORTED_MODULE_10__.Repetition.type.DS_AL_CODA, options.params.yShift);
    mm3.setMeasure(3);
    mm3.setContext(ctx).draw();
    const notesmm3 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['a/4'], duration: 'q' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['f/4'], duration: 'q' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['f/4'], duration: 'q' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['a/4'], duration: 'q' }),
    ];
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, mm3, notesmm3);
    // bar 4 - juxtapose fourth measure
    const mm4 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(mm3.getWidth() + mm3.getX(), mm1.getY(), 150);
    mm4.setRepetitionType(_src_staverepetition__WEBPACK_IMPORTED_MODULE_10__.Repetition.type.CODA_LEFT, options.params.yShift);
    mm4.setMeasure(4);
    mm4.setContext(ctx).draw();
    const notesmm4 = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['a/4'], duration: 'q' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['f/4'], duration: 'q' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['f/4'], duration: 'q' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['a/4'], duration: 'q' }),
    ];
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, mm4, notesmm4);
}
function drawVolta(options, contextBuilder) {
    options.assert.expect(0);
    // Get the rendering context
    const ctx = contextBuilder(options.elementId, 725, 200);
    // bar 1
    const mm1 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(10, 50, 125);
    mm1.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.REPEAT_BEGIN);
    mm1.setRepetitionType(_src_staverepetition__WEBPACK_IMPORTED_MODULE_10__.Repetition.type.SEGNO_LEFT);
    mm1.addClef('treble');
    mm1.addKeySignature('A');
    mm1.setMeasure(1);
    mm1.setSection('A', 0);
    mm1.setContext(ctx).draw();
    const notesmm1 = [new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4'], duration: 'w' })];
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, mm1, notesmm1);
    // bar 2 - juxtapose second measure
    const mm2 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(mm1.getWidth() + mm1.getX(), mm1.getY(), 60);
    mm2.setRepetitionType(_src_staverepetition__WEBPACK_IMPORTED_MODULE_10__.Repetition.type.CODA_RIGHT);
    mm2.setMeasure(2);
    mm2.setContext(ctx).draw();
    const notesmm2 = [new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['d/4'], duration: 'w' })];
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, mm2, notesmm2);
    // bar 3 - juxtapose third measure
    const mm3 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(mm2.getWidth() + mm2.getX(), mm1.getY(), 60);
    mm3.setVoltaType(_src_stavevolta__WEBPACK_IMPORTED_MODULE_11__.VoltaType.BEGIN, '1.', -5);
    mm3.setMeasure(3);
    mm3.setContext(ctx).draw();
    const notesmm3 = [new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['e/4'], duration: 'w' })];
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, mm3, notesmm3);
    // bar 4 - juxtapose fourth measure
    const mm4 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(mm3.getWidth() + mm3.getX(), mm1.getY(), 60);
    mm4.setVoltaType(_src_stavevolta__WEBPACK_IMPORTED_MODULE_11__.VoltaType.MID, '', -5);
    mm4.setMeasure(4);
    mm4.setContext(ctx).draw();
    const notesmm4 = [new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['f/4'], duration: 'w' })];
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, mm4, notesmm4);
    // bar 5 - juxtapose fifth measure
    const mm5 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(mm4.getWidth() + mm4.getX(), mm1.getY(), 60);
    mm5.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.REPEAT_END);
    mm5.setVoltaType(_src_stavevolta__WEBPACK_IMPORTED_MODULE_11__.VoltaType.END, '', -5);
    mm5.setMeasure(5);
    mm5.setContext(ctx).draw();
    const notesmm5 = [new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['g/4'], duration: 'w' })];
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, mm5, notesmm5);
    // bar 6 - juxtapose sixth measure
    const mm6 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(mm5.getWidth() + mm5.getX(), mm1.getY(), 60);
    mm6.setVoltaType(_src_stavevolta__WEBPACK_IMPORTED_MODULE_11__.VoltaType.BEGIN_END, '2.', -5);
    mm6.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.DOUBLE);
    mm6.setMeasure(6);
    mm6.setContext(ctx).draw();
    const notesmm6 = [new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['a/4'], duration: 'w' })];
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, mm6, notesmm6);
    // bar 7 - juxtapose seventh measure
    const mm7 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(mm6.getWidth() + mm6.getX(), mm1.getY(), 60);
    mm7.setMeasure(7);
    mm7.setSection('B', 0);
    mm7.setContext(ctx).draw();
    const notesmm7 = [new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['b/4'], duration: 'w' })];
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, mm7, notesmm7);
    // bar 8 - juxtapose eighth measure
    const mm8 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(mm7.getWidth() + mm7.getX(), mm1.getY(), 60);
    mm8.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.DOUBLE);
    mm8.setRepetitionType(_src_staverepetition__WEBPACK_IMPORTED_MODULE_10__.Repetition.type.DS_AL_CODA);
    mm8.setMeasure(8);
    mm8.setContext(ctx).draw();
    const notesmm8 = [new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/5'], duration: 'w' })];
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, mm8, notesmm8);
    // bar 9 - juxtapose ninth measure
    const mm9 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(mm8.getWidth() + mm8.getX() + 20, mm1.getY(), 125);
    mm9.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.END);
    mm9.setRepetitionType(_src_staverepetition__WEBPACK_IMPORTED_MODULE_10__.Repetition.type.CODA_LEFT);
    mm9.addClef('treble');
    mm9.addKeySignature('A');
    mm9.setMeasure(9);
    mm9.setContext(ctx).draw();
    const notesmm9 = [new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['d/5'], duration: 'w' })];
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, mm9, notesmm9);
}
function drawVoltaModifier(options, contextBuilder) {
    options.assert.expect(0);
    // Get the rendering context
    const ctx = contextBuilder(options.elementId, 1100, 200);
    // bar 1: volta begin, with modifiers (clef, keysignature)
    const mm1 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(10, 50, 175);
    mm1.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.REPEAT_BEGIN);
    mm1.setVoltaType(_src_stavevolta__WEBPACK_IMPORTED_MODULE_11__.VoltaType.BEGIN_END, '1.', -5);
    mm1.addClef('treble');
    mm1.addKeySignature('A');
    mm1.setMeasure(1);
    mm1.setSection('A', 0);
    mm1.setContext(ctx).draw();
    const notesmm1 = [new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4'], duration: 'w' })];
    // Helper function to justify and draw a 4/4 voice
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, mm1, notesmm1);
    // bar 2: volta beginMid, with modifiers (clef, keysignature)
    const mm2 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(mm1.getX() + mm1.getWidth(), mm1.getY(), 175);
    mm2.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.REPEAT_BEGIN);
    mm2.setRepetitionType(_src_staverepetition__WEBPACK_IMPORTED_MODULE_10__.Repetition.type.DS);
    mm2.setVoltaType(_src_stavevolta__WEBPACK_IMPORTED_MODULE_11__.VoltaType.BEGIN, '2.', -5);
    mm2.addClef('treble');
    mm2.addKeySignature('A');
    mm2.setMeasure(2);
    mm2.setContext(ctx).draw();
    const notesmm2 = [new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4'], duration: 'w' })];
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, mm2, notesmm2);
    // bar 3: volta mid, with modifiers (clef, keysignature)
    const mm3 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(mm2.getX() + mm2.getWidth(), mm2.getY(), 175);
    mm3.setVoltaType(_src_stavevolta__WEBPACK_IMPORTED_MODULE_11__.VoltaType.MID, '', -5);
    mm3.setRepetitionType(_src_staverepetition__WEBPACK_IMPORTED_MODULE_10__.Repetition.type.DS);
    mm3.addClef('treble');
    mm3.addKeySignature('B');
    mm3.setMeasure(3);
    mm3.setSection('B', 0);
    mm3.setContext(ctx).draw();
    const notesmm3 = [new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4'], duration: 'w' })];
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, mm3, notesmm3);
    // bar 4: volta end, with modifiers (clef, keysignature)
    const mm4 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(mm3.getX() + mm3.getWidth(), mm3.getY(), 175);
    mm4.setVoltaType(_src_stavevolta__WEBPACK_IMPORTED_MODULE_11__.VoltaType.END, '1.', -5);
    mm4.setRepetitionType(_src_staverepetition__WEBPACK_IMPORTED_MODULE_10__.Repetition.type.DS);
    mm4.addClef('treble');
    mm4.addKeySignature('A');
    mm4.setMeasure(4);
    mm4.setSection('C', 0);
    mm4.setContext(ctx).draw();
    const notesmm4 = [new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4'], duration: 'w' })];
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, mm4, notesmm4);
    // bar 5: d.s. shift (similar potential x-shift concern)
    const mm5 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(mm4.getX() + mm4.getWidth(), mm4.getY(), 175);
    // mm5.addModifier(new Repetition(Repetition.type.DS, mm4.getX() + mm4.getWidth(), 50), StaveModifierPosition.RIGHT);
    mm5.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_8__.BarlineType.DOUBLE);
    mm5.setRepetitionType(_src_staverepetition__WEBPACK_IMPORTED_MODULE_10__.Repetition.type.DS);
    mm5.addClef('treble');
    mm5.addKeySignature('A');
    mm5.setMeasure(5);
    mm5.setSection('D', 0);
    mm5.setContext(ctx).draw();
    const notesmm5 = [new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4'], duration: 'w' })];
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, mm5, notesmm5);
    // bar 6: d.s. without modifiers
    const mm6 = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(mm5.getX() + mm5.getWidth(), mm5.getY(), 175);
    // mm5.addModifier(new Repetition(Repetition.type.DS, mm4.getX() + mm4.getWidth(), 50), StaveModifierPosition.RIGHT);
    mm6.setRepetitionType(_src_staverepetition__WEBPACK_IMPORTED_MODULE_10__.Repetition.type.DS);
    mm6.setMeasure(6);
    mm6.setSection('E', 0);
    mm6.setContext(ctx).draw();
    const notesmm6 = [new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4'], duration: 'w' })];
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, mm6, notesmm6);
}
function drawTempo(options, contextBuilder) {
    options.assert.expect(0);
    const ctx = contextBuilder(options.elementId, 725, 350);
    const padding = 10;
    let x = 0;
    let y = 50;
    function drawTempoStaveBar(width, tempo, tempoY, notes) {
        const staveBar = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(padding + x, y, width);
        if (x === 0)
            staveBar.addClef('treble');
        staveBar.setTempo(tempo, tempoY);
        staveBar.setContext(ctx).draw();
        const notesBar = notes || [
            new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4'], duration: 'q' }),
            new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['d/4'], duration: 'q' }),
            new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['b/4'], duration: 'q' }),
            new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4'], duration: 'q' }),
        ];
        _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, staveBar, notesBar);
        x += width;
    }
    drawTempoStaveBar(120, { duration: 'q', dots: 1, bpm: 80 }, 0);
    drawTempoStaveBar(100, { duration: '8', dots: 2, bpm: 90 }, 0);
    drawTempoStaveBar(100, { duration: '16', dots: 1, bpm: 96 }, 0);
    drawTempoStaveBar(100, { duration: '32', bpm: 70 }, 0);
    drawTempoStaveBar(250, { name: 'Andante', bpm: 120 }, -20, [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['d/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['g/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['e/5'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['d/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['g/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['e/4'], duration: '8' }),
    ]);
    x = 0;
    y += 150;
    drawTempoStaveBar(120, { duration: 'w', bpm: 80 }, 0);
    drawTempoStaveBar(100, { duration: 'h', bpm: 90 }, 0);
    drawTempoStaveBar(100, { duration: 'q', bpm: 96 }, 0);
    drawTempoStaveBar(100, { duration: '8', bpm: 70 }, 0);
    drawTempoStaveBar(250, { name: 'Andante grazioso' }, 0, [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['d/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['g/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['e/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['c/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['d/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['g/4'], duration: '8' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_9__.StaveNote({ keys: ['e/4'], duration: '8' }),
    ]);
}
function configureSingleLine(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 120);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(10, 10, 300);
    stave
        .setConfigForLine(0, { visible: true })
        .setConfigForLine(1, { visible: false })
        .setConfigForLine(2, { visible: true })
        .setConfigForLine(3, { visible: false })
        .setConfigForLine(4, { visible: true });
    stave.setContext(ctx).draw();
    const config = stave.getConfigForLines();
    options.assert.equal(config[0].visible, true, 'getLinesConfiguration() - Line 0');
    options.assert.equal(config[1].visible, false, 'getLinesConfiguration() - Line 1');
    options.assert.equal(config[2].visible, true, 'getLinesConfiguration() - Line 2');
    options.assert.equal(config[3].visible, false, 'getLinesConfiguration() - Line 3');
    options.assert.equal(config[4].visible, true, 'getLinesConfiguration() - Line 4');
    options.assert.ok(true, 'all pass');
}
function configureAllLines(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 120);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(10, 10, 300);
    stave
        .setConfigForLines([{ visible: false }, {}, { visible: false }, { visible: true }, { visible: false }])
        .setContext(ctx)
        .draw();
    const config = stave.getConfigForLines();
    options.assert.equal(config[0].visible, false, 'getLinesConfiguration() - Line 0');
    options.assert.equal(config[1].visible, true, 'getLinesConfiguration() - Line 1');
    options.assert.equal(config[2].visible, false, 'getLinesConfiguration() - Line 2');
    options.assert.equal(config[3].visible, true, 'getLinesConfiguration() - Line 3');
    options.assert.equal(config[4].visible, false, 'getLinesConfiguration() - Line 4');
    options.assert.ok(true, 'all pass');
}
function drawStaveText(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 900, 140);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(300, 10, 300);
    stave.setStaveText('Violin', _src_modifier__WEBPACK_IMPORTED_MODULE_6__.Modifier.Position.LEFT);
    stave.setStaveText('Right Text', _src_modifier__WEBPACK_IMPORTED_MODULE_6__.Modifier.Position.RIGHT);
    stave.setStaveText('Above Text', _src_modifier__WEBPACK_IMPORTED_MODULE_6__.Modifier.Position.ABOVE);
    stave.setStaveText('Below Text', _src_modifier__WEBPACK_IMPORTED_MODULE_6__.Modifier.Position.BELOW);
    stave.setContext(ctx).draw();
    options.assert.ok(true, 'all pass');
}
function drawStaveTextMultiLine(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 900, 200);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_7__.Stave(300, 40, 300);
    stave.setStaveText('Violin', _src_modifier__WEBPACK_IMPORTED_MODULE_6__.Modifier.Position.LEFT, { shiftY: -10 });
    stave.setStaveText('2nd line', _src_modifier__WEBPACK_IMPORTED_MODULE_6__.Modifier.Position.LEFT, { shiftY: 10 });
    stave.setStaveText('Right Text', _src_modifier__WEBPACK_IMPORTED_MODULE_6__.Modifier.Position.RIGHT, { shiftY: -10 });
    stave.setStaveText('2nd line', _src_modifier__WEBPACK_IMPORTED_MODULE_6__.Modifier.Position.RIGHT, { shiftY: 10 });
    stave.setStaveText('Above Text', _src_modifier__WEBPACK_IMPORTED_MODULE_6__.Modifier.Position.ABOVE, { shiftY: -10 });
    stave.setStaveText('2nd line', _src_modifier__WEBPACK_IMPORTED_MODULE_6__.Modifier.Position.ABOVE, { shiftY: 10 });
    stave.setStaveText('Left Below Text', _src_modifier__WEBPACK_IMPORTED_MODULE_6__.Modifier.Position.BELOW, {
        shiftY: -10,
        justification: _src_textnote__WEBPACK_IMPORTED_MODULE_12__.TextJustification.LEFT,
    });
    stave.setStaveText('Right Below Text', _src_modifier__WEBPACK_IMPORTED_MODULE_6__.Modifier.Position.BELOW, {
        shiftY: 10,
        justification: _src_textnote__WEBPACK_IMPORTED_MODULE_12__.TextJustification.RIGHT,
    });
    stave.setContext(ctx).draw();
    options.assert.ok(true, 'all pass');
}
function factoryAPI(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 900, 200);
    const stave = f.Stave({ x: 300, y: 40, width: 300 });
    stave.setStaveText('Violin', _src_modifier__WEBPACK_IMPORTED_MODULE_6__.Modifier.Position.LEFT, { shiftY: -10 });
    stave.setStaveText('2nd line', _src_modifier__WEBPACK_IMPORTED_MODULE_6__.Modifier.Position.LEFT, { shiftY: 10 });
    f.draw();
    options.assert.ok(true, 'all pass');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(StaveTests);



/***/ }),

/***/ "./tests/staveconnector_tests.ts":
/*!***************************************!*\
  !*** ./tests/staveconnector_tests.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StaveConnectorTests: () => (/* binding */ StaveConnectorTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_flow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/flow */ "./src/flow.ts");
/* harmony import */ var _src_modifier__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/modifier */ "./src/modifier.ts");
/* harmony import */ var _src_stave__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/stave */ "./src/stave.ts");
/* harmony import */ var _src_stavebarline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/stavebarline */ "./src/stavebarline.ts");
/* harmony import */ var _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/staveconnector */ "./src/staveconnector.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// StaveConnector Tests
// TODO: Should we change StaveConnector.type => StaveConnectorType? We are inconsistent with this.






const StaveConnectorTests = {
    Start() {
        QUnit.module('StaveConnector');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Single Draw Test', drawSingle);
        run('Single Draw Test, 4px Stave Line Thickness', drawSingle4pxStaveLines);
        run('Single Both Sides Test', drawSingleBoth);
        run('Double Draw Test', drawDouble);
        run('Bold Double Line Left Draw Test', drawRepeatBegin);
        run('Bold Double Line Right Draw Test', drawRepeatEnd);
        run('Thin Double Line Right Draw Test', drawThinDouble);
        run('Bold Double Lines Overlapping Draw Test', drawRepeatAdjacent);
        run('Bold Double Lines Offset Draw Test', drawRepeatOffset);
        run('Bold Double Lines Offset Draw Test 2', drawRepeatOffset2);
        run('Brace Draw Test', drawBrace);
        run('Brace Wide Draw Test', drawBraceWide);
        run('Bracket Draw Test', drawBracket);
        run('Combined Draw Test', drawCombined);
    },
};
function drawSingle(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 300);
    const stave1 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(25, 10, 300);
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(25, 120, 300);
    stave1.setContext(ctx);
    stave2.setContext(ctx);
    const connector = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave1, stave2);
    connector.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.SINGLE);
    connector.setContext(ctx);
    stave1.draw();
    stave2.draw();
    connector.draw();
    options.assert.ok(true, 'all pass');
}
function drawSingle4pxStaveLines(options, contextBuilder) {
    const oldThickness = _src_flow__WEBPACK_IMPORTED_MODULE_1__.Flow.STAVE_LINE_THICKNESS;
    _src_flow__WEBPACK_IMPORTED_MODULE_1__.Flow.STAVE_LINE_THICKNESS = 4;
    const ctx = contextBuilder(options.elementId, 400, 300);
    const stave1 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(25, 10, 300);
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(25, 120, 300);
    stave1.setContext(ctx);
    stave2.setContext(ctx);
    const connector = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave1, stave2);
    connector.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.SINGLE);
    connector.setContext(ctx);
    stave1.draw();
    stave2.draw();
    connector.draw();
    _src_flow__WEBPACK_IMPORTED_MODULE_1__.Flow.STAVE_LINE_THICKNESS = oldThickness;
    options.assert.ok(true, 'all pass');
}
function drawSingleBoth(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 300);
    const stave1 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(25, 10, 300);
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(25, 120, 300);
    stave1.setContext(ctx);
    stave2.setContext(ctx);
    const connector1 = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave1, stave2);
    connector1.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.SINGLE_LEFT);
    connector1.setContext(ctx);
    const connector2 = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave1, stave2);
    connector2.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.SINGLE_RIGHT);
    connector2.setContext(ctx);
    stave1.draw();
    stave2.draw();
    connector1.draw();
    connector2.draw();
    options.assert.ok(true, 'all pass');
}
function drawDouble(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 300);
    const stave1 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(25, 10, 300);
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(25, 120, 300);
    stave1.setContext(ctx);
    stave2.setContext(ctx);
    const connector = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave1, stave2);
    const line = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave1, stave2);
    connector.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.DOUBLE);
    connector.setContext(ctx);
    line.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.SINGLE);
    connector.setContext(ctx);
    line.setContext(ctx);
    stave1.draw();
    stave2.draw();
    connector.draw();
    line.draw();
    options.assert.ok(true, 'all pass');
}
function drawBrace(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 450, 300);
    const stave1 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(100, 10, 300);
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(100, 120, 300);
    stave1.setContext(ctx);
    stave2.setContext(ctx);
    const connector = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave1, stave2);
    const line = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave1, stave2);
    connector.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.BRACE);
    connector.setContext(ctx);
    connector.setText('Piano');
    line.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.SINGLE);
    connector.setContext(ctx);
    line.setContext(ctx);
    stave1.draw();
    stave2.draw();
    connector.draw();
    line.draw();
    options.assert.ok(true, 'all pass');
}
function drawBraceWide(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 300);
    const stave1 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(25, -20, 300);
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(25, 200, 300);
    stave1.setContext(ctx);
    stave2.setContext(ctx);
    const connector = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave1, stave2);
    const line = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave1, stave2);
    connector.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.BRACE);
    connector.setContext(ctx);
    line.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.SINGLE);
    connector.setContext(ctx);
    line.setContext(ctx);
    stave1.draw();
    stave2.draw();
    connector.draw();
    line.draw();
    options.assert.ok(true, 'all pass');
}
function drawBracket(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 300);
    const stave1 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(25, 10, 300);
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(25, 120, 300);
    stave1.setContext(ctx);
    stave2.setContext(ctx);
    const connector = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave1, stave2);
    const line = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave1, stave2);
    connector.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.BRACKET);
    connector.setContext(ctx);
    line.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.SINGLE);
    connector.setContext(ctx);
    line.setContext(ctx);
    stave1.draw();
    stave2.draw();
    connector.draw();
    line.draw();
    options.assert.ok(true, 'all pass');
}
function drawRepeatBegin(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 300);
    const stave1 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(25, 10, 300);
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(25, 120, 300);
    stave1.setContext(ctx);
    stave2.setContext(ctx);
    stave1.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.REPEAT_BEGIN);
    stave2.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.REPEAT_BEGIN);
    const line = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave1, stave2);
    line.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.BOLD_DOUBLE_LEFT);
    line.setContext(ctx);
    stave1.draw();
    stave2.draw();
    line.draw();
    options.assert.ok(true, 'all pass');
}
function drawRepeatEnd(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 300);
    const stave1 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(25, 10, 300);
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(25, 120, 300);
    stave1.setContext(ctx);
    stave2.setContext(ctx);
    stave1.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.REPEAT_END);
    stave2.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.REPEAT_END);
    const line = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave1, stave2);
    line.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.BOLD_DOUBLE_RIGHT);
    line.setContext(ctx);
    stave1.draw();
    stave2.draw();
    line.draw();
    options.assert.ok(true, 'all pass');
}
function drawThinDouble(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 300);
    const stave1 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(25, 10, 300);
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(25, 120, 300);
    stave1.setContext(ctx);
    stave2.setContext(ctx);
    stave1.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.DOUBLE);
    stave2.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.DOUBLE);
    const line = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave1, stave2);
    line.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.THIN_DOUBLE);
    line.setContext(ctx);
    stave1.draw();
    stave2.draw();
    line.draw();
    options.assert.ok(true, 'all pass');
}
function drawRepeatAdjacent(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 300);
    const stave1 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(25, 10, 150);
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(25, 120, 150);
    const stave3 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(175, 10, 150);
    const stave4 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(175, 120, 150);
    stave1.setContext(ctx);
    stave2.setContext(ctx);
    stave3.setContext(ctx);
    stave4.setContext(ctx);
    stave1.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.REPEAT_END);
    stave2.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.REPEAT_END);
    stave3.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.END);
    stave4.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.END);
    stave1.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.REPEAT_BEGIN);
    stave2.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.REPEAT_BEGIN);
    stave3.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.REPEAT_BEGIN);
    stave4.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.REPEAT_BEGIN);
    const connector1 = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave1, stave2);
    const connector2 = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave1, stave2);
    const connector3 = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave3, stave4);
    const connector4 = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave3, stave4);
    connector1.setContext(ctx);
    connector2.setContext(ctx);
    connector3.setContext(ctx);
    connector4.setContext(ctx);
    connector1.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.BOLD_DOUBLE_LEFT);
    connector2.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.BOLD_DOUBLE_RIGHT);
    connector3.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.BOLD_DOUBLE_LEFT);
    connector4.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.BOLD_DOUBLE_RIGHT);
    stave1.draw();
    stave2.draw();
    stave3.draw();
    stave4.draw();
    connector1.draw();
    connector2.draw();
    connector3.draw();
    connector4.draw();
    options.assert.ok(true, 'all pass');
}
function drawRepeatOffset2(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 300);
    const stave1 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(25, 10, 150);
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(25, 120, 150);
    const stave3 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(175, 10, 150);
    const stave4 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(175, 120, 150);
    stave1.setContext(ctx);
    stave2.setContext(ctx);
    stave3.setContext(ctx);
    stave4.setContext(ctx);
    stave1.addClef('treble');
    stave2.addClef('bass');
    stave3.addClef('alto');
    stave4.addClef('treble');
    stave1.addTimeSignature('4/4');
    stave2.addTimeSignature('4/4');
    stave3.addTimeSignature('6/8');
    stave4.addTimeSignature('6/8');
    stave1.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.REPEAT_END);
    stave2.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.REPEAT_END);
    stave3.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.END);
    stave4.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.END);
    stave1.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.REPEAT_BEGIN);
    stave2.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.REPEAT_BEGIN);
    stave3.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.REPEAT_BEGIN);
    stave4.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.REPEAT_BEGIN);
    const connector1 = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave1, stave2);
    const connector2 = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave1, stave2);
    const connector3 = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave3, stave4);
    const connector4 = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave3, stave4);
    const connector5 = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave3, stave4);
    connector1.setContext(ctx);
    connector2.setContext(ctx);
    connector3.setContext(ctx);
    connector4.setContext(ctx);
    connector5.setContext(ctx);
    connector1.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.BOLD_DOUBLE_LEFT);
    connector2.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.BOLD_DOUBLE_RIGHT);
    connector3.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.BOLD_DOUBLE_LEFT);
    connector4.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.BOLD_DOUBLE_RIGHT);
    connector5.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.SINGLE_LEFT);
    connector1.setXShift(stave1.getModifierXShift());
    connector3.setXShift(stave3.getModifierXShift());
    stave1.draw();
    stave2.draw();
    stave3.draw();
    stave4.draw();
    connector1.draw();
    connector2.draw();
    connector3.draw();
    connector4.draw();
    connector5.draw();
    options.assert.ok(true, 'all pass');
}
function drawRepeatOffset(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 300);
    const stave1 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(25, 10, 150);
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(25, 120, 150);
    const stave3 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(185, 10, 150);
    const stave4 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(185, 120, 150);
    stave1.setContext(ctx);
    stave2.setContext(ctx);
    stave3.setContext(ctx);
    stave4.setContext(ctx);
    stave1.addClef('bass');
    stave2.addClef('alto');
    stave3.addClef('treble');
    stave4.addClef('tenor');
    stave3.addKeySignature('Ab');
    stave4.addKeySignature('Ab');
    stave1.addTimeSignature('4/4');
    stave2.addTimeSignature('4/4');
    stave3.addTimeSignature('6/8');
    stave4.addTimeSignature('6/8');
    stave1.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.REPEAT_END);
    stave2.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.REPEAT_END);
    stave3.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.END);
    stave4.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.END);
    stave1.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.REPEAT_BEGIN);
    stave2.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.REPEAT_BEGIN);
    stave3.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.REPEAT_BEGIN);
    stave4.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.REPEAT_BEGIN);
    const connector1 = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave1, stave2);
    const connector2 = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave1, stave2);
    const connector3 = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave3, stave4);
    const connector4 = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave3, stave4);
    const connector5 = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave3, stave4);
    connector1.setContext(ctx);
    connector2.setContext(ctx);
    connector3.setContext(ctx);
    connector4.setContext(ctx);
    connector5.setContext(ctx);
    connector1.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.BOLD_DOUBLE_LEFT);
    connector2.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.BOLD_DOUBLE_RIGHT);
    connector3.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.BOLD_DOUBLE_LEFT);
    connector4.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.BOLD_DOUBLE_RIGHT);
    connector5.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.SINGLE_LEFT);
    connector1.setXShift(stave1.getModifierXShift());
    connector3.setXShift(stave3.getModifierXShift());
    stave1.draw();
    stave2.draw();
    stave3.draw();
    stave4.draw();
    connector1.draw();
    connector2.draw();
    connector3.draw();
    connector4.draw();
    connector5.draw();
    options.assert.ok(true, 'all pass');
}
function drawCombined(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 550, 700);
    const stave1 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(150, 10, 300);
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(150, 100, 300);
    const stave3 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(150, 190, 300);
    const stave4 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(150, 280, 300);
    const stave5 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(150, 370, 300);
    const stave6 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(150, 460, 300);
    const stave7 = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(150, 560, 300);
    stave1.setStaveText('Violin', _src_modifier__WEBPACK_IMPORTED_MODULE_2__.Modifier.Position.LEFT);
    stave1.setContext(ctx);
    stave2.setContext(ctx);
    stave3.setContext(ctx);
    stave4.setContext(ctx);
    stave5.setContext(ctx);
    stave6.setContext(ctx);
    stave7.setContext(ctx);
    const connSingle = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave1, stave7);
    const connDouble = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave2, stave3);
    const connBracket = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave4, stave7);
    const connNone = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave4, stave5);
    const connBrace = new _src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector(stave6, stave7);
    connSingle.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.SINGLE);
    connDouble.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.DOUBLE);
    connBracket.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.BRACKET);
    connBrace.setType(_src_staveconnector__WEBPACK_IMPORTED_MODULE_5__.StaveConnector.type.BRACE);
    connBrace.setXShift(-5);
    connDouble.setText('Piano');
    connNone.setText('Multiple', { shiftY: -15 });
    connNone.setText('Line Text', { shiftY: 15 });
    connBrace.setText('Harpsichord');
    connSingle.setContext(ctx);
    connDouble.setContext(ctx);
    connBracket.setContext(ctx);
    connNone.setContext(ctx);
    connBrace.setContext(ctx);
    stave1.draw();
    stave2.draw();
    stave3.draw();
    stave4.draw();
    stave5.draw();
    stave6.draw();
    stave7.draw();
    connSingle.draw();
    connDouble.draw();
    connBracket.draw();
    connNone.draw();
    connBrace.draw();
    options.assert.ok(true, 'all pass');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(StaveConnectorTests);



/***/ }),

/***/ "./tests/stavehairpin_tests.ts":
/*!*************************************!*\
  !*** ./tests/stavehairpin_tests.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StaveHairpinTests: () => (/* binding */ StaveHairpinTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_stavehairpin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/stavehairpin */ "./src/stavehairpin.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
// @author Raffaele Viglianti, 2012
//
// StaveHairpin Tests


const StaveHairpinTests = {
    Start() {
        QUnit.module('StaveHairpin');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Simple StaveHairpin', simple);
        run('Horizontal Offset StaveHairpin', horizontal);
        run('Vertical Offset StaveHairpin', vertical);
        run('Height StaveHairpin', height);
    },
};
/**
 * Helper function to draw a single hairpin (either crescendo or decrescendo).
 * @param type is StaveHairpin.type.CRESC or StaveHairpin.type.DECRESC.
 * @param position is Modifier.Position.ABOVE or Modifier.Position.BELOW.
 */
function drawHairpin(firstNote, lastNote, ctx, type, position, options) {
    const hairpin = new _src_stavehairpin__WEBPACK_IMPORTED_MODULE_1__.StaveHairpin({ firstNote, lastNote }, type);
    hairpin.setContext(ctx);
    hairpin.setPosition(position);
    if (options) {
        hairpin.setRenderOptions(options);
    }
    hairpin.draw();
}
/**
 * Helper function
 */
function createTest(drawTwoHairpins) {
    return (options) => {
        const factory = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
        const ctx = factory.getContext();
        const stave = factory.Stave();
        const notes = [
            factory
                .StaveNote({ keys: ['c/4', 'e/4', 'a/4'], stemDirection: 1, duration: '4' })
                .addModifier(factory.Accidental({ type: 'b' }), 0)
                .addModifier(factory.Accidental({ type: '#' }), 1),
            factory.StaveNote({ keys: ['d/4'], stemDirection: 1, duration: '4' }),
            factory.StaveNote({ keys: ['e/4'], stemDirection: 1, duration: '4' }),
            factory.StaveNote({ keys: ['f/4'], stemDirection: 1, duration: '4' }),
        ];
        const voice = factory.Voice().addTickables(notes);
        factory.Formatter().joinVoices([voice]).formatToStave([voice], stave);
        factory.draw();
        drawTwoHairpins(ctx, notes);
        options.assert.ok(true, 'Simple Test');
    };
}
const simple = createTest((ctx, notes) => {
    drawHairpin(notes[0], notes[2], ctx, 1, 4);
    drawHairpin(notes[1], notes[3], ctx, 2, 3);
});
const horizontal = createTest((ctx, notes) => {
    drawHairpin(notes[0], notes[2], ctx, 1, 3, {
        height: 10,
        yShift: 0,
        leftShiftPx: 0,
        rightShiftPx: 0, // right horizontal offset
    });
    drawHairpin(notes[3], notes[3], ctx, 2, 4, {
        height: 10,
        yShift: 0,
        leftShiftPx: 0,
        rightShiftPx: 120, // right horizontal offset
    });
});
const vertical = createTest((ctx, notes) => {
    drawHairpin(notes[0], notes[2], ctx, 1, 4, {
        height: 10,
        yShift: 0,
        leftShiftPx: 0,
        rightShiftPx: 0, // right horizontal offset
    });
    drawHairpin(notes[2], notes[3], ctx, 2, 4, {
        height: 10,
        yShift: -15,
        leftShiftPx: 2,
        rightShiftPx: 0, // right horizontal offset
    });
});
const height = createTest((ctx, notes) => {
    drawHairpin(notes[0], notes[2], ctx, 1, 4, {
        height: 10,
        yShift: 0,
        leftShiftPx: 0,
        rightShiftPx: 0, // right horizontal offset
    });
    drawHairpin(notes[2], notes[3], ctx, 2, 4, {
        height: 15,
        yShift: 0,
        leftShiftPx: 2,
        rightShiftPx: 0, // right horizontal offset
    });
});
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(StaveHairpinTests);



/***/ }),

/***/ "./tests/staveline_tests.ts":
/*!**********************************!*\
  !*** ./tests/staveline_tests.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StaveLineTests: () => (/* binding */ StaveLineTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_dot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/dot */ "./src/dot.ts");
/* harmony import */ var _src_font__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/font */ "./src/font.ts");
/* harmony import */ var _src_metrics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/metrics */ "./src/metrics.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// StaveLine Tests




const StaveLineTests = {
    Start() {
        QUnit.module('StaveLine');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Simple StaveLine', simple0);
        run('StaveLine Arrow Options', simple1);
    },
};
function simple0(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave().addClef('treble');
    const notes = [
        f.StaveNote({ keys: ['c/4'], duration: '4', clef: 'treble' }),
        f.StaveNote({ keys: ['c/5'], duration: '4', clef: 'treble' }),
        f.StaveNote({ keys: ['c/4', 'g/4', 'b/4'], duration: '4', clef: 'treble' }),
        f.StaveNote({ keys: ['f/4', 'a/4', 'f/5'], duration: '4', clef: 'treble' }),
    ];
    const voice = f.Voice().addTickables(notes);
    f.StaveLine({
        from: notes[0],
        to: notes[1],
        firstIndexes: [0],
        lastIndexes: [0],
        options: {
            font: { family: _src_metrics__WEBPACK_IMPORTED_MODULE_3__.Metrics.get('fontFamily'), size: 12, style: _src_font__WEBPACK_IMPORTED_MODULE_2__.FontStyle.ITALIC },
            text: 'gliss.',
        },
    });
    const staveLine2 = f.StaveLine({
        from: notes[2],
        to: notes[3],
        firstIndexes: [2, 1, 0],
        lastIndexes: [0, 1, 2],
    });
    staveLine2.renderOptions.lineDash = [10, 10];
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true);
}
function simple1(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 770);
    const stave = f.Stave().addClef('treble');
    const notes = [
        f.StaveNote({ keys: ['c#/5', 'd/5'], duration: '4', clef: 'treble', stemDirection: -1 }),
        f.StaveNote({ keys: ['c/4'], duration: '4', clef: 'treble' }).addModifier(f.Accidental({ type: '#' }), 0),
        f.StaveNote({ keys: ['c/4', 'e/4', 'g/4'], duration: '4', clef: 'treble' }),
        f
            .StaveNote({ keys: ['f/4', 'a/4', 'c/5'], duration: '4', clef: 'treble' })
            .addModifier(f.Accidental({ type: '#' }), 2),
        f.StaveNote({ keys: ['c/4'], duration: '4', clef: 'treble' }).addModifier(f.Accidental({ type: '#' }), 0),
        f.StaveNote({ keys: ['c#/5', 'd/5'], duration: '4', clef: 'treble', stemDirection: -1 }),
        f.StaveNote({ keys: ['c/4', 'd/4', 'g/4'], duration: '4', clef: 'treble' }),
        f
            .StaveNote({ keys: ['f/4', 'a/4', 'c/5'], duration: '4', clef: 'treble' })
            .addModifier(f.Accidental({ type: '#' }), 2),
    ];
    _src_dot__WEBPACK_IMPORTED_MODULE_1__.Dot.buildAndAttach([notes[0]], { all: true });
    const voice = f.Voice().setStrict(false).addTickables(notes);
    const staveLine0 = f.StaveLine({
        from: notes[0],
        to: notes[1],
        firstIndexes: [0],
        lastIndexes: [0],
        options: { text: 'Left' },
    });
    const staveLine4 = f.StaveLine({
        from: notes[2],
        to: notes[3],
        firstIndexes: [1],
        lastIndexes: [1],
        options: { text: 'Right' },
    });
    const staveLine1 = f.StaveLine({
        from: notes[4],
        to: notes[5],
        firstIndexes: [0],
        lastIndexes: [0],
        options: { text: 'Center' },
    });
    const staveLine2 = f.StaveLine({
        from: notes[6],
        to: notes[7],
        firstIndexes: [1],
        lastIndexes: [0],
    });
    const staveLine3 = f.StaveLine({
        from: notes[6],
        to: notes[7],
        firstIndexes: [2],
        lastIndexes: [2],
        options: { text: 'Top' },
    });
    staveLine0.renderOptions.drawEndArrow = true;
    staveLine0.renderOptions.textJustification = 1;
    staveLine0.renderOptions.textPositionVertical = 2;
    staveLine1.renderOptions.drawEndArrow = true;
    staveLine1.renderOptions.arrowheadLength = 30;
    staveLine1.renderOptions.lineWidth = 5;
    staveLine1.renderOptions.textJustification = 2;
    staveLine1.renderOptions.textPositionVertical = 2;
    staveLine4.renderOptions.lineWidth = 2;
    staveLine4.renderOptions.drawEndArrow = true;
    staveLine4.renderOptions.drawStartArrow = true;
    staveLine4.renderOptions.arrowheadAngle = 0.5;
    staveLine4.renderOptions.arrowheadLength = 20;
    staveLine4.renderOptions.textJustification = 3;
    staveLine4.renderOptions.textPositionVertical = 2;
    staveLine2.renderOptions.drawStartArrow = true;
    staveLine2.renderOptions.lineDash = [5, 4];
    staveLine3.renderOptions.drawEndArrow = true;
    staveLine3.renderOptions.drawStartArrow = true;
    staveLine3.renderOptions.color = 'red';
    staveLine3.renderOptions.textPositionVertical = 1;
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true);
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(StaveLineTests);



/***/ }),

/***/ "./tests/stavemodifier_tests.ts":
/*!**************************************!*\
  !*** ./tests/stavemodifier_tests.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StaveModifierTests: () => (/* binding */ StaveModifierTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_stave__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/stave */ "./src/stave.ts");
/* harmony import */ var _src_stavebarline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/stavebarline */ "./src/stavebarline.ts");
/* harmony import */ var _src_stavemodifier__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/stavemodifier */ "./src/stavemodifier.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// StaveModifier Tests




const StaveModifierTests = {
    Start() {
        QUnit.module('StaveModifier');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Stave Draw Test', draw);
        run('Begin & End StaveModifier Test', drawBeginAndEnd);
    },
};
function draw(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 120);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_1__.Stave(10, 10, 300);
    stave.setContext(ctx);
    stave.draw();
    options.assert.equal(stave.getYForNote(0), 100, 'getYForNote(0)');
    options.assert.equal(stave.getYForLine(5), 100, 'getYForLine(5)');
    options.assert.equal(stave.getYForLine(0), 50, 'getYForLine(0) - Top Line');
    options.assert.equal(stave.getYForLine(4), 90, 'getYForLine(4) - Bottom Line');
    options.assert.ok(true, 'all pass');
}
function drawBeginAndEnd(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 500, 240);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_1__.Stave(10, 10, 400);
    stave.setContext(ctx);
    stave.setTimeSignature('C|');
    stave.setKeySignature('Db');
    stave.setClef('treble');
    stave.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_2__.BarlineType.REPEAT_BEGIN);
    stave.setEndClef('alto');
    stave.setEndTimeSignature('9/8');
    stave.setEndKeySignature('G', 'C#');
    stave.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_2__.BarlineType.DOUBLE);
    stave.draw();
    // change
    const END = _src_stavemodifier__WEBPACK_IMPORTED_MODULE_3__.StaveModifierPosition.END;
    stave.setY(100);
    stave.setTimeSignature('3/4');
    stave.setKeySignature('G', 'C#');
    stave.setClef('bass');
    stave.setBegBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_2__.BarlineType.SINGLE);
    stave.setClef('treble', undefined, undefined, END);
    stave.setTimeSignature('C', undefined, END);
    stave.setKeySignature('F', undefined, END);
    stave.setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_2__.BarlineType.SINGLE);
    stave.draw();
    options.assert.ok(true, 'all pass');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(StaveModifierTests);



/***/ }),

/***/ "./tests/stavenote_tests.ts":
/*!**********************************!*\
  !*** ./tests/stavenote_tests.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StaveNoteTests: () => (/* binding */ StaveNoteTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_accidental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/accidental */ "./src/accidental.ts");
/* harmony import */ var _src_annotation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/annotation */ "./src/annotation.ts");
/* harmony import */ var _src_articulation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/articulation */ "./src/articulation.ts");
/* harmony import */ var _src_beam__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/beam */ "./src/beam.ts");
/* harmony import */ var _src_dot__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/dot */ "./src/dot.ts");
/* harmony import */ var _src_flow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/flow */ "./src/flow.ts");
/* harmony import */ var _src_formatter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/formatter */ "./src/formatter.ts");
/* harmony import */ var _src_fraction__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/fraction */ "./src/fraction.ts");
/* harmony import */ var _src_frethandfinger__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/frethandfinger */ "./src/frethandfinger.ts");
/* harmony import */ var _src_modifier__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../src/modifier */ "./src/modifier.ts");
/* harmony import */ var _src_modifiercontext__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../src/modifiercontext */ "./src/modifiercontext.ts");
/* harmony import */ var _src_stave__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../src/stave */ "./src/stave.ts");
/* harmony import */ var _src_stavenote__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../src/stavenote */ "./src/stavenote.ts");
/* harmony import */ var _src_stem__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../src/stem */ "./src/stem.ts");
/* harmony import */ var _src_stringnumber__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../src/stringnumber */ "./src/stringnumber.ts");
/* harmony import */ var _src_strokes__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../src/strokes */ "./src/strokes.ts");
/* harmony import */ var _src_tickcontext__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../src/tickcontext */ "./src/tickcontext.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// StaveNote Tests
// TODO: In StaveNote.preFormat() line 929, should noteHeadPadding default to StaveNote.minNoteheadPadding?
//       The bounding box of a note changes slightly when we add a ModifierContext (even if we add zero modifiers).


















const StaveNoteTests = {
    Start() {
        QUnit.module('StaveNote');
        QUnit.test('Tick', ticks);
        QUnit.test('Tick - New API', ticksNewAPI);
        QUnit.test('Stem', stem);
        QUnit.test('Automatic Stem Direction', autoStem);
        QUnit.test('Stem Extension Pitch', stemExtensionPitch);
        QUnit.test('Displacement after calling setStemDirection', setStemDirectionDisplacement);
        QUnit.test('StaveLine', staveLine);
        QUnit.test('Width', width);
        QUnit.test('TickContext', tickContext);
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('StaveNote Draw - Treble', drawBasic, { clef: 'treble', octaveShift: 0, restKey: 'r/4' });
        run('StaveNote BoundingBoxes - Treble', drawBoundingBoxes, { clef: 'treble', octaveShift: 0, restKey: 'r/4' });
        run('StaveNote Draw - Alto', drawBasic, { clef: 'alto', octaveShift: -1, restKey: 'r/4' });
        run('StaveNote Draw - Tenor', drawBasic, { clef: 'tenor', octaveShift: -1, restKey: 'r/3' });
        run('StaveNote Draw - Bass', drawBasic, { clef: 'bass', octaveShift: -2, restKey: 'r/3' });
        run('StaveNote Draw - Harmonic And Muted', drawHarmonicAndMuted);
        run('StaveNote Draw - Slash', drawSlash);
        run('Displacements', displacements);
        run('StaveNote Draw - Bass 2', drawBass);
        run('StaveNote Draw - Key Styles', drawKeyStyles);
        run('StaveNote Draw - StaveNote Stem Styles', drawNoteStemStyles);
        run('StaveNote Draw - StaveNote Stem Lengths', drawNoteStemLengths);
        run('StaveNote Draw - StaveNote Flag Styles', drawNoteStylesWithFlag);
        run('StaveNote Draw - StaveNote Styles', drawNoteStyles);
        run('Stave, Ledger Line, Beam, Stem and Flag Styles', drawBeamStyles);
        run('Flag and Dot Placement - Stem Up', dotsAndFlagsStemUp);
        run('Flag and Dots Placement - Stem Down', dotsAndFlagsStemDown);
        run('Beam and Dot Placement - Stem Up', dotsAndBeamsUp);
        run('Beam and Dot Placement - Stem Down', dotsAndBeamsDown);
        run('No Padding', noPadding);
        run('Note Heads Placement - Simple', noteHeadsSimple);
        run('Note Heads Placement - Hidden Notes', noteHeadsHidden);
        run('Center Aligned Note', centerAlignedRest);
        run('Center Aligned Note with Articulation', centerAlignedRestFermata);
        run('Center Aligned Note with Annotation', centerAlignedRestAnnotation);
        run('Center Aligned Note - Multi Voice', centerAlignedMultiVoice);
        run('Center Aligned Note with Multiple Modifiers', centerAlignedNoteMultiModifiers);
        // This interactivity test currently only works with the SVG backend.
        _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runSVGTest('Interactive Mouseover StaveNote', drawBasic, {
            clef: 'treble',
            octaveShift: 0,
            restKey: 'r/4',
            ui: true,
        });
    },
};
// Helper function to create StaveNotes.
const staveNote = (struct) => new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote(struct);
/**
 * Helper function to draw a note with an optional bounding box.
 */
function draw(note, stave, context, x, drawBoundingBox = false, addModifierContext = true) {
    // Associate the note with the stave.
    note.setStave(stave);
    // A ModifierContext is required for dots and other modifiers to be drawn properly.
    // If added, it changes the bounding box of a note, even if there are no modifiers to draw.
    // See StaveNote.minNoteheadPadding in stavenote.ts.
    if (addModifierContext) {
        note.addToModifierContext(new _src_modifiercontext__WEBPACK_IMPORTED_MODULE_11__.ModifierContext());
    }
    new _src_tickcontext__WEBPACK_IMPORTED_MODULE_17__.TickContext().addTickable(note).preFormat().setX(x);
    note.setContext(context).draw();
    if (drawBoundingBox) {
        const bb = note.getBoundingBox();
        context.rect(bb.getX(), bb.getY(), bb.getW(), bb.getH());
        context.stroke();
    }
    return note;
}
function ticks(assert) {
    const BEAT = (1 * _src_flow__WEBPACK_IMPORTED_MODULE_6__.Flow.RESOLUTION) / 4;
    // Key value pairs of `testName: [durationString, expectedBeats, expectedNoteType]`
    const tickTests = {
        'Breve note': ['1/2', 8.0, 'n'],
        'Whole note': ['w', 4.0, 'n'],
        'Quarter note': ['q', 1.0, 'n'],
        'Dotted half note': ['hd', 3.0, 'n'],
        'Doubled-dotted half note': ['hdd', 3.5, 'n'],
        'Triple-dotted half note': ['hddd', 3.75, 'n'],
        'Dotted half rest': ['hdr', 3.0, 'r'],
        'Double-dotted half rest': ['hddr', 3.5, 'r'],
        'Triple-dotted half rest': ['hdddr', 3.75, 'r'],
        'Dotted harmonic quarter note': ['qdh', 1.5, 'h'],
        'Double-dotted harmonic quarter note': ['qddh', 1.75, 'h'],
        'Triple-dotted harmonic quarter note': ['qdddh', 1.875, 'h'],
        'Dotted muted 8th note': ['8dm', 0.75, 'm'],
        'Double-dotted muted 8th note': ['8ddm', 0.875, 'm'],
        'Triple-dotted muted 8th note': ['8dddm', 0.9375, 'm'],
    };
    Object.keys(tickTests).forEach((testName) => {
        const testData = tickTests[testName];
        const durationString = testData[0];
        const expectedBeats = testData[1];
        const expectedNoteType = testData[2];
        const note = new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote({ keys: ['c/4', 'e/4', 'g/4'], duration: durationString });
        assert.equal(note.getTicks().value(), BEAT * expectedBeats, testName + ' must have ' + expectedBeats + ' beats');
        assert.equal(note.getNoteType(), expectedNoteType, 'Note type must be ' + expectedNoteType);
    });
    assert.throws(() => new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote({ keys: ['c/4', 'e/4', 'g/4'], duration: '8.7dddm' }), /BadArguments/, "Invalid note duration '8.7' throws BadArguments exception");
    assert.throws(() => new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote({ keys: ['c/4', 'e/4', 'g/4'], duration: '2Z' }), /BadArguments/, "Invalid note type 'Z' throws BadArguments exception");
    assert.throws(() => new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote({ keys: ['c/4', 'e/4', 'g/4'], duration: '2dddZ' }), /BadArguments/, "Invalid note type 'Z' throws BadArguments exception");
}
function ticksNewAPI(assert) {
    const BEAT = (1 * _src_flow__WEBPACK_IMPORTED_MODULE_6__.Flow.RESOLUTION) / 4;
    // Key value pairs of `testName: [noteData, expectedBeats, expectedNoteType]`
    const tickTests = {
        'Breve note': [{ duration: '1/2' }, 8.0, 'n'],
        'Whole note': [{ duration: 'w' }, 4.0, 'n'],
        'Quarter note': [{ duration: 'q' }, 1.0, 'n'],
        'Dotted half note': [{ duration: 'h', dots: 1 }, 3.0, 'n'],
        'Doubled-dotted half note': [{ duration: 'h', dots: 2 }, 3.5, 'n'],
        'Triple-dotted half note': [{ duration: 'h', dots: 3 }, 3.75, 'n'],
        'Dotted half rest': [{ duration: 'h', dots: 1, type: 'r' }, 3.0, 'r'],
        'Double-dotted half rest': [{ duration: 'h', dots: 2, type: 'r' }, 3.5, 'r'],
        'Triple-dotted half rest': [{ duration: 'h', dots: 3, type: 'r' }, 3.75, 'r'],
        'Dotted harmonic quarter note': [{ duration: 'q', dots: 1, type: 'h' }, 1.5, 'h'],
        'Double-dotted harmonic quarter note': [{ duration: 'q', dots: 2, type: 'h' }, 1.75, 'h'],
        'Triple-dotted harmonic quarter note': [{ duration: 'q', dots: 3, type: 'h' }, 1.875, 'h'],
        'Dotted muted 8th note': [{ duration: '8', dots: 1, type: 'm' }, 0.75, 'm'],
        'Double-dotted muted 8th note': [{ duration: '8', dots: 2, type: 'm' }, 0.875, 'm'],
        'Triple-dotted muted 8th note': [{ duration: '8', dots: 3, type: 'm' }, 0.9375, 'm'],
    };
    Object.keys(tickTests).forEach(function (testName) {
        const testData = tickTests[testName];
        const noteData = testData[0];
        const expectedBeats = testData[1];
        const expectedNoteType = testData[2];
        noteData.keys = ['c/4', 'e/4', 'g/4'];
        const note = new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote(noteData);
        assert.equal(note.getTicks().value(), BEAT * expectedBeats, testName + ' must have ' + expectedBeats + ' beats');
        assert.equal(note.getNoteType(), expectedNoteType, 'Note type must be ' + expectedNoteType);
    });
    assert.throws(() => new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote({ keys: ['c/4', 'e/4', 'g/4'], duration: '8.7dddm' }), /BadArguments/, "Invalid note duration '8.7' throws BadArguments exception");
    assert.throws(() => new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote({ keys: ['c/4', 'e/4', 'g/4'], duration: '2Z' }), /BadArguments/, "Invalid note type 'Z' throws BadArguments exception");
    assert.throws(() => new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote({ keys: ['c/4', 'e/4', 'g/4'], duration: '2dddZ' }), /BadArguments/, "Invalid note type 'Z' throws BadArguments exception");
}
function stem(assert) {
    const note = new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote({ keys: ['c/4', 'e/4', 'g/4'], duration: 'w' });
    assert.equal(note.getStemDirection(), _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP, 'Default note has UP stem');
}
function autoStem(assert) {
    const testData = [
        [['c/5', 'e/5', 'g/5'], _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN],
        [['e/4', 'g/4', 'c/5'], _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP],
        [['c/5'], _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN],
        [['a/4', 'e/5', 'g/5'], _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN],
        [['b/4'], _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN],
    ];
    testData.forEach((td) => {
        const keys = td[0];
        const expectedStemDirection = td[1];
        const note = new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote({ keys: keys, autoStem: true, duration: '8' });
        assert.equal(note.getStemDirection(), expectedStemDirection, 'Stem must be ' + (expectedStemDirection === _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP ? 'up' : 'down'));
    });
}
function stemExtensionPitch(assert) {
    // [keys, expectedStemExtension, override stem direction]
    const testData = [
        [['c/5', 'e/5', 'g/5'], 0, 0],
        [['e/4', 'g/4', 'c/5'], 0, 0],
        [['c/5'], 0, 0],
        [['f/3'], 15, 0],
        [['f/3'], 15, _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP],
        [['f/3'], 0, _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN],
        [['f/3', 'e/5'], 0, 0],
        [['g/6'], 25, 0],
        [['g/6'], 25, _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN],
        [['g/6'], 0, _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP],
    ];
    testData.forEach((td) => {
        const keys = td[0];
        const expectedStemExtension = td[1];
        const overrideStemDirection = td[2];
        let note;
        if (overrideStemDirection === 0) {
            note = new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote({ keys: keys, autoStem: true, duration: '4' });
        }
        else {
            note = new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote({ keys: keys, duration: '4', stemDirection: overrideStemDirection });
        }
        assert.equal(note.getStemExtension(), expectedStemExtension, 'For ' + keys.toString() + ' StemExtension must be ' + expectedStemExtension);
        // set to weird Stave
        const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_12__.Stave(10, 10, 300, { spacingBetweenLinesPx: 20 });
        note.setStave(stave);
        assert.equal(note.getStemExtension(), expectedStemExtension * 2, 'For wide staff ' + keys.toString() + ' StemExtension must be ' + expectedStemExtension * 2);
        //    const wholeNote = new StaveNote({ keys: keys, duration: 'w' });
        //    assert.equal(
        //      wholeNote.getStemExtension(),
        //      -1 * Flow.STEM_HEIGHT,
        //      'For ' + keys.toString() + ' wholeNote StemExtension must always be -1 * Flow.STEM_HEIGHT'
        //    );
    });
}
function setStemDirectionDisplacement(assert) {
    function getDisplacements(note) {
        return note.noteHeads.map((noteHead) => noteHead.isDisplaced());
    }
    const stemUpDisplacements = [false, true, false];
    const stemDownDisplacements = [true, false, false];
    const note = new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote({ keys: ['c/5', 'd/5', 'g/5'], stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP, duration: '4' });
    assert.deepEqual(getDisplacements(note), stemUpDisplacements);
    note.setStemDirection(_src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN);
    assert.deepEqual(getDisplacements(note), stemDownDisplacements);
    note.setStemDirection(_src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP);
    assert.deepEqual(getDisplacements(note), stemUpDisplacements);
}
function staveLine(assert) {
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_12__.Stave(10, 10, 300);
    const note = new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote({ keys: ['c/4', 'e/4', 'a/4'], duration: 'w' });
    note.setStave(stave);
    const props = note.getKeyProps();
    assert.equal(props[0].line, 0, 'C/4 on line 0');
    assert.equal(props[1].line, 1, 'E/4 on line 1');
    assert.equal(props[2].line, 2.5, 'A/4 on line 2.5');
    const ys = note.getYs();
    assert.equal(ys.length, 3, 'Chord should be rendered on three lines');
    assert.equal(ys[0], 100, 'Line for C/4');
    assert.equal(ys[1], 90, 'Line for E/4');
    assert.equal(ys[2], 75, 'Line for A/4');
}
function width(assert) {
    const note = new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote({ keys: ['c/4', 'e/4', 'a/4'], duration: 'w' });
    assert.throws(() => note.getWidth(), /UnformattedNote/, 'Unformatted note should have no width');
}
function tickContext(assert) {
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_12__.Stave(10, 10, 400);
    const note = new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote({ keys: ['c/4', 'e/4', 'a/4'], duration: 'w' }).setStave(stave);
    new _src_tickcontext__WEBPACK_IMPORTED_MODULE_17__.TickContext().addTickable(note).preFormat().setX(10).setPadding(0);
    assert.expect(0);
}
function drawBasic(options, contextBuilder) {
    const clef = options.params.clef;
    const octaveShift = options.params.octaveShift;
    const restKey = options.params.restKey;
    const ctx = contextBuilder(options.elementId, 700, 180);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_12__.Stave(10, 30, 750);
    stave.setContext(ctx);
    stave.addClef(clef);
    stave.draw();
    const lowerKeys = ['c/', 'e/', 'a/'];
    const higherKeys = ['c/', 'e/', 'a/'];
    for (let k = 0; k < lowerKeys.length; k++) {
        lowerKeys[k] = lowerKeys[k] + (4 + octaveShift);
        higherKeys[k] = higherKeys[k] + (5 + octaveShift);
    }
    const restKeys = [restKey];
    const noteStructs = [
        { clef: clef, keys: higherKeys, duration: '1/2' },
        { clef: clef, keys: lowerKeys, duration: 'w' },
        { clef: clef, keys: higherKeys, duration: 'h' },
        { clef: clef, keys: lowerKeys, duration: 'q' },
        { clef: clef, keys: higherKeys, duration: '8' },
        { clef: clef, keys: lowerKeys, duration: '16' },
        { clef: clef, keys: higherKeys, duration: '32' },
        { clef: clef, keys: higherKeys, duration: '64' },
        { clef: clef, keys: higherKeys, duration: '128' },
        { clef: clef, keys: lowerKeys, duration: '1/2', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { clef: clef, keys: lowerKeys, duration: 'w', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { clef: clef, keys: lowerKeys, duration: 'h', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { clef: clef, keys: lowerKeys, duration: 'q', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { clef: clef, keys: lowerKeys, duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { clef: clef, keys: lowerKeys, duration: '16', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { clef: clef, keys: lowerKeys, duration: '32', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { clef: clef, keys: lowerKeys, duration: '64', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { clef: clef, keys: lowerKeys, duration: '128', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { clef: clef, keys: restKeys, duration: '1/2r' },
        { clef: clef, keys: restKeys, duration: 'wr' },
        { clef: clef, keys: restKeys, duration: 'hr' },
        { clef: clef, keys: restKeys, duration: 'qr' },
        { clef: clef, keys: restKeys, duration: '8r' },
        { clef: clef, keys: restKeys, duration: '16r' },
        { clef: clef, keys: restKeys, duration: '32r' },
        { clef: clef, keys: restKeys, duration: '64r' },
        { clef: clef, keys: restKeys, duration: '128r' },
        { keys: ['x/4'], duration: 'h' },
    ];
    options.assert.expect(noteStructs.length * 2);
    const colorDescendants = (parentItem, color) => () => parentItem.querySelectorAll('*').forEach((child) => {
        child.setAttribute('fill', color);
        child.setAttribute('stroke', color);
    });
    for (let i = 0; i < noteStructs.length; ++i) {
        const note = draw(staveNote(noteStructs[i]), stave, ctx, (i + 1) * 25);
        // If this is an interactivity test (ui: true), then attach mouseover & mouseout handlers to the notes.
        if (options.params.ui) {
            const item = note.getSVGElement();
            if (item) {
                item.addEventListener('mouseover', colorDescendants(item, 'green'), false);
                item.addEventListener('mouseout', colorDescendants(item, 'black'), false);
            }
        }
        options.assert.ok(note.getX() > 0, 'Note ' + i + ' has X value');
        options.assert.ok(note.getYs().length > 0, 'Note ' + i + ' has Y values');
    }
}
function drawBoundingBoxes(options, contextBuilder) {
    const clef = options.params.clef;
    const octaveShift = options.params.octaveShift;
    const restKey = options.params.restKey;
    const ctx = contextBuilder(options.elementId, 700, 180);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_12__.Stave(10, 30, 750);
    stave.setContext(ctx);
    stave.addClef(clef);
    stave.draw();
    const lowerKeys = ['c/', 'e/', 'a/'];
    const higherKeys = ['c/', 'e/', 'a/'];
    for (let k = 0; k < lowerKeys.length; k++) {
        lowerKeys[k] = lowerKeys[k] + (4 + octaveShift);
        higherKeys[k] = higherKeys[k] + (5 + octaveShift);
    }
    const restKeys = [restKey];
    const noteStructs = [
        { clef: clef, keys: higherKeys, duration: '1/2' },
        { clef: clef, keys: lowerKeys, duration: 'w' },
        { clef: clef, keys: higherKeys, duration: 'h' },
        { clef: clef, keys: lowerKeys, duration: 'q' },
        { clef: clef, keys: higherKeys, duration: '8' },
        { clef: clef, keys: lowerKeys, duration: '16' },
        { clef: clef, keys: higherKeys, duration: '32' },
        { clef: clef, keys: higherKeys, duration: '64' },
        { clef: clef, keys: higherKeys, duration: '128' },
        { clef: clef, keys: lowerKeys, duration: '1/2', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { clef: clef, keys: lowerKeys, duration: 'w', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { clef: clef, keys: lowerKeys, duration: 'h', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { clef: clef, keys: lowerKeys, duration: 'q', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { clef: clef, keys: lowerKeys, duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { clef: clef, keys: lowerKeys, duration: '16', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { clef: clef, keys: lowerKeys, duration: '32', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { clef: clef, keys: lowerKeys, duration: '64', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { clef: clef, keys: lowerKeys, duration: '128' },
        { clef: clef, keys: restKeys, duration: '1/2r' },
        { clef: clef, keys: restKeys, duration: 'wr' },
        { clef: clef, keys: restKeys, duration: 'hr' },
        { clef: clef, keys: restKeys, duration: 'qr' },
        { clef: clef, keys: restKeys, duration: '8r' },
        { clef: clef, keys: restKeys, duration: '16r' },
        { clef: clef, keys: restKeys, duration: '32r' },
        { clef: clef, keys: restKeys, duration: '64r' },
        { clef: clef, keys: restKeys, duration: '128r' },
        { keys: ['x/4'], duration: 'h' },
    ];
    options.assert.expect(noteStructs.length * 2);
    for (let i = 0; i < noteStructs.length; ++i) {
        const note = draw(staveNote(noteStructs[i]), stave, ctx, (i + 1) * 25, true /* drawBoundingBox */, false /* addModifierContext */);
        options.assert.ok(note.getX() > 0, 'Note ' + i + ' has X value');
        options.assert.ok(note.getYs().length > 0, 'Note ' + i + ' has Y values');
    }
}
function drawBass(options, contextBuilder) {
    options.assert.expect(40);
    const ctx = contextBuilder(options.elementId, 600, 280);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_12__.Stave(10, 10, 650);
    stave.setContext(ctx);
    stave.addClef('bass');
    stave.draw();
    const noteStructs = [
        { clef: 'bass', keys: ['c/3', 'e/3', 'a/3'], duration: '1/2' },
        { clef: 'bass', keys: ['c/2', 'e/2', 'a/2'], duration: 'w' },
        { clef: 'bass', keys: ['c/3', 'e/3', 'a/3'], duration: 'h' },
        { clef: 'bass', keys: ['c/2', 'e/2', 'a/2'], duration: 'q' },
        { clef: 'bass', keys: ['c/3', 'e/3', 'a/3'], duration: '8' },
        { clef: 'bass', keys: ['c/2', 'e/2', 'a/2'], duration: '16' },
        { clef: 'bass', keys: ['c/3', 'e/3', 'a/3'], duration: '32' },
        { clef: 'bass', keys: ['c/2', 'e/2', 'a/2'], duration: 'h', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { clef: 'bass', keys: ['c/2', 'e/2', 'a/2'], duration: 'q', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { clef: 'bass', keys: ['c/2', 'e/2', 'a/2'], duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { clef: 'bass', keys: ['c/2', 'e/2', 'a/2'], duration: '16', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { clef: 'bass', keys: ['c/2', 'e/2', 'a/2'], duration: '32', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['r/4'], duration: '1/2r' },
        { keys: ['r/4'], duration: 'wr' },
        { keys: ['r/4'], duration: 'hr' },
        { keys: ['r/4'], duration: 'qr' },
        { keys: ['r/4'], duration: '8r' },
        { keys: ['r/4'], duration: '16r' },
        { keys: ['r/4'], duration: '32r' },
        { keys: ['x/4'], duration: 'h' },
    ];
    for (let i = 0; i < noteStructs.length; ++i) {
        const note = draw(staveNote(noteStructs[i]), stave, ctx, (i + 1) * 25);
        options.assert.ok(note.getX() > 0, 'Note ' + i + ' has X value');
        options.assert.ok(note.getYs().length > 0, 'Note ' + i + ' has Y values');
    }
}
function displacements(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 700, 155);
    ctx.scale(0.9, 0.9);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_12__.Stave(10, 10, 675);
    stave.setContext(ctx);
    stave.draw();
    const noteStructs = [
        { keys: ['g/3', 'a/3', 'c/4', 'd/4', 'e/4'], duration: '1/2' },
        { keys: ['g/3', 'a/3', 'c/4', 'd/4', 'e/4'], duration: 'w' },
        { keys: ['d/4', 'e/4', 'f/4'], duration: 'h' },
        { keys: ['f/4', 'g/4', 'a/4', 'b/4'], duration: 'q' },
        { keys: ['e/3', 'b/3', 'c/4', 'e/4', 'f/4', 'g/5', 'a/5'], duration: '8' },
        { keys: ['a/3', 'c/4', 'e/4', 'g/4', 'a/4', 'b/4'], duration: '16' },
        { keys: ['c/4', 'e/4', 'a/4'], duration: '32' },
        { keys: ['c/4', 'e/4', 'a/4', 'a/4'], duration: '64' },
        { keys: ['g/3', 'c/4', 'd/4', 'e/4'], duration: 'h', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['d/4', 'e/4', 'f/4'], duration: 'q', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['f/4', 'g/4', 'a/4', 'b/4'], duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['c/4', 'd/4', 'e/4', 'f/4', 'g/4', 'a/4'], duration: '16', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['b/3', 'c/4', 'e/4', 'a/4', 'b/5', 'c/6', 'e/6'], duration: '32', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        {
            keys: ['b/3', 'c/4', 'e/4', 'a/4', 'b/5', 'c/6', 'e/6', 'e/6'],
            duration: '64',
            stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN,
        },
    ];
    options.assert.expect(noteStructs.length * 2);
    for (let i = 0; i < noteStructs.length; ++i) {
        const note = draw(staveNote(noteStructs[i]), stave, ctx, (i + 1) * 45);
        options.assert.ok(note.getX() > 0, 'Note ' + i + ' has X value');
        options.assert.ok(note.getYs().length > 0, 'Note ' + i + ' has Y values');
    }
}
function drawHarmonicAndMuted(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 1000, 180);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_12__.Stave(10, 10, 950);
    stave.setContext(ctx);
    stave.draw();
    const noteStructs = [
        { keys: ['c/4', 'e/4', 'a/4'], duration: '1/2h' },
        { keys: ['c/4', 'e/4', 'a/4'], duration: 'wh' },
        { keys: ['c/4', 'e/4', 'a/4'], duration: 'hh' },
        { keys: ['c/4', 'e/4', 'a/4'], duration: 'qh' },
        { keys: ['c/4', 'e/4', 'a/4'], duration: '8h' },
        { keys: ['c/4', 'e/4', 'a/4'], duration: '16h' },
        { keys: ['c/4', 'e/4', 'a/4'], duration: '32h' },
        { keys: ['c/4', 'e/4', 'a/4'], duration: '64h' },
        { keys: ['c/4', 'e/4', 'a/4'], duration: '128h' },
        { keys: ['c/4', 'e/4', 'a/4'], duration: '1/2h', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['c/4', 'e/4', 'a/4'], duration: 'wh', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['c/4', 'e/4', 'a/4'], duration: 'hh', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['c/4', 'e/4', 'a/4'], duration: 'qh', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['c/4', 'e/4', 'a/4'], duration: '8h', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['c/4', 'e/4', 'a/4'], duration: '16h', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['c/4', 'e/4', 'a/4'], duration: '32h', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['c/4', 'e/4', 'a/4'], duration: '64h', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['c/4', 'e/4', 'a/4'], duration: '128h', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['c/4', 'e/4', 'a/4'], duration: '1/2m' },
        { keys: ['c/4', 'e/4', 'a/4'], duration: 'wm' },
        { keys: ['c/4', 'e/4', 'a/4'], duration: 'hm' },
        { keys: ['c/4', 'e/4', 'a/4'], duration: 'qm' },
        { keys: ['c/4', 'e/4', 'a/4'], duration: '8m' },
        { keys: ['c/4', 'e/4', 'a/4'], duration: '16m' },
        { keys: ['c/4', 'e/4', 'a/4'], duration: '32m' },
        { keys: ['c/4', 'e/4', 'a/4'], duration: '64m' },
        { keys: ['c/4', 'e/4', 'a/4'], duration: '128m' },
        { keys: ['c/4', 'e/4', 'a/4'], duration: '1/2m', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['c/4', 'e/4', 'a/4'], duration: 'wm', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['c/4', 'e/4', 'a/4'], duration: 'hm', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['c/4', 'e/4', 'a/4'], duration: 'qm', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['c/4', 'e/4', 'a/4'], duration: '8m', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['c/4', 'e/4', 'a/4'], duration: '16m', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['c/4', 'e/4', 'a/4'], duration: '32m', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['c/4', 'e/4', 'a/4'], duration: '64m', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['c/4', 'e/4', 'a/4'], duration: '128m', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
    ];
    options.assert.expect(noteStructs.length * 2);
    for (let i = 0; i < noteStructs.length; ++i) {
        const note = draw(staveNote(noteStructs[i]), stave, ctx, i * 25 + 5);
        options.assert.ok(note.getX() > 0, 'Note ' + i + ' has X value');
        options.assert.ok(note.getYs().length > 0, 'Note ' + i + ' has Y values');
    }
}
function drawSlash(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 700, 180);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_12__.Stave(10, 10, 650);
    stave.setContext(ctx);
    stave.draw();
    const notes = [
        { keys: ['b/4'], duration: '1/2s', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['b/4'], duration: 'ws', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['b/4'], duration: 'hs', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['b/4'], duration: 'qs', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['b/4'], duration: '8s', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['b/4'], duration: '16s', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['b/4'], duration: '32s', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['b/4'], duration: '64s', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['b/4'], duration: '128s', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['b/4'], duration: '1/2s', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP },
        { keys: ['b/4'], duration: 'ws', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP },
        { keys: ['b/4'], duration: 'hs', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP },
        { keys: ['b/4'], duration: 'qs', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP },
        { keys: ['b/4'], duration: '8s', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP },
        { keys: ['b/4'], duration: '16s', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP },
        { keys: ['b/4'], duration: '32s', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP },
        { keys: ['b/4'], duration: '64s', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP },
        { keys: ['b/4'], duration: '128s', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP },
        // Beam
        { keys: ['b/4'], duration: '8s', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['b/4'], duration: '8s', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['b/4'], duration: '8s', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP },
        { keys: ['b/4'], duration: '8s', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP },
    ];
    const staveNotes = notes.map((struct) => new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote(struct));
    const beam1 = new _src_beam__WEBPACK_IMPORTED_MODULE_4__.Beam([staveNotes[16], staveNotes[17]]);
    const beam2 = new _src_beam__WEBPACK_IMPORTED_MODULE_4__.Beam([staveNotes[18], staveNotes[19]]);
    _src_formatter__WEBPACK_IMPORTED_MODULE_7__.Formatter.FormatAndDraw(ctx, stave, staveNotes, false);
    beam1.setContext(ctx).draw();
    beam2.setContext(ctx).draw();
    options.assert.ok('Slash Note Heads');
}
function drawKeyStyles(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 300, 280);
    ctx.scale(3, 3);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_12__.Stave(10, 0, 100);
    const note = new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote({ keys: ['g/4', 'bb/4', 'd/5'], duration: 'q' })
        .setStave(stave)
        .addModifier(new _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental('b'), 1)
        .setKeyStyle(1, { shadowBlur: 2, shadowColor: 'blue', fillStyle: 'blue' });
    new _src_tickcontext__WEBPACK_IMPORTED_MODULE_17__.TickContext().addTickable(note).preFormat().setX(25);
    stave.setContext(ctx).draw();
    note.setContext(ctx).draw();
    options.assert.ok(note.getX() > 0, 'Note has X value');
    options.assert.ok(note.getYs().length > 0, 'Note has Y values');
}
function drawNoteStyles(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 300, 280);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_12__.Stave(10, 0, 100);
    ctx.scale(3, 3);
    const note = new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote({ keys: ['g/4', 'bb/4', 'd/5'], duration: '8' })
        .setStave(stave)
        .addModifier(new _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental('b'), 1);
    note.setStyle({ shadowBlur: 2, shadowColor: 'blue', fillStyle: 'blue', strokeStyle: 'blue' });
    new _src_tickcontext__WEBPACK_IMPORTED_MODULE_17__.TickContext().addTickable(note).preFormat().setX(25);
    stave.setContext(ctx).draw();
    note.setContext(ctx).draw();
    options.assert.ok(note.getX() > 0, 'Note has X value');
    options.assert.ok(note.getYs().length > 0, 'Note has Y values');
}
function drawNoteStemStyles(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 300, 280);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_12__.Stave(10, 0, 100);
    ctx.scale(3, 3);
    const note = new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote({ keys: ['g/4', 'bb/4', 'd/5'], duration: 'q' })
        .setStave(stave)
        .addModifier(new _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental('b'), 1);
    note.setStemStyle({ shadowBlur: 2, shadowColor: 'blue', fillStyle: 'blue', strokeStyle: 'blue' });
    new _src_tickcontext__WEBPACK_IMPORTED_MODULE_17__.TickContext().addTickable(note).preFormat().setX(25);
    stave.setContext(ctx).draw();
    note.setContext(ctx).draw();
    options.assert.ok('Note Stem Style');
}
function drawNoteStemLengths(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 975, 150);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_12__.Stave(10, 10, 975);
    stave.setContext(ctx).draw();
    const keys = [
        'e/3',
        'f/3',
        'g/3',
        'a/3',
        'b/3',
        'c/4',
        'd/4',
        'e/4',
        'f/4',
        'g/4',
        'f/5',
        'g/5',
        'a/5',
        'b/5',
        'c/6',
        'd/6',
        'e/6',
        'f/6',
        'g/6',
        'a/6',
    ];
    const notes = [];
    let note;
    let i;
    for (i = 0; i < keys.length; i++) {
        let duration = 'q';
        if (i % 2 === 1) {
            duration = '8';
        }
        note = new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote({ keys: [keys[i]], duration, autoStem: true }).setStave(stave);
        new _src_tickcontext__WEBPACK_IMPORTED_MODULE_17__.TickContext().addTickable(note);
        note.setContext(ctx);
        notes.push(note);
    }
    const wholeKeys = ['e/3', 'a/3', 'f/5', 'a/5', 'd/6', 'a/6'];
    for (i = 0; i < wholeKeys.length; i++) {
        note = new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote({ keys: [wholeKeys[i]], duration: 'w' }).setStave(stave);
        new _src_tickcontext__WEBPACK_IMPORTED_MODULE_17__.TickContext().addTickable(note);
        note.setContext(ctx);
        notes.push(note);
    }
    _src_formatter__WEBPACK_IMPORTED_MODULE_7__.Formatter.FormatAndDraw(ctx, stave, notes);
    options.assert.ok('Note Stem Length');
}
function drawNoteStylesWithFlag(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 300, 280);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_12__.Stave(10, 0, 100);
    ctx.scale(3, 3);
    const note = new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote({ keys: ['g/4', 'bb/4', 'd/5'], duration: '8' })
        .setStave(stave)
        .addModifier(new _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental('b'), 1);
    note.setFlagStyle({ shadowBlur: 2, shadowColor: 'blue', fillStyle: 'blue', strokeStyle: 'blue' });
    new _src_tickcontext__WEBPACK_IMPORTED_MODULE_17__.TickContext().addTickable(note).preFormat().setX(25);
    stave.setContext(ctx).draw();
    note.setContext(ctx).draw();
    options.assert.ok(note.getX() > 0, 'Note has X value');
    options.assert.ok(note.getYs().length > 0, 'Note has Y values');
}
function drawBeamStyles(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 160);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_12__.Stave(10, 10, 380);
    stave.setStyle({ strokeStyle: '#EEAAEE', lineWidth: 3 });
    stave.setContext(ctx);
    stave.draw();
    const notes = [
        // beam1
        { keys: ['b/4'], duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['b/4'], duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        // should be unstyled...
        { keys: ['b/4'], duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        // beam2 should also be unstyled
        { keys: ['b/4'], duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['b/4'], duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        // beam3
        { keys: ['b/4'], duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP },
        { keys: ['b/4'], duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP },
        // beam4
        { keys: ['d/6'], duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        { keys: ['c/6', 'd/6'], duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        // unbeamed
        { keys: ['d/6', 'e/6'], duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
        // unbeamed, unstyled
        { keys: ['e/6', 'f/6'], duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN },
    ];
    const staveNotes = notes.map((note) => new _src_stavenote__WEBPACK_IMPORTED_MODULE_13__.StaveNote(note));
    const beam1 = new _src_beam__WEBPACK_IMPORTED_MODULE_4__.Beam(staveNotes.slice(0, 2));
    const beam2 = new _src_beam__WEBPACK_IMPORTED_MODULE_4__.Beam(staveNotes.slice(3, 5));
    const beam3 = new _src_beam__WEBPACK_IMPORTED_MODULE_4__.Beam(staveNotes.slice(5, 7));
    const beam4 = new _src_beam__WEBPACK_IMPORTED_MODULE_4__.Beam(staveNotes.slice(7, 9));
    // stem, key, ledger, flag; beam.setStyle
    beam1.setStyle({ fillStyle: 'blue', strokeStyle: 'blue' });
    staveNotes[0].setKeyStyle(0, { fillStyle: 'purple' });
    staveNotes[0].setStemStyle({ strokeStyle: 'green' });
    staveNotes[1].setStemStyle({ strokeStyle: 'orange' });
    staveNotes[1].setKeyStyle(0, { fillStyle: 'darkturquoise' });
    staveNotes[5].setStyle({ fillStyle: 'tomato', strokeStyle: 'tomato' });
    beam3.setStyle({ shadowBlur: 4, shadowColor: 'blue' });
    staveNotes[9].setLedgerLineStyle({ fillStyle: 'lawngreen', strokeStyle: 'lawngreen', lineWidth: 1 });
    staveNotes[9].setFlagStyle({ fillStyle: 'orange', strokeStyle: 'orange' });
    _src_formatter__WEBPACK_IMPORTED_MODULE_7__.Formatter.FormatAndDraw(ctx, stave, staveNotes, false);
    beam1.setContext(ctx).draw();
    beam2.setContext(ctx).draw();
    beam3.setContext(ctx).draw();
    beam4.setContext(ctx).draw();
    options.assert.ok('draw beam styles');
}
function dotsAndFlagsStemUp(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 800, 150);
    ctx.scale(1.0, 1.0);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_12__.Stave(10, 10, 975);
    const notes = [
        staveNote({ keys: ['f/4'], duration: '4', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP }),
        staveNote({ keys: ['f/4'], duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP }),
        staveNote({ keys: ['f/4'], duration: '16', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP }),
        staveNote({ keys: ['f/4'], duration: '32', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP }),
        staveNote({ keys: ['f/4'], duration: '64', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP }),
        staveNote({ keys: ['f/4'], duration: '128', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP }),
        staveNote({ keys: ['g/4'], duration: '4', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP }),
        staveNote({ keys: ['g/4'], duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP }),
        staveNote({ keys: ['g/4'], duration: '16', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP }),
        staveNote({ keys: ['g/4'], duration: '32' }),
        staveNote({ keys: ['g/4'], duration: '64', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP }),
        staveNote({ keys: ['g/4'], duration: '128', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP }),
    ];
    _src_dot__WEBPACK_IMPORTED_MODULE_5__.Dot.buildAndAttach(notes, { all: true });
    _src_dot__WEBPACK_IMPORTED_MODULE_5__.Dot.buildAndAttach([notes[5], notes[11]], { all: true });
    stave.setContext(ctx).draw();
    for (let i = 0; i < notes.length; ++i) {
        draw(notes[i], stave, ctx, i * 65);
    }
    options.assert.ok(true, 'Full Dot');
}
function dotsAndFlagsStemDown(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 800, 160);
    ctx.scale(1.0, 1.0);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_12__.Stave(10, 10, 975);
    const staveNotes = [
        staveNote({ keys: ['e/5'], duration: '4', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN }),
        staveNote({ keys: ['e/5'], duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN }),
        staveNote({ keys: ['e/5'], duration: '16', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN }),
        staveNote({ keys: ['e/5'], duration: '32', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN }),
        staveNote({ keys: ['e/5'], duration: '64', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN }),
        staveNote({ keys: ['e/5'], duration: '128', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN }),
        staveNote({ keys: ['d/5'], duration: '4', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN }),
        staveNote({ keys: ['d/5'], duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN }),
        staveNote({ keys: ['d/5'], duration: '16', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN }),
        staveNote({ keys: ['d/5'], duration: '32', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN }),
        staveNote({ keys: ['d/5'], duration: '64', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN }),
        staveNote({ keys: ['d/5'], duration: '128', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN }),
    ];
    _src_dot__WEBPACK_IMPORTED_MODULE_5__.Dot.buildAndAttach(staveNotes, { all: true });
    stave.setContext(ctx).draw();
    for (let i = 0; i < staveNotes.length; ++i) {
        draw(staveNotes[i], stave, ctx, i * 65);
    }
    options.assert.ok(true, 'Full Dot');
}
function dotsAndBeamsUp(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 800, 150);
    ctx.scale(1.0, 1.0);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_12__.Stave(10, 10, 975);
    const staveNotes = [
        staveNote({ keys: ['f/4'], duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP }),
        staveNote({ keys: ['f/4'], duration: '16', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP }),
        staveNote({ keys: ['f/4'], duration: '32', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP }),
        staveNote({ keys: ['f/4'], duration: '64', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP }),
        staveNote({ keys: ['f/4'], duration: '128', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP }),
        staveNote({ keys: ['g/4'], duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP }),
        staveNote({ keys: ['g/4'], duration: '16', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP }),
        staveNote({ keys: ['g/4'], duration: '32' }),
        staveNote({ keys: ['g/4'], duration: '64', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP }),
        staveNote({ keys: ['g/4'], duration: '128', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.UP }),
    ];
    _src_dot__WEBPACK_IMPORTED_MODULE_5__.Dot.buildAndAttach(staveNotes, { all: true });
    _src_dot__WEBPACK_IMPORTED_MODULE_5__.Dot.buildAndAttach([staveNotes[4], staveNotes[9]], { all: true });
    const beam = new _src_beam__WEBPACK_IMPORTED_MODULE_4__.Beam(staveNotes);
    stave.setContext(ctx).draw();
    for (let i = 0; i < staveNotes.length; ++i) {
        draw(staveNotes[i], stave, ctx, i * 65);
    }
    beam.setContext(ctx).draw();
    options.assert.ok(true, 'Full Dot');
}
function dotsAndBeamsDown(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 800, 160);
    ctx.scale(1.0, 1.0);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_12__.Stave(10, 10, 975);
    const staveNotes = [
        staveNote({ keys: ['e/5'], duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN }),
        staveNote({ keys: ['e/5'], duration: '16', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN }),
        staveNote({ keys: ['e/5'], duration: '32', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN }),
        staveNote({ keys: ['e/5'], duration: '64', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN }),
        staveNote({ keys: ['e/5'], duration: '128', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN }),
        staveNote({ keys: ['d/5'], duration: '8', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN }),
        staveNote({ keys: ['d/5'], duration: '16', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN }),
        staveNote({ keys: ['d/5'], duration: '32', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN }),
        staveNote({ keys: ['d/5'], duration: '64', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN }),
        staveNote({ keys: ['d/5'], duration: '128', stemDirection: _src_stem__WEBPACK_IMPORTED_MODULE_14__.Stem.DOWN }),
    ];
    _src_dot__WEBPACK_IMPORTED_MODULE_5__.Dot.buildAndAttach(staveNotes, { all: true });
    const beam = new _src_beam__WEBPACK_IMPORTED_MODULE_4__.Beam(staveNotes);
    stave.setContext(ctx).draw();
    for (let i = 0; i < staveNotes.length; ++i) {
        draw(staveNotes[i], stave, ctx, i * 65);
    }
    beam.setContext(ctx).draw();
    options.assert.ok(true, 'Full Dot');
}
function noteHeadsSimple(options) {
    const vf = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 800, 250);
    const score = vf.EasyScore();
    const system1 = vf.System({ y: 100, x: 50, width: 200 });
    system1
        .addStave({
        voices: [
            score.voice([...score.beam(score.notes('a4/8, b4/8', { stem: 'up' })), ...score.notes('a4/q/r, a4/h/r')]),
            score.voice(score.notes('g4/w')),
        ],
    })
        .addClef('treble')
        .addTimeSignature('4/4');
    const system2 = vf.System({ y: 100, x: 250, width: 150 });
    system2.addStave({
        voices: [score.voice(score.notes('b4/h, b4/h/r')), score.voice(score.notes('b4/w'))],
    });
    const system3 = vf.System({ y: 100, x: 400, width: 150 });
    system3.addStave({
        voices: [score.voice(score.notes('d5/h, d5/h/r')), score.voice(score.notes('e4/w'))],
    });
    const system4 = vf.System({ y: 100, x: 550, width: 150 });
    system4.addStave({
        voices: [
            score.voice(score.notes('e4/q, e4/q/r, e4/h/r')),
            score.voice(score.notes('e4/8, e4/8/r, e4/q/r, e4/h/r')),
        ],
    });
    vf.draw();
    options.assert.expect(0);
}
function noPadding(options) {
    const vf = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 800, 500);
    const score = vf.EasyScore();
    function newStave(y, noPadding) {
        let system = vf.System({ y, x: 50, width: 200, noPadding });
        system
            .addStave({
            voices: [
                score.voice([...score.beam(score.notes('a4/8, b4/8', { stem: 'up' })), ...score.notes('a4/q, a4/h')]),
                score.voice(score.notes('g4/w')),
            ],
        })
            .addClef('treble')
            .addTimeSignature('4/4');
        system = vf.System({ y, x: 250, width: 150, noPadding });
        system.addStave({
            voices: [score.voice(score.notes('b4/h, b4/h')), score.voice(score.notes('b4/w'))],
        });
        system = vf.System({ y, x: 400, width: 150, noPadding });
        system.addStave({
            voices: [score.voice(score.notes('d5/h, d5/h')), score.voice(score.notes('e4/w'))],
        });
        system = vf.System({ y, x: 550, width: 150, noPadding });
        system.addStave({
            voices: [score.voice(score.notes('e4/q, e4/q, e4/h')), score.voice(score.notes('e4/8, e4/8, e4/q, e4/h'))],
        });
    }
    newStave(100, true);
    newStave(200, false);
    vf.draw();
    options.assert.expect(0);
}
function noteHeadsHidden(options) {
    const vf = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 800, 250);
    const score = vf.EasyScore();
    const system1 = vf.System({ y: 100, x: 50, width: 200 });
    const notes1 = score.notes('g4/w');
    notes1[0].renderOptions.draw = false;
    system1
        .addStave({
        voices: [
            score.voice([...score.beam(score.notes('a4/8, b4/8', { stem: 'up' })), ...score.notes('a4/q/r, a4/h/r')]),
            score.voice(notes1),
        ],
    })
        .addClef('treble')
        .addTimeSignature('4/4');
    const system2 = vf.System({ y: 100, x: 250, width: 150 });
    const notes2 = score.notes('b4/w');
    notes2[0].renderOptions.draw = false;
    system2.addStave({
        voices: [score.voice(score.notes('b4/h, b4/h/r')), score.voice(notes2)],
    });
    const system3 = vf.System({ y: 100, x: 400, width: 150 });
    system3.addStave({
        voices: [score.voice(score.notes('d5/h, d5/h/r')), score.voice(score.notes('e4/w'))],
    });
    const system4 = vf.System({ y: 100, x: 550, width: 150 });
    const notes4 = score.notes('e4/q, e4/q/r, e4/h/r');
    notes4[0].renderOptions.draw = false;
    notes4[2].renderOptions.draw = false;
    system4.addStave({
        voices: [score.voice(notes4), score.voice(score.notes('e4/8, e4/8/r, e4/q/r, e4/h/r'))],
    });
    vf.draw();
    options.assert.expect(0);
}
function centerAlignedRest(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 400, 160);
    const stave = f.Stave({ x: 10, y: 10, width: 350 }).addClef('treble').addTimeSignature('4/4');
    const note = f.StaveNote({ keys: ['b/4'], duration: '1r', alignCenter: true });
    const voice = f.Voice().setStrict(false).addTickables([note]);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true);
}
function centerAlignedRestFermata(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 400, 160);
    const stave = f.Stave({ x: 10, y: 10, width: 350 }).addClef('treble').addTimeSignature('4/4');
    const note = f
        .StaveNote({ keys: ['b/4'], duration: '1r', alignCenter: true })
        .addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_3__.Articulation('a@a').setPosition(3), 0);
    const voice = f.Voice().setStrict(false).addTickables([note]);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true);
}
function centerAlignedRestAnnotation(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 400, 160);
    const stave = f.Stave({ x: 10, y: 10, width: 350 }).addClef('treble').addTimeSignature('4/4');
    const note = f
        .StaveNote({ keys: ['b/4'], duration: '1r', alignCenter: true })
        .addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_2__.Annotation('Whole measure rest').setVerticalJustification(_src_annotation__WEBPACK_IMPORTED_MODULE_2__.AnnotationVerticalJustify.TOP), 0);
    const voice = f.Voice().setStrict(false).addTickables([note]);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true);
}
function centerAlignedNoteMultiModifiers(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 400, 160);
    const stave = f.Stave({ x: 10, y: 10, width: 350 }).addClef('treble').addTimeSignature('4/4');
    function newFinger(num, pos) {
        return new _src_frethandfinger__WEBPACK_IMPORTED_MODULE_9__.FretHandFinger(num).setPosition(pos);
    }
    const note = f
        .StaveNote({ keys: ['c/4', 'e/4', 'g/4'], duration: '4', alignCenter: true })
        .addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_2__.Annotation('Test').setPosition(3), 0)
        .addStroke(0, new _src_strokes__WEBPACK_IMPORTED_MODULE_16__.Stroke(2))
        .addModifier(new _src_accidental__WEBPACK_IMPORTED_MODULE_1__.Accidental('#'), 1)
        .addModifier(newFinger('3', _src_modifier__WEBPACK_IMPORTED_MODULE_10__.Modifier.Position.LEFT), 0)
        .addModifier(newFinger('2', _src_modifier__WEBPACK_IMPORTED_MODULE_10__.Modifier.Position.LEFT), 2)
        .addModifier(newFinger('1', _src_modifier__WEBPACK_IMPORTED_MODULE_10__.Modifier.Position.RIGHT), 1)
        .addModifier(new _src_stringnumber__WEBPACK_IMPORTED_MODULE_15__.StringNumber('4').setPosition(_src_modifier__WEBPACK_IMPORTED_MODULE_10__.Modifier.Position.BELOW), 2);
    _src_dot__WEBPACK_IMPORTED_MODULE_5__.Dot.buildAndAttach([note], { all: true });
    const voice = f.Voice().setStrict(false).addTickables([note]);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true);
}
function centerAlignedMultiVoice(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 400, 160);
    const stave = f.Stave({ x: 10, y: 10, width: 350 }).addClef('treble').addTimeSignature('3/8');
    // Set a custom duration of 3 / 8.
    const customDuration = new _src_fraction__WEBPACK_IMPORTED_MODULE_8__.Fraction(3, 8);
    // TODO: Should the whole rest draw a ledger line that is visible to the left/right of the rest?
    const notes0 = [
        f.StaveNote({
            keys: ['c/4'],
            duration: '1r',
            alignCenter: true,
            durationOverride: customDuration,
        }),
    ];
    const createStaveNote = (struct) => f.StaveNote(struct);
    const notes1 = [
        { keys: ['b/4'], duration: '8' },
        { keys: ['b/4'], duration: '8' },
        { keys: ['b/4'], duration: '8' },
    ].map(createStaveNote);
    notes1[1].addModifier(f.Accidental({ type: '#' }), 0);
    f.Beam({ notes: notes1 });
    const voice0 = f.Voice({ time: '3/8' }).setStrict(false).addTickables(notes0);
    const voice1 = f.Voice({ time: '3/8' }).setStrict(false).addTickables(notes1);
    f.Formatter().joinVoices([voice0, voice1]).formatToStave([voice0, voice1], stave);
    f.draw();
    options.assert.ok(true);
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(StaveNoteTests);



/***/ }),

/***/ "./tests/stavetie_tests.ts":
/*!*********************************!*\
  !*** ./tests/stavetie_tests.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StaveTieTests: () => (/* binding */ StaveTieTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_stem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/stem */ "./src/stem.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// StaveTie Tests


const StaveTieTests = {
    Start() {
        QUnit.module('StaveTie');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Simple StaveTie', simple);
        run('Chord StaveTie', chord);
        run('Stem Up StaveTie', stemUp);
        run('No End Note With Clef', noEndNote1);
        run('No End Note', noEndNote2);
        run('No Start Note With Clef', noStartNote1);
        run('No Start Note', noStartNote2);
        run('Set Direction Down', setDirectionDown);
        run('Set Direction Up', setDirectionUp);
    },
};
/**
 * Used by the 7 tests below to set up the stave, easyscore, notes, voice, and to format & draw.
 */
function createTest(notesData, setupTies) {
    return (options) => {
        const factory = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 300);
        const stave = factory.Stave();
        const score = factory.EasyScore();
        const notes = score.notes(notesData[0], notesData[1]);
        const voice = score.voice(notes);
        // const tickables = voice.getTickables(); // same as the notes that we passed in.
        setupTies(factory, notes, stave);
        factory.Formatter().joinVoices([voice]).formatToStave([voice], stave);
        factory.draw();
        options.assert.ok(true);
    };
}
const simple = createTest(['(cb4 e#4 a4)/2, (d4 e4 f4)', { stem: 'down' }], (f, notes) => {
    f.StaveTie({
        from: notes[0],
        to: notes[1],
        firstIndexes: [0, 1],
        lastIndexes: [0, 1],
    });
});
const chord = createTest(['(d4 e4 f4)/2, (cn4 f#4 a4)', { stem: 'down' }], (f, notes) => {
    f.StaveTie({
        from: notes[0],
        to: notes[1],
        firstIndexes: [0, 1, 2],
        lastIndexes: [0, 1, 2],
    });
});
const stemUp = createTest(['(d4 e4 f4)/2, (cn4 f#4 a4)', { stem: 'up' }], (f, notes) => {
    f.StaveTie({
        from: notes[0],
        to: notes[1],
        firstIndexes: [0, 1, 2],
        lastIndexes: [0, 1, 2],
    });
});
const noEndNote1 = createTest(['(cb4 e#4 a4)/2, (d4 e4 f4)', { stem: 'down' }], (f, notes, stave) => {
    stave.addEndClef('treble');
    f.StaveTie({
        from: notes[1],
        firstIndexes: [2],
        lastIndexes: [2],
        text: 'slow.',
    });
});
const noEndNote2 = createTest(['(cb4 e#4 a4)/2, (d4 e4 f4)', { stem: 'down' }], (f, notes) => {
    f.StaveTie({
        from: notes[1],
        firstIndexes: [2],
        lastIndexes: [2],
        text: 'slow.',
    });
});
const noStartNote1 = createTest(['(cb4 e#4 a4)/2, (d4 e4 f4)', { stem: 'down' }], (f, notes, stave) => {
    stave.addClef('treble');
    f.StaveTie({
        to: notes[0],
        firstIndexes: [2],
        lastIndexes: [2],
        text: 'H',
    });
});
const noStartNote2 = createTest(['(cb4 e#4 a4)/2, (d4 e4 f4)', { stem: 'down' }], (f, notes) => {
    f.StaveTie({
        to: notes[0],
        firstIndexes: [2],
        lastIndexes: [2],
        text: 'H',
    });
});
const setDirectionDown = createTest(['(cb4 e#4 a4)/2, (d4 e4 f4)', { stem: 'down' }], (f, notes) => {
    f.StaveTie({
        from: notes[0],
        to: notes[1],
        firstIndexes: [0, 1],
        lastIndexes: [0, 1],
        options: { direction: _src_stem__WEBPACK_IMPORTED_MODULE_1__.Stem.DOWN },
    });
});
const setDirectionUp = createTest(['(cb4 e#4 a4)/2, (d4 e4 f4)', { stem: 'down' }], (f, notes) => {
    f.StaveTie({
        from: notes[0],
        to: notes[1],
        firstIndexes: [0, 1],
        lastIndexes: [0, 1],
        options: { direction: _src_stem__WEBPACK_IMPORTED_MODULE_1__.Stem.UP },
    });
});
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(StaveTieTests);



/***/ }),

/***/ "./tests/stringnumber_tests.ts":
/*!*************************************!*\
  !*** ./tests/stringnumber_tests.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StringNumberTests: () => (/* binding */ StringNumberTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/element */ "./src/element.ts");
/* harmony import */ var _src_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/renderer */ "./src/renderer.ts");
/* harmony import */ var _src_stave__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/stave */ "./src/stave.ts");
/* harmony import */ var _src_stavebarline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/stavebarline */ "./src/stavebarline.ts");
/* harmony import */ var _src_strokes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/strokes */ "./src/strokes.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// StringNumber Tests






const StringNumberTests = {
    Start() {
        QUnit.module('StringNumber');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('String Number In Notation', drawMultipleMeasures);
        run('String Number In Notation - no circle', drawMultipleMeasures, { drawCircle: false });
        run('Fret Hand Finger In Notation', drawFretHandFingers);
        run('Multi Voice With Strokes, String & Finger Numbers', multi);
        run('Complex Measure With String & Finger Numbers', drawAccidentals);
        run('Shifted Notehead, Multiple Modifiers', shiftedNoteheadMultipleModifiers);
    },
};
function drawMultipleMeasures(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 775, 200);
    const score = f.EasyScore();
    // bar 1
    const stave1 = f.Stave({ width: 300 }).setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.DOUBLE).addClef('treble');
    const notes1 = score.notes('(c4 e4 g4)/4., (c5 e5 g5)/8, (c4 f4 g4)/4, (c4 f4 g4)/4', { stem: 'down' });
    notes1[0]
        .addModifier(f.StringNumber({ number: '5', position: 'right' }, (_a = options.params) === null || _a === void 0 ? void 0 : _a.drawCircle), 0)
        .addModifier(f.StringNumber({ number: '4', position: 'left' }, (_b = options.params) === null || _b === void 0 ? void 0 : _b.drawCircle), 1)
        .addModifier(f.StringNumber({ number: '3', position: 'right' }, (_c = options.params) === null || _c === void 0 ? void 0 : _c.drawCircle), 2);
    notes1[1]
        .addModifier(f.Accidental({ type: '#' }), 0)
        .addModifier(f.StringNumber({ number: '5', position: 'below' }, (_d = options.params) === null || _d === void 0 ? void 0 : _d.drawCircle), 0)
        .addModifier(f.Accidental({ type: '#' }).setAsCautionary(), 1)
        .addModifier(f
        .StringNumber({ number: '3', position: 'above' }, (_e = options.params) === null || _e === void 0 ? void 0 : _e.drawCircle)
        .setLastNote(notes1[3])
        .setLineEndType(_src_renderer__WEBPACK_IMPORTED_MODULE_2__.Renderer.LineEndType.DOWN), 2);
    notes1[2]
        .addModifier(f.StringNumber({ number: '5', position: 'left' }, (_f = options.params) === null || _f === void 0 ? void 0 : _f.drawCircle), 0)
        .addModifier(f.StringNumber({ number: '3', position: 'left' }, (_g = options.params) === null || _g === void 0 ? void 0 : _g.drawCircle), 2)
        .addModifier(f.Accidental({ type: '#' }), 1);
    notes1[3]
        .addModifier(f.StringNumber({ number: '5', position: 'right' }, (_h = options.params) === null || _h === void 0 ? void 0 : _h.drawCircle).setOffsetY(7), 0)
        .addModifier(f.StringNumber({ number: '4', position: 'right' }, (_j = options.params) === null || _j === void 0 ? void 0 : _j.drawCircle).setOffsetY(6), 1)
        .addModifier(f.StringNumber({ number: '3', position: 'right' }, (_k = options.params) === null || _k === void 0 ? void 0 : _k.drawCircle).setOffsetY(-6), 2);
    const voice1 = score.voice(notes1);
    f.Formatter().joinVoices([voice1]).formatToStave([voice1], stave1);
    // bar 2 - juxtaposing second bar next to first bar
    const stave2 = f
        .Stave({ x: stave1.getWidth() + stave1.getX(), y: stave1.getY(), width: 300 })
        .setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.DOUBLE);
    const notes2 = score.notes('(c4 e4 g4)/4, (c5 e5 g5), (c4 f4 g4), (c4 f4 g4)', { stem: 'up' });
    notes2[0]
        .addModifier(f.StringNumber({ number: '5', position: 'right' }, (_l = options.params) === null || _l === void 0 ? void 0 : _l.drawCircle), 0)
        .addModifier(f.StringNumber({ number: '4', position: 'left' }, (_m = options.params) === null || _m === void 0 ? void 0 : _m.drawCircle), 1)
        .addModifier(f.StringNumber({ number: '3', position: 'right' }, (_o = options.params) === null || _o === void 0 ? void 0 : _o.drawCircle), 2);
    notes2[1]
        .addModifier(f.Accidental({ type: '#' }), 0)
        .addModifier(f.StringNumber({ number: '5', position: 'below' }, (_p = options.params) === null || _p === void 0 ? void 0 : _p.drawCircle), 0)
        .addModifier(f.Accidental({ type: '#' }), 1)
        .addModifier(f
        .StringNumber({ number: '3', position: 'above' }, (_q = options.params) === null || _q === void 0 ? void 0 : _q.drawCircle)
        .setLastNote(notes2[3])
        .setDashed(false), 2);
    notes2[2]
        .addModifier(f.StringNumber({ number: '3', position: 'left' }, (_r = options.params) === null || _r === void 0 ? void 0 : _r.drawCircle), 2)
        .addModifier(f.Accidental({ type: '#' }), 1);
    notes2[3]
        .addModifier(f.StringNumber({ number: '5', position: 'right' }, (_s = options.params) === null || _s === void 0 ? void 0 : _s.drawCircle).setOffsetY(7), 0)
        .addModifier(f.StringNumber({ number: '4', position: 'right' }, (_t = options.params) === null || _t === void 0 ? void 0 : _t.drawCircle).setOffsetY(6), 1)
        .addModifier(f.StringNumber({ number: '3', position: 'right' }, (_u = options.params) === null || _u === void 0 ? void 0 : _u.drawCircle).setOffsetY(-6), 2);
    const voice2 = score.voice(notes2);
    f.Formatter().joinVoices([voice2]).formatToStave([voice2], stave2);
    // bar 3 - juxtaposing third bar next to second bar
    const stave3 = f
        .Stave({ x: stave2.getWidth() + stave2.getX(), y: stave2.getY(), width: 150 })
        .setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.END);
    const notesBar3 = score.notes('(c4 e4 g4 a4)/1.');
    notesBar3[0]
        .addModifier(f.StringNumber({ number: '5', position: 'below' }, (_v = options.params) === null || _v === void 0 ? void 0 : _v.drawCircle), 0)
        .addModifier(f.StringNumber({ number: '4', position: 'right' }, (_w = options.params) === null || _w === void 0 ? void 0 : _w.drawCircle), 1)
        .addModifier(f.StringNumber({ number: '3', position: 'left' }, (_x = options.params) === null || _x === void 0 ? void 0 : _x.drawCircle), 2)
        .addModifier(f.StringNumber({ number: '2', position: 'above' }, (_y = options.params) === null || _y === void 0 ? void 0 : _y.drawCircle), 3);
    const voice3 = score.voice(notesBar3, { time: '6/4' });
    f.Formatter().joinVoices([voice3]).formatToStave([voice3], stave3);
    f.draw();
    options.assert.ok(true, 'String Number');
}
function drawFretHandFingers(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 725, 200);
    const score = f.EasyScore();
    // bar 1
    const stave1 = f.Stave({ width: 350 }).setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.DOUBLE).addClef('treble');
    const notes1 = score.notes('(c4 e4 g4)/4, (c5 e5 g5), (c4 f4 g4), (c4 f4 g4)', { stem: 'down' });
    notes1[0]
        .addModifier(f.Fingering({ number: '3', position: 'left' }), 0)
        .addModifier(f.Fingering({ number: '2', position: 'left' }), 1)
        .addModifier(f.Fingering({ number: '0', position: 'left' }), 2);
    notes1[1]
        .addModifier(f.Accidental({ type: '#' }), 0)
        .addModifier(f.Fingering({ number: '3', position: 'left' }), 0)
        .addModifier(f.Fingering({ number: '2', position: 'left' }), 1)
        .addModifier(f.Accidental({ type: '#' }), 1)
        .addModifier(f.Fingering({ number: '0', position: 'left' }), 2);
    notes1[2]
        .addModifier(f.Fingering({ number: '3', position: 'below' }), 0)
        .addModifier(f.Fingering({ number: '4', position: 'left' }), 1)
        .addModifier(f.StringNumber({ number: '4', position: 'left' }), 1)
        .addModifier(f.Fingering({ number: '0', position: 'above' }), 2)
        .addModifier(f.Accidental({ type: '#' }), 1);
    notes1[3]
        .addModifier(f.Fingering({ number: '3', position: 'right' }), 0)
        .addModifier(f.StringNumber({ number: '5', position: 'right' }).setOffsetY(7), 0)
        .addModifier(f.Fingering({ number: '4', position: 'right' }), 1)
        .addModifier(f.StringNumber({ number: '4', position: 'right' }).setOffsetY(6), 1)
        .addModifier(f.Fingering({ number: '0', position: 'right' }).setOffsetY(-5), 2)
        .addModifier(f.StringNumber({ number: '3', position: 'right' }).setOffsetY(-6), 2);
    const voice1 = score.voice(notes1);
    f.Formatter().joinVoices([voice1]).formatToStave([voice1], stave1);
    // bar 2 - juxtaposing second bar next to first bar
    const stave2 = f
        .Stave({ x: stave1.getWidth() + stave1.getX(), y: stave1.getY(), width: 350 })
        .setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.END);
    const notes2 = score.notes('(c4 e4 g4)/4., (c5 e5 g5)/8, (c4 f4 g4)/8, (c4 f4 g4)/4.[stem="down"]', {
        stem: 'up',
    });
    notes2[0]
        .addModifier(f.Fingering({ number: '3', position: 'right' }), 0)
        .addModifier(f.Fingering({ number: '2', position: 'left' }), 1)
        .addModifier(f.StringNumber({ number: '4', position: 'right' }), 1)
        .addModifier(f.Fingering({ number: '0', position: 'above' }), 2);
    notes2[1]
        .addModifier(f.Accidental({ type: '#' }), 0)
        .addModifier(f.Fingering({ number: '3', position: 'right' }), 0)
        .addModifier(f.Fingering({ number: '2', position: 'left' }), 1)
        .addModifier(f.Accidental({ type: '#' }), 1)
        .addModifier(f.Fingering({ number: '0', position: 'left' }), 2);
    notes2[2]
        .addModifier(f.Fingering({ number: '3', position: 'below' }), 0)
        .addModifier(f.Fingering({ number: '2', position: 'left' }), 1)
        .addModifier(f.StringNumber({ number: '4', position: 'left' }), 1)
        .addModifier(f.Fingering({ number: '1', position: 'right' }), 2)
        .addModifier(f.Accidental({ type: '#' }), 2);
    notes2[3]
        .addModifier(f.Fingering({ number: '3', position: 'right' }), 0)
        .addModifier(f.StringNumber({ number: '5', position: 'right' }).setOffsetY(7), 0)
        .addModifier(f.Fingering({ number: '4', position: 'right' }), 1)
        .addModifier(f.StringNumber({ number: '4', position: 'right' }).setOffsetY(6), 1)
        .addModifier(f.Fingering({ number: '1', position: 'right' }).setOffsetY(-6), 2)
        .addModifier(f.StringNumber({ number: '3', position: 'right' }).setOffsetY(-6), 2);
    const voice2 = score.voice(notes2);
    f.Formatter().joinVoices([voice2]).formatToStave([voice2], stave2);
    f.draw();
    options.assert.ok(true, 'String Number');
}
function multi(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 200);
    const score = f.EasyScore();
    const stave = f.Stave();
    const notes1 = score.notes('(c4 e4 g4)/4, (a3 e4 g4), (c4 d4 a4), (c4 d4 a4)', { stem: 'up' });
    notes1[0]
        .addStroke(0, new _src_strokes__WEBPACK_IMPORTED_MODULE_5__.Stroke(5))
        .addModifier(f.Fingering({ number: '3', position: 'left' }), 0)
        .addModifier(f.Fingering({ number: '2', position: 'left' }), 1)
        .addModifier(f.Fingering({ number: '0', position: 'left' }), 2)
        .addModifier(f.StringNumber({ number: '4', position: 'left' }), 1)
        .addModifier(f.StringNumber({ number: '3', position: 'above' }), 2);
    notes1[1]
        .addStroke(0, new _src_strokes__WEBPACK_IMPORTED_MODULE_5__.Stroke(6))
        .addModifier(f.StringNumber({ number: '4', position: 'right' }), 1)
        .addModifier(f.StringNumber({ number: '3', position: 'above' }), 2)
        .addModifier(f.Accidental({ type: '#' }), 0)
        .addModifier(f.Accidental({ type: '#' }), 1)
        .addModifier(f.Accidental({ type: '#' }), 2);
    notes1[2]
        .addStroke(0, new _src_strokes__WEBPACK_IMPORTED_MODULE_5__.Stroke(2))
        .addModifier(f.Fingering({ number: '3', position: 'left' }), 0)
        .addModifier(f.Fingering({ number: '0', position: 'right' }), 1)
        .addModifier(f.StringNumber({ number: '4', position: 'right' }), 1)
        .addModifier(f.Fingering({ number: '1', position: 'left' }), 2)
        .addModifier(f.StringNumber({ number: '3', position: 'right' }), 2);
    notes1[3]
        .addStroke(0, new _src_strokes__WEBPACK_IMPORTED_MODULE_5__.Stroke(1))
        .addModifier(f.StringNumber({ number: '3', position: 'left' }), 2)
        .addModifier(f.StringNumber({ number: '4', position: 'right' }), 1);
    const notes2 = score.notes('e3/8, e3, e3, e3, e3, e3, e3, e3', { stem: 'down' });
    notes2[0]
        .addModifier(f.Fingering({ number: '0', position: 'left' }), 0)
        .addModifier(f.StringNumber({ number: '6', position: 'below' }), 0);
    notes2[2].addModifier(f.Accidental({ type: '#' }), 0);
    notes2[4].addModifier(f.Fingering({ number: '0', position: 'left' }), 0);
    // Position string number 6 beneath the strum arrow: left (15) and down (18)
    notes2[4].addModifier(f.StringNumber({ number: '6', position: 'left' }).setOffsetX(15).setOffsetY(18), 0);
    // Important Note: notes2 must come first, otherwise ledger lines from notes2 will be drawn on top of notes from notes1!
    // BUG: VexFlow draws TWO ledger lines for middle C, because both notes1 and notes2 require the middle C ledger line.
    const voices = [score.voice(notes2), score.voice(notes1)];
    f.Formatter().joinVoices(voices).formatToStave(voices, stave);
    f.Beam({ notes: notes2.slice(0, 4) });
    f.Beam({ notes: notes2.slice(4, 8) });
    f.draw();
    options.assert.ok(true, 'Strokes Test Multi Voice');
}
function drawAccidentals(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 750);
    const el = new _src_element__WEBPACK_IMPORTED_MODULE_1__.Element();
    el.setText(String.fromCharCode(0xe050));
    const clefWidth = el.getWidth(); // widest clef
    const notes = [
        f.StaveNote({ keys: ['c/4', 'e/4', 'g/4', 'c/5', 'e/5', 'g/5'], stemDirection: 1, duration: '4' }),
        f.StaveNote({ keys: ['c/4', 'e/4', 'g/4', 'd/5', 'e/5', 'g/5'], stemDirection: 1, duration: '4' }),
        f.StaveNote({ keys: ['c/4', 'e/4', 'g/4', 'd/5', 'e/5', 'g/5'], stemDirection: -1, duration: '4' }),
        f.StaveNote({ keys: ['c/4', 'e/4', 'g/4', 'd/5', 'e/5', 'g/5'], stemDirection: -1, duration: '4' }),
    ];
    notes[0]
        .addModifier(f.Fingering({ number: '3', position: 'left' }), 0)
        .addModifier(f.Accidental({ type: '#' }), 0)
        .addModifier(f.Fingering({ number: '2', position: 'left' }), 1)
        .addModifier(f.StringNumber({ number: '2', position: 'left' }), 1)
        .addModifier(f.Accidental({ type: '#' }), 1)
        .addModifier(f.Fingering({ number: '0', position: 'left' }), 2)
        .addModifier(f.Accidental({ type: '#' }), 2)
        .addModifier(f.Fingering({ number: '3', position: 'left' }), 3)
        .addModifier(f.Accidental({ type: '#' }), 3)
        .addModifier(f.Fingering({ number: '2', position: 'right' }), 4)
        .addModifier(f.StringNumber({ number: '3', position: 'right' }), 4)
        .addModifier(f.Accidental({ type: '#' }), 4)
        .addModifier(f.Fingering({ number: '0', position: 'left' }), 5)
        .addModifier(f.Accidental({ type: '#' }), 5);
    notes[1]
        .addModifier(f.Accidental({ type: '#' }), 0)
        .addModifier(f.Accidental({ type: '#' }), 1)
        .addModifier(f.Accidental({ type: '#' }), 2)
        .addModifier(f.Accidental({ type: '#' }), 3)
        .addModifier(f.Accidental({ type: '#' }), 4)
        .addModifier(f.Accidental({ type: '#' }), 5);
    notes[2]
        .addModifier(f.Fingering({ number: '3', position: 'left' }), 0)
        .addModifier(f.Accidental({ type: '#' }), 0)
        .addModifier(f.Fingering({ number: '2', position: 'left' }), 1)
        .addModifier(f.StringNumber({ number: '2', position: 'left' }), 1)
        .addModifier(f.Accidental({ type: '#' }), 1)
        .addModifier(f.Fingering({ number: '0', position: 'left' }), 2)
        .addModifier(f.Accidental({ type: '#' }), 2)
        .addModifier(f.Fingering({ number: '3', position: 'left' }), 3)
        .addModifier(f.Accidental({ type: '#' }), 3)
        .addModifier(f.Fingering({ number: '2', position: 'right' }), 4)
        .addModifier(f.StringNumber({ number: '3', position: 'right' }), 4)
        .addModifier(f.Accidental({ type: '#' }), 4)
        .addModifier(f.Fingering({ number: '0', position: 'left' }), 5)
        .addModifier(f.Accidental({ type: '#' }), 5);
    notes[3]
        .addModifier(f.Accidental({ type: '#' }), 0)
        .addModifier(f.Accidental({ type: '#' }), 1)
        .addModifier(f.Accidental({ type: '#' }), 2)
        .addModifier(f.Accidental({ type: '#' }), 3)
        .addModifier(f.Accidental({ type: '#' }), 4)
        .addModifier(f.Accidental({ type: '#' }), 5);
    const voice = f.Voice().addTickables(notes);
    const ctx = f.getContext();
    const formatter = f.Formatter().joinVoices([voice]);
    const stavePadding = clefWidth + _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave.defaultPadding + 10;
    const nwidth = Math.max(formatter.preCalculateMinTotalWidth([voice]), 490 - stavePadding);
    formatter.format([voice], nwidth);
    const stave = f
        .Stave({ x: 0, y: 0, width: nwidth + stavePadding })
        .setContext(ctx)
        .setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.DOUBLE)
        .addClef('treble')
        .draw();
    voice.draw(ctx, stave);
    options.assert.ok(true, 'String Number');
}
function shiftedNoteheadMultipleModifiers(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 900, 150);
    const score = f.EasyScore();
    score.set({ time: '6/4' });
    const stave = f.Stave({ width: 900 }).setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.BarlineType.END).addClef('treble');
    const notes = ['A4 B4', 'B4 C5', 'A4 B#4', 'B4 C#5', 'A#4 B#4', 'B#4 C#5']
        .map((keys) => score.notes(`(${keys})/q`))
        .flat();
    notes.forEach((note) => {
        note
            .addModifier(f.StringNumber({ number: '2', position: 'left' }, true), 1)
            .addModifier(f.StringNumber({ number: '2', position: 'right' }, true), 1);
    });
    const voice = score.voice(notes);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'String Number');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(StringNumberTests);



/***/ }),

/***/ "./tests/strokes_tests.ts":
/*!********************************!*\
  !*** ./tests/strokes_tests.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StrokesTests: () => (/* binding */ StrokesTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/index */ "./src/index.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Strokes Tests


const StrokesTests = {
    Start() {
        QUnit.module('Strokes');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        // TODO: Rename tests by removing 'Strokes - ' since it is redundant with the module name.
        // This will make flow.html easier to read.
        run('Strokes - Brush/Roll/Rasquedo', brushRollRasquedo);
        run('Strokes - Arpeggio directionless (without arrows)', arpeggioDirectionless);
        run('Strokes - Multi Voice', multiVoice);
        run('Strokes - Notation and Tab', notesWithTab);
        run('Strokes - Multi-Voice Notation and Tab', multiNotationAndTab);
    },
};
function brushRollRasquedo(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 200);
    const score = f.EasyScore();
    // bar 1
    const stave1 = f.Stave({ width: 250 }).setEndBarType(_src_index__WEBPACK_IMPORTED_MODULE_1__.Barline.type.DOUBLE);
    const notes1 = score.notes('(a3 e4 a4)/4, (c4 e4 g4), (c4 e4 g4), (c4 e4 g4)', { stem: 'up' });
    notes1[0].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(1));
    notes1[1]
        .addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(2))
        .addModifier(f.Accidental({ type: '#' }), 1)
        .addModifier(f.Accidental({ type: '#' }), 2)
        .addModifier(f.Accidental({ type: '#' }), 0);
    notes1[2].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(1));
    notes1[3].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(2));
    const voice1 = score.voice(notes1);
    f.Formatter().joinVoices([voice1]).formatToStave([voice1], stave1);
    // bar 2
    const stave2 = f
        .Stave({ x: stave1.getWidth() + stave1.getX(), y: stave1.getY(), width: 300 })
        .setEndBarType(_src_index__WEBPACK_IMPORTED_MODULE_1__.Barline.type.DOUBLE);
    const notes2 = score.notes('(c4 d4 g4)/4, (c4 d4 g4), (c4 d4 g4), (c4 d4 a4)', { stem: 'up' });
    notes2[0].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(3));
    notes2[1].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(4));
    notes2[2].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(5));
    notes2[3]
        .addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(6))
        .addModifier(f.Accidental({ type: 'bb' }), 0)
        .addModifier(f.Accidental({ type: 'bb' }), 1)
        .addModifier(f.Accidental({ type: 'bb' }), 2);
    const voice2 = score.voice(notes2);
    f.Formatter().joinVoices([voice2]).formatToStave([voice2], stave2);
    f.draw();
    options.assert.ok(true, 'Brush/Roll/Rasquedo');
}
function arpeggioDirectionless(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 700, 200);
    const score = f.EasyScore();
    // bar 1
    const stave1 = f.Stave({ x: 100, width: 500 }).setEndBarType(_src_index__WEBPACK_IMPORTED_MODULE_1__.Barline.type.DOUBLE);
    const notes1 = score.notes('(g4 b4 d5)/4, (g4 b4 d5 g5), (g4 b4 d5 g5), (g4 b4 d5)', { stem: 'up' });
    const graceNoteStructs = [
        { keys: ['e/4'], duration: '32' },
        { keys: ['f/4'], duration: '32' },
        { keys: ['g/4'], duration: '32' },
    ];
    const graceNotes = graceNoteStructs.map((graceNoteStruct) => f.GraceNote(graceNoteStruct));
    const graceNoteGroup = f.GraceNoteGroup({ notes: graceNotes, slur: false });
    graceNoteGroup.beamNotes();
    notes1[0].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(7));
    notes1[1]
        .addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(7))
        .addModifier(f.Accidental({ type: '#' }), 0)
        .addModifier(f.Accidental({ type: '#' }), 1)
        .addModifier(f.Accidental({ type: '#' }), 2)
        .addModifier(f.Accidental({ type: '#' }), 3);
    notes1[2]
        .addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(7))
        .addModifier(f.Accidental({ type: 'b' }), 1)
        .addModifier(graceNoteGroup, 0);
    notes1[3].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(7)).addModifier(f.NoteSubGroup({
        notes: [f.ClefNote({ type: 'treble', options: { size: 'default', annotation: '8va' } })],
    }), 0);
    const voice1 = score.voice(notes1);
    f.Formatter().joinVoices([voice1]).formatToStave([voice1], stave1);
    f.draw();
    options.assert.ok(true, 'Arpeggio directionless (without arrows)');
}
function multiVoice(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 500, 200);
    const score = f.EasyScore();
    const stave = f.Stave();
    const notes1 = score.notes('(c4 e4 g4)/4, (c4 e4 g4), (c4 d4 a4), (c4 d4 a4)', { stem: 'up' });
    notes1[0].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(5));
    notes1[1]
        .addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(6))
        .addModifier(f.Accidental({ type: '#' }), 0)
        .addModifier(f.Accidental({ type: '#' }), 2);
    notes1[2].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(2));
    notes1[3].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(1));
    const notes2 = score.notes('e3/8, e3, e3, e3, e3, e3, e3, e3', { stem: 'down' });
    f.Beam({ notes: notes2.slice(0, 4) });
    f.Beam({ notes: notes2.slice(4, 8) });
    const voices = [notes1, notes2].map((notes) => score.voice(notes));
    f.Formatter().joinVoices(voices).formatToStave(voices, stave);
    f.draw();
    options.assert.ok(true, 'Strokes Test Multi Voice');
}
function multiNotationAndTab(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 400, 275);
    const score = f.EasyScore();
    const stave = f.Stave().addClef('treble');
    // notation upper voice notes
    const notes1 = score.notes('(g4 b4 e5)/4, (g4 b4 e5), (g4 b4 e5), (g4 b4 e5)', { stem: 'up' });
    notes1[0].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(3, { allVoices: false }));
    notes1[1].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(6));
    notes1[2].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(2, { allVoices: false }));
    notes1[3].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(1));
    const notes2 = score.notes('g3/4, g3, g3, g3', { stem: 'down' });
    f.TabStave({ y: 100 }).addClef('tab').setNoteStartX(stave.getNoteStartX());
    // tablature upper voice notes
    const tabNotes1 = [
        f.TabNote({
            positions: [
                { str: 3, fret: 0 },
                { str: 2, fret: 0 },
                { str: 1, fret: 1 },
            ],
            duration: '4',
        }),
        f.TabNote({
            positions: [
                { str: 3, fret: 0 },
                { str: 2, fret: 0 },
                { str: 1, fret: 1 },
            ],
            duration: '4',
        }),
        f.TabNote({
            positions: [
                { str: 3, fret: 0 },
                { str: 2, fret: 0 },
                { str: 1, fret: 1 },
            ],
            duration: '4',
        }),
        f.TabNote({
            positions: [
                { str: 3, fret: 0 },
                { str: 2, fret: 0 },
                { str: 1, fret: 1 },
            ],
            duration: '4',
        }),
    ];
    tabNotes1[0].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(3, { allVoices: false }));
    tabNotes1[1].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(6));
    tabNotes1[2].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(2, { allVoices: false }));
    tabNotes1[3].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(1));
    const tabNotes2 = [
        f.TabNote({ positions: [{ str: 6, fret: 3 }], duration: '4' }),
        f.TabNote({ positions: [{ str: 6, fret: 3 }], duration: '4' }),
        f.TabNote({ positions: [{ str: 6, fret: 3 }], duration: '4' }),
        f.TabNote({ positions: [{ str: 6, fret: 3 }], duration: '4' }),
    ];
    const voices = [notes1, notes2, tabNotes1, tabNotes2].map((notes) => score.voice(notes));
    f.Formatter().joinVoices(voices).formatToStave(voices, stave);
    f.draw();
    options.assert.ok(true, 'Strokes Test Notation & Tab Multi Voice');
}
/*
function drawTabStrokes(options: TestOptions): void {
  const f = VexFlowTests.makeFactory(options, 600, 200);
  const stave1 = f.TabStave({ width: 250 }).setEndBarType(Barline.type.DOUBLE);

  const tabNotes1 = [
    f.TabNote({
      positions: [
        { str: 2, fret: 8 },
        { str: 3, fret: 9 },
        { str: 4, fret: 10 },
      ],
      duration: '4',
    }),
    f.TabNote({
      positions: [
        { str: 3, fret: 7 },
        { str: 4, fret: 8 },
        { str: 5, fret: 9 },
      ],
      duration: '4',
    }),
    f.TabNote({
      positions: [
        { str: 1, fret: 5 },
        { str: 2, fret: 6 },
        { str: 3, fret: 7 },
        { str: 4, fret: 7 },
        { str: 5, fret: 5 },
        { str: 6, fret: 5 },
      ],
      duration: '4',
    }),
    f.TabNote({
      positions: [
        { str: 4, fret: 3 },
        { str: 5, fret: 4 },
        { str: 6, fret: 5 },
      ],
      duration: '4',
    }),
  ];

  tabNotes1[0].addStroke(0, new Stroke(1));
  tabNotes1[1].addStroke(0, new Stroke(2));
  tabNotes1[2].addStroke(0, new Stroke(3));
  tabNotes1[3].addStroke(0, new Stroke(4));

  const tabVoice1 = f.Voice().addTickables(tabNotes1);

  f.Formatter().joinVoices([tabVoice1]).formatToStave([tabVoice1], stave1);

  // bar 2
  const stave2 = f.TabStave({ x: stave1.getWidth() + stave1.getX(), width: 300 }).setEndBarType(Barline.type.DOUBLE);

  const tabNotes2 = [
    f.TabNote({
      positions: [
        { str: 2, fret: 7 },
        { str: 3, fret: 8 },
        { str: 4, fret: 9 },
      ],
      duration: '2',
    }),
    f.TabNote({
      positions: [
        { str: 1, fret: 5 },
        { str: 2, fret: 6 },
        { str: 3, fret: 7 },
        { str: 4, fret: 7 },
        { str: 5, fret: 5 },
        { str: 6, fret: 5 },
      ],
      duration: '2',
    }),
  ];

  tabNotes2[0].addStroke(0, new Stroke(6));
  tabNotes2[1].addStroke(0, new Stroke(5));

  const tabVoice2 = f.Voice().addTickables(tabNotes2);

  f.Formatter().joinVoices([tabVoice2]).formatToStave([tabVoice2], stave2);

  f.draw();

  options.assert.ok(true, 'Strokes Tab test');
}
*/
function notesWithTab(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 500, 300);
    const stave = f.Stave({ x: 15, y: 40, width: 450 }).addClef('treble');
    const notes = [
        f
            .StaveNote({ keys: ['b/4', 'd/5', 'g/5'], stemDirection: -1, duration: '4' })
            .addModifier(f.Accidental({ type: 'b' }), 1)
            .addModifier(f.Accidental({ type: 'b' }), 0),
        f.StaveNote({ keys: ['c/5', 'd/5'], stemDirection: -1, duration: '4' }),
        f.StaveNote({ keys: ['b/3', 'e/4', 'a/4', 'd/5'], stemDirection: 1, duration: '8' }),
        f
            .StaveNote({ keys: ['a/3', 'e/4', 'a/4', 'c/5', 'e/5', 'a/5'], stemDirection: 1, duration: '8' })
            .addModifier(f.Accidental({ type: '#' }), 3),
        f.StaveNote({ keys: ['b/3', 'e/4', 'a/4', 'd/5'], stemDirection: 1, duration: '8' }),
        f
            .StaveNote({ keys: ['a/3', 'e/4', 'a/4', 'c/5', 'f/5', 'a/5'], stemDirection: 1, duration: '8' })
            .addModifier(f.Accidental({ type: '#' }), 3)
            .addModifier(f.Accidental({ type: '#' }), 4),
    ];
    const tabstave = f
        .TabStave({ x: stave.getX(), y: 140, width: 450 })
        .addClef('tab')
        .setNoteStartX(stave.getNoteStartX());
    const tabNotes = [
        f
            .TabNote({
            positions: [
                { str: 1, fret: 3 },
                { str: 2, fret: 2 },
                { str: 3, fret: 3 },
            ],
            duration: '4',
        })
            .addModifier(new _src_index__WEBPACK_IMPORTED_MODULE_1__.Bend([{ type: _src_index__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: 'Full' }]), 0),
        f
            .TabNote({
            positions: [
                { str: 2, fret: 3 },
                { str: 3, fret: 5 },
            ],
            duration: '4',
        })
            .addModifier(new _src_index__WEBPACK_IMPORTED_MODULE_1__.Bend([{ type: _src_index__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: 'Unison' }]), 1),
        f.TabNote({
            positions: [
                { str: 3, fret: 7 },
                { str: 4, fret: 7 },
                { str: 5, fret: 7 },
                { str: 6, fret: 7 },
            ],
            duration: '8',
        }),
        f.TabNote({
            positions: [
                { str: 1, fret: 5 },
                { str: 2, fret: 5 },
                { str: 3, fret: 6 },
                { str: 4, fret: 7 },
                { str: 5, fret: 7 },
                { str: 6, fret: 5 },
            ],
            duration: '8',
        }),
        f.TabNote({
            positions: [
                { str: 3, fret: 7 },
                { str: 4, fret: 7 },
                { str: 5, fret: 7 },
                { str: 6, fret: 7 },
            ],
            duration: '8',
        }),
        f.TabNote({
            positions: [
                { str: 1, fret: 5 },
                { str: 2, fret: 5 },
                { str: 3, fret: 6 },
                { str: 4, fret: 7 },
                { str: 5, fret: 7 },
                { str: 6, fret: 5 },
            ],
            duration: '8',
        }),
    ];
    notes[0].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(1));
    notes[1].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(2));
    notes[2].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(3));
    notes[3].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(4));
    notes[4].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(5));
    notes[5].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(6));
    tabNotes[0].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(1));
    tabNotes[1].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(2));
    tabNotes[2].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(3));
    tabNotes[3].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(4));
    tabNotes[4].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(5));
    tabNotes[5].addStroke(0, new _src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke(6));
    f.StaveConnector({
        topStave: stave,
        bottomStave: tabstave,
        type: 'bracket',
    });
    f.StaveConnector({
        topStave: stave,
        bottomStave: tabstave,
        type: 'single',
    });
    const voice = f.Voice().addTickables(notes);
    const tabVoice = f.Voice().addTickables(tabNotes);
    const beams = _src_index__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voice);
    f.Formatter().joinVoices([voice]).joinVoices([tabVoice]).formatToStave([voice, tabVoice], stave);
    f.draw();
    beams.forEach(function (beam) {
        beam.setContext(f.getContext()).draw();
    });
    options.assert.ok(true);
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(StrokesTests);



/***/ }),

/***/ "./tests/style_tests.ts":
/*!******************************!*\
  !*** ./tests/style_tests.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StyleTests: () => (/* binding */ StyleTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_annotation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/annotation */ "./src/annotation.ts");
/* harmony import */ var _src_articulation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/articulation */ "./src/articulation.ts");
/* harmony import */ var _src_bend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/bend */ "./src/bend.ts");
/* harmony import */ var _src_formatter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/formatter */ "./src/formatter.ts");
/* harmony import */ var _src_keysignature__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/keysignature */ "./src/keysignature.ts");
/* harmony import */ var _src_notesubgroup__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/notesubgroup */ "./src/notesubgroup.ts");
/* harmony import */ var _src_ornament__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/ornament */ "./src/ornament.ts");
/* harmony import */ var _src_stavemodifier__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/stavemodifier */ "./src/stavemodifier.ts");
/* harmony import */ var _src_strokes__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/strokes */ "./src/strokes.ts");
/* harmony import */ var _src_tabnote__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../src/tabnote */ "./src/tabnote.ts");
/* harmony import */ var _src_tabstave__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../src/tabstave */ "./src/tabstave.ts");
/* harmony import */ var _src_timesignature__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../src/timesignature */ "./src/timesignature.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Style Tests
// TODO: The .addStroke(0, new Stroke(...)) in the tab test case shows a NO GLYPH for the Petaluma font.
// TODO: Changing ctx.font seems to have no effect in the tab test case. Should it?
//       Annotation sets its own font.
//       TabNote sets its own font.
//       Is there a way to set all the text fonts in one go?













const StyleTests = {
    Start() {
        QUnit.module('Style');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Basic Style', stave);
        run('TabNote modifiers Style', tab);
    },
};
/**
 * Helper function to create a ElementStyle options object of the form { fillStyle: XXX, strokeStyle: YYY }.
 * Used for updating the fillStyle and optionally the strokeStyle.
 */
function FS(fillStyle, strokeStyle) {
    const ret = { fillStyle };
    if (strokeStyle) {
        ret.strokeStyle = strokeStyle;
    }
    return ret;
}
/**
 * Color elements on a stave.
 */
function stave(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 150);
    const stave = f.Stave({ x: 25, y: 20, width: 500 });
    // Stave modifiers test.
    const keySig = new _src_keysignature__WEBPACK_IMPORTED_MODULE_5__.KeySignature('D');
    keySig.addToStave(stave);
    keySig.setStyle(FS('blue'));
    stave.addTimeSignature('4/4');
    const timeSig = stave.getModifiers(_src_stavemodifier__WEBPACK_IMPORTED_MODULE_8__.StaveModifierPosition.BEGIN, _src_timesignature__WEBPACK_IMPORTED_MODULE_12__.TimeSignature.CATEGORY);
    timeSig[0].setStyle(FS('brown'));
    const notes = [
        f
            .StaveNote({ keys: ['c/4', 'e/4', 'a/4'], stemDirection: 1, duration: '4' })
            .addModifier(f.Accidental({ type: 'b' }), 0)
            .addModifier(f.Accidental({ type: '#' }), 1),
        f
            .StaveNote({ keys: ['c/4', 'e/4', 'a/4'], stemDirection: 1, duration: '4' })
            .addModifier(f.Accidental({ type: 'b' }), 0)
            .addModifier(f.Accidental({ type: '#' }), 1),
        f.StaveNote({ keys: ['e/4'], stemDirection: 1, duration: '4' }),
        f.StaveNote({ keys: ['f/4'], stemDirection: 1, duration: '8' }),
        // voice.draw() test.
        f.TextDynamics({ text: 'sfz', duration: '16' }).setStyle(FS('blue')),
        // GhostNote modifiers test.
        f.GhostNote({ duration: '16' }).addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('GhostNote green text').setStyle(FS('green')), 0),
    ];
    const notes0 = notes[0];
    const notes1 = notes[1];
    notes0.setKeyStyle(0, FS('red'));
    notes1.setKeyStyle(0, FS('red'));
    // StaveNote modifiers test.
    const mods1 = notes1.getModifiers();
    mods1[0].setStyle(FS('green'));
    notes0.addModifier(new _src_articulation__WEBPACK_IMPORTED_MODULE_2__.Articulation('a.').setPosition(4).setStyle(FS('green')), 0);
    notes0.addModifier(new _src_ornament__WEBPACK_IMPORTED_MODULE_7__.Ornament('mordent').setStyle(FS('lightgreen')), 0);
    notes1.addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('blue').setStyle(FS('blue')), 0);
    notes1.addModifier(new _src_notesubgroup__WEBPACK_IMPORTED_MODULE_6__.NoteSubGroup([f.ClefNote({ options: { size: 'small' } }).setStyle(FS('blue'))]), 0);
    const voice = f.Voice().addTickables(notes);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'Basic Style');
}
/**
 * Color elements on a guitar tab.
 */
function tab(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 500, 140);
    ctx.font = '10pt Arial';
    const stave = new _src_tabstave__WEBPACK_IMPORTED_MODULE_11__.TabStave(10, 10, 450).addTabGlyph();
    stave.getModifiers()[2].setStyle(FS('blue'));
    stave.setContext(ctx).draw();
    const tabNote = (noteStruct) => new _src_tabnote__WEBPACK_IMPORTED_MODULE_10__.TabNote(noteStruct);
    const notes = [
        tabNote({
            positions: [
                { str: 2, fret: 10 },
                { str: 4, fret: 9 },
            ],
            duration: 'h',
        }).addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('green text').setStyle(FS('green')), 0),
        tabNote({
            positions: [
                { str: 2, fret: 10 },
                { str: 4, fret: 9 },
            ],
            duration: 'h',
        })
            .addModifier(new _src_bend__WEBPACK_IMPORTED_MODULE_3__.Bend([{ type: _src_bend__WEBPACK_IMPORTED_MODULE_3__.Bend.UP, text: 'Full' }]).setStyle(FS('brown')), 0)
            .addStroke(0, new _src_strokes__WEBPACK_IMPORTED_MODULE_9__.Stroke(1, { allVoices: false }).setStyle(FS('blue'))),
    ];
    _src_formatter__WEBPACK_IMPORTED_MODULE_4__.Formatter.FormatAndDraw(ctx, stave, notes);
    options.assert.ok(true, 'TabNote Modifiers Style');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(StyleTests);



/***/ }),

/***/ "./tests/tabnote_tests.ts":
/*!********************************!*\
  !*** ./tests/tabnote_tests.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TabNoteTests: () => (/* binding */ TabNoteTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_dot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/dot */ "./src/dot.ts");
/* harmony import */ var _src_flow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/flow */ "./src/flow.ts");
/* harmony import */ var _src_formatter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/formatter */ "./src/formatter.ts");
/* harmony import */ var _src_metrics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/metrics */ "./src/metrics.ts");
/* harmony import */ var _src_stave__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/stave */ "./src/stave.ts");
/* harmony import */ var _src_tabnote__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/tabnote */ "./src/tabnote.ts");
/* harmony import */ var _src_tabstave__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/tabstave */ "./src/tabstave.ts");
/* harmony import */ var _src_tickcontext__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/tickcontext */ "./src/tickcontext.ts");
/* harmony import */ var _src_voice__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/voice */ "./src/voice.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// TabNote Tests










const TabNoteTests = {
    Start() {
        QUnit.module('TabNote');
        QUnit.test('Tick', ticks);
        QUnit.test('TabStave Line', tabStaveLine);
        QUnit.test('Width', width);
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('TabNote Draw', draw);
        run('TabNote Stems Up', drawStemsUp);
        run('TabNote Stems Down', drawStemsDown);
        run('TabNote Stems Up Through Stave', drawStemsUpThrough);
        run('TabNote Stems Down Through Stave', drawStemsDownThrough);
        run('TabNote Stems with Dots', drawStemsDotted);
    },
};
function ticks(assert) {
    const BEAT = (1 * _src_flow__WEBPACK_IMPORTED_MODULE_2__.Flow.RESOLUTION) / 4;
    let note = new _src_tabnote__WEBPACK_IMPORTED_MODULE_6__.TabNote({ positions: [{ str: 6, fret: 6 }], duration: '1' });
    assert.equal(note.getTicks().value(), BEAT * 4, 'Whole note has 4 beats');
    note = new _src_tabnote__WEBPACK_IMPORTED_MODULE_6__.TabNote({ positions: [{ str: 3, fret: 4 }], duration: '4' });
    assert.equal(note.getTicks().value(), BEAT, 'Quarter note has 1 beat');
}
function tabStaveLine(assert) {
    const note = new _src_tabnote__WEBPACK_IMPORTED_MODULE_6__.TabNote({
        positions: [
            { str: 6, fret: 6 },
            { str: 4, fret: 5 },
        ],
        duration: '1',
    });
    const positions = note.getPositions();
    assert.equal(positions[0].str, 6, 'String 6, Fret 6');
    assert.equal(positions[0].fret, 6, 'String 6, Fret 6');
    assert.equal(positions[1].str, 4, 'String 4, Fret 5');
    assert.equal(positions[1].fret, 5, 'String 4, Fret 5');
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_5__.Stave(10, 10, 300);
    note.setStave(stave);
    const ys = note.getYs();
    assert.equal(ys.length, 2, 'Chord should be rendered on two lines');
    assert.equal(ys[0], 100, 'Line for String 6, Fret 6');
    assert.equal(ys[1], 80, 'Line for String 4, Fret 5');
}
function width(assert) {
    assert.expect(1);
    const note = new _src_tabnote__WEBPACK_IMPORTED_MODULE_6__.TabNote({
        positions: [
            { str: 6, fret: 6 },
            { str: 4, fret: 5 },
        ],
        duration: '1',
    });
    assert.throws(() => note.getWidth(), /UnformattedNote/, 'Unformatted note should have no width');
}
function draw(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 600, 140);
    ctx.font = '10pt Arial';
    const stave = new _src_tabstave__WEBPACK_IMPORTED_MODULE_7__.TabStave(10, 10, 550);
    stave.setContext(ctx);
    stave.draw();
    const notes = [
        { positions: [{ str: 6, fret: 6 }], duration: '4' },
        {
            positions: [
                { str: 3, fret: 6 },
                { str: 4, fret: 25 },
            ],
            duration: '4',
        },
        {
            positions: [
                { str: 2, fret: 'x' },
                { str: 5, fret: 15 },
            ],
            duration: '4',
        },
        {
            positions: [
                { str: 2, fret: 'x' },
                { str: 5, fret: 5 },
            ],
            duration: '4',
        },
        {
            positions: [
                { str: 2, fret: 10 },
                { str: 5, fret: 12 },
            ],
            duration: '4',
        },
        {
            positions: [
                { str: 6, fret: 0 },
                { str: 5, fret: 5 },
                { str: 4, fret: 5 },
                { str: 3, fret: 4 },
                { str: 2, fret: 3 },
                { str: 1, fret: 0 },
            ],
            duration: '4',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '4',
        },
    ];
    // Helper function
    function showNote(noteStruct, stave, ctx, x) {
        const tabNote = new _src_tabnote__WEBPACK_IMPORTED_MODULE_6__.TabNote(noteStruct);
        const tickContext = new _src_tickcontext__WEBPACK_IMPORTED_MODULE_8__.TickContext();
        tickContext.addTickable(tabNote).preFormat().setX(x);
        tabNote.setContext(ctx).setStave(stave);
        tabNote.draw();
        return tabNote;
    }
    for (let i = 0; i < notes.length; ++i) {
        const note = notes[i];
        const tabNote = showNote(note, stave, ctx, (i + 1) * 25);
        options.assert.ok(tabNote.getX() > 0, 'Note ' + i + ' has X value');
        options.assert.ok(tabNote.getYs().length > 0, 'Note ' + i + ' has Y values');
    }
}
function drawStemsUp(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 600, 200);
    ctx.font = '10pt Arial';
    const stave = new _src_tabstave__WEBPACK_IMPORTED_MODULE_7__.TabStave(10, 30, 550);
    stave.setContext(ctx);
    stave.draw();
    const specs = [
        {
            positions: [
                { str: 3, fret: 6 },
                { str: 4, fret: 25 },
            ],
            duration: '4',
        },
        {
            positions: [
                { str: 2, fret: 10 },
                { str: 5, fret: 12 },
            ],
            duration: '8',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '8',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '16',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '32',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '64',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '128',
        },
    ];
    const notes = specs.map((struct) => {
        const tabNote = new _src_tabnote__WEBPACK_IMPORTED_MODULE_6__.TabNote(struct);
        tabNote.renderOptions.drawStem = true;
        return tabNote;
    });
    const voice = new _src_voice__WEBPACK_IMPORTED_MODULE_9__.Voice(_src_flow__WEBPACK_IMPORTED_MODULE_2__.Flow.TIME4_4).setMode(_src_voice__WEBPACK_IMPORTED_MODULE_9__.VoiceMode.SOFT);
    voice.addTickables(notes);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_3__.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    voice.draw(ctx, stave);
    options.assert.ok(true, 'TabNotes successfully drawn');
}
function drawStemsDown(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 600, 200);
    ctx.font = '10pt Arial';
    const stave = new _src_tabstave__WEBPACK_IMPORTED_MODULE_7__.TabStave(10, 10, 550);
    stave.setContext(ctx);
    stave.draw();
    const specs = [
        {
            positions: [
                { str: 3, fret: 6 },
                { str: 4, fret: 25 },
            ],
            duration: '4',
        },
        {
            positions: [
                { str: 2, fret: 10 },
                { str: 5, fret: 12 },
            ],
            duration: '8',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '8',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '16',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '32',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '64',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '128',
        },
    ];
    const notes = specs.map((struct) => {
        const tabNote = new _src_tabnote__WEBPACK_IMPORTED_MODULE_6__.TabNote(struct);
        tabNote.renderOptions.drawStem = true;
        tabNote.setStemDirection(-1);
        return tabNote;
    });
    const voice = new _src_voice__WEBPACK_IMPORTED_MODULE_9__.Voice(_src_flow__WEBPACK_IMPORTED_MODULE_2__.Flow.TIME4_4).setMode(_src_voice__WEBPACK_IMPORTED_MODULE_9__.VoiceMode.SOFT);
    voice.addTickables(notes);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_3__.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    voice.draw(ctx, stave);
    options.assert.ok(true, 'All objects have been drawn');
}
function drawStemsUpThrough(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 600, 200);
    ctx.font = '10pt Arial';
    const stave = new _src_tabstave__WEBPACK_IMPORTED_MODULE_7__.TabStave(10, 30, 550);
    stave.setContext(ctx);
    stave.draw();
    const specs = [
        {
            positions: [
                { str: 3, fret: 6 },
                { str: 4, fret: 25 },
            ],
            duration: '4',
        },
        {
            positions: [
                { str: 2, fret: 10 },
                { str: 5, fret: 12 },
            ],
            duration: '8',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '8',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '16',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '32',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '64',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '128',
        },
    ];
    const notes = specs.map((struct) => {
        const tabNote = new _src_tabnote__WEBPACK_IMPORTED_MODULE_6__.TabNote(struct);
        tabNote.renderOptions.drawStem = true;
        tabNote.renderOptions.drawStemThroughStave = true;
        return tabNote;
    });
    ctx.setFont(_src_metrics__WEBPACK_IMPORTED_MODULE_4__.Metrics.get('fontFamily'), 10, 'bold');
    const voice = new _src_voice__WEBPACK_IMPORTED_MODULE_9__.Voice(_src_flow__WEBPACK_IMPORTED_MODULE_2__.Flow.TIME4_4).setMode(_src_voice__WEBPACK_IMPORTED_MODULE_9__.VoiceMode.SOFT);
    voice.addTickables(notes);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_3__.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    voice.draw(ctx, stave);
    options.assert.ok(true, 'TabNotes successfully drawn');
}
function drawStemsDownThrough(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 600, 250);
    ctx.font = '10pt Arial';
    const stave = new _src_tabstave__WEBPACK_IMPORTED_MODULE_7__.TabStave(10, 10, 550, { numLines: 8 });
    stave.setContext(ctx);
    stave.draw();
    const specs = [
        {
            positions: [
                { str: 3, fret: 6 },
                { str: 4, fret: 25 },
            ],
            duration: '4',
        },
        {
            positions: [
                { str: 2, fret: 10 },
                { str: 5, fret: 12 },
            ],
            duration: '8',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '8',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '16',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
                { str: 6, fret: 10 },
            ],
            duration: '32',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '64',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 3, fret: 5 },
                { str: 5, fret: 5 },
                { str: 7, fret: 5 },
            ],
            duration: '128',
        },
    ];
    const notes = specs.map((struct) => {
        const tabNote = new _src_tabnote__WEBPACK_IMPORTED_MODULE_6__.TabNote(struct);
        tabNote.renderOptions.drawStem = true;
        tabNote.renderOptions.drawStemThroughStave = true;
        tabNote.setStemDirection(-1);
        return tabNote;
    });
    ctx.setFont('Arial', 10, 'bold');
    const voice = new _src_voice__WEBPACK_IMPORTED_MODULE_9__.Voice(_src_flow__WEBPACK_IMPORTED_MODULE_2__.Flow.TIME4_4).setMode(_src_voice__WEBPACK_IMPORTED_MODULE_9__.VoiceMode.SOFT);
    voice.addTickables(notes);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_3__.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    voice.draw(ctx, stave);
    options.assert.ok(true, 'All objects have been drawn');
}
function drawStemsDotted(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 600, 200);
    ctx.font = '10pt Arial';
    const stave = new _src_tabstave__WEBPACK_IMPORTED_MODULE_7__.TabStave(10, 10, 550);
    stave.setContext(ctx);
    stave.draw();
    const specs = [
        {
            positions: [
                { str: 3, fret: 6 },
                { str: 4, fret: 25 },
            ],
            duration: '4d',
        },
        {
            positions: [
                { str: 2, fret: 10 },
                { str: 5, fret: 12 },
            ],
            duration: '8',
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '4dd',
            stemDirection: -1,
        },
        {
            positions: [
                { str: 1, fret: 6 },
                { str: 4, fret: 5 },
            ],
            duration: '16',
            stemDirection: -1,
        },
    ];
    const notes = specs.map((struct) => new _src_tabnote__WEBPACK_IMPORTED_MODULE_6__.TabNote(struct, true /* drawStem */));
    _src_dot__WEBPACK_IMPORTED_MODULE_1__.Dot.buildAndAttach([notes[0], notes[2], notes[2]]);
    const voice = new _src_voice__WEBPACK_IMPORTED_MODULE_9__.Voice(_src_flow__WEBPACK_IMPORTED_MODULE_2__.Flow.TIME4_4).setMode(_src_voice__WEBPACK_IMPORTED_MODULE_9__.VoiceMode.SOFT);
    voice.addTickables(notes);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_3__.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    voice.draw(ctx, stave);
    options.assert.ok(true, 'TabNotes successfully drawn');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(TabNoteTests);



/***/ }),

/***/ "./tests/tabslide_tests.ts":
/*!*********************************!*\
  !*** ./tests/tabslide_tests.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TabSlideTests: () => (/* binding */ TabSlideTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_flow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/flow */ "./src/flow.ts");
/* harmony import */ var _src_formatter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/formatter */ "./src/formatter.ts");
/* harmony import */ var _src_tabnote__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/tabnote */ "./src/tabnote.ts");
/* harmony import */ var _src_tabslide__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/tabslide */ "./src/tabslide.ts");
/* harmony import */ var _src_tabstave__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/tabstave */ "./src/tabstave.ts");
/* harmony import */ var _src_voice__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/voice */ "./src/voice.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// TabSlide Tests







const TabSlideTests = {
    Start() {
        QUnit.module('TabSlide');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Simple TabSlide', simple);
        run('Slide Up', slideUp);
        run('Slide Down', slideDown);
    },
};
function tieNotes(notes, indexes, stave, ctx) {
    const voice = new _src_voice__WEBPACK_IMPORTED_MODULE_6__.Voice(_src_flow__WEBPACK_IMPORTED_MODULE_1__.Flow.TIME4_4);
    voice.addTickables(notes);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_2__.Formatter().joinVoices([voice]).format([voice], 100);
    voice.draw(ctx, stave);
    const tie = new _src_tabslide__WEBPACK_IMPORTED_MODULE_4__.TabSlide({
        firstNote: notes[0],
        lastNote: notes[1],
        firstIndexes: indexes,
        lastIndexes: indexes,
    }, _src_tabslide__WEBPACK_IMPORTED_MODULE_4__.TabSlide.SLIDE_UP);
    tie.setContext(ctx);
    tie.draw();
}
function setupContext(options, width) {
    // eslint-disable-next-line
    const context = options.contextBuilder(options.elementId, 350, 140);
    context.scale(0.9, 0.9);
    context.font = '10pt Arial';
    const stave = new _src_tabstave__WEBPACK_IMPORTED_MODULE_5__.TabStave(10, 10, width || 350).addTabGlyph().setContext(context).draw();
    return { context, stave };
}
// Helper function to create TabNote objects.
const tabNote = (noteStruct) => new _src_tabnote__WEBPACK_IMPORTED_MODULE_3__.TabNote(noteStruct);
/**
 * Test Case
 */
function simple(options, contextBuilder) {
    options.contextBuilder = contextBuilder;
    const { stave, context } = setupContext(options);
    tieNotes([
        tabNote({ positions: [{ str: 4, fret: 4 }], duration: 'h' }),
        tabNote({ positions: [{ str: 4, fret: 6 }], duration: 'h' }),
    ], [0], stave, context);
    options.assert.ok(true, 'Simple Test');
}
/**
 * The slideUp and slideDown tests pass in a builder function: TabSlide.createSlideUp | TabSlide.createSlideDown.
 */
function multiTest(options, buildTabSlide) {
    const { context, stave } = setupContext(options, 440);
    const notes = [
        tabNote({ positions: [{ str: 4, fret: 4 }], duration: '8' }),
        tabNote({ positions: [{ str: 4, fret: 4 }], duration: '8' }),
        tabNote({
            positions: [
                { str: 4, fret: 4 },
                { str: 5, fret: 4 },
            ],
            duration: '8',
        }),
        tabNote({
            positions: [
                { str: 4, fret: 6 },
                { str: 5, fret: 6 },
            ],
            duration: '8',
        }),
        tabNote({ positions: [{ str: 2, fret: 14 }], duration: '8' }),
        tabNote({ positions: [{ str: 2, fret: 16 }], duration: '8' }),
        tabNote({
            positions: [
                { str: 2, fret: 14 },
                { str: 3, fret: 14 },
            ],
            duration: '8',
        }),
        tabNote({
            positions: [
                { str: 2, fret: 16 },
                { str: 3, fret: 16 },
            ],
            duration: '8',
        }),
    ];
    const voice = new _src_voice__WEBPACK_IMPORTED_MODULE_6__.Voice(_src_flow__WEBPACK_IMPORTED_MODULE_1__.Flow.TIME4_4).addTickables(notes);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_2__.Formatter().joinVoices([voice]).format([voice], 300);
    voice.draw(context, stave);
    buildTabSlide({
        firstNote: notes[0],
        lastNote: notes[1],
        firstIndexes: [0],
        lastIndexes: [0],
    })
        .setContext(context)
        .draw();
    options.assert.ok(true, 'Single note');
    buildTabSlide({
        firstNote: notes[2],
        lastNote: notes[3],
        firstIndexes: [0, 1],
        lastIndexes: [0, 1],
    })
        .setContext(context)
        .draw();
    options.assert.ok(true, 'Chord');
    buildTabSlide({
        firstNote: notes[4],
        lastNote: notes[5],
        firstIndexes: [0],
        lastIndexes: [0],
    })
        .setContext(context)
        .draw();
    options.assert.ok(true, 'Single note high-fret');
    buildTabSlide({
        firstNote: notes[6],
        lastNote: notes[7],
        firstIndexes: [0, 1],
        lastIndexes: [0, 1],
    })
        .setContext(context)
        .draw();
    options.assert.ok(true, 'Chord high-fret');
}
function slideUp(options, contextBuilder) {
    options.contextBuilder = contextBuilder;
    multiTest(options, _src_tabslide__WEBPACK_IMPORTED_MODULE_4__.TabSlide.createSlideUp);
}
function slideDown(options, contextBuilder) {
    options.contextBuilder = contextBuilder;
    multiTest(options, _src_tabslide__WEBPACK_IMPORTED_MODULE_4__.TabSlide.createSlideDown);
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(TabSlideTests);



/***/ }),

/***/ "./tests/tabstave_tests.ts":
/*!*********************************!*\
  !*** ./tests/tabstave_tests.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TabStaveTests: () => (/* binding */ TabStaveTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_tabstave__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/tabstave */ "./src/tabstave.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// TabStave Tests


const TabStaveTests = {
    Start() {
        QUnit.module('TabStave');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('TabStave Draw Test', draw);
    },
};
function draw(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 160);
    const stave = new _src_tabstave__WEBPACK_IMPORTED_MODULE_1__.TabStave(10, 10, 300);
    stave.setNumLines(6);
    stave.setContext(ctx);
    stave.draw();
    options.assert.equal(stave.getYForNote(0), 127, 'getYForNote(0)');
    options.assert.equal(stave.getYForLine(5), 127, 'getYForLine(5)');
    options.assert.equal(stave.getYForLine(0), 62, 'getYForLine(0) - Top Line');
    options.assert.equal(stave.getYForLine(4), 114, 'getYForLine(4) - Bottom Line');
    options.assert.ok(true, 'all pass');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(TabStaveTests);



/***/ }),

/***/ "./tests/tabtie_tests.ts":
/*!*******************************!*\
  !*** ./tests/tabtie_tests.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TabTieTests: () => (/* binding */ TabTieTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_annotation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/annotation */ "./src/annotation.ts");
/* harmony import */ var _src_flow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/flow */ "./src/flow.ts");
/* harmony import */ var _src_formatter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/formatter */ "./src/formatter.ts");
/* harmony import */ var _src_tabnote__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/tabnote */ "./src/tabnote.ts");
/* harmony import */ var _src_tabstave__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/tabstave */ "./src/tabstave.ts");
/* harmony import */ var _src_tabtie__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/tabtie */ "./src/tabtie.ts");
/* harmony import */ var _src_voice__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/voice */ "./src/voice.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// TabTie Tests








const TabTieTests = {
    Start() {
        QUnit.module('TabTie');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Simple TabTie', simple);
        run('Hammerons', simpleHammerOn);
        run('Pulloffs', simplePullOff);
        run('Tapping', tap);
        run('Continuous', continuous);
    },
};
/**
 * Helper function to create TabNote objects.
 */
const tabNote = (noteStruct) => new _src_tabnote__WEBPACK_IMPORTED_MODULE_4__.TabNote(noteStruct);
/**
 * Helper function to create a RenderContext and TabStave.
 */
function setupContext(options, w = 0, h = 0) {
    // eslint-disable-next-line
    const context = options.contextBuilder(options.elementId, w || 350, h || 160);
    context.setFont('Arial', _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.Font.size);
    const stave = new _src_tabstave__WEBPACK_IMPORTED_MODULE_5__.TabStave(10, 10, w || 350).addTabGlyph().setContext(context).draw();
    return { context, stave };
}
/**
 * Helper function to create the TabTie between two Note objects.
 */
function tieNotes(notes, indexes, stave, ctx, text) {
    const voice = new _src_voice__WEBPACK_IMPORTED_MODULE_7__.Voice(_src_flow__WEBPACK_IMPORTED_MODULE_2__.Flow.TIME4_4);
    voice.addTickables(notes);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_3__.Formatter().joinVoices([voice]).format([voice], 100);
    voice.draw(ctx, stave);
    const tie = new _src_tabtie__WEBPACK_IMPORTED_MODULE_6__.TabTie({
        firstNote: notes[0],
        lastNote: notes[1],
        firstIndexes: indexes,
        lastIndexes: indexes,
    }, text !== null && text !== void 0 ? text : 'Annotation');
    tie.setContext(ctx);
    tie.draw();
}
/**
 * Two notes on string 4 with a tie drawn between them.
 */
function simple(options, contextBuilder) {
    options.contextBuilder = contextBuilder;
    const { context, stave } = setupContext(options);
    const note1 = tabNote({ positions: [{ str: 4, fret: 4 }], duration: 'h' });
    const note2 = tabNote({ positions: [{ str: 4, fret: 6 }], duration: 'h' });
    tieNotes([note1, note2], [0], stave, context);
    options.assert.ok(true, 'Simple Test');
}
function simpleHammerOn(options, contextBuilder) {
    options.contextBuilder = contextBuilder;
    multiTest(options, _src_tabtie__WEBPACK_IMPORTED_MODULE_6__.TabTie.createHammeron);
}
function simplePullOff(options, contextBuilder) {
    options.contextBuilder = contextBuilder;
    multiTest(options, _src_tabtie__WEBPACK_IMPORTED_MODULE_6__.TabTie.createPulloff);
}
/**
 * Helper function for the two test cases above (simpleHammerOn and simplePullOff).
 */
function multiTest(options, createTabTie) {
    const { context, stave } = setupContext(options, 440, 140);
    const notes = [
        tabNote({ positions: [{ str: 4, fret: 4 }], duration: '8' }),
        tabNote({ positions: [{ str: 4, fret: 4 }], duration: '8' }),
        tabNote({
            positions: [
                { str: 4, fret: 4 },
                { str: 5, fret: 4 },
            ],
            duration: '8',
        }),
        tabNote({
            positions: [
                { str: 4, fret: 6 },
                { str: 5, fret: 6 },
            ],
            duration: '8',
        }),
        tabNote({ positions: [{ str: 2, fret: 14 }], duration: '8' }),
        tabNote({ positions: [{ str: 2, fret: 16 }], duration: '8' }),
        tabNote({
            positions: [
                { str: 2, fret: 14 },
                { str: 3, fret: 14 },
            ],
            duration: '8',
        }),
        tabNote({
            positions: [
                { str: 2, fret: 16 },
                { str: 3, fret: 16 },
            ],
            duration: '8',
        }),
    ];
    const voice = new _src_voice__WEBPACK_IMPORTED_MODULE_7__.Voice(_src_flow__WEBPACK_IMPORTED_MODULE_2__.Flow.TIME4_4).addTickables(notes);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_3__.Formatter().joinVoices([voice]).format([voice], 300);
    voice.draw(context, stave);
    createTabTie({
        firstNote: notes[0],
        lastNote: notes[1],
        firstIndexes: [0],
        lastIndexes: [0],
    })
        .setContext(context)
        .draw();
    options.assert.ok(true, 'Single note');
    createTabTie({
        firstNote: notes[2],
        lastNote: notes[3],
        firstIndexes: [0, 1],
        lastIndexes: [0, 1],
    })
        .setContext(context)
        .draw();
    options.assert.ok(true, 'Chord');
    createTabTie({
        firstNote: notes[4],
        lastNote: notes[5],
        firstIndexes: [0],
        lastIndexes: [0],
    })
        .setContext(context)
        .draw();
    options.assert.ok(true, 'Single note high-fret');
    createTabTie({
        firstNote: notes[6],
        lastNote: notes[7],
        firstIndexes: [0, 1],
        lastIndexes: [0, 1],
    })
        .setContext(context)
        .draw();
    options.assert.ok(true, 'Chord high-fret');
}
function tap(options, contextBuilder) {
    options.contextBuilder = contextBuilder;
    const { context, stave } = setupContext(options);
    const note1 = tabNote({ positions: [{ str: 4, fret: 12 }], duration: 'h' }).addModifier(new _src_annotation__WEBPACK_IMPORTED_MODULE_1__.Annotation('T'), 0);
    const note2 = tabNote({ positions: [{ str: 4, fret: 10 }], duration: 'h' });
    tieNotes([note1, note2], [0], stave, context, 'P');
    options.assert.ok(true, 'Tapping Test');
}
function continuous(options, contextBuilder) {
    options.contextBuilder = contextBuilder;
    const { context, stave } = setupContext(options, 440, 140);
    const notes = [
        tabNote({ positions: [{ str: 4, fret: 4 }], duration: 'q' }),
        tabNote({ positions: [{ str: 4, fret: 5 }], duration: 'q' }),
        tabNote({ positions: [{ str: 4, fret: 6 }], duration: 'h' }),
    ];
    const voice = new _src_voice__WEBPACK_IMPORTED_MODULE_7__.Voice(_src_flow__WEBPACK_IMPORTED_MODULE_2__.Flow.TIME4_4).addTickables(notes);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_3__.Formatter().joinVoices([voice]).format([voice], 300);
    voice.draw(context, stave);
    _src_tabtie__WEBPACK_IMPORTED_MODULE_6__.TabTie.createHammeron({
        firstNote: notes[0],
        lastNote: notes[1],
        firstIndexes: [0],
        lastIndexes: [0],
    })
        .setContext(context)
        .draw();
    _src_tabtie__WEBPACK_IMPORTED_MODULE_6__.TabTie.createPulloff({
        firstNote: notes[1],
        lastNote: notes[2],
        firstIndexes: [0],
        lastIndexes: [0],
    })
        .setContext(context)
        .draw();
    options.assert.ok(true, 'Continuous Hammeron');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(TabTieTests);



/***/ }),

/***/ "./tests/textbracket_tests.ts":
/*!************************************!*\
  !*** ./tests/textbracket_tests.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextBracketTests: () => (/* binding */ TextBracketTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// TextBracket Tests

const TextBracketTests = {
    Start() {
        QUnit.module('TextBracket');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Simple TextBracket', simple0);
        run('TextBracket Styles', simple1);
    },
};
function simple0(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 550);
    const stave = f.Stave();
    const score = f.EasyScore();
    const notes = score.notes('c4/4, c4, c4, c4, c4', { stem: 'up' });
    const voice = score.voice(notes, { time: '5/4' });
    f.TextBracket({
        from: notes[0],
        to: notes[4],
        text: '15',
        options: {
            superscript: 'va',
            position: 'top',
        },
    });
    f.TextBracket({
        from: notes[0],
        to: notes[4],
        text: '8',
        options: {
            superscript: 'vb',
            position: 'bottom',
            line: 3,
        },
    });
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true);
}
function simple1(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 550);
    const stave = f.Stave();
    const score = f.EasyScore();
    const notes = score.notes('c4/4, c4, c4, c4, c4', { stem: 'up' });
    const voice = score.voice(notes, { time: '5/4' });
    const topOctaves = [
        f.TextBracket({
            from: notes[0],
            to: notes[1],
            text: 'Cool notes',
            options: {
                superscript: '',
                position: 'top',
            },
        }),
        f.TextBracket({
            from: notes[2],
            to: notes[4],
            text: 'Testing',
            options: {
                position: 'top',
                superscript: 'superscript',
                // weight & style below can be left undefined. They will fall back to the default defined in textbracket.ts.
                font: { family: 'Arial', size: 15, weight: 'normal', style: 'normal' },
            },
        }),
    ];
    const bottomOctaves = [
        f.TextBracket({
            from: notes[0],
            to: notes[1],
            text: '8',
            options: {
                superscript: 'vb',
                position: 'bottom',
                line: 3,
                font: { size: 30 },
            },
        }),
        f.TextBracket({
            from: notes[2],
            to: notes[4],
            text: 'Not cool notes',
            options: {
                superscript: ' super uncool',
                position: 'bottom',
                line: 4,
            },
        }),
    ];
    topOctaves[1].renderOptions.lineWidth = 2;
    topOctaves[1].renderOptions.showBracket = false;
    bottomOctaves[0].renderOptions.underlineSuperscript = false;
    bottomOctaves[0].setDashed(false);
    bottomOctaves[1].renderOptions.bracketHeight = 40;
    bottomOctaves[1].setDashed(true, [2, 2]);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true);
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(TextBracketTests);



/***/ }),

/***/ "./tests/textnote_tests.ts":
/*!*********************************!*\
  !*** ./tests/textnote_tests.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextNoteTests: () => (/* binding */ TextNoteTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_crescendo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/crescendo */ "./src/crescendo.ts");
/* harmony import */ var _src_flow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/flow */ "./src/flow.ts");
/* harmony import */ var _src_note__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/note */ "./src/note.ts");
/* harmony import */ var _src_stave__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/stave */ "./src/stave.ts");
/* harmony import */ var _src_textnote__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/textnote */ "./src/textnote.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Text Note Tests






const TextNoteTests = {
    Start() {
        QUnit.module('TextNote');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('TextNote Formatting', formatTextNotes);
        run('TextNote Formatting 2', formatTextNotes2);
        run('TextNote Superscript and Subscript', superscriptAndSubscript);
        run('TextNote Formatting With Glyphs 0', formatTextGlyphs0);
        run('TextNote Formatting With Glyphs 1', formatTextGlyphs1);
        run('Crescendo', crescendo);
        run('Text Dynamics', textDynamics);
    },
};
function formatTextNotes(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 400, 200);
    const stave = f.Stave({ y: 40 });
    const score = f.EasyScore();
    const voice1 = score.voice([
        f
            .StaveNote({ keys: ['c/4', 'e/4', 'a/4'], stemDirection: -1, duration: 'h' })
            .addModifier(f.Accidental({ type: 'b' }), 0)
            .addModifier(f.Accidental({ type: '#' }), 1),
        f.StaveNote({ keys: ['d/4', 'e/4', 'f/4'], stemDirection: -1, duration: 'q' }),
        f
            .StaveNote({ keys: ['c/4', 'f/4', 'a/4'], stemDirection: -1, duration: 'q' })
            .addModifier(f.Accidental({ type: 'n' }), 0)
            .addModifier(f.Accidental({ type: '#' }), 1),
    ]);
    const voice2 = score.voice([
        f.TextNote({ text: 'Center Justification', duration: 'h' }).setJustification(_src_textnote__WEBPACK_IMPORTED_MODULE_5__.TextNote.Justification.CENTER),
        f.TextNote({ text: 'Left Line 1', duration: 'q' }).setLine(1),
        f.TextNote({ text: 'Right', duration: 'q' }).setJustification(_src_textnote__WEBPACK_IMPORTED_MODULE_5__.TextNote.Justification.RIGHT),
    ]);
    const formatter = f.Formatter();
    formatter.joinVoices([voice1, voice2]).formatToStave([voice1, voice2], stave);
    f.draw();
    options.assert.ok(true);
}
function formatTextNotes2(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 200);
    const stave = f.Stave({ y: 40 });
    const score = f.EasyScore();
    const voice1 = score.voice([
        f.StaveNote({ keys: ['g/4'], stemDirection: 1, duration: '16' }),
        f.StaveNote({ keys: ['g/4'], stemDirection: 1, duration: '16' }),
        f.StaveNote({ keys: ['g/4'], stemDirection: 1, duration: '16' }),
        f.StaveNote({ keys: ['g/5'], stemDirection: -1, duration: '16' }),
        f.StaveNote({ keys: ['g/5'], stemDirection: -1, duration: '16' }),
        f.StaveNote({ keys: ['g/5'], stemDirection: -1, duration: '16' }),
        f.StaveNote({ keys: ['g/5', 'a/5'], stemDirection: -1, duration: '16' }),
        f.StaveNote({ keys: ['g/5', 'a/5'], stemDirection: -1, duration: '16' }),
        f.StaveNote({ keys: ['g/5', 'a/5'], stemDirection: -1, duration: '16' }),
        f.StaveNote({ keys: ['g/4', 'a/4'], stemDirection: 1, duration: '16' }),
        f.StaveNote({ keys: ['g/4', 'a/4'], stemDirection: 1, duration: '16' }),
        f.StaveNote({ keys: ['g/4', 'a/4'], stemDirection: 1, duration: '16' }),
        f.StaveNote({ keys: ['g/4', 'a/4'], stemDirection: 1, duration: 'q' }),
    ]);
    const voice2 = score.voice([
        f.TextNote({ text: 'C', duration: '16' }).setJustification(_src_textnote__WEBPACK_IMPORTED_MODULE_5__.TextNote.Justification.CENTER),
        f.TextNote({ text: 'L', duration: '16' }),
        f.TextNote({ text: 'R', duration: '16' }).setJustification(_src_textnote__WEBPACK_IMPORTED_MODULE_5__.TextNote.Justification.RIGHT),
        f.TextNote({ text: 'C', duration: '16' }).setJustification(_src_textnote__WEBPACK_IMPORTED_MODULE_5__.TextNote.Justification.CENTER),
        f.TextNote({ text: 'L', duration: '16' }),
        f.TextNote({ text: 'R', duration: '16' }).setJustification(_src_textnote__WEBPACK_IMPORTED_MODULE_5__.TextNote.Justification.RIGHT),
        f.TextNote({ text: 'C', duration: '16' }).setJustification(_src_textnote__WEBPACK_IMPORTED_MODULE_5__.TextNote.Justification.CENTER),
        f.TextNote({ text: 'L', duration: '16' }),
        f.TextNote({ text: 'R', duration: '16' }).setJustification(_src_textnote__WEBPACK_IMPORTED_MODULE_5__.TextNote.Justification.RIGHT),
        f.TextNote({ text: 'C', duration: '16' }).setJustification(_src_textnote__WEBPACK_IMPORTED_MODULE_5__.TextNote.Justification.CENTER),
        f.TextNote({ text: 'L', duration: '16' }),
        f.TextNote({ text: 'R', duration: '16' }).setJustification(_src_textnote__WEBPACK_IMPORTED_MODULE_5__.TextNote.Justification.RIGHT),
        f.TextNote({ text: 'R', duration: 'q' }).setJustification(_src_textnote__WEBPACK_IMPORTED_MODULE_5__.TextNote.Justification.RIGHT),
    ]);
    f.Formatter().joinVoices([voice1, voice2]).formatToStave([voice1, voice2], stave);
    voice2.getTickables().forEach((note) => _src_note__WEBPACK_IMPORTED_MODULE_3__.Note.plotMetrics(f.getContext(), note, 170));
    f.draw();
    options.assert.ok(true);
}
function superscriptAndSubscript(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 230);
    const stave = f.Stave({ y: 40 });
    const score = f.EasyScore();
    const voice1 = score.voice([
        f
            .StaveNote({ keys: ['c/4', 'e/4', 'a/4'], stemDirection: 1, duration: 'h' })
            .addModifier(f.Accidental({ type: 'b' }), 0)
            .addModifier(f.Accidental({ type: '#' }), 1),
        f.StaveNote({ keys: ['d/4', 'e/4', 'f/4'], stemDirection: 1, duration: 'q' }),
        f
            .StaveNote({ keys: ['c/4', 'f/4', 'a/4'], stemDirection: 1, duration: 'q' })
            .addModifier(f.Accidental({ type: 'n' }), 0)
            .addModifier(f.Accidental({ type: '#' }), 1),
    ]);
    const notes2 = [
        f.TextNote({ text: _src_flow__WEBPACK_IMPORTED_MODULE_2__.Flow.unicode.flat + 'I', superscript: '+5', duration: '8' }),
        f.TextNote({ text: 'D' + _src_flow__WEBPACK_IMPORTED_MODULE_2__.Flow.unicode.sharp + '/F', duration: '4d', superscript: 'sus2' }),
        f.TextNote({ text: 'ii', superscript: '6', subscript: '4', duration: '8' }),
        f.TextNote({ text: 'C', superscript: _src_flow__WEBPACK_IMPORTED_MODULE_2__.Flow.unicode.triangle + '7', subscript: '', duration: '8' }),
        f.TextNote({ text: 'vii', superscript: _src_flow__WEBPACK_IMPORTED_MODULE_2__.Flow.unicode['o-with-slash'] + '7', duration: '8' }),
        f.TextNote({ text: 'V', superscript: '7', duration: '8' }),
    ];
    options.assert.equal(notes2[0].getText(), _src_flow__WEBPACK_IMPORTED_MODULE_2__.Flow.unicode.flat + 'I', 'TextNote.getText() return .text');
    const voice2 = score.voice(notes2);
    voice2.getTickables().forEach((note) => {
        const textNote = note;
        textNote.setFontSize(15);
        textNote.setLine(13);
        textNote.setJustification(_src_textnote__WEBPACK_IMPORTED_MODULE_5__.TextNote.Justification.LEFT);
    });
    f.Formatter().joinVoices([voice1, voice2]).formatToStave([voice1, voice2], stave);
    f.draw();
    options.assert.ok(true);
}
function formatTextGlyphs0(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 230);
    const stave = f.Stave({ y: 40 });
    const score = f.EasyScore();
    const voice1 = score.voice([
        f
            .StaveNote({ keys: ['c/4', 'e/4', 'a/4'], stemDirection: -1, duration: 'h' })
            .addModifier(f.Accidental({ type: 'b' }), 0)
            .addModifier(f.Accidental({ type: '#' }), 1),
        f.StaveNote({ keys: ['d/4', 'e/4', 'f/4'], stemDirection: -1, duration: '8' }),
        f.StaveNote({ keys: ['c/4', 'f/4', 'a/4'], stemDirection: -1, duration: '8' }),
        f.StaveNote({ keys: ['c/4', 'f/4', 'a/4'], stemDirection: -1, duration: '8' }),
        f.StaveNote({ keys: ['c/4', 'f/4', 'a/4'], stemDirection: -1, duration: '8' }),
    ]);
    const voice2 = score.voice([
        f.TextNote({ text: 'Center', duration: '8' }).setJustification(_src_textnote__WEBPACK_IMPORTED_MODULE_5__.TextNote.Justification.CENTER),
        f.TextNote({ glyph: 'f', duration: '8' }),
        f.TextNote({ glyph: 'p', duration: '8' }),
        f.TextNote({ glyph: 'm', duration: '8' }),
        f.TextNote({ glyph: 'z', duration: '8' }),
        f.TextNote({ glyph: 'mordentUpper', duration: '16' }),
        f.TextNote({ glyph: 'mordentLower', duration: '16' }),
        f.TextNote({ glyph: 'segno', duration: '8' }),
        f.TextNote({ glyph: 'coda', duration: '8' }),
    ]);
    voice2.getTickables().forEach((n) => n.setJustification(_src_textnote__WEBPACK_IMPORTED_MODULE_5__.TextNote.Justification.CENTER));
    f.Formatter().joinVoices([voice1, voice2]).formatToStave([voice1, voice2], stave);
    f.draw();
    options.assert.ok(true);
}
function formatTextGlyphs1(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 230);
    const stave = f.Stave({ y: 40 });
    const score = f.EasyScore();
    const voice1 = score.voice([
        f
            .StaveNote({ keys: ['c/4', 'e/4', 'a/4'], stemDirection: -1, duration: 'h' })
            .addModifier(f.Accidental({ type: 'b' }), 0)
            .addModifier(f.Accidental({ type: '#' }), 1),
        f.StaveNote({ keys: ['d/4', 'e/4', 'f/4'], stemDirection: -1, duration: '8' }),
        f.StaveNote({ keys: ['c/4', 'f/4', 'a/4'], stemDirection: -1, duration: '8' }),
        f.StaveNote({ keys: ['c/4', 'f/4', 'a/4'], stemDirection: -1, duration: '8' }),
        f.StaveNote({ keys: ['c/4', 'f/4', 'a/4'], stemDirection: -1, duration: '8' }),
    ]);
    const voice2 = score.voice([
        f.TextNote({ glyph: 'turn', duration: '16' }),
        f.TextNote({ glyph: 'turnInverted', duration: '16' }),
        f.TextNote({ glyph: 'pedalOpen', duration: '8' }).setLine(10),
        f.TextNote({ glyph: 'pedalClose', duration: '8' }).setLine(10),
        f.TextNote({ glyph: 'caesuraCurved', duration: '8' }).setLine(3),
        f.TextNote({ glyph: 'caesuraStraight', duration: '8' }).setLine(3),
        f.TextNote({ glyph: 'breath', duration: '8' }).setLine(2),
        f.TextNote({ glyph: 'tick', duration: '8' }).setLine(3),
        f.TextNote({ glyph: 'tr', duration: '8', smooth: true }).setJustification(_src_textnote__WEBPACK_IMPORTED_MODULE_5__.TextNote.Justification.CENTER),
    ]);
    voice2.getTickables().forEach((n) => n.setJustification(_src_textnote__WEBPACK_IMPORTED_MODULE_5__.TextNote.Justification.CENTER));
    f.Formatter().joinVoices([voice1, voice2]).formatToStave([voice1, voice2], stave);
    f.draw();
    options.assert.ok(true);
}
function crescendo(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 230);
    const stave = f.Stave({ y: 40 });
    const score = f.EasyScore();
    const voice = score.voice([
        f.TextNote({ glyph: 'p', duration: '16' }),
        new _src_crescendo__WEBPACK_IMPORTED_MODULE_1__.Crescendo({ duration: '4d' }).setLine(0).setHeight(25).setStave(stave),
        f.TextNote({ glyph: 'f', duration: '16' }),
        new _src_crescendo__WEBPACK_IMPORTED_MODULE_1__.Crescendo({ duration: '4' }).setLine(5).setStave(stave),
        new _src_crescendo__WEBPACK_IMPORTED_MODULE_1__.Crescendo({ duration: '4' }).setLine(10).setDecrescendo(true).setHeight(5).setStave(stave),
    ]);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true);
}
function textDynamics(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 230);
    const score = f.EasyScore();
    const voice = score.voice([
        f.TextDynamics({ text: 'sfz', duration: '4' }),
        f.TextDynamics({ text: 'rfz', duration: '4' }),
        f.TextDynamics({ text: 'mp', duration: '4' }),
        f.TextDynamics({ text: 'ppp', duration: '4' }),
        f.TextDynamics({ text: 'fff', duration: '4' }),
        f.TextDynamics({ text: 'mf', duration: '4' }),
        f.TextDynamics({ text: 'sff', duration: '4' }),
    ], { time: '7/4' });
    // This is refactored to use preCalculateMinWidth... to exercise
    // a bug fix when textDynamic got formatted more than once.
    const formatter = f.Formatter();
    formatter.joinVoices([voice]);
    // const width = 250; //formatter.preCalculateMinTotalWidth([voice]);
    const width = formatter.preCalculateMinTotalWidth([voice]);
    formatter.format([voice]);
    const stave = f.Stave({ y: 40, width: width + _src_stave__WEBPACK_IMPORTED_MODULE_4__.Stave.defaultPadding });
    stave.draw();
    voice.draw(f.getContext(), stave);
    options.assert.ok(true);
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(TextNoteTests);



/***/ }),

/***/ "./tests/threevoice_tests.ts":
/*!***********************************!*\
  !*** ./tests/threevoice_tests.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ThreeVoicesTests: () => (/* binding */ ThreeVoicesTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_beam__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/beam */ "./src/beam.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Three Voices Tests - Three voices in single staff.


const ThreeVoicesTests = {
    Start() {
        // TODO: Rename the module to 'Three Voices', because we aren't really testing rests.
        QUnit.module('Three Voice Rests');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Three Voices - #1', threeVoices1);
        run('Three Voices - #2 Complex', threeVoices2);
        run('Three Voices - #3', threeVoices3);
        run('Auto Adjust Rest Positions - Two Voices', autoRestTwoVoices);
        run('Auto Adjust Rest Positions - Three Voices #1', autoRestThreeVoices1);
        run('Auto Adjust Rest Positions - Three Voices #2', autoRestThreeVoices2);
    },
};
/**
 * Helper for setting up the first three test cases: threeVoices1, threeVoices2, threeVoices3.
 */
function createThreeVoicesTest(noteGroup1, noteGroup2, noteGroup3, setup) {
    return (options) => {
        const factory = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 200);
        const stave = factory.Stave().addClef('treble').addTimeSignature('4/4');
        const score = factory.EasyScore();
        // Convert each noteGroup array to StaveNote[].
        const noteGroups = [noteGroup1, noteGroup2, noteGroup3].map((args) => score.notes(...args));
        const voices = noteGroups.map((notes) => score.voice(notes));
        setup(factory, voices);
        const beams = [
            _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voices[0], +1),
            _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voices[1], -1),
            _src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voices[2], -1),
        ].reduce(_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.concat);
        // Set option to position rests near the notes in each voice.
        factory.Formatter().joinVoices(voices).formatToStave(voices, stave);
        factory.draw();
        for (let i = 0; i < beams.length; i++) {
            beams[i].setContext(factory.getContext()).draw();
        }
        options.assert.ok(true);
    };
}
/**
 *
 */
const threeVoices1 = createThreeVoicesTest(['e5/2, e5', { stem: 'up' }], ['(d4 a4 d#5)/8, b4, (d4 a4 c5), b4, (d4 a4 c5), b4, (d4 a4 c5), b4', { stem: 'down' }], ['b3/4, e3, f3, a3', { stem: 'down' }], (f, voices) => {
    voices[0].getTickables()[0].addModifier(f.Fingering({ number: '0', position: 'left' }), 0);
    voices[1]
        .getTickables()[0]
        .addModifier(f.Fingering({ number: '0', position: 'left' }), 0)
        .addModifier(f.Fingering({ number: '4', position: 'left' }), 1);
});
/**
 * Lots of beamed notes. A beam and notehead overlap.
 */
const threeVoices2 = createThreeVoicesTest(['(a4 e5)/16, e5, e5, e5, e5/8, e5, e5/2', { stem: 'up' }], ['(d4 d#5)/16, (b4 c5), d5, e5, (d4 a4 c5)/8, b4, (d4 a4 c5), b4, (d4 a4 c5), b4', { stem: 'down' }], ['b3/8, b3, e3/4, f3, a3', { stem: 'down' }], (f, voices) => {
    voices[0]
        .getTickables()[0]
        .addModifier(f.Fingering({ number: '2', position: 'left' }), 0)
        .addModifier(f.Fingering({ number: '0', position: 'above' }), 1);
    voices[1]
        .getTickables()[0]
        .addModifier(f.Fingering({ number: '0', position: 'left' }), 0)
        .addModifier(f.Fingering({ number: '4', position: 'left' }), 1);
});
/**
 *
 */
const threeVoices3 = createThreeVoicesTest(['(g4 e5)/4, e5, (g4 e5)/2', { stem: 'up' }], ['c#5/4, b4/8, b4/8/r, a4/4., g4/8', { stem: 'down' }], ['c4/4, b3, a3, g3', { stem: 'down' }], (f, voices) => {
    voices[0]
        .getTickables()[0]
        .addModifier(f.Fingering({ number: '0', position: 'left' }), 0)
        .addModifier(f.Fingering({ number: '0', position: 'left' }), 1);
    voices[1].getTickables()[0].addModifier(f.Fingering({ number: '1', position: 'left' }), 0);
    voices[2].getTickables()[0].addModifier(f.Fingering({ number: '3', position: 'left' }), 0);
});
function autoRestTwoVoices(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 900, 200);
    const score = f.EasyScore();
    let x = 10;
    let beams = [];
    function createMeasure(measureTitle, width, alignRests) {
        const stave = f.Stave({ x: x, y: 50, width: width }).setBegBarType(1);
        x += width;
        const noteArrays = [
            score.notes('b4/8/r, e5/16, b4/r, b4/8/r, e5/16, b4/r, b4/8/r, d5/16, b4/r, e5/4', { stem: 'up' }),
            score.notes('c5/16, c4, b4/r, d4, e4, f4, b4/r, g4, g4[stem="up"], a4[stem="up"], b4/r, b4[stem="up"], e4/4', {
                stem: 'down',
            }),
            [f.TextNote({ text: measureTitle, line: -1, duration: '1', smooth: true })],
        ];
        const voices = noteArrays.map((notes) => score.voice(notes));
        beams = beams.concat(_src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voices[0], 1)).concat(_src_beam__WEBPACK_IMPORTED_MODULE_1__.Beam.applyAndGetBeams(voices[1], -1));
        f.Formatter().joinVoices(voices).formatToStave(voices, stave, { alignRests });
    }
    createMeasure('Default Rest Positions', 400, false);
    createMeasure('Rests Repositioned To Avoid Collisions', 400, true);
    f.draw();
    for (let i = 0; i < beams.length; i++) {
        beams[i].setContext(f.getContext()).draw();
    }
    options.assert.ok(true, 'Auto Adjust Rests - Two Voices');
}
function autoRestThreeVoices1(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 850, 200);
    const score = f.EasyScore();
    let x = 10;
    function createMeasure(measureTitle, width, alignRests) {
        const stave = f.Stave({ x: x, y: 50, width: width }).setBegBarType(1);
        const voices = [
            score.voice(score.notes('b4/4/r, e5, e5/r, e5/r, e5, e5, e5, e5/r', { stem: 'up' }), { time: '8/4' }),
            score.voice(score.notes('b4/4/r, b4/r, b4/r, b4, b4/r, b4/r, b4, b4', { stem: 'down' }), { time: '8/4' }),
            score.voice(score.notes('e4/4/r, e4/r, f4, b4/r, g4, c4, e4/r, c4', { stem: 'down' }), { time: '8/4' }),
            score.voice([
                f.TextNote({ text: measureTitle, duration: '1', line: -1, smooth: true }),
                f.TextNote({ text: '', duration: '1', line: -1, smooth: true }),
            ], { time: '8/4' }),
        ];
        f.Formatter().joinVoices(voices).formatToStave(voices, stave, { alignRests });
        x += width;
    }
    createMeasure('Default Rest Positions', 400, false);
    createMeasure('Rests Repositioned To Avoid Collisions', 400, true);
    f.draw();
    options.assert.ok(true);
}
function autoRestThreeVoices2(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 850, 200);
    const score = f.EasyScore();
    let x = 10;
    function createMeasure(measureTitle, width, alignRests) {
        const stave = f.Stave({ x: x, y: 50, width: width }).setBegBarType(1);
        const voices = [
            score.voice(score.notes('b4/16/r, e5, e5/r, e5/r, e5, e5, e5, e5/r'), { time: '2/4' }),
            score.voice(score.notes('b4/16/r, b4/r, b4/r, b4, b4/r, b4/r, b4, b4'), { time: '2/4' }),
            score.voice(score.notes('e4/16/r, e4/r, f4, b4/r, g4, c4, e4/r, c4'), { time: '2/4' }),
            score.voice([f.TextNote({ text: measureTitle, duration: 'h', line: -1, smooth: true })], { time: '2/4' }),
        ];
        f.Formatter().joinVoices(voices).formatToStave(voices, stave, { alignRests });
        x += width;
    }
    createMeasure('Default Rest Positions', 400, false);
    createMeasure('Rests Repositioned To Avoid Collisions', 400, true);
    f.draw();
    options.assert.ok(true);
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(ThreeVoicesTests);



/***/ }),

/***/ "./tests/tickcontext_tests.ts":
/*!************************************!*\
  !*** ./tests/tickcontext_tests.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TickContextTests: () => (/* binding */ TickContextTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_flow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/flow */ "./src/flow.ts");
/* harmony import */ var _src_tickcontext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/tickcontext */ "./src/tickcontext.ts");
/* harmony import */ var _mocks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mocks */ "./tests/mocks.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// TickContext Tests




const TickContextTests = {
    Start() {
        QUnit.module('TickContext');
        QUnit.test('Current Tick Test', currentTick);
        QUnit.test('Tracking Test', tracking);
    },
};
function currentTick(assert) {
    const tc = new _src_tickcontext__WEBPACK_IMPORTED_MODULE_2__.TickContext();
    assert.equal(tc.getCurrentTick().value(), 0, 'New tick context has no ticks');
}
function tracking(assert) {
    const BEAT = (1 * _src_flow__WEBPACK_IMPORTED_MODULE_1__.Flow.RESOLUTION) / 4;
    const tickables = [
        new _mocks__WEBPACK_IMPORTED_MODULE_3__.MockTickable().setTicks(BEAT).setWidth(10),
        new _mocks__WEBPACK_IMPORTED_MODULE_3__.MockTickable().setTicks(BEAT * 2).setWidth(20),
        new _mocks__WEBPACK_IMPORTED_MODULE_3__.MockTickable().setTicks(BEAT).setWidth(30),
    ];
    const tc = new _src_tickcontext__WEBPACK_IMPORTED_MODULE_2__.TickContext();
    tc.setPadding(0);
    tc.addTickable(tickables[0]);
    assert.equal(tc.getMaxTicks().value(), BEAT);
    tc.addTickable(tickables[1]);
    assert.equal(tc.getMaxTicks().value(), BEAT * 2);
    tc.addTickable(tickables[2]);
    assert.equal(tc.getMaxTicks().value(), BEAT * 2);
    assert.equal(tc.getWidth(), 0);
    tc.preFormat();
    assert.equal(tc.getWidth(), 30);
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(TickContextTests);



/***/ }),

/***/ "./tests/timesignature_tests.ts":
/*!**************************************!*\
  !*** ./tests/timesignature_tests.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TimeSignatureTests: () => (/* binding */ TimeSignatureTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_stave__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/stave */ "./src/stave.ts");
/* harmony import */ var _src_staveconnector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/staveconnector */ "./src/staveconnector.ts");
/* harmony import */ var _src_timesignature__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/timesignature */ "./src/timesignature.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// TimeSignature Tests




const TimeSignatureTests = {
    Start() {
        QUnit.module('TimeSignature');
        QUnit.test('Time Signature Parser', parser);
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Basic Time Signatures', basic);
        run('Big Signature Test', big);
        run('Additive Signature Test', additive);
        run('Alternating Signature Test', alternating);
        run('Interchangeable Signature Test', interchangeable);
        run('Aggregate Signature Test', agregate);
        run('Complex Signature Test', complex);
        run('Time Signature multiple staves alignment test', multiple);
        run('Time Signature Change Test', change);
    },
};
function parser(assert) {
    const timeSig = new _src_timesignature__WEBPACK_IMPORTED_MODULE_3__.TimeSignature();
    assert.equal(timeSig.getTimeSpec(), '4/4', 'default time signature is 4/4');
    const mustFail = ['asdf', '123/', '/10', '/', '4567', 'C+', '1+', '+1', '(3+', '+3)', '()', '(+)'];
    mustFail.forEach((invalidString) => {
        assert.throws(() => new _src_timesignature__WEBPACK_IMPORTED_MODULE_3__.TimeSignature(invalidString), /BadTimeSignature/);
    });
    const mustPass = ['4/4', '10/12', '1/8', '1234567890/1234567890', 'C', 'C|', '+'];
    mustPass.forEach((validString) => new _src_timesignature__WEBPACK_IMPORTED_MODULE_3__.TimeSignature(validString));
    timeSig.setTimeSig('4/4');
    assert.equal(timeSig.getIsNumeric(), true, '4/4 is numeric');
    assert.equal(timeSig.getLine(), 0, 'digits are on line 0');
    timeSig.setTimeSig('C|');
    assert.equal(timeSig.getTimeSpec(), 'C|', 'timeSpec changed to C|');
    assert.equal(timeSig.getIsNumeric(), false, 'cut time is not numeric');
    assert.equal(timeSig.getLine(), 2, 'cut/common are on line 2');
    assert.ok(true, 'all pass');
}
function basic(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 600, 120);
    new _src_stave__WEBPACK_IMPORTED_MODULE_1__.Stave(10, 10, 500)
        .addTimeSignature('2/2')
        .addTimeSignature('3/4')
        .addTimeSignature('4/4')
        .addTimeSignature('6/8')
        .addTimeSignature('C')
        .addTimeSignature('C|')
        .addEndTimeSignature('2/2')
        .addEndTimeSignature('3/4')
        .addEndTimeSignature('4/4')
        .addEndClef('treble')
        .addEndTimeSignature('6/8')
        .addEndTimeSignature('C')
        .addEndTimeSignature('C|')
        .setContext(ctx)
        .draw();
    options.assert.ok(true, 'all pass');
}
function big(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 120);
    new _src_stave__WEBPACK_IMPORTED_MODULE_1__.Stave(10, 10, 300)
        .addTimeSignature('12/8')
        .addTimeSignature('7/16')
        .addTimeSignature('1234567/890')
        .addTimeSignature('987/654321')
        .setContext(ctx)
        .draw();
    options.assert.ok(true, 'all pass');
}
function additive(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 120);
    new _src_stave__WEBPACK_IMPORTED_MODULE_1__.Stave(10, 10, 300).addTimeSignature('2+3+2/8').setContext(ctx).draw();
    options.assert.ok(true, 'all pass');
}
function alternating(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 120);
    new _src_stave__WEBPACK_IMPORTED_MODULE_1__.Stave(10, 10, 300).addTimeSignature('6/8').addTimeSignature('+').addTimeSignature('3/4').setContext(ctx).draw();
    options.assert.ok(true, 'all pass');
}
function interchangeable(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 120);
    new _src_stave__WEBPACK_IMPORTED_MODULE_1__.Stave(10, 10, 300).addTimeSignature('3/4').addTimeSignature('-').addTimeSignature('2/4').setContext(ctx).draw();
    options.assert.ok(true, 'all pass');
}
function agregate(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 120);
    new _src_stave__WEBPACK_IMPORTED_MODULE_1__.Stave(10, 10, 300)
        .addTimeSignature('2/4')
        .addTimeSignature('+')
        .addTimeSignature('3/8')
        .addTimeSignature('+')
        .addTimeSignature('5/4')
        .setContext(ctx)
        .draw();
    options.assert.ok(true, 'all pass');
}
function complex(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 120);
    new _src_stave__WEBPACK_IMPORTED_MODULE_1__.Stave(10, 10, 300)
        .addTimeSignature('(2+3)/16')
        .addTimeSignature('+')
        .addTimeSignature('3/8')
        .setContext(ctx)
        .draw();
    options.assert.ok(true, 'all pass');
}
function multiple(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 400, 350);
    // Each StaveLineConfig object is of the form { visible: boolean }.
    const stave1LineConfig = [false, false, true, false, false].map((visible) => ({ visible }));
    const stave1 = new _src_stave__WEBPACK_IMPORTED_MODULE_1__.Stave(15, 0, 300)
        .setConfigForLines(stave1LineConfig)
        .addClef('percussion')
        .addTimeSignature('4/4', 25) // passing the custom padding in pixels
        .setContext(ctx)
        .draw();
    const stave2 = new _src_stave__WEBPACK_IMPORTED_MODULE_1__.Stave(15, 110, 300).addClef('treble').addTimeSignature('4/4').setContext(ctx).draw();
    const stave3 = new _src_stave__WEBPACK_IMPORTED_MODULE_1__.Stave(15, 220, 300).addClef('bass').addTimeSignature('4/4').setContext(ctx).draw();
    _src_stave__WEBPACK_IMPORTED_MODULE_1__.Stave.formatBegModifiers([stave1, stave2, stave3]);
    new _src_staveconnector__WEBPACK_IMPORTED_MODULE_2__.StaveConnector(stave1, stave2).setType('single').setContext(ctx).draw();
    new _src_staveconnector__WEBPACK_IMPORTED_MODULE_2__.StaveConnector(stave2, stave3).setType('single').setContext(ctx).draw();
    new _src_staveconnector__WEBPACK_IMPORTED_MODULE_2__.StaveConnector(stave2, stave3).setType('brace').setContext(ctx).draw();
    options.assert.ok(true, 'all pass');
}
function change(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 900);
    const stave = f.Stave({ x: 0, y: 0 }).addClef('treble').addTimeSignature('C|');
    const tickables = [
        f.StaveNote({ keys: ['c/4'], duration: '4', clef: 'treble' }),
        f.TimeSigNote({ time: '3/4' }),
        f.StaveNote({ keys: ['d/4'], duration: '4', clef: 'alto' }),
        f.StaveNote({ keys: ['b/3'], duration: '4r', clef: 'alto' }),
        f.TimeSigNote({ time: 'C' }),
        f.StaveNote({ keys: ['c/3', 'e/3', 'g/3'], duration: '4', clef: 'bass' }),
        f.TimeSigNote({ time: '9/8' }),
        f.StaveNote({ keys: ['c/4'], duration: '4', clef: 'treble' }),
    ];
    const voice = f.Voice().setStrict(false).addTickables(tickables);
    f.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'all pass');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(TimeSignatureTests);



/***/ }),

/***/ "./tests/tremolo_tests.ts":
/*!********************************!*\
  !*** ./tests/tremolo_tests.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TremoloTests: () => (/* binding */ TremoloTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_stavebarline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/stavebarline */ "./src/stavebarline.ts");
/* harmony import */ var _src_tremolo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/tremolo */ "./src/tremolo.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Tremolo Tests



const TremoloTests = {
    Start() {
        QUnit.module('Tremolo');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Tremolo - Basic', tremoloBasic);
    },
};
function tremoloBasic(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600, 200);
    const score = f.EasyScore();
    // bar 1
    const stave1 = f.Stave({ width: 250 }).setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_1__.Barline.type.DOUBLE);
    const notes1 = score.notes('e4/4, e4, e4, e4', { stem: 'up' });
    notes1[0].addModifier(new _src_tremolo__WEBPACK_IMPORTED_MODULE_2__.Tremolo(3), 0);
    notes1[1].addModifier(new _src_tremolo__WEBPACK_IMPORTED_MODULE_2__.Tremolo(2), 0);
    notes1[2].addModifier(new _src_tremolo__WEBPACK_IMPORTED_MODULE_2__.Tremolo(1), 0);
    const voice1 = score.voice(notes1);
    f.Formatter().joinVoices([voice1]).formatToStave([voice1], stave1);
    // bar 2
    const stave2 = f
        .Stave({ x: stave1.getWidth() + stave1.getX(), y: stave1.getY(), width: 300 })
        .setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_1__.Barline.type.DOUBLE);
    const notes2 = score.notes('e5/4, e5, e5, e5', { stem: 'down' });
    notes2[1].addModifier(new _src_tremolo__WEBPACK_IMPORTED_MODULE_2__.Tremolo(1), 0);
    notes2[2].addModifier(new _src_tremolo__WEBPACK_IMPORTED_MODULE_2__.Tremolo(2), 0);
    notes2[3].addModifier(new _src_tremolo__WEBPACK_IMPORTED_MODULE_2__.Tremolo(3), 0);
    const voice2 = score.voice(notes2);
    f.Formatter().joinVoices([voice2]).formatToStave([voice2], stave2);
    f.draw();
    options.assert.ok(true, 'Tremolo - Basic');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(TremoloTests);



/***/ }),

/***/ "./tests/tuning_tests.ts":
/*!*******************************!*\
  !*** ./tests/tuning_tests.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TuningTests: () => (/* binding */ TuningTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_tuning__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/tuning */ "./src/tuning.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Tuning Tests


const TuningTests = {
    Start() {
        QUnit.module('Tuning');
        QUnit.test('Standard Tuning', standard);
        QUnit.test('Standard Banjo Tuning', banjo);
        QUnit.test('Return note for fret', noteForFret);
    },
};
/**
 * Helper function to verify that the provided tuning matches a standard 6-string guitar.
 */
function checkStandard(assert, tuning) {
    assert.throws(() => tuning.getValueForString(0), /BadArguments/, 'String 0');
    assert.throws(() => tuning.getValueForString(9), /BadArguments/, 'String 9');
    // TODO: Tuning constructor has a bug in that the default tuning has 8 strings.
    // See: 'E/5,B/4,G/4,D/4,A/3,E/3,B/2,E/2' in tuning.ts constructor.
    // assert.throws(() => tuning.getValueForString(7), /BadArguments/, 'String 7');
    // Tuning.getValueForString() returns a note number where the value 60 corresponds to middle C.
    assert.equal(tuning.getValueForString(6), 40, 'Low E string');
    assert.equal(tuning.getValueForString(5), 45, 'A string');
    assert.equal(tuning.getValueForString(4), 50, 'D string');
    assert.equal(tuning.getValueForString(3), 55, 'G string');
    assert.equal(tuning.getValueForString(2), 59, 'B string');
    assert.equal(tuning.getValueForString(1), 64, 'High E string');
}
/**
 * Helper function to verify that the provided tuning matches a standard 5-string banjo.
 */
function checkStandardBanjo(assert, tuning) {
    assert.throws(() => tuning.getValueForString(0), /BadArguments/, 'String 0');
    assert.throws(() => tuning.getValueForString(6), /BadArguments/, 'String 6');
    assert.equal(tuning.getValueForString(5), 67, 'High G string');
    assert.equal(tuning.getValueForString(4), 50, 'D string');
    assert.equal(tuning.getValueForString(3), 55, 'G string');
    assert.equal(tuning.getValueForString(2), 59, 'B string');
    assert.equal(tuning.getValueForString(1), 62, 'High D string');
}
function standard(assert) {
    assert.expect(16);
    const tuning = new _src_tuning__WEBPACK_IMPORTED_MODULE_1__.Tuning();
    checkStandard(assert, tuning);
    // Set the tuning by specifying a name: 'standard'.
    tuning.setTuning('standard');
    checkStandard(assert, tuning);
}
function banjo(assert) {
    assert.expect(7);
    const tuning = new _src_tuning__WEBPACK_IMPORTED_MODULE_1__.Tuning();
    tuning.setTuning('standardBanjo');
    checkStandardBanjo(assert, tuning);
}
function noteForFret(assert) {
    assert.expect(8);
    const tuning = new _src_tuning__WEBPACK_IMPORTED_MODULE_1__.Tuning('E/5,B/4,G/4,D/4,A/3,E/3');
    assert.throws(() => tuning.getNoteForFret(-1, 1), /BadArguments/, 'Fret = -1');
    assert.throws(() => tuning.getNoteForFret(1, -1), /BadArguments/, 'String = -1');
    assert.equal(tuning.getNoteForFret(0, 1), 'E/5', 'High E string');
    assert.equal(tuning.getNoteForFret(5, 1), 'A/5', 'High E string, fret 5');
    assert.equal(tuning.getNoteForFret(0, 2), 'B/4', 'B string');
    assert.equal(tuning.getNoteForFret(0, 3), 'G/4', 'G string');
    assert.equal(tuning.getNoteForFret(12, 2), 'B/5', 'B string, fret 12');
    assert.equal(tuning.getNoteForFret(0, 6), 'E/3', 'Low E string');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(TuningTests);



/***/ }),

/***/ "./tests/tuplet_tests.ts":
/*!*******************************!*\
  !*** ./tests/tuplet_tests.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TupletTests: () => (/* binding */ TupletTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_dot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/dot */ "./src/dot.ts");
/* harmony import */ var _src_formatter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/formatter */ "./src/formatter.ts");
/* harmony import */ var _src_stem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/stem */ "./src/stem.ts");
/* harmony import */ var _src_tuplet__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/tuplet */ "./src/tuplet.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Tuplet Tests





const TupletTests = {
    Start() {
        QUnit.module('Tuplet');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Simple Tuplet', simple);
        run('Beamed Tuplet', beamed);
        run('Ratioed Tuplet', ratio);
        run('Bottom Tuplet', bottom);
        run('Bottom Ratioed Tuplet', bottomRatio);
        run('Awkward Tuplet', awkward);
        run('Complex Tuplet', complex);
        run('Mixed Stem Direction Tuplet', mixedTop);
        run('Mixed Stem Direction Bottom Tuplet', mixedBottom);
        run('Nested Tuplets', nested);
        run('Single Tuplets', single);
    },
};
// Helper Functions to set the stem direction and duration of the options objects (i.e., StaveNoteStruct)
// that are ultimately passed into Factory.StaveNote().
// eslint-disable-next-line
const set = (key) => (value) => (object) => {
    object[key] = value;
    return object;
};
const setStemDirection = set('stemDirection');
const setStemUp = setStemDirection(_src_stem__WEBPACK_IMPORTED_MODULE_3__.Stem.UP);
const setStemDown = setStemDirection(_src_stem__WEBPACK_IMPORTED_MODULE_3__.Stem.DOWN);
const setDurationToQuarterNote = set('duration')('4');
/**
 * Simple test case with one ascending triplet and one descending triplet.
 */
function simple(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave({ x: 10, y: 10, width: 350 }).addTimeSignature('3/4');
    const notes = [
        { keys: ['g/4'], duration: '4' },
        { keys: ['a/4'], duration: '4' },
        { keys: ['b/4'], duration: '4' },
        { keys: ['b/4'], duration: '8' },
        { keys: ['a/4'], duration: '8' },
        { keys: ['g/4'], duration: '8' },
    ]
        .map(setStemUp)
        .map(f.StaveNote.bind(f));
    f.Tuplet({ notes: notes.slice(0, 3) });
    f.Tuplet({ notes: notes.slice(3, 6) });
    // 3/4 time
    const voice = f
        .Voice({ time: { numBeats: 3, beatValue: 4 } })
        .setStrict(true)
        .addTickables(notes);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_2__.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'Simple Test');
}
function beamed(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave({ x: 10, y: 10, width: 350 }).addTimeSignature('3/8');
    const notes = [
        { keys: ['b/4'], duration: '16' },
        { keys: ['a/4'], duration: '16' },
        { keys: ['g/4'], duration: '16' },
        { keys: ['a/4'], duration: '8' },
        { keys: ['f/4'], duration: '8' },
        { keys: ['a/4'], duration: '8' },
        { keys: ['f/4'], duration: '8' },
        { keys: ['a/4'], duration: '8' },
        { keys: ['f/4'], duration: '8' },
        { keys: ['g/4'], duration: '8' },
    ]
        .map(setStemUp)
        .map(f.StaveNote.bind(f));
    f.Beam({ notes: notes.slice(0, 3) });
    f.Beam({ notes: notes.slice(3, 10) });
    f.Tuplet({ notes: notes.slice(0, 3) });
    f.Tuplet({ notes: notes.slice(3, 10) });
    // 3/8 time
    const voice = f
        .Voice({ time: { numBeats: 3, beatValue: 8 } })
        .setStrict(true)
        .addTickables(notes);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_2__.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'Beamed Test');
}
function ratio(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave({ x: 10, y: 10, width: 350 }).addTimeSignature('4/4');
    const notes = [
        { keys: ['f/4'], duration: '4' },
        { keys: ['a/4'], duration: '4' },
        { keys: ['b/4'], duration: '4' },
        { keys: ['g/4'], duration: '8' },
        { keys: ['e/4'], duration: '8' },
        { keys: ['g/4'], duration: '8' },
    ]
        .map(setStemUp)
        .map(f.StaveNote.bind(f));
    f.Beam({
        notes: notes.slice(3, 6),
    });
    f.Tuplet({
        notes: notes.slice(0, 3),
        options: {
            ratioed: true,
        },
    });
    f.Tuplet({
        notes: notes.slice(3, 6),
        options: {
            ratioed: true,
            notesOccupied: 4,
        },
    });
    const voice = f.Voice().setStrict(true).addTickables(notes);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_2__.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'Ratioed Test');
}
function bottom(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 350, 160);
    const stave = f.Stave({ x: 10, y: 10 }).addTimeSignature('3/4');
    const notes = [
        { keys: ['f/4'], duration: '4' },
        { keys: ['c/4'], duration: '4' },
        { keys: ['g/4'], duration: '4' },
        { keys: ['d/5'], duration: '8' },
        { keys: ['g/3'], duration: '8' },
        { keys: ['b/4'], duration: '8' },
    ]
        .map(setStemDown)
        .map(f.StaveNote.bind(f));
    f.Beam({
        notes: notes.slice(3, 6),
    });
    f.Tuplet({
        notes: notes.slice(0, 3),
        options: { location: _src_tuplet__WEBPACK_IMPORTED_MODULE_4__.Tuplet.LOCATION_BOTTOM },
    });
    f.Tuplet({
        notes: notes.slice(3, 6),
        options: { location: _src_tuplet__WEBPACK_IMPORTED_MODULE_4__.Tuplet.LOCATION_BOTTOM },
    });
    const voice = f
        .Voice({ time: { numBeats: 3, beatValue: 4 } })
        .setStrict(true)
        .addTickables(notes);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_2__.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'Bottom Test');
}
function bottomRatio(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 350, 160);
    const stave = f.Stave({ x: 10, y: 10 }).addTimeSignature('5/8');
    const notes = [
        { keys: ['f/4'], duration: '4' },
        { keys: ['c/4'], duration: '4' },
        { keys: ['d/4'], duration: '4' },
        { keys: ['d/5'], duration: '8' },
        { keys: ['g/5'], duration: '8' },
        { keys: ['b/4'], duration: '8' },
    ]
        .map(setStemDown)
        .map(f.StaveNote.bind(f));
    f.Beam({
        notes: notes.slice(3, 6),
    });
    f.Tuplet({
        notes: notes.slice(0, 3),
        options: {
            location: _src_tuplet__WEBPACK_IMPORTED_MODULE_4__.Tuplet.LOCATION_BOTTOM,
            ratioed: true,
        },
    });
    f.Tuplet({
        notes: notes.slice(3, 6),
        options: {
            location: _src_tuplet__WEBPACK_IMPORTED_MODULE_4__.Tuplet.LOCATION_BOTTOM,
            notesOccupied: 1,
        },
    });
    const voice = f
        .Voice({ time: { numBeats: 5, beatValue: 8 } })
        .setStrict(true)
        .addTickables(notes);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_2__.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'Bottom Ratioed Test');
}
function awkward(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 370, 160);
    const stave = f.Stave({ x: 10, y: 10 });
    const notes = [
        { keys: ['g/4'], duration: '16' },
        { keys: ['b/4'], duration: '16' },
        { keys: ['a/4'], duration: '16' },
        { keys: ['a/4'], duration: '16' },
        { keys: ['g/4'], duration: '16' },
        { keys: ['f/4'], duration: '16' },
        { keys: ['e/4'], duration: '16' },
        { keys: ['c/4'], duration: '16' },
        { keys: ['g/4'], duration: '16' },
        { keys: ['a/4'], duration: '16' },
        { keys: ['f/4'], duration: '16' },
        { keys: ['e/4'], duration: '16' },
        { keys: ['c/4'], duration: '8' },
        { keys: ['d/4'], duration: '8' },
        { keys: ['e/4'], duration: '8' },
    ]
        .map(setStemUp)
        .map(f.StaveNote.bind(f));
    f.Beam({ notes: notes.slice(0, 12) });
    f.Tuplet({
        notes: notes.slice(0, 12),
        options: {
            notesOccupied: 142,
            ratioed: true,
        },
    });
    f.Tuplet({
        notes: notes.slice(12, 15),
        options: {
            ratioed: true,
        },
    }).setBracketed(true);
    const voice = f.Voice().setStrict(false).addTickables(notes);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_2__.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'Awkward Test');
}
function complex(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 600);
    const stave = f.Stave({ x: 10, y: 10 }).addTimeSignature('4/4');
    const notes1 = [
        { keys: ['b/4'], duration: '8d' },
        { keys: ['a/4'], duration: '16' },
        { keys: ['g/4'], duration: '8' },
        { keys: ['a/4'], duration: '16' },
        { keys: ['b/4'], duration: '16r' },
        { keys: ['g/4'], duration: '32' },
        { keys: ['f/4'], duration: '32' },
        { keys: ['g/4'], duration: '32' },
        { keys: ['f/4'], duration: '32' },
        { keys: ['a/4'], duration: '16' },
        { keys: ['f/4'], duration: '8' },
        { keys: ['b/4'], duration: '8' },
        { keys: ['a/4'], duration: '8' },
        { keys: ['g/4'], duration: '8' },
        { keys: ['b/4'], duration: '8' },
        { keys: ['a/4'], duration: '8' },
    ]
        .map(setStemUp)
        .map(f.StaveNote.bind(f));
    _src_dot__WEBPACK_IMPORTED_MODULE_1__.Dot.buildAndAttach([notes1[0]], { all: true });
    const notes2 = [{ keys: ['c/4'] }, { keys: ['c/4'] }, { keys: ['c/4'] }, { keys: ['c/4'] }]
        .map(setDurationToQuarterNote)
        .map(setStemDown)
        .map(f.StaveNote.bind(f));
    f.Beam({ notes: notes1.slice(0, 3) });
    f.Beam({ notes: notes1.slice(5, 9) });
    f.Beam({ notes: notes1.slice(11, 16) });
    f.Tuplet({
        notes: notes1.slice(0, 3),
    });
    f.Tuplet({
        notes: notes1.slice(3, 11),
        options: {
            numNotes: 7,
            notesOccupied: 4,
            ratioed: false,
        },
    });
    f.Tuplet({
        notes: notes1.slice(11, 16),
        options: {
            notesOccupied: 4,
        },
    });
    const voice1 = f.Voice().setStrict(true).addTickables(notes1);
    const voice2 = f.Voice().setStrict(true).addTickables(notes2);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_2__.Formatter().joinVoices([voice1, voice2]).formatToStave([voice1, voice2], stave);
    f.draw();
    options.assert.ok(true, 'Complex Test');
}
function mixedTop(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave({ x: 10, y: 10 });
    const notes = [
        { keys: ['a/4'], stemDirection: 1 },
        { keys: ['c/6'], stemDirection: -1 },
        { keys: ['a/4'], stemDirection: 1 },
        { keys: ['f/5'], stemDirection: 1 },
        { keys: ['a/4'], stemDirection: -1 },
        { keys: ['c/6'], stemDirection: -1 },
    ]
        .map(setDurationToQuarterNote)
        .map(f.StaveNote.bind(f));
    f.Tuplet({
        notes: notes.slice(0, 2),
        options: {
            notesOccupied: 3,
        },
    });
    f.Tuplet({
        notes: notes.slice(2, 4),
        options: {
            notesOccupied: 3,
        },
    });
    f.Tuplet({
        notes: notes.slice(4, 6),
        options: {
            notesOccupied: 3,
        },
    });
    const voice = f.Voice().setStrict(false).addTickables(notes);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_2__.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'Mixed Stem Direction Tuplet');
}
function mixedBottom(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave({ x: 10, y: 10 });
    const notes = [
        { keys: ['f/3'], stemDirection: 1 },
        { keys: ['a/5'], stemDirection: -1 },
        { keys: ['a/4'], stemDirection: 1 },
        { keys: ['f/3'], stemDirection: 1 },
        { keys: ['a/4'], stemDirection: -1 },
        { keys: ['c/4'], stemDirection: -1 },
    ]
        .map(setDurationToQuarterNote)
        .map(f.StaveNote.bind(f));
    f.Tuplet({
        notes: notes.slice(0, 2),
        options: {
            notesOccupied: 3,
        },
    });
    f.Tuplet({
        notes: notes.slice(2, 4),
        options: {
            notesOccupied: 3,
        },
    });
    f.Tuplet({
        notes: notes.slice(4, 6),
        options: {
            notesOccupied: 3,
        },
    });
    const voice = f.Voice().setStrict(false).addTickables(notes);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_2__.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'Mixed Stem Direction Bottom Tuplet');
}
function nested(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave({ x: 10, y: 10 }).addTimeSignature('4/4');
    const notes = [
        // Big triplet 1:
        { keys: ['b/4'], duration: '4' },
        { keys: ['a/4'], duration: '4' },
        { keys: ['g/4'], duration: '16' },
        { keys: ['a/4'], duration: '16' },
        { keys: ['f/4'], duration: '16' },
        { keys: ['a/4'], duration: '16' },
        { keys: ['g/4'], duration: '16' },
        { keys: ['b/4'], duration: '2' },
    ]
        .map(setStemUp)
        .map(f.StaveNote.bind(f));
    f.Beam({
        notes: notes.slice(2, 7),
    });
    f.Tuplet({
        notes: notes.slice(0, 7),
        options: {
            notesOccupied: 2,
            numNotes: 3,
        },
    });
    f.Tuplet({
        notes: notes.slice(2, 7),
        options: {
            notesOccupied: 4,
            numNotes: 5,
        },
    });
    // 4/4 time
    const voice = f.Voice().setStrict(true).addTickables(notes);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_2__.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'Nested Tuplets');
}
function single(options) {
    const f = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options);
    const stave = f.Stave({ x: 10, y: 10 }).addTimeSignature('4/4');
    const notes = [
        // Big triplet 1:
        { keys: ['c/4'], duration: '4' },
        { keys: ['d/4'], duration: '8' },
        { keys: ['e/4'], duration: '8' },
        { keys: ['f/4'], duration: '8' },
        { keys: ['g/4'], duration: '8' },
        { keys: ['a/4'], duration: '2' },
        { keys: ['b/4'], duration: '4' },
    ]
        .map(setStemUp)
        .map(f.StaveNote.bind(f));
    f.Beam({
        notes: notes.slice(1, 4),
    });
    // big quartuplet
    f.Tuplet({
        notes: notes.slice(0, -1),
        options: {
            numNotes: 4,
            notesOccupied: 3,
            ratioed: true,
            bracketed: true,
        },
    });
    // first singleton
    f.Tuplet({
        notes: notes.slice(0, 1),
        options: {
            numNotes: 3,
            notesOccupied: 2,
            ratioed: true,
        },
    });
    // eighth note triplet
    f.Tuplet({
        notes: notes.slice(1, 4),
        options: {
            numNotes: 3,
            notesOccupied: 2,
        },
    });
    // second singleton
    f.Tuplet({
        notes: notes.slice(4, 5),
        options: {
            numNotes: 3,
            notesOccupied: 2,
            ratioed: true,
            bracketed: true,
        },
    });
    // 4/4 time
    const voice = f
        .Voice({ time: { numBeats: 4, beatValue: 4 } })
        .setStrict(true)
        .addTickables(notes);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_2__.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    f.draw();
    options.assert.ok(true, 'Nested Tuplets');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(TupletTests);



/***/ }),

/***/ "./tests/typeguard_tests.ts":
/*!**********************************!*\
  !*** ./tests/typeguard_tests.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TypeGuardTests: () => (/* binding */ TypeGuardTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_canvascontext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/canvascontext */ "./src/canvascontext.ts");
/* harmony import */ var _src_stavenote__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/stavenote */ "./src/stavenote.ts");
/* harmony import */ var _src_stemmablenote__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/stemmablenote */ "./src/stemmablenote.ts");
/* harmony import */ var _src_tabnote__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/tabnote */ "./src/tabnote.ts");
/* harmony import */ var _src_typeguard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/typeguard */ "./src/typeguard.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// @author Ron B. Yeh
// MIT License
//
// TypeGuard Tests
// eslint-disable-next-line
// @ts-nocheck to support ES5 style class declaration in the fakeES5() test case.






const TypeGuardTests = {
    Start() {
        QUnit.module('TypeGuard');
        QUnit.test('Real VexFlow Types', real);
        QUnit.test('Fake VexFlow Types in ES5', fakeES5);
        QUnit.test('Fake VexFlow Types in ES6', fakeES6);
        QUnit.test('Edge Case ES5/ES6', edgeCaseES5vsES6);
    },
};
function real(assert) {
    const s = new _src_stavenote__WEBPACK_IMPORTED_MODULE_2__.StaveNote({ keys: ['c/4'], duration: 'w' });
    assert.ok((0,_src_typeguard__WEBPACK_IMPORTED_MODULE_5__.isStaveNote)(s), 'isStaveNote helper function');
    assert.ok((0,_src_typeguard__WEBPACK_IMPORTED_MODULE_5__.isCategory)(s, 'StaveNote'), 'Use isCategory(s, "StaveNote") directly');
    assert.notOk((0,_src_typeguard__WEBPACK_IMPORTED_MODULE_5__.isTabNote)(s), 'isTabNote helper function. s is NOT a TabNote.');
    const t = new _src_tabnote__WEBPACK_IMPORTED_MODULE_4__.TabNote({ positions: [{ str: 2, fret: 1 }], duration: '1' });
    assert.ok((0,_src_typeguard__WEBPACK_IMPORTED_MODULE_5__.isTabNote)(t), 'isTabNote helper function');
    assert.notOk((0,_src_typeguard__WEBPACK_IMPORTED_MODULE_5__.isStaveNote)(t), 't is NOT a StaveNote');
    assert.ok((0,_src_typeguard__WEBPACK_IMPORTED_MODULE_5__.isNote)(s), 'StaveNote extends StemmableNote which extends Note, so s is a Note');
    assert.ok((0,_src_typeguard__WEBPACK_IMPORTED_MODULE_5__.isStemmableNote)(t), 'TabNote extends StemmableNote');
    assert.ok((0,_src_typeguard__WEBPACK_IMPORTED_MODULE_5__.isNote)(t), 'TabNote extends StemmableNote which extends Note, so t is a Note');
    const canvas = document.createElement('canvas');
    canvas.width = 800;
    canvas.height = 400;
    const ctx = new _src_canvascontext__WEBPACK_IMPORTED_MODULE_1__.CanvasContext(canvas.getContext('2d'));
    assert.ok((0,_src_typeguard__WEBPACK_IMPORTED_MODULE_5__.isRenderContext)(ctx), 'ctx is a RenderContext');
}
/**
 * Helper function to test the fake VexFlow objects we create in fakeES5() and fakeES6().
 */
function checkFakeObjects(assert, fakeStemmableNote, fakeStaveNote) {
    assert.ok((0,_src_typeguard__WEBPACK_IMPORTED_MODULE_5__.isStemmableNote)(fakeStemmableNote), 'Fake StemmableNote is a StemmableNote.');
    assert.notOk((0,_src_typeguard__WEBPACK_IMPORTED_MODULE_5__.isNote)(fakeStemmableNote), 'Fake StemmableNote is not a Note (no ancestors with the correct CATEGORY).');
    assert.ok((0,_src_typeguard__WEBPACK_IMPORTED_MODULE_5__.isCategory)(fakeStaveNote, 'StaveNote'), 'Fake StaveNote is a StaveNote.');
    assert.ok((0,_src_typeguard__WEBPACK_IMPORTED_MODULE_5__.isStaveNote)(fakeStaveNote), 'Fake StaveNote is a StaveNote (via helper function).');
    assert.ok((0,_src_typeguard__WEBPACK_IMPORTED_MODULE_5__.isCategory)(fakeStaveNote, 'StemmableNote'), 'Fake StaveNote is also a StemmableNote (via inheritance).');
    assert.notOk((0,_src_typeguard__WEBPACK_IMPORTED_MODULE_5__.isNote)(fakeStaveNote), 'Fake StaveNote is not a Note. CATEGORY does not match.');
}
/**
 * Demonstrate that an object (ES5-style) can pass the isCategory(...) test if it
 * has the correct static .CATEGORY property.
 */
function fakeES5(assert) {
    function FakeStemmableNote() {
        this.isFake = true;
    }
    FakeStemmableNote.CATEGORY = _src_stemmablenote__WEBPACK_IMPORTED_MODULE_3__.StemmableNote.CATEGORY;
    function FakeStaveNote() {
        FakeStemmableNote.call(this);
    }
    FakeStaveNote.CATEGORY = _src_stavenote__WEBPACK_IMPORTED_MODULE_2__.StaveNote.CATEGORY;
    FakeStaveNote.prototype = Object.create(FakeStemmableNote.prototype);
    FakeStaveNote.prototype.constructor = FakeStaveNote;
    const fakeStemmableNote = new FakeStemmableNote();
    const fakeStaveNote = new FakeStaveNote();
    checkFakeObjects(assert, fakeStemmableNote, fakeStaveNote);
}
/**
 * Demonstrate that an object (ES6-style) can pass the isCategory(...) test if it
 * or its ancestor has the correct static .CATEGORY property.
 */
function fakeES6(assert) {
    class FakeStemmableNote {
    }
    FakeStemmableNote.CATEGORY = _src_stemmablenote__WEBPACK_IMPORTED_MODULE_3__.StemmableNote.CATEGORY;
    class FakeStaveNote extends FakeStemmableNote {
    }
    FakeStaveNote.CATEGORY = _src_stavenote__WEBPACK_IMPORTED_MODULE_2__.StaveNote.CATEGORY;
    const fakeStemmableNote = new FakeStemmableNote();
    const fakeStaveNote = new FakeStaveNote();
    checkFakeObjects(assert, fakeStemmableNote, fakeStaveNote);
}
/**
 * The tsconfig.json target is ES6 (as of August 18, 2021), so isCategory() works even when the root class "extends Object".
 */
function edgeCaseES5vsES6(assert) {
    class Z extends Object {
    }
    class Y extends Z {
    }
    class X extends Y {
    }
    const zInstance = new Z();
    const xInstance = new X();
    assert.ok(xInstance instanceof Object, 'es5 & es6: x IS an instanceof Object');
    // If targeting es5, these three assertions only pass if we remove "extends Object" from the class Z definition.
    assert.ok(zInstance instanceof Z, 'es6: z IS an instanceof Z');
    assert.ok(xInstance instanceof Y, 'es6: x IS an instanceof Y');
    assert.ok(xInstance instanceof Z, 'es6: x IS an instanceof Z');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(TypeGuardTests);



/***/ }),

/***/ "./tests/unison_tests.ts":
/*!*******************************!*\
  !*** ./tests/unison_tests.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UnisonTests: () => (/* binding */ UnisonTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_flow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/flow */ "./src/flow.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Unison Tests


const UnisonTests = {
    Start() {
        QUnit.module('Unison');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Simple(true)', simple, { unison: true, voice1: 'e4/q, e4/q, e4/h', voice2: 'e4/8, e4/8, e4/q, e4/h' });
        run('Simple(false)', simple, { unison: false, voice1: 'e4/q, e4/q, e4/h', voice2: 'e4/8, e4/8, e4/q, e4/h' });
        run('Accidentals(true)', simple, {
            unison: true,
            voice1: 'e4/q, e#4/q, e#4/h',
            voice2: 'e4/8, e4/8, eb4/q, eb4/h',
        });
        run('Accidentals(false)', simple, {
            unison: false,
            voice1: 'e4/q, e#4/q, e#4/h',
            voice2: 'e4/8, e4/8, eb4/q, eb4/h',
        });
        run('Dots(true)', simple, { unison: true, voice1: 'e4/q.., e4/16, e4/h', voice2: '(a4 e4)/q., e4/8, e4/h' });
        run('Dots(false)', simple, { unison: false, voice1: 'e4/q.., e4/16, e4/h', voice2: '(a4 e4)/q., e4/8, e4/h' });
        run('Breve(true)', breve, { unison: true });
        run('Breve(false)', breve, { unison: false });
        run('Style(true)', style, { unison: true });
        run('Style(false)', style, { unison: false });
    },
};
function simple(options) {
    _src_flow__WEBPACK_IMPORTED_MODULE_1__.Flow.UNISON = options.params.unison;
    const vf = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 500, 200);
    const score = vf.EasyScore();
    const system = vf.System({ y: 40, x: 10, width: 400 });
    system.addStave({
        voices: [score.voice(score.notes(options.params.voice1)), score.voice(score.notes(options.params.voice2))],
    });
    system.getStaves()[0].setClef('treble');
    system.getStaves()[0].setTimeSignature('4/4');
    vf.draw();
    options.assert.expect(0);
}
function style(options) {
    _src_flow__WEBPACK_IMPORTED_MODULE_1__.Flow.UNISON = options.params.unison;
    const vf = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 500, 200);
    const score = vf.EasyScore();
    const system = vf.System({ y: 40, x: 10, width: 400 });
    const notes1 = score.notes('e4/q, e4/q, e4/h');
    const notes2 = score.notes('e4/8, e4/8, e4/q, e4/h');
    notes1[2].setStyle({ fillStyle: 'blue', strokeStyle: 'blue' });
    notes2[3].setStyle({ fillStyle: 'green', strokeStyle: 'green' });
    system.addStave({
        voices: [score.voice(notes1), score.voice(notes2)],
    });
    system.getStaves()[0].setClef('treble');
    system.getStaves()[0].setTimeSignature('4/4');
    vf.draw();
    options.assert.expect(0);
}
function breve(options) {
    _src_flow__WEBPACK_IMPORTED_MODULE_1__.Flow.UNISON = options.params.unison;
    const vf = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 500, 200);
    const score = vf.EasyScore();
    const system = vf.System({ y: 40, x: 10, width: 400 });
    system.addStave({
        voices: [
            score.voice([vf.StaveNote({ keys: ['e/4'], duration: '1/2' })], { time: '8/4' }),
            score.voice(score.notes('e4/1, e4/1'), { time: '8/4' }),
        ],
    });
    system.getStaves()[0].setClef('treble');
    system.getStaves()[0].setTimeSignature('8/4');
    vf.draw();
    options.assert.expect(0);
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(UnisonTests);



/***/ }),

/***/ "./tests/vexflow_test_helpers.ts":
/*!***************************************!*\
  !*** ./tests/vexflow_test_helpers.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MAJOR_KEYS: () => (/* binding */ MAJOR_KEYS),
/* harmony export */   MINOR_KEYS: () => (/* binding */ MINOR_KEYS),
/* harmony export */   VexFlowTests: () => (/* binding */ VexFlowTests),
/* harmony export */   concat: () => (/* binding */ concat)
/* harmony export */ });
/* harmony import */ var _src_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/index */ "./src/index.ts");
/* harmony import */ var _src_metrics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/metrics */ "./src/metrics.ts");
/* harmony import */ var _src_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/util */ "./src/util.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// VexFlow Test Support Library
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _a, _VexFlowTests_NEXT_TEST_ID;



const global = (0,_src_util__WEBPACK_IMPORTED_MODULE_2__.globalObject)();
// Each test case will switch through the available fonts, and then restore the original font when done.
let originalFontNames;
function useTempFontStack(fontName) {
    originalFontNames = _src_index__WEBPACK_IMPORTED_MODULE_0__.Flow.getMusicFont();
    _src_index__WEBPACK_IMPORTED_MODULE_0__.Flow.setMusicFont(...VexFlowTests.FONT_STACKS[fontName]);
}
function restoreOriginalFontStack() {
    _src_index__WEBPACK_IMPORTED_MODULE_0__.Flow.setMusicFont(...originalFontNames);
}
// A micro util inspired by jQuery.
if (!global.$) {
    // generate_png_images.js uses jsdom and does not include jQuery.
    global.$ = (param) => {
        let element;
        if (typeof param !== 'string') {
            element = param;
        }
        else if (param.startsWith('<')) {
            // Extract the tag name: e.g., <div/> => div
            // Assume param.match returns something (! operator).
            // eslint-disable-next-line
            const tagName = param.match(/[A-Za-z]+/g)[0];
            element = document.createElement(tagName);
        }
        else {
            element = document.querySelector(param);
        }
        const $element = {
            // eslint-disable-next-line
            get(index) {
                return element;
            },
            addClass(c) {
                element.classList.add(c);
                return $element;
            },
            text(t) {
                element.textContent = t;
                return $element;
            },
            html(h) {
                if (!h) {
                    return element.innerHTML;
                }
                else {
                    element.innerHTML = h;
                    return $element;
                }
            },
            append(...elementsToAppend) {
                elementsToAppend.forEach((e) => {
                    element.appendChild(e);
                });
                return $element;
            },
            attr(attrName, val) {
                element.setAttribute(attrName, val);
                return $element;
            },
        };
        return $element;
    };
}
/** Allow `name` to be used inside file names. */
function sanitizeName(name) {
    return name.replace(/[^a-zA-Z0-9]/g, '_');
}
const CANVAS_TEST_CONFIG = {
    backend: _src_index__WEBPACK_IMPORTED_MODULE_0__.Renderer.Backends.CANVAS,
    tagName: 'canvas',
    testType: 'Canvas',
    fontStacks: ['Bravura'],
};
const CANVAS_TEXT_CONFIG = {
    backend: _src_index__WEBPACK_IMPORTED_MODULE_0__.Renderer.Backends.CANVAS,
    tagName: 'canvas',
    testType: 'Canvas',
    fontStacks: ['Bravura'],
};
const SVG_TEST_CONFIG = {
    backend: _src_index__WEBPACK_IMPORTED_MODULE_0__.Renderer.Backends.SVG,
    tagName: 'div',
    testType: 'SVG',
    fontStacks: [
        'Bravura',
        'Finale Ash',
        'Finale Broadway',
        'Finale Maestro',
        'Gonville',
        'Gootville',
        'Leland',
        'MuseJazz',
        'Petaluma',
    ],
};
const SVG_TEXT_CONFIG = {
    backend: _src_index__WEBPACK_IMPORTED_MODULE_0__.Renderer.Backends.SVG,
    tagName: 'div',
    testType: 'SVG',
    fontStacks: ['Bravura'],
};
const NODE_TEST_CONFIG = {
    backend: _src_index__WEBPACK_IMPORTED_MODULE_0__.Renderer.Backends.CANVAS,
    tagName: 'canvas',
    testType: 'NodeCanvas',
    fontStacks: ['Bravura', 'Gonville', 'Petaluma', 'Leland'],
};
class VexFlowTests {
    // Call this at the end of a `tests/xxxx_tests.ts` file to register the module.
    static register(test) {
        VexFlowTests.tests.push(test);
    }
    static parseJobOptions(runOptions) {
        let { jobs, job } = runOptions || { jobs: 1, job: 0 };
        if (window) {
            const { location } = window;
            if (location) {
                const sps = new URLSearchParams(location.search);
                const jobsParam = sps.get('jobs');
                const jobParam = sps.get('job');
                if (jobsParam) {
                    jobs = parseInt(jobsParam, 10);
                }
                if (jobParam) {
                    job = parseInt(jobParam, 10);
                }
            }
        }
        return {
            jobs,
            job,
        };
    }
    // flow.html calls this to invoke all the tests.
    static run(runOptions) {
        const { jobs, job } = VexFlowTests.parseJobOptions(runOptions);
        VexFlowTests.tests.forEach((test, idx) => {
            if (jobs === 1 || idx % jobs === job) {
                test.Start();
            }
        });
    }
    static set NODE_FONT_STACKS(fontStacks) {
        NODE_TEST_CONFIG.fontStacks = fontStacks;
    }
    /** Return a unique ID for a test. */
    static generateTestID(prefix) {
        var _b, _c, _d;
        return prefix + '_' + (__classPrivateFieldSet(_b = VexFlowTests, _a, (_d = __classPrivateFieldGet(_b, _a, "f", _VexFlowTests_NEXT_TEST_ID), _c = _d++, _d), "f", _VexFlowTests_NEXT_TEST_ID), _c);
    }
    /**
     * Run `func` inside a QUnit test for each of the enabled rendering backends.
     * @param name
     * @param testFunc
     * @param params
     */
    // eslint-disable-next-line
    static runTests(name, testFunc, params) {
        VexFlowTests.runCanvasTest(name, testFunc, params);
        VexFlowTests.runSVGTest(name, testFunc, params);
        VexFlowTests.runNodeTest(name, testFunc, params);
    }
    // eslint-disable-next-line
    static runTextTests(name, testFunc, params) {
        VexFlowTests.runCanvasText(name, testFunc, params);
        VexFlowTests.runSVGText(name, testFunc, params);
    }
    /**
     * Append a <div/> which contains the test case title and rendered output. See tests/flow.html.
     * @param elementId
     * @param testTitle
     * @param tagName
     */
    static createTest(elementId, testTitle, tagName, titleId = '') {
        const anchorTestTitle = `<a href="#${titleId}">${testTitle}</a>`;
        const title = $('<div/>').addClass('name').attr('id', titleId).html(anchorTestTitle).get(0);
        const vexOutput = $(`<${tagName}/>`).addClass('vex-tabdiv').attr('id', elementId).get(0);
        const container = $('<div/>').addClass('testcanvas').append(title, vexOutput).get(0);
        $('#qunit-tests').append(container);
        return vexOutput;
    }
    static makeFactory(options, width = 450, height = 140) {
        const { elementId, backend } = options;
        return new _src_index__WEBPACK_IMPORTED_MODULE_0__.Factory({ renderer: { elementId, backend, width, height } });
    }
    // eslint-disable-next-line
    static runCanvasTest(name, testFunc, params) {
        if (VexFlowTests.RUN_CANVAS_TESTS) {
            const helper = null;
            VexFlowTests.runWithParams(Object.assign(Object.assign({}, CANVAS_TEST_CONFIG), { name, testFunc, params, helper }));
        }
    }
    // eslint-disable-next-line
    static runCanvasText(name, testFunc, params) {
        if (VexFlowTests.RUN_CANVAS_TESTS) {
            const helper = null;
            VexFlowTests.runWithParams(Object.assign(Object.assign({}, CANVAS_TEXT_CONFIG), { name, testFunc, params, helper }));
        }
    }
    // eslint-disable-next-line
    static runSVGTest(name, testFunc, params) {
        if (VexFlowTests.RUN_SVG_TESTS) {
            const helper = null;
            VexFlowTests.runWithParams(Object.assign(Object.assign({}, SVG_TEST_CONFIG), { name, testFunc, params, helper }));
        }
    }
    // eslint-disable-next-line
    static runSVGText(name, testFunc, params) {
        if (VexFlowTests.RUN_SVG_TESTS) {
            const helper = null;
            VexFlowTests.runWithParams(Object.assign(Object.assign({}, SVG_TEXT_CONFIG), { name, testFunc, params, helper }));
        }
    }
    // eslint-disable-next-line
    static runNodeTest(name, testFunc, params) {
        if (VexFlowTests.RUN_NODE_TESTS) {
            const helper = VexFlowTests.runNodeTestHelper;
            VexFlowTests.runWithParams(Object.assign(Object.assign({}, NODE_TEST_CONFIG), { name, testFunc, params, helper }));
        }
    }
    /**
     * Save the PNG file.
     * @param fontName
     * @param element
     */
    static runNodeTestHelper(fontName, element) {
        if (_src_index__WEBPACK_IMPORTED_MODULE_0__.Renderer.lastContext !== undefined) {
            const moduleName = sanitizeName(QUnit.module.name);
            const testName = sanitizeName(QUnit.test.name);
            // If we are only testing Bravura, we OMIT the font name from the
            // output image file name, which allows visual diffs against
            // the previous release: version 3.0.9. In the future, if we decide
            // to test all fonts by default, we can remove this check.
            const onlyBravura = NODE_TEST_CONFIG.fontStacks.length === 1 && fontName === 'Bravura';
            const fontInfo = onlyBravura ? '' : `.${fontName}`;
            const fileName = `${VexFlowTests.NODE_IMAGEDIR}/${moduleName}.${testName}${fontInfo}.png`;
            const imageData = element.toDataURL().split(';base64,').pop();
            const imageBuffer = Buffer.from(imageData, 'base64');
            VexFlowTests.shims.fs.writeFileSync(fileName, imageBuffer, { encoding: 'base64' });
        }
    }
    /** Run QUnit.test(...) for each font. */
    // eslint-disable-next-line
    static runWithParams({ fontStacks, testFunc, name, params, backend, tagName, testType, helper }) {
        if (name === undefined) {
            throw new Error('Test name is undefined.');
        }
        const testTypeLowerCase = testType.toLowerCase();
        fontStacks.forEach((fontStackName) => {
            // eslint-disable-next-line
            QUnit.test(name, (assert) => {
                useTempFontStack(fontStackName);
                const elementId = VexFlowTests.generateTestID(`${testTypeLowerCase}_` + fontStackName);
                const moduleName = assert.test.module.name;
                const title = moduleName + '  ' + name + `  ${testType} + ${fontStackName}`;
                // Add an element id for the title div, so that we can scroll directly to a test case.
                // Add a fragment identifier to the url (e.g., #Stave.Multiple_Stave_Barline_Test.Bravura)
                // This titleId will match the name of the PNGs generated by visual regression tests
                // (without the _Current.png or _Reference.png).
                let prefix = '';
                if (testTypeLowerCase === 'canvas') {
                    prefix = testTypeLowerCase + '_';
                }
                else {
                    // DO NOT ADD A PREFIX TO SVG TESTS
                    // The canvas prefix above is for making sure our element ids are unique,
                    // since we have a canvas+bravura test case and a svg+bravura test case
                    // that would otherwise have the same titleId.
                }
                const titleId = `${prefix}${sanitizeName(moduleName)}.${sanitizeName(name)}.${fontStackName}`;
                const element = VexFlowTests.createTest(elementId, title, tagName, titleId);
                const options = { elementId, params, assert, backend };
                const isSVG = backend === _src_index__WEBPACK_IMPORTED_MODULE_0__.Renderer.Backends.SVG;
                const contextBuilder = isSVG ? _src_index__WEBPACK_IMPORTED_MODULE_0__.Renderer.getSVGContext : _src_index__WEBPACK_IMPORTED_MODULE_0__.Renderer.getCanvasContext;
                testFunc(options, contextBuilder);
                restoreOriginalFontStack();
                if (helper)
                    helper(fontStackName, element);
            });
        });
    }
    /**
     * @param ctx
     * @param x
     * @param y
     */
    static plotLegendForNoteWidth(ctx, x, y) {
        ctx.save();
        ctx.setFont(_src_metrics__WEBPACK_IMPORTED_MODULE_1__.Metrics.get('fontFamily'), 8);
        const spacing = 12;
        let lastY = y;
        function legend(color, text) {
            ctx.beginPath();
            ctx.setStrokeStyle(color);
            ctx.setFillStyle(color);
            ctx.setLineWidth(10);
            ctx.moveTo(x, lastY - 4);
            ctx.lineTo(x + 10, lastY - 4);
            ctx.stroke();
            ctx.setFillStyle('black');
            ctx.fillText(text, x + 15, lastY);
            lastY += spacing;
        }
        legend('green', 'Note + Flag');
        legend('red', 'Modifiers');
        legend('#999', 'Displaced Head');
        legend('#DDD', 'Formatter Shift');
        ctx.restore();
    }
}
_a = VexFlowTests;
VexFlowTests.tests = [];
VexFlowTests.RUN_CANVAS_TESTS = true;
VexFlowTests.RUN_SVG_TESTS = true;
VexFlowTests.RUN_NODE_TESTS = false;
// Default font properties for tests.
VexFlowTests.Font = { size: 10 };
/**
 * Each font stack is a prioritized list of font names.
 */
VexFlowTests.FONT_STACKS = {
    Bravura: ['Bravura', 'Roboto Slab'],
    Gonville: ['GonvilleSmufl', 'Bravura', 'Roboto Slab'],
    Petaluma: ['Petaluma', 'Bravura', 'Petaluma Script'],
    Leland: ['Leland', 'Bravura', 'Roboto Slab'],
    MuseJazz: ['MuseJazz', 'Bravura', 'Academico'],
    Gootville: ['Gootville', 'Bravura', 'Academico'],
    'Finale Ash': ['Finale Ash', 'Bravura', 'Academico'],
    'Finale Broadway': ['Finale Broadway', 'Bravura', 'Academico'],
    'Finale Maestro': ['Finale Maestro', 'Bravura', 'Academico'],
};
_VexFlowTests_NEXT_TEST_ID = { value: 0 };
/**
 * Used with array.reduce(...) to flatten arrays of arrays in the tests.
 */
// eslint-disable-next-line
const concat = (a, b) => a.concat(b);
/** Used in KeySignature and ClefKeySignature Tests. */
const MAJOR_KEYS = [
    //
    'C',
    'F',
    'Bb',
    'Eb',
    'Ab',
    'Db',
    'Gb',
    'Cb',
    'G',
    'D',
    'A',
    'E',
    'B',
    'F#',
    'C#',
];
const MINOR_KEYS = [
    'Am',
    'Dm',
    'Gm',
    'Cm',
    'Fm',
    'Bbm',
    'Ebm',
    'Abm',
    'Em',
    'Bm',
    'F#m',
    'C#m',
    'G#m',
    'D#m',
    'A#m',
];
// VexFlow classes can be accessed via Vex.Flow.* or by directly importing a library class.
// Tests can be accessed via Vex.Flow.Test.* or by directly importing a test class.
// Here we set Vex.Flow.Test = VexFlowTests.
// eslint-disable-next-line
// @ts-ignore
_src_index__WEBPACK_IMPORTED_MODULE_0__.Flow.Test = VexFlowTests;


/***/ }),

/***/ "./tests/vf_prefix_tests.ts":
/*!**********************************!*\
  !*** ./tests/vf_prefix_tests.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VFPrefixTests: () => (/* binding */ VFPrefixTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/index */ "./src/index.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// VF.* Prefix Tests
//
// VexFlow classes are available under the global Vex.Flow.* namespace.


const VFPrefixTests = {
    Start() {
        QUnit.module('VF.* API');
        QUnit.test('VF.* API', VFPrefix);
        QUnit.test('VF Alias', VFAlias);
    },
};
function VFPrefix(assert) {
    // Intentionally use Vex.Flow here so we can verify that the Vex.Flow.* API
    // is equivalent to using the individual classes in TypeScript.
    const VF = Vex.Flow;
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Accidental, VF.Accidental);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Annotation, VF.Annotation);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Articulation, VF.Articulation);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Barline, VF.Barline);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.BarNote, VF.BarNote);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Beam, VF.Beam);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Bend, VF.Bend);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.BoundingBox, VF.BoundingBox);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.ChordSymbol, VF.ChordSymbol);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Clef, VF.Clef);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.ClefNote, VF.ClefNote);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Crescendo, VF.Crescendo);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Curve, VF.Curve);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Dot, VF.Dot);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.EasyScore, VF.EasyScore);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Element, VF.Element);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Factory, VF.Factory);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Flow.RESOLUTION, VF.RESOLUTION);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Font, VF.Font);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Formatter, VF.Formatter);
    assert.propEqual(new _src_index__WEBPACK_IMPORTED_MODULE_1__.Formatter(), new VF.Formatter(), 'new Formatter()');
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Fraction, VF.Fraction);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.FretHandFinger, VF.FretHandFinger);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.GhostNote, VF.GhostNote);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.GlyphNote, VF.GlyphNote);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.GraceNote, VF.GraceNote);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.GraceNoteGroup, VF.GraceNoteGroup);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.GraceTabNote, VF.GraceTabNote);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.KeyManager, VF.KeyManager);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.KeySignature, VF.KeySignature);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.KeySigNote, VF.KeySigNote);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Modifier, VF.Modifier);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.ModifierContext, VF.ModifierContext);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.MultiMeasureRest, VF.MultiMeasureRest);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Music, VF.Music);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Note, VF.Note);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.NoteHead, VF.NoteHead);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.NoteSubGroup, VF.NoteSubGroup);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Ornament, VF.Ornament);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Parser, VF.Parser);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.PedalMarking, VF.PedalMarking);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Registry, VF.Registry);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Renderer, VF.Renderer);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.RepeatNote, VF.RepeatNote);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Repetition, VF.Repetition);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Stave, VF.Stave);
    assert.notEqual(_src_index__WEBPACK_IMPORTED_MODULE_1__.Stave, VF.StaveNote);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.StaveConnector, VF.StaveConnector);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.StaveHairpin, VF.StaveHairpin);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.StaveLine, VF.StaveLine);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.StaveModifier, VF.StaveModifier);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.StaveNote, VF.StaveNote);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.StaveTempo, VF.StaveTempo);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.StaveText, VF.StaveText);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.StaveTie, VF.StaveTie);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Stem, VF.Stem);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.StringNumber, VF.StringNumber);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Stroke, VF.Stroke);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.System, VF.System);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.TabNote, VF.TabNote);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.TabSlide, VF.TabSlide);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.TabStave, VF.TabStave);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.TabTie, VF.TabTie);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.TextBracket, VF.TextBracket);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.TextDynamics, VF.TextDynamics);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.TextNote, VF.TextNote);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.TickContext, VF.TickContext);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.TimeSignature, VF.TimeSignature);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.TimeSigNote, VF.TimeSigNote);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Tremolo, VF.Tremolo);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Tuning, VF.Tuning);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Tuplet, VF.Tuplet);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Vibrato, VF.Vibrato);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.VibratoBracket, VF.VibratoBracket);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Voice, VF.Voice);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Volta, VF.Volta);
}
/**
 * If you have name collisions with VexFlow classes, consider extracting classes from Vex.Flow
 * and renaming them with a VF prefix.
 */
function VFAlias(assert) {
    const Flow = Vex.Flow;
    const VFAliases = {
        get VFAccidental() {
            return Flow.Accidental;
        },
        get VFAnnotation() {
            return Flow.Annotation;
        },
        get VFVibrato() {
            return Flow.Vibrato;
        },
    };
    const { VFVibrato, VFAccidental, VFAnnotation } = VFAliases;
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Accidental, VFAccidental);
    assert.equal(_src_index__WEBPACK_IMPORTED_MODULE_1__.Annotation, VFAnnotation);
    const vibrato = new VFVibrato();
    assert.ok(vibrato);
    const acc1 = new VFAccidental('##');
    const acc2 = new _src_index__WEBPACK_IMPORTED_MODULE_1__.Accidental('##');
    assert.equal(acc1.type, acc2.type);
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(VFPrefixTests);



/***/ }),

/***/ "./tests/vibrato_tests.ts":
/*!********************************!*\
  !*** ./tests/vibrato_tests.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VibratoTests: () => (/* binding */ VibratoTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/index */ "./src/index.ts");
/* harmony import */ var _src_metrics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/metrics */ "./src/metrics.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Vibrato Tests



const VibratoTests = {
    Start() {
        QUnit.module('Vibrato');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Simple Vibrato', simple);
        run('Harsh Vibrato', harsh);
        run('Vibrato with Bend', withBend);
    },
};
// Helper function to create TabNote objects.
const tabNote = (noteStruct) => new _src_index__WEBPACK_IMPORTED_MODULE_1__.TabNote(noteStruct);
/**
 * Default vibrato symbol (wavy line) on top of a tab with two notes fretted.
 */
function simple(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 500, 240);
    ctx.scale(1.5, 1.5);
    ctx.font = '10pt Arial';
    const stave = new _src_index__WEBPACK_IMPORTED_MODULE_1__.TabStave(10, 10, 450).addTabGlyph().setContext(ctx).draw();
    const notes = [
        tabNote({
            positions: [
                { str: 2, fret: 10 },
                { str: 4, fret: 9 },
            ],
            duration: 'h',
        }).addModifier(new _src_index__WEBPACK_IMPORTED_MODULE_1__.Vibrato(), 0),
        tabNote({
            positions: [{ str: 2, fret: 10 }],
            duration: 'h',
        }).addModifier(new _src_index__WEBPACK_IMPORTED_MODULE_1__.Vibrato(), 0),
    ];
    _src_index__WEBPACK_IMPORTED_MODULE_1__.Formatter.FormatAndDraw(ctx, stave, notes);
    options.assert.ok(true, 'Simple Vibrato');
}
/**
 * The harsh vibrato symbol is a zig zag line with sharp points.
 * This test is nearly identical to the 'simple' test above.
 * The only difference is that we call .setHarsh(true) on each Vibrato object.
 */
function harsh(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 500, 240);
    ctx.scale(1.5, 1.5);
    ctx.font = '10pt Arial';
    const stave = new _src_index__WEBPACK_IMPORTED_MODULE_1__.TabStave(10, 10, 450).addTabGlyph().setContext(ctx).draw();
    const notes = [
        tabNote({
            positions: [
                { str: 2, fret: 10 },
                { str: 4, fret: 9 },
            ],
            duration: 'h',
        }).addModifier(new _src_index__WEBPACK_IMPORTED_MODULE_1__.Vibrato().setVibratoCode(0xeae2), 0),
        tabNote({
            positions: [{ str: 2, fret: 10 }],
            duration: 'h',
        }).addModifier(new _src_index__WEBPACK_IMPORTED_MODULE_1__.Vibrato().setVibratoCode(0xeac0), 0),
    ];
    _src_index__WEBPACK_IMPORTED_MODULE_1__.Formatter.FormatAndDraw(ctx, stave, notes);
    options.assert.ok(true, 'Harsh Vibrato');
}
function withBend(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 500, 240);
    ctx.scale(1.3, 1.3);
    ctx.setFont(_src_metrics__WEBPACK_IMPORTED_MODULE_2__.Metrics.get('fontFamily'), _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.Font.size);
    const stave = new _src_index__WEBPACK_IMPORTED_MODULE_1__.TabStave(10, 10, 450).addTabGlyph().setContext(ctx).draw();
    const notes = [
        tabNote({
            positions: [
                { str: 2, fret: 9 },
                { str: 3, fret: 9 },
            ],
            duration: 'q',
        })
            .addModifier(new _src_index__WEBPACK_IMPORTED_MODULE_1__.Bend([
            { type: _src_index__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: '1/2' },
            { type: _src_index__WEBPACK_IMPORTED_MODULE_1__.Bend.DOWN, text: '' },
        ]), 0)
            .addModifier(new _src_index__WEBPACK_IMPORTED_MODULE_1__.Bend([
            { type: _src_index__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: '1/2' },
            { type: _src_index__WEBPACK_IMPORTED_MODULE_1__.Bend.DOWN, text: '' },
        ]), 1)
            .addModifier(new _src_index__WEBPACK_IMPORTED_MODULE_1__.Vibrato(), 0),
        tabNote({
            positions: [{ str: 2, fret: 10 }],
            duration: 'q',
        })
            .addModifier(new _src_index__WEBPACK_IMPORTED_MODULE_1__.Bend([{ type: _src_index__WEBPACK_IMPORTED_MODULE_1__.Bend.UP, text: 'Full' }]), 0)
            .addModifier(new _src_index__WEBPACK_IMPORTED_MODULE_1__.Vibrato().setVibratoWidth(60), 0),
        tabNote({
            positions: [{ str: 2, fret: 10 }],
            duration: 'h',
        }).addModifier(new _src_index__WEBPACK_IMPORTED_MODULE_1__.Vibrato().setVibratoWidth(120).setVibratoCode(0xeae2), 0),
    ];
    _src_index__WEBPACK_IMPORTED_MODULE_1__.Formatter.FormatAndDraw(ctx, stave, notes);
    options.assert.ok(true, 'Vibrato with Bend');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(VibratoTests);



/***/ }),

/***/ "./tests/vibratobracket_tests.ts":
/*!***************************************!*\
  !*** ./tests/vibratobracket_tests.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VibratoBracketTests: () => (/* binding */ VibratoBracketTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
// @author Balazs Forian-Szabo
//
// VibratoBracket Tests
// TODO: It's annoying to have to cast "as Note" or "as Note[]". Could we add a method to Voice to get the tickables as Note[]? Voice.getTickables() vs Voice.getNotes()?

const VibratoBracketTests = {
    Start() {
        QUnit.module('VibratoBracket');
        const run = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests;
        run('Simple VibratoBracket', simple);
        run('Harsh VibratoBracket Without End Note', withoutEndNote);
        run('Harsh VibratoBracket Without Start Note', withoutStartNote);
    },
};
// Helper function to set up the stave, easyscore, voice, and to format & draw.
function createTest(noteGroup, setupVibratoBracket) {
    return (options) => {
        const factory = _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.makeFactory(options, 650, 200);
        const stave = factory.Stave();
        const score = factory.EasyScore();
        const voice = score.voice(score.notes(noteGroup));
        setupVibratoBracket(factory, voice.getTickables());
        factory.Formatter().joinVoices([voice]).formatToStave([voice], stave);
        factory.draw();
        options.assert.ok(true);
    };
}
const simple = createTest('c4/4, c4, c4, c4', (factory, notes) => {
    factory.VibratoBracket({
        from: notes[0],
        to: notes[3],
        options: { line: 2 },
    });
});
const withoutEndNote = createTest('c4/4, c4, c4, c4', (factory, notes) => {
    factory.VibratoBracket({
        from: notes[2],
        to: null,
        options: { line: 2, code: 0xeae2 },
    });
});
const withoutStartNote = createTest('c4/4, c4, c4, c4', (factory, notes) => {
    factory.VibratoBracket({
        from: null,
        to: notes[2],
        options: { line: 2, code: 0xeae2 },
    });
});
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(VibratoBracketTests);



/***/ }),

/***/ "./tests/voice_tests.ts":
/*!******************************!*\
  !*** ./tests/voice_tests.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VoiceTests: () => (/* binding */ VoiceTests)
/* harmony export */ });
/* harmony import */ var _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vexflow_test_helpers */ "./tests/vexflow_test_helpers.ts");
/* harmony import */ var _src_flow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/flow */ "./src/flow.ts");
/* harmony import */ var _src_formatter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/formatter */ "./src/formatter.ts");
/* harmony import */ var _src_stave__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/stave */ "./src/stave.ts");
/* harmony import */ var _src_stavebarline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/stavebarline */ "./src/stavebarline.ts");
/* harmony import */ var _src_stavenote__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/stavenote */ "./src/stavenote.ts");
/* harmony import */ var _src_voice__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/voice */ "./src/voice.ts");
/* harmony import */ var _mocks__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mocks */ "./tests/mocks.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// Voice Tests








const VoiceTests = {
    Start() {
        QUnit.module('Voice');
        QUnit.test('Strict Test', strict);
        QUnit.test('Ignore Test', ignore);
        _vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.runTests('Full Voice Mode Test', full);
    },
};
const BEAT = (1 * _src_flow__WEBPACK_IMPORTED_MODULE_1__.Flow.RESOLUTION) / 4;
// Helper function to create a tickable with a preset number of ticks.
const createTickable = () => new _mocks__WEBPACK_IMPORTED_MODULE_7__.MockTickable().setTicks(BEAT);
function strict(assert) {
    assert.expect(8);
    const tickables = [createTickable(), createTickable(), createTickable()];
    const voice = new _src_voice__WEBPACK_IMPORTED_MODULE_6__.Voice(_src_flow__WEBPACK_IMPORTED_MODULE_1__.Flow.TIME4_4);
    assert.equal(voice.getTotalTicks().value(), BEAT * 4, '4/4 Voice has 4 beats');
    assert.equal(voice.getTicksUsed().value(), BEAT * 0, 'No beats in voice');
    voice.addTickables(tickables);
    assert.equal(voice.getTicksUsed().value(), BEAT * 3, 'Three beats in voice');
    voice.addTickable(createTickable());
    assert.equal(voice.getTicksUsed().value(), BEAT * 4, 'Four beats in voice');
    assert.equal(voice.isComplete(), true, 'Voice is complete');
    const numeratorBeforeException = voice.getTicksUsed().numerator;
    assert.throws(() => voice.addTickable(createTickable()), /BadArgument/, '"Too many ticks" exception');
    // Verify that adding too many ticks does not affect the `ticksUsed` property of the voice.
    // See voice.ts: this.ticksUsed.subtract(ticks);
    assert.equal(voice.getTicksUsed().numerator, numeratorBeforeException, 'Revert `ticksUsed` after a "Too many ticks" exception');
    assert.equal(voice.getSmallestTickCount().value(), BEAT, 'Smallest tick count is BEAT');
}
function ignore(assert) {
    const tickables = [
        createTickable(),
        createTickable(),
        createTickable().setIgnoreTicks(true),
        createTickable(),
        createTickable().setIgnoreTicks(true),
        createTickable(),
    ];
    const voice = new _src_voice__WEBPACK_IMPORTED_MODULE_6__.Voice(_src_flow__WEBPACK_IMPORTED_MODULE_1__.Flow.TIME4_4);
    voice.addTickables(tickables);
    assert.ok(true, 'all pass');
}
function full(options, contextBuilder) {
    const ctx = contextBuilder(options.elementId, 550, 200);
    const stave = new _src_stave__WEBPACK_IMPORTED_MODULE_3__.Stave(10, 50, 500).addClef('treble').addTimeSignature('4/4').setEndBarType(_src_stavebarline__WEBPACK_IMPORTED_MODULE_4__.Barline.type.END);
    const notes = [
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_5__.StaveNote({ keys: ['c/4'], duration: '4' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_5__.StaveNote({ keys: ['d/4'], duration: '4' }),
        new _src_stavenote__WEBPACK_IMPORTED_MODULE_5__.StaveNote({ keys: ['r/4'], duration: '4r' }),
    ];
    notes.forEach((note) => note.setStave(stave));
    const voice = new _src_voice__WEBPACK_IMPORTED_MODULE_6__.Voice(_src_flow__WEBPACK_IMPORTED_MODULE_1__.Flow.TIME4_4).setMode(_src_voice__WEBPACK_IMPORTED_MODULE_6__.Voice.Mode.FULL).addTickables(notes);
    new _src_formatter__WEBPACK_IMPORTED_MODULE_2__.Formatter().joinVoices([voice]).formatToStave([voice], stave);
    stave.setContext(ctx).draw();
    voice.draw(ctx);
    const bb = voice.getBoundingBox();
    if (bb) {
        ctx.rect(bb.getX(), bb.getY(), bb.getW(), bb.getH());
    }
    ctx.stroke();
    options.assert.throws(() => voice.addTickable(new _src_stavenote__WEBPACK_IMPORTED_MODULE_5__.StaveNote({ keys: ['c/4'], duration: '2' })), /BadArgument/, 'Voice cannot exceed full amount of ticks');
}
_vexflow_test_helpers__WEBPACK_IMPORTED_MODULE_0__.VexFlowTests.register(VoiceTests);



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!*******************************************!*\
  !*** ./entry/vexflow-debug-with-tests.ts ***!
  \*******************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Accidental: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Accidental),
/* harmony export */   AccidentalTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.AccidentalTests),
/* harmony export */   Annotation: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Annotation),
/* harmony export */   AnnotationHorizontalJustify: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.AnnotationHorizontalJustify),
/* harmony export */   AnnotationTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.AnnotationTests),
/* harmony export */   AnnotationVerticalJustify: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.AnnotationVerticalJustify),
/* harmony export */   Articulation: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Articulation),
/* harmony export */   ArticulationTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.ArticulationTests),
/* harmony export */   AutoBeamFormattingTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.AutoBeamFormattingTests),
/* harmony export */   BEAM_BOTH: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.BEAM_BOTH),
/* harmony export */   BEAM_LEFT: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.BEAM_LEFT),
/* harmony export */   BEAM_RIGHT: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.BEAM_RIGHT),
/* harmony export */   BachDemoTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.BachDemoTests),
/* harmony export */   BarNote: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.BarNote),
/* harmony export */   Barline: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Barline),
/* harmony export */   BarlineTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.BarlineTests),
/* harmony export */   BarlineType: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.BarlineType),
/* harmony export */   Beam: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Beam),
/* harmony export */   BeamTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.BeamTests),
/* harmony export */   Bend: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Bend),
/* harmony export */   BendTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.BendTests),
/* harmony export */   BoundingBox: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.BoundingBox),
/* harmony export */   BoundingBoxTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.BoundingBoxTests),
/* harmony export */   Builder: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Builder),
/* harmony export */   CanvasContext: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.CanvasContext),
/* harmony export */   Category: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Category),
/* harmony export */   ChordSymbol: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.ChordSymbol),
/* harmony export */   ChordSymbolBlock: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.ChordSymbolBlock),
/* harmony export */   ChordSymbolHorizontalJustify: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.ChordSymbolHorizontalJustify),
/* harmony export */   ChordSymbolTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.ChordSymbolTests),
/* harmony export */   ChordSymbolVerticalJustify: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.ChordSymbolVerticalJustify),
/* harmony export */   Clef: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Clef),
/* harmony export */   ClefKeySignatureTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.ClefKeySignatureTests),
/* harmony export */   ClefNote: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.ClefNote),
/* harmony export */   ClefTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.ClefTests),
/* harmony export */   Crescendo: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Crescendo),
/* harmony export */   CrossBeamTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.CrossBeamTests),
/* harmony export */   Curve: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Curve),
/* harmony export */   CurvePosition: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.CurvePosition),
/* harmony export */   CurveTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.CurveTests),
/* harmony export */   Dot: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Dot),
/* harmony export */   DotTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.DotTests),
/* harmony export */   EasyScore: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.EasyScore),
/* harmony export */   EasyScoreGrammar: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.EasyScoreGrammar),
/* harmony export */   EasyScoreTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.EasyScoreTests),
/* harmony export */   Element: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Element),
/* harmony export */   Factory: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Factory),
/* harmony export */   FactoryTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.FactoryTests),
/* harmony export */   Flow: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Flow),
/* harmony export */   Font: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Font),
/* harmony export */   FontStyle: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.FontStyle),
/* harmony export */   FontTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.FontTests),
/* harmony export */   FontWeight: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.FontWeight),
/* harmony export */   Formatter: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Formatter),
/* harmony export */   FormatterTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.FormatterTests),
/* harmony export */   Fraction: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Fraction),
/* harmony export */   FractionTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.FractionTests),
/* harmony export */   FretHandFinger: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.FretHandFinger),
/* harmony export */   GhostNote: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.GhostNote),
/* harmony export */   GhostNoteTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.GhostNoteTests),
/* harmony export */   GlyphNote: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.GlyphNote),
/* harmony export */   GlyphNoteTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.GlyphNoteTests),
/* harmony export */   GraceNote: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.GraceNote),
/* harmony export */   GraceNoteGroup: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.GraceNoteGroup),
/* harmony export */   GraceNoteTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.GraceNoteTests),
/* harmony export */   GraceTabNote: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.GraceTabNote),
/* harmony export */   GraceTabNoteTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.GraceTabNoteTests),
/* harmony export */   KeyManager: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.KeyManager),
/* harmony export */   KeyManagerTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.KeyManagerTests),
/* harmony export */   KeySigNote: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.KeySigNote),
/* harmony export */   KeySignature: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.KeySignature),
/* harmony export */   KeySignatureTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.KeySignatureTests),
/* harmony export */   Modifier: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Modifier),
/* harmony export */   ModifierContext: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.ModifierContext),
/* harmony export */   ModifierContextTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.ModifierContextTests),
/* harmony export */   ModifierPosition: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.ModifierPosition),
/* harmony export */   MultiMeasureRest: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.MultiMeasureRest),
/* harmony export */   MultiMeasureRestTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.MultiMeasureRestTests),
/* harmony export */   Music: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Music),
/* harmony export */   MusicTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.MusicTests),
/* harmony export */   Note: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Note),
/* harmony export */   NoteHead: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.NoteHead),
/* harmony export */   NoteHeadTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.NoteHeadTests),
/* harmony export */   NoteSubGroup: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.NoteSubGroup),
/* harmony export */   NoteSubGroupTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.NoteSubGroupTests),
/* harmony export */   OffscreenCanvasTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.OffscreenCanvasTests),
/* harmony export */   Ornament: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Ornament),
/* harmony export */   OrnamentTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.OrnamentTests),
/* harmony export */   Parenthesis: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Parenthesis),
/* harmony export */   Parser: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Parser),
/* harmony export */   ParserTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.ParserTests),
/* harmony export */   PedalMarking: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.PedalMarking),
/* harmony export */   PedalMarkingTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.PedalMarkingTests),
/* harmony export */   PercussionTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.PercussionTests),
/* harmony export */   Piece: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Piece),
/* harmony export */   Registry: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Registry),
/* harmony export */   RegistryTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.RegistryTests),
/* harmony export */   RenderContext: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.RenderContext),
/* harmony export */   Renderer: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Renderer),
/* harmony export */   RendererBackends: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.RendererBackends),
/* harmony export */   RendererLineEndType: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.RendererLineEndType),
/* harmony export */   RendererTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.RendererTests),
/* harmony export */   RepeatNote: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.RepeatNote),
/* harmony export */   Repetition: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Repetition),
/* harmony export */   RestsTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.RestsTests),
/* harmony export */   RhythmTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.RhythmTests),
/* harmony export */   RuntimeError: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.RuntimeError),
/* harmony export */   SVGContext: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.SVGContext),
/* harmony export */   Stave: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Stave),
/* harmony export */   StaveConnector: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.StaveConnector),
/* harmony export */   StaveConnectorTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.StaveConnectorTests),
/* harmony export */   StaveHairpin: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.StaveHairpin),
/* harmony export */   StaveHairpinTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.StaveHairpinTests),
/* harmony export */   StaveLine: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.StaveLine),
/* harmony export */   StaveLineTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.StaveLineTests),
/* harmony export */   StaveModifier: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.StaveModifier),
/* harmony export */   StaveModifierPosition: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.StaveModifierPosition),
/* harmony export */   StaveModifierTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.StaveModifierTests),
/* harmony export */   StaveNote: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.StaveNote),
/* harmony export */   StaveNoteTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.StaveNoteTests),
/* harmony export */   StaveSection: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.StaveSection),
/* harmony export */   StaveTempo: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.StaveTempo),
/* harmony export */   StaveTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.StaveTests),
/* harmony export */   StaveText: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.StaveText),
/* harmony export */   StaveTie: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.StaveTie),
/* harmony export */   StaveTieTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.StaveTieTests),
/* harmony export */   Stem: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Stem),
/* harmony export */   StemmableNote: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.StemmableNote),
/* harmony export */   StringNumber: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.StringNumber),
/* harmony export */   StringNumberTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.StringNumberTests),
/* harmony export */   Stroke: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Stroke),
/* harmony export */   StrokesTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.StrokesTests),
/* harmony export */   StyleTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.StyleTests),
/* harmony export */   SymbolModifiers: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.SymbolModifiers),
/* harmony export */   System: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.System),
/* harmony export */   TabNote: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.TabNote),
/* harmony export */   TabNoteTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.TabNoteTests),
/* harmony export */   TabSlide: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.TabSlide),
/* harmony export */   TabSlideTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.TabSlideTests),
/* harmony export */   TabStave: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.TabStave),
/* harmony export */   TabStaveTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.TabStaveTests),
/* harmony export */   TabTie: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.TabTie),
/* harmony export */   TabTieTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.TabTieTests),
/* harmony export */   TextBracket: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.TextBracket),
/* harmony export */   TextBracketPosition: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.TextBracketPosition),
/* harmony export */   TextBracketTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.TextBracketTests),
/* harmony export */   TextDynamics: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.TextDynamics),
/* harmony export */   TextJustification: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.TextJustification),
/* harmony export */   TextNote: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.TextNote),
/* harmony export */   TextNoteTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.TextNoteTests),
/* harmony export */   ThreeVoicesTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.ThreeVoicesTests),
/* harmony export */   TickContext: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.TickContext),
/* harmony export */   TickContextTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.TickContextTests),
/* harmony export */   Tickable: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Tickable),
/* harmony export */   TimeSigNote: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.TimeSigNote),
/* harmony export */   TimeSignature: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.TimeSignature),
/* harmony export */   TimeSignatureTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.TimeSignatureTests),
/* harmony export */   Tremolo: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Tremolo),
/* harmony export */   TremoloTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.TremoloTests),
/* harmony export */   Tuning: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Tuning),
/* harmony export */   TuningTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.TuningTests),
/* harmony export */   Tuplet: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Tuplet),
/* harmony export */   TupletLocation: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.TupletLocation),
/* harmony export */   TupletTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.TupletTests),
/* harmony export */   TypeGuardTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.TypeGuardTests),
/* harmony export */   UnisonTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.UnisonTests),
/* harmony export */   VFPrefixTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.VFPrefixTests),
/* harmony export */   Vex: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Vex),
/* harmony export */   Vibrato: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Vibrato),
/* harmony export */   VibratoBracket: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.VibratoBracket),
/* harmony export */   VibratoBracketTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.VibratoBracketTests),
/* harmony export */   VibratoTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.VibratoTests),
/* harmony export */   Voice: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Voice),
/* harmony export */   VoiceMode: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.VoiceMode),
/* harmony export */   VoiceTests: () => (/* reexport safe */ _tests_index__WEBPACK_IMPORTED_MODULE_1__.VoiceTests),
/* harmony export */   Volta: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.Volta),
/* harmony export */   VoltaType: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.VoltaType),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defined: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.defined),
/* harmony export */   drawDot: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.drawDot),
/* harmony export */   getBottomY: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.getBottomY),
/* harmony export */   getInitialOffset: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.getInitialOffset),
/* harmony export */   getTopY: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.getTopY),
/* harmony export */   globalObject: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.globalObject),
/* harmony export */   isAccidental: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.isAccidental),
/* harmony export */   isAnnotation: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.isAnnotation),
/* harmony export */   isBarline: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.isBarline),
/* harmony export */   isCategory: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.isCategory),
/* harmony export */   isDot: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.isDot),
/* harmony export */   isGraceNote: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.isGraceNote),
/* harmony export */   isGraceNoteGroup: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.isGraceNoteGroup),
/* harmony export */   isHTMLCanvas: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.isHTMLCanvas),
/* harmony export */   isHTMLDiv: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.isHTMLDiv),
/* harmony export */   isNote: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.isNote),
/* harmony export */   isRenderContext: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.isRenderContext),
/* harmony export */   isStaveNote: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.isStaveNote),
/* harmony export */   isStemmableNote: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.isStemmableNote),
/* harmony export */   isTabNote: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.isTabNote),
/* harmony export */   log: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.log),
/* harmony export */   midLine: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.midLine),
/* harmony export */   normalizeAngle: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.normalizeAngle),
/* harmony export */   prefix: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.prefix),
/* harmony export */   sumArray: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.sumArray),
/* harmony export */   upperFirst: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.upperFirst),
/* harmony export */   warn: () => (/* reexport safe */ _src_index__WEBPACK_IMPORTED_MODULE_0__.warn)
/* harmony export */ });
/* harmony import */ var _src_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/index */ "./src/index.ts");
/* harmony import */ var _tests_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tests/index */ "./tests/index.ts");
/* harmony import */ var _src_flow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/flow */ "./src/flow.ts");
// Copyright (c) 2023-present VexFlow contributors: https://github.com/vexflow/vexflow/graphs/contributors
// MIT License
//
// vexflow-debug-with-tests.ts is the entry point for the build output file vexflow-debug-with-tests.js.
// It statically bundles all the music engraving fonts, and also includes the tests from vexflow/tests/.
// The output file is used by flow.html & flow-headless-browser.html to run the tests.



_src_flow__WEBPACK_IMPORTED_MODULE_2__.Flow.setMusicFont('Bravura', 'Roboto Slab');
// Re-export all exports from src/index.ts and tests/index.ts.


// Also collect all exports into a default export for CJS projects.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Object.assign(Object.assign({}, _src_index__WEBPACK_IMPORTED_MODULE_0__), _tests_index__WEBPACK_IMPORTED_MODULE_1__));

})();

__webpack_exports__ = __webpack_exports__["default"];
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=vexflow-debug-with-tests.js.map